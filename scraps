
#;(define (remove-varargs e vst) 
  (match e
         [`(let ([,x ',dat]) ,e0)
          `(let ([,x ',dat]) ,(remove-varargs e0 vst))]
         [`(let ([,x (prim ,op ,xs ...)]) ,e0)
          `(let ([,x (prim ,op ,@xs)]) ,(remove-varargs e0 vst))]
         [`(let ([,x (apply-prim ,op ,y)]) ,e0)
          `(let ([,x (apply-prim ,op ,y)]) ,(remove-varargs e0 vst))]
         [`(let ([,x (lambda (,xs ...) ,body)]) ,e0)
          #:when (or (not vst) (set-member? vst `(lambda ,xs ,body)))
          (define gx (gensym 'rvp))
          (define emsg0 (gensym 'emsg0)) (define emsg1 (gensym 'emsg1))
          (define n0? (gensym 'n0?)) (define n1? (gensym 'n1?))
          (define len0 (gensym 'len0))
          (define len1 (gensym 'len1))
          (define h0 (gensym 'h0))
          (define h1 (gensym 'h1))
          (define gx+e
            (foldr (lambda (x gx+e)
                     (define gx (gensym 'rvp))
                     (define n? (gensym 'n?))
                     (define h (gensym 'h))
                     (define emsg (gensym 'emsg))
                     (define head (car gx+e))
                     (cons gx
                           `(let ([,x (prim car ,gx)])
                              (let ([,head (prim cdr ,gx)])
                                ,(cdr gx+e)))))                                       
                   (cons (gensym 'na) (remove-varargs body vst))
                   xs))
          `(let ([,emsg0 '"library runtime error: Too few arguments provided."])
             (let ([,emsg1 '"library runtime error: Too many arguments provided."])
               (let ([,x (lambda (,(car gx+e))
                           (let ([,len0 ',(length xs)])
                             (let ([,len1 (prim length ,(car gx+e))])
                               (let ([,n0? (prim < ,len1 ,len0)])
                                 (if ,n0?
                                     (let ([,h0 (prim halt ,emsg0)])
                                       (,h0 ,h0))
                                     (let ([,n1? (prim > ,len1 ,len0)])
                                       (if ,n1?
                                           (let ([,h1 (prim halt ,emsg1)])
                                             (,h1 ,h1))
                                           ,(cdr gx+e))))))))])
                 ,(remove-varargs e0 vst))))]
           
         [`(let ([,x (lambda (,xs ...) ,body)]) ,e0)
          `(let ([,x (lambda (,@xs) ,(remove-varargs body vst))])
             ,(remove-varargs e0 vst))]
         [`(let ([,x (lambda ,y ,body)]) ,e0)
          `(let ([,x (lambda (,y) ,(remove-varargs body vst))])
             ,(remove-varargs e0 vst))]
         [`(if ,x ,e0 ,e1)
          `(if ,x ,(remove-varargs e0 vst) ,(remove-varargs e1 vst))]
         [`(apply ,f ,args)
          `(,f ,args)] 
         [`(,f ,xs ...)
          #:when (or (not vst) (set-member? vst e))
          (define gx+e
            (let ()
              (define gx (gensym 'rva))
              (foldl (lambda (x gx+e)
                       (define gx (gensym 'rva))
                       (cons
                        gx
                        `(let ([,(car gx+e) (prim cons ,x ,gx)])
                           ,(cdr gx+e))))
                     (cons gx `(,f ,gx))
                     xs)))
          `(let ([,(car gx+e) '()])
             ,(cdr gx+e))]
         [`(,f ,xs ...)
          `(,f . ,xs)]))


 /*  u64* hash = DECODE_OTHER(h);

  const scheme_key* const k = new ((scheme_key*)malloc(sizeof(scheme_key))) scheme_key(const_init_int(2222));
  const scheme_value* const v = new ((scheme_value*)malloc(sizeof(scheme_value))) scheme_value(const_init_int(200));
  const hamt<scheme_key, scheme_value>* actual_hash = (hamt<scheme_key, scheme_value>*)hash[1];
  actual_hash = actual_hash->insert(k, v);
  printf(" %i \n", DECODE_INT(actual_hash->get(k)->value));
  hash[1] = (u64)actual_hash;
  h = ENCODE_OTHER(hash);

  u64 v_ret = prim_hash_ref(h, const_init_int(2222));
  printf(" %i \n ", DECODE_INT(v_ret));
  */  
  //printf("Hash's identifier is %lu \n", hash[0]);

  //  const scheme_key* const s = new ((scheme_key*)malloc(sizeof(scheme_key))) scheme_key(const_init_int(2222), const_init_int(200));
  //  const scheme_key* const s0 = new ((scheme_key*)malloc(sizeof(scheme_key))) scheme_key(const_init_int(2222), const_init_int(200));
  //  const hamt<scheme_key, scheme_key>* actual_hash = (hamt<scheme_key, scheme_key>*)hash[1];
  //  actual_hash = actual_hash->insert(s, s0);

  //  actual_hash->get(new ((scheme_key*)GC_MALLOC(sizeof(scheme_key))) scheme_key(60, 0));
  
  //    hash[1] = (u64)actual_hash;
  //   h = ENCODE_OTHER(hash);

  //  u64* lol = DECODE_OTHER(h);
  //  printf(" %i \n", DECODE_INT((((hamt<scheme_key, scheme_key>*)lol[1])->get(s))->value));
  
  //    int k = prim_hash_ref(h, const_init_int(2222));
  //  printf(" %i ", k);
	 //  printf(" %lu ", k->value);
	 //  k->value;
  //  printf("got back key %i value %i \n", DECODE_INT(k->key), DECODE_INT(k->value));
  
 
