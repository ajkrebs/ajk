; ModuleID = 'header.cpp'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

%"class.std::ios_base::Init" = type { i8 }
%class.hamt = type { [7 x %class.KV], i64 }
%class.KV = type { %"union.KV<scheme_key, scheme_value, 0>::Key", %"union.KV<scheme_key, scheme_value, 0>::Val" }
%"union.KV<scheme_key, scheme_value, 0>::Key" = type { i64 }
%"union.KV<scheme_key, scheme_value, 0>::Val" = type { %class.KV.0* }
%class.KV.0 = type { %"union.KV<scheme_key, scheme_value, 1>::Key", %"union.KV<scheme_key, scheme_value, 1>::Val" }
%"union.KV<scheme_key, scheme_value, 1>::Key" = type { i64 }
%"union.KV<scheme_key, scheme_value, 1>::Val" = type { %class.KV.1* }
%class.KV.1 = type { %"union.KV<scheme_key, scheme_value, 2>::Key", %"union.KV<scheme_key, scheme_value, 2>::Val" }
%"union.KV<scheme_key, scheme_value, 2>::Key" = type { i64 }
%"union.KV<scheme_key, scheme_value, 2>::Val" = type { %class.KV.2* }
%class.KV.2 = type { %"union.KV<scheme_key, scheme_value, 3>::Key", %"union.KV<scheme_key, scheme_value, 3>::Val" }
%"union.KV<scheme_key, scheme_value, 3>::Key" = type { i64 }
%"union.KV<scheme_key, scheme_value, 3>::Val" = type { %class.KV.3* }
%class.KV.3 = type { %"union.KV<scheme_key, scheme_value, 4>::Key", %"union.KV<scheme_key, scheme_value, 4>::Val" }
%"union.KV<scheme_key, scheme_value, 4>::Key" = type { i64 }
%"union.KV<scheme_key, scheme_value, 4>::Val" = type { %class.KV.4* }
%class.KV.4 = type { %"union.KV<scheme_key, scheme_value, 5>::Key", %"union.KV<scheme_key, scheme_value, 5>::Val" }
%"union.KV<scheme_key, scheme_value, 5>::Key" = type { i64 }
%"union.KV<scheme_key, scheme_value, 5>::Val" = type { %class.KV.5* }
%class.KV.5 = type { %"union.KV<scheme_key, scheme_value, 6>::Key", %"union.KV<scheme_key, scheme_value, 6>::Val" }
%"union.KV<scheme_key, scheme_value, 6>::Key" = type { i64 }
%"union.KV<scheme_key, scheme_value, 6>::Val" = type { %class.KV.6* }
%class.KV.6 = type { %"union.KV<scheme_key, scheme_value, 7>::Key", %"union.KV<scheme_key, scheme_value, 7>::Val" }
%"union.KV<scheme_key, scheme_value, 7>::Key" = type { i64 }
%"union.KV<scheme_key, scheme_value, 7>::Val" = type { %class.KV.7* }
%class.KV.7 = type { %"union.KV<scheme_key, scheme_value, 8>::Key", %"union.KV<scheme_key, scheme_value, 8>::Val" }
%"union.KV<scheme_key, scheme_value, 8>::Key" = type { i64 }
%"union.KV<scheme_key, scheme_value, 8>::Val" = type { %class.KV.8* }
%class.KV.8 = type { %"union.KV<scheme_key, scheme_value, 9>::Key", %"union.KV<scheme_key, scheme_value, 9>::Val" }
%"union.KV<scheme_key, scheme_value, 9>::Key" = type { i64 }
%"union.KV<scheme_key, scheme_value, 9>::Val" = type { %class.KV.9* }
%class.KV.9 = type { %"union.KV<scheme_key, scheme_value, 10>::Key", %"union.KV<scheme_key, scheme_value, 10>::Val" }
%"union.KV<scheme_key, scheme_value, 10>::Key" = type { i64 }
%"union.KV<scheme_key, scheme_value, 10>::Val" = type { %class.LL* }
%class.LL = type { %class.scheme_key*, %class.scheme_value*, %class.LL* }
%class.scheme_key = type { i64 }
%class.scheme_value = type { i64 }

$_ZN4hamtI10scheme_key12scheme_valueEC2Ev = comdat any

$_ZN10scheme_keyC2Em = comdat any

$_ZN12scheme_valueC2Em = comdat any

$_ZNK4hamtI10scheme_key12scheme_valueE6insertEPKS0_PKS1_ = comdat any

$_ZNK4hamtI10scheme_key12scheme_valueE6removeEPKS0_ = comdat any

$_ZNK4hamtI10scheme_key12scheme_valueE3getEPKS0_ = comdat any

$_ZNK4hamtI10scheme_key12scheme_valueE4sizeEv = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj0EEC2Ev = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj0EE3KeyC2Em = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj0EE3ValC2EPKS1_ = comdat any

$_ZNK10scheme_key4hashEv = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj0EEC2EPKS0_PKS1_ = comdat any

$_ZNK10scheme_keyeqERKS_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj0EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj0EE12insert_innerERKS2_mPKS0_PKS1_Pm = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj0EE3KeyC2EPKS0_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj1EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj1EEC2ERKS2_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj0EEC2EmPKS_IS0_S1_Lj1EE = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj1EEC2EPKS0_PKS1_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj2EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj2EEC2ERKS2_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj1EEC2EmPKS_IS0_S1_Lj2EE = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj2EEC2EPKS0_PKS1_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj3EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj3EEC2ERKS2_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj2EEC2EmPKS_IS0_S1_Lj3EE = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj3EEC2EPKS0_PKS1_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj4EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj4EEC2ERKS2_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj3EEC2EmPKS_IS0_S1_Lj4EE = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj4EEC2EPKS0_PKS1_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj5EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj5EEC2ERKS2_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj4EEC2EmPKS_IS0_S1_Lj5EE = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj5EEC2EPKS0_PKS1_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj6EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj6EEC2ERKS2_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj5EEC2EmPKS_IS0_S1_Lj6EE = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj6EEC2EPKS0_PKS1_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj7EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj7EEC2ERKS2_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj6EEC2EmPKS_IS0_S1_Lj7EE = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj7EEC2EPKS0_PKS1_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj8EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj8EEC2ERKS2_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj7EEC2EmPKS_IS0_S1_Lj8EE = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj8EEC2EPKS0_PKS1_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj9EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj9EEC2ERKS2_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj8EEC2EmPKS_IS0_S1_Lj9EE = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj9EEC2EPKS0_PKS1_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj10EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj10EEC2ERKS2_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj9EEC2EmPKS_IS0_S1_Lj10EE = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj10EEC2EPKS0_PKS1_ = comdat any

$_ZN2LLI10scheme_key12scheme_valueEC2EPKS0_PKS1_PKS2_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj10EEC2EmPK2LLIS0_S1_E = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj10EE3KeyC2Em = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj10EE3ValC2EPK2LLIS0_S1_E = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj9EE3KeyC2Em = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj9EE3ValC2EPKS_IS0_S1_Lj10EE = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj10EE3KeyC2EPKS0_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj10EE3ValC2EPKS1_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj8EE3KeyC2Em = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj8EE3ValC2EPKS_IS0_S1_Lj9EE = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj9EE3KeyC2EPKS0_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj9EE3ValC2EPKS1_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj7EE3KeyC2Em = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj7EE3ValC2EPKS_IS0_S1_Lj8EE = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj8EE3KeyC2EPKS0_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj8EE3ValC2EPKS1_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj6EE3KeyC2Em = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj6EE3ValC2EPKS_IS0_S1_Lj7EE = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj7EE3KeyC2EPKS0_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj7EE3ValC2EPKS1_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj5EE3KeyC2Em = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj5EE3ValC2EPKS_IS0_S1_Lj6EE = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj6EE3KeyC2EPKS0_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj6EE3ValC2EPKS1_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj4EE3KeyC2Em = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj4EE3ValC2EPKS_IS0_S1_Lj5EE = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj5EE3KeyC2EPKS0_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj5EE3ValC2EPKS1_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj3EE3KeyC2Em = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj3EE3ValC2EPKS_IS0_S1_Lj4EE = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj4EE3KeyC2EPKS0_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj4EE3ValC2EPKS1_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj2EE3KeyC2Em = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj2EE3ValC2EPKS_IS0_S1_Lj3EE = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj3EE3KeyC2EPKS0_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj3EE3ValC2EPKS1_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj1EE3KeyC2Em = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj1EE3ValC2EPKS_IS0_S1_Lj2EE = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj2EE3KeyC2EPKS0_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj2EE3ValC2EPKS1_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj0EE3ValC2EPKS_IS0_S1_Lj1EE = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj1EE3KeyC2EPKS0_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj1EE3ValC2EPKS1_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj1EE11update_nodeEPKS2_jjRS3_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj1EE12insert_innerERKS2_mPKS0_PKS1_Pm = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj2EE11update_nodeEPKS2_jjRS3_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj2EE12insert_innerERKS2_mPKS0_PKS1_Pm = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj3EE11update_nodeEPKS2_jjRS3_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj3EE12insert_innerERKS2_mPKS0_PKS1_Pm = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj4EE11update_nodeEPKS2_jjRS3_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj4EE12insert_innerERKS2_mPKS0_PKS1_Pm = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj5EE11update_nodeEPKS2_jjRS3_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj5EE12insert_innerERKS2_mPKS0_PKS1_Pm = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj6EE11update_nodeEPKS2_jjRS3_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj6EE12insert_innerERKS2_mPKS0_PKS1_Pm = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj7EE11update_nodeEPKS2_jjRS3_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj7EE12insert_innerERKS2_mPKS0_PKS1_Pm = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj8EE11update_nodeEPKS2_jjRS3_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj8EE12insert_innerERKS2_mPKS0_PKS1_Pm = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj9EE11update_nodeEPKS2_jjRS3_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj9EE12insert_innerERKS2_mPKS0_PKS1_Pm = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj10EE11update_nodeEPKS2_jjRS3_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj10EE12insert_innerERKS2_mPKS0_PKS1_Pm = comdat any

$_ZNK2LLI10scheme_key12scheme_valueE6insertEPKS0_PKS1_Pm = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj0EE12remove_innerERKS2_mPKS0_Pm = comdat any

$_ZNK2KVI10scheme_key12scheme_valueLj0EEeqERKS2_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj0EEC2ERKS2_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj1EE12remove_innerERKS2_mPKS0_Pm = comdat any

$_ZNK2KVI10scheme_key12scheme_valueLj1EEeqERKS2_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj2EE12remove_innerERKS2_mPKS0_Pm = comdat any

$_ZNK2KVI10scheme_key12scheme_valueLj2EEeqERKS2_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj3EE12remove_innerERKS2_mPKS0_Pm = comdat any

$_ZNK2KVI10scheme_key12scheme_valueLj3EEeqERKS2_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj4EE12remove_innerERKS2_mPKS0_Pm = comdat any

$_ZNK2KVI10scheme_key12scheme_valueLj4EEeqERKS2_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj5EE12remove_innerERKS2_mPKS0_Pm = comdat any

$_ZNK2KVI10scheme_key12scheme_valueLj5EEeqERKS2_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj6EE12remove_innerERKS2_mPKS0_Pm = comdat any

$_ZNK2KVI10scheme_key12scheme_valueLj6EEeqERKS2_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj7EE12remove_innerERKS2_mPKS0_Pm = comdat any

$_ZNK2KVI10scheme_key12scheme_valueLj7EEeqERKS2_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj8EE12remove_innerERKS2_mPKS0_Pm = comdat any

$_ZNK2KVI10scheme_key12scheme_valueLj8EEeqERKS2_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj9EE12remove_innerERKS2_mPKS0_Pm = comdat any

$_ZNK2KVI10scheme_key12scheme_valueLj9EEeqERKS2_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj10EE12remove_innerERKS2_mPKS0_Pm = comdat any

$_ZNK2KVI10scheme_key12scheme_valueLj10EEeqERKS2_ = comdat any

$_ZNK2LLI10scheme_key12scheme_valueE6removeEPKS0_Pm = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj0EE10inner_findERKS2_mPKS0_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj1EE10inner_findERKS2_mPKS0_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj2EE10inner_findERKS2_mPKS0_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj3EE10inner_findERKS2_mPKS0_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj4EE10inner_findERKS2_mPKS0_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj5EE10inner_findERKS2_mPKS0_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj6EE10inner_findERKS2_mPKS0_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj7EE10inner_findERKS2_mPKS0_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj8EE10inner_findERKS2_mPKS0_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj9EE10inner_findERKS2_mPKS0_ = comdat any

$_ZN2KVI10scheme_key12scheme_valueLj10EE10inner_findERKS2_mPKS0_ = comdat any

$_ZNK2LLI10scheme_key12scheme_valueE4findEPKS0_ = comdat any

@_ZStL8__ioinit = internal global %"class.std::ios_base::Init" zeroinitializer, align 1
@__dso_handle = external global i8
@memory_used_bytes = global i32 0, align 4
@.str = private unnamed_addr constant [25 x i8] c"library run-time error: \00", align 1
@.str.1 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str.2 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.3 = private unnamed_addr constant [20 x i8] c"Memory cap exceeded\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c"%lu\0A\00", align 1
@.str.5 = private unnamed_addr constant [68 x i8] c"Expected value: null (in expect_args0). Prim cannot take arguments.\00", align 1
@.str.6 = private unnamed_addr constant [79 x i8] c"Expected cons value (in expect_args1). Prim applied on an empty argument list.\00", align 1
@.str.7 = private unnamed_addr constant [70 x i8] c"Expected null value (in expect_args1). Prim can only take 1 argument.\00", align 1
@.str.8 = private unnamed_addr constant [37 x i8] c"Expected a cons value. (expect_cons)\00", align 1
@.str.9 = private unnamed_addr constant [51 x i8] c"Expected a vector or special value. (expect_other)\00", align 1
@.str.10 = private unnamed_addr constant [3 x i8] c"()\00", align 1
@.str.11 = private unnamed_addr constant [13 x i8] c"#<procedure>\00", align 1
@.str.12 = private unnamed_addr constant [2 x i8] c"(\00", align 1
@.str.13 = private unnamed_addr constant [4 x i8] c" . \00", align 1
@.str.14 = private unnamed_addr constant [2 x i8] c")\00", align 1
@.str.15 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.16 = private unnamed_addr constant [5 x i8] c"\22%s\22\00", align 1
@.str.17 = private unnamed_addr constant [3 x i8] c"#(\00", align 1
@.str.18 = private unnamed_addr constant [2 x i8] c",\00", align 1
@.str.19 = private unnamed_addr constant [36 x i8] c"(print.. v); unrecognized value %lu\00", align 1
@.str.20 = private unnamed_addr constant [4 x i8] c"'()\00", align 1
@.str.21 = private unnamed_addr constant [3 x i8] c"'(\00", align 1
@.str.22 = private unnamed_addr constant [4 x i8] c"'%s\00", align 1
@.str.23 = private unnamed_addr constant [34 x i8] c"(print v); unrecognized value %lu\00", align 1
@.str.24 = private unnamed_addr constant [49 x i8] c"first argument to make-vector must be an integer\00", align 1
@.str.25 = private unnamed_addr constant [39 x i8] c"prim applied on more than 2 arguments.\00", align 1
@.str.26 = private unnamed_addr constant [49 x i8] c"second argument to vector-ref must be an integer\00", align 1
@.str.27 = private unnamed_addr constant [46 x i8] c"first argument to vector-ref must be a vector\00", align 1
@.str.28 = private unnamed_addr constant [46 x i8] c"vector-ref not given a properly formed vector\00", align 1
@.str.29 = private unnamed_addr constant [48 x i8] c"first argument to vector-ref must be an integer\00", align 1
@.str.30 = private unnamed_addr constant [6 x i8] c"HELLO\00", align 1
@.str.31 = private unnamed_addr constant [8 x i8] c"GOODBYE\00", align 1
@.str.32 = private unnamed_addr constant [28 x i8] c"Non-function value applied.\00", align 1
@.str.33 = private unnamed_addr constant [34 x i8] c"(prim + a b); a is not an integer\00", align 1
@.str.34 = private unnamed_addr constant [34 x i8] c"(prim + a b); b is not an integer\00", align 1
@.str.35 = private unnamed_addr constant [36 x i8] c"Tried to apply + on non list value.\00", align 1
@.str.36 = private unnamed_addr constant [34 x i8] c"(prim - a b); b is not an integer\00", align 1
@.str.37 = private unnamed_addr constant [36 x i8] c"Tried to apply - on non list value.\00", align 1
@.str.38 = private unnamed_addr constant [34 x i8] c"(prim * a b); a is not an integer\00", align 1
@.str.39 = private unnamed_addr constant [34 x i8] c"(prim * a b); b is not an integer\00", align 1
@.str.40 = private unnamed_addr constant [34 x i8] c"(prim / a b); a is not an integer\00", align 1
@.str.41 = private unnamed_addr constant [34 x i8] c"(prim / a b); b is not an integer\00", align 1
@.str.42 = private unnamed_addr constant [47 x i8] c"(prim / a b); b is 0: Division by 0 undefined.\00", align 1
@.str.43 = private unnamed_addr constant [34 x i8] c"(prim = a b); a is not an integer\00", align 1
@.str.44 = private unnamed_addr constant [34 x i8] c"(prim = a b); b is not an integer\00", align 1
@.str.45 = private unnamed_addr constant [34 x i8] c"(prim < a b); a is not an integer\00", align 1
@.str.46 = private unnamed_addr constant [34 x i8] c"(prim < a b); b is not an integer\00", align 1
@.str.47 = private unnamed_addr constant [35 x i8] c"(prim <= a b); a is not an integer\00", align 1
@.str.48 = private unnamed_addr constant [35 x i8] c"(prim <= a b); b is not an integer\00", align 1
@.str.49 = private unnamed_addr constant [39 x i8] c"prim not (a): a is not a boolean value\00", align 1
@llvm.global_ctors = appending global [1 x { i32, void ()*, i8* }] [{ i32, void ()*, i8* } { i32 65535, void ()* @_GLOBAL__sub_I_header.cpp, i8* null }]

; Function Attrs: uwtable
define internal void @__cxx_global_var_init() #0 section ".text.startup" {
  call void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"* @_ZStL8__ioinit)
  %1 = call i32 @__cxa_atexit(void (i8*)* bitcast (void (%"class.std::ios_base::Init"*)* @_ZNSt8ios_base4InitD1Ev to void (i8*)*), i8* getelementptr inbounds (%"class.std::ios_base::Init", %"class.std::ios_base::Init"* @_ZStL8__ioinit, i32 0, i32 0), i8* @__dso_handle) #3
  ret void
}

declare void @_ZNSt8ios_base4InitC1Ev(%"class.std::ios_base::Init"*) #1

; Function Attrs: nounwind
declare void @_ZNSt8ios_base4InitD1Ev(%"class.std::ios_base::Init"*) #2

; Function Attrs: nounwind
declare i32 @__cxa_atexit(void (i8*)*, i8*, i8*) #3

; Function Attrs: uwtable
define void @fatal_err(i8* %msg) #0 {
  %1 = alloca i8*, align 8
  store i8* %msg, i8** %1, align 8
  %2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str, i32 0, i32 0))
  %3 = load i8*, i8** %1, align 8
  %4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i32 0, i32 0), i8* %3)
  %5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 1) #9
  unreachable
                                                  ; No predecessors!
  ret void
}

declare i32 @printf(i8*, ...) #1

; Function Attrs: noreturn nounwind
declare void @exit(i32) #4

; Function Attrs: nounwind uwtable
define i64 @expect_not_cons(i64 %p) #5 {
  %1 = alloca i64, align 8
  store i64 %p, i64* %1, align 8
  ret i64 31
}

; Function Attrs: uwtable
define i64* @alloc(i64 %m) #0 {
  %1 = alloca i64*, align 8
  %2 = alloca i64, align 8
  store i64 %m, i64* %2, align 8
  %3 = call i64 @GC_get_heap_size()
  %4 = icmp ult i64 %3, 512000000
  br i1 %4, label %5, label %9

; <label>:5                                       ; preds = %0
  %6 = load i64, i64* %2, align 8
  %7 = call noalias i8* @GC_malloc(i64 %6)
  %8 = bitcast i8* %7 to i64*
  store i64* %8, i64** %1, align 8
  br label %11

; <label>:9                                       ; preds = %0
  call void @fatal_err(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.3, i32 0, i32 0))
  br label %10

; <label>:10                                      ; preds = %9
  store i64* null, i64** %1, align 8
  br label %11

; <label>:11                                      ; preds = %10, %5
  %12 = load i64*, i64** %1, align 8
  ret i64* %12
}

declare i64 @GC_get_heap_size() #1

declare noalias i8* @GC_malloc(i64) #1

; Function Attrs: uwtable
define i64* @make_closure(i64 %size) #0 {
  %1 = alloca i64, align 8
  %s = alloca i32, align 4
  %clo = alloca i64*, align 8
  store i64 %size, i64* %1, align 8
  store i32 8, i32* %s, align 4
  %2 = load i64, i64* %1, align 8
  %3 = load i32, i32* %s, align 4
  %4 = sext i32 %3 to i64
  %5 = add i64 %2, %4
  %6 = call i64* @alloc(i64 %5)
  store i64* %6, i64** %clo, align 8
  %7 = load i64*, i64** %clo, align 8
  %8 = getelementptr inbounds i64, i64* %7, i64 0
  store i64 0, i64* %8, align 8
  %9 = load i64*, i64** %clo, align 8
  ret i64* %9
}

; Function Attrs: uwtable
define void @print_u64(i64 %i) #0 {
  %1 = alloca i64, align 8
  store i64 %i, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0), i64 %2)
  ret void
}

; Function Attrs: uwtable
define i64 @expect_args0(i64 %args) #0 {
  %1 = alloca i64, align 8
  store i64 %args, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %4, label %5

; <label>:4                                       ; preds = %0
  call void @fatal_err(i8* getelementptr inbounds ([68 x i8], [68 x i8]* @.str.5, i32 0, i32 0))
  br label %5

; <label>:5                                       ; preds = %4, %0
  ret i64 0
}

; Function Attrs: uwtable
define i64 @expect_args1(i64 %args) #0 {
  %1 = alloca i64, align 8
  %p = alloca i64*, align 8
  store i64 %args, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = and i64 %2, 7
  %4 = icmp ne i64 %3, 1
  br i1 %4, label %5, label %6

; <label>:5                                       ; preds = %0
  call void @fatal_err(i8* getelementptr inbounds ([79 x i8], [79 x i8]* @.str.6, i32 0, i32 0))
  br label %6

; <label>:6                                       ; preds = %5, %0
  %7 = load i64, i64* %1, align 8
  %8 = and i64 %7, -8
  %9 = inttoptr i64 %8 to i64*
  store i64* %9, i64** %p, align 8
  %10 = load i64*, i64** %p, align 8
  %11 = getelementptr inbounds i64, i64* %10, i64 1
  %12 = load i64, i64* %11, align 8
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %14, label %15

; <label>:14                                      ; preds = %6
  call void @fatal_err(i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.7, i32 0, i32 0))
  br label %15

; <label>:15                                      ; preds = %14, %6
  %16 = load i64*, i64** %p, align 8
  %17 = getelementptr inbounds i64, i64* %16, i64 0
  %18 = load i64, i64* %17, align 8
  ret i64 %18
}

; Function Attrs: uwtable
define i64 @expect_cons(i64 %p, i64* %rest) #0 {
  %1 = alloca i64, align 8
  %2 = alloca i64*, align 8
  %pp = alloca i64*, align 8
  store i64 %p, i64* %1, align 8
  store i64* %rest, i64** %2, align 8
  %3 = load i64, i64* %1, align 8
  %4 = and i64 %3, 7
  %5 = icmp ne i64 %4, 1
  br i1 %5, label %6, label %7

; <label>:6                                       ; preds = %0
  call void @fatal_err(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.8, i32 0, i32 0))
  br label %7

; <label>:7                                       ; preds = %6, %0
  %8 = load i64, i64* %1, align 8
  %9 = and i64 %8, -8
  %10 = inttoptr i64 %9 to i64*
  store i64* %10, i64** %pp, align 8
  %11 = load i64*, i64** %pp, align 8
  %12 = getelementptr inbounds i64, i64* %11, i64 1
  %13 = load i64, i64* %12, align 8
  %14 = load i64*, i64** %2, align 8
  store i64 %13, i64* %14, align 8
  %15 = load i64*, i64** %pp, align 8
  %16 = getelementptr inbounds i64, i64* %15, i64 0
  %17 = load i64, i64* %16, align 8
  ret i64 %17
}

; Function Attrs: uwtable
define i64 @expect_other(i64 %v, i64* %rest) #0 {
  %1 = alloca i64, align 8
  %2 = alloca i64*, align 8
  %p = alloca i64*, align 8
  store i64 %v, i64* %1, align 8
  store i64* %rest, i64** %2, align 8
  %3 = load i64, i64* %1, align 8
  %4 = and i64 %3, 7
  %5 = icmp ne i64 %4, 6
  br i1 %5, label %6, label %7

; <label>:6                                       ; preds = %0
  call void @fatal_err(i8* getelementptr inbounds ([51 x i8], [51 x i8]* @.str.9, i32 0, i32 0))
  br label %7

; <label>:7                                       ; preds = %6, %0
  %8 = load i64, i64* %1, align 8
  %9 = and i64 %8, -8
  %10 = inttoptr i64 %9 to i64*
  store i64* %10, i64** %p, align 8
  %11 = load i64*, i64** %p, align 8
  %12 = getelementptr inbounds i64, i64* %11, i64 1
  %13 = load i64, i64* %12, align 8
  %14 = load i64*, i64** %2, align 8
  store i64 %13, i64* %14, align 8
  %15 = load i64*, i64** %p, align 8
  %16 = getelementptr inbounds i64, i64* %15, i64 0
  %17 = load i64, i64* %16, align 8
  ret i64 %17
}

; Function Attrs: nounwind uwtable
define i64 @const_init_int(i64 %i) #5 {
  %1 = alloca i64, align 8
  store i64 %i, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = trunc i64 %2 to i32
  %4 = zext i32 %3 to i64
  %5 = shl i64 %4, 32
  %6 = or i64 %5, 2
  ret i64 %6
}

; Function Attrs: nounwind uwtable
define i64 @const_init_void() #5 {
  ret i64 39
}

; Function Attrs: nounwind uwtable
define i64 @const_init_null() #5 {
  ret i64 0
}

; Function Attrs: nounwind uwtable
define i64 @const_init_true() #5 {
  ret i64 31
}

; Function Attrs: nounwind uwtable
define i64 @const_init_false() #5 {
  ret i64 15
}

; Function Attrs: nounwind uwtable
define i64 @const_init_string(i8* %s) #5 {
  %1 = alloca i8*, align 8
  store i8* %s, i8** %1, align 8
  %2 = load i8*, i8** %1, align 8
  %3 = ptrtoint i8* %2 to i64
  %4 = or i64 %3, 3
  ret i64 %4
}

; Function Attrs: nounwind uwtable
define i64 @const_init_symbol(i8* %s) #5 {
  %1 = alloca i8*, align 8
  store i8* %s, i8** %1, align 8
  %2 = load i8*, i8** %1, align 8
  %3 = ptrtoint i8* %2 to i64
  %4 = or i64 %3, 4
  ret i64 %4
}

; Function Attrs: uwtable
define i64 @prim_print_aux(i64 %v) #0 {
  %1 = alloca i64, align 8
  %p = alloca i64*, align 8
  %vec = alloca i64*, align 8
  %len = alloca i64, align 8
  %i = alloca i64, align 8
  store i64 %v, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = icmp eq i64 %2, 0
  br i1 %3, label %4, label %6

; <label>:4                                       ; preds = %0
  %5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.10, i32 0, i32 0))
  br label %108

; <label>:6                                       ; preds = %0
  %7 = load i64, i64* %1, align 8
  %8 = and i64 %7, 7
  %9 = icmp eq i64 %8, 0
  br i1 %9, label %10, label %12

; <label>:10                                      ; preds = %6
  %11 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.11, i32 0, i32 0))
  br label %107

; <label>:12                                      ; preds = %6
  %13 = load i64, i64* %1, align 8
  %14 = and i64 %13, 7
  %15 = icmp eq i64 %14, 1
  br i1 %15, label %16, label %31

; <label>:16                                      ; preds = %12
  %17 = load i64, i64* %1, align 8
  %18 = and i64 %17, -8
  %19 = inttoptr i64 %18 to i64*
  store i64* %19, i64** %p, align 8
  %20 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.12, i32 0, i32 0))
  %21 = load i64*, i64** %p, align 8
  %22 = getelementptr inbounds i64, i64* %21, i64 0
  %23 = load i64, i64* %22, align 8
  %24 = call i64 @prim_print_aux(i64 %23)
  %25 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.13, i32 0, i32 0))
  %26 = load i64*, i64** %p, align 8
  %27 = getelementptr inbounds i64, i64* %26, i64 1
  %28 = load i64, i64* %27, align 8
  %29 = call i64 @prim_print_aux(i64 %28)
  %30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.14, i32 0, i32 0))
  br label %106

; <label>:31                                      ; preds = %12
  %32 = load i64, i64* %1, align 8
  %33 = and i64 %32, 7
  %34 = icmp eq i64 %33, 2
  br i1 %34, label %35, label %40

; <label>:35                                      ; preds = %31
  %36 = load i64, i64* %1, align 8
  %37 = lshr i64 %36, 32
  %38 = trunc i64 %37 to i32
  %39 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.15, i32 0, i32 0), i32 %38)
  br label %105

; <label>:40                                      ; preds = %31
  %41 = load i64, i64* %1, align 8
  %42 = and i64 %41, 7
  %43 = icmp eq i64 %42, 3
  br i1 %43, label %44, label %49

; <label>:44                                      ; preds = %40
  %45 = load i64, i64* %1, align 8
  %46 = and i64 %45, -8
  %47 = inttoptr i64 %46 to i8*
  %48 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.16, i32 0, i32 0), i8* %47)
  br label %104

; <label>:49                                      ; preds = %40
  %50 = load i64, i64* %1, align 8
  %51 = and i64 %50, 7
  %52 = icmp eq i64 %51, 4
  br i1 %52, label %53, label %58

; <label>:53                                      ; preds = %49
  %54 = load i64, i64* %1, align 8
  %55 = and i64 %54, -8
  %56 = inttoptr i64 %55 to i8*
  %57 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i32 0, i32 0), i8* %56)
  br label %103

; <label>:58                                      ; preds = %49
  %59 = load i64, i64* %1, align 8
  %60 = and i64 %59, 7
  %61 = icmp eq i64 %60, 6
  br i1 %61, label %62, label %99

; <label>:62                                      ; preds = %58
  %63 = load i64, i64* %1, align 8
  %64 = and i64 %63, -8
  %65 = inttoptr i64 %64 to i64*
  %66 = getelementptr inbounds i64, i64* %65, i64 0
  %67 = load i64, i64* %66, align 8
  %68 = and i64 %67, 7
  %69 = icmp eq i64 1, %68
  br i1 %69, label %70, label %99

; <label>:70                                      ; preds = %62
  %71 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.17, i32 0, i32 0))
  %72 = load i64, i64* %1, align 8
  %73 = and i64 %72, -8
  %74 = inttoptr i64 %73 to i64*
  store i64* %74, i64** %vec, align 8
  %75 = load i64*, i64** %vec, align 8
  %76 = getelementptr inbounds i64, i64* %75, i64 0
  %77 = load i64, i64* %76, align 8
  %78 = lshr i64 %77, 3
  store i64 %78, i64* %len, align 8
  %79 = load i64*, i64** %vec, align 8
  %80 = getelementptr inbounds i64, i64* %79, i64 1
  %81 = load i64, i64* %80, align 8
  %82 = call i64 @prim_print_aux(i64 %81)
  store i64 2, i64* %i, align 8
  br label %83

; <label>:83                                      ; preds = %94, %70
  %84 = load i64, i64* %i, align 8
  %85 = load i64, i64* %len, align 8
  %86 = icmp ule i64 %84, %85
  br i1 %86, label %87, label %97

; <label>:87                                      ; preds = %83
  %88 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.18, i32 0, i32 0))
  %89 = load i64, i64* %i, align 8
  %90 = load i64*, i64** %vec, align 8
  %91 = getelementptr inbounds i64, i64* %90, i64 %89
  %92 = load i64, i64* %91, align 8
  %93 = call i64 @prim_print_aux(i64 %92)
  br label %94

; <label>:94                                      ; preds = %87
  %95 = load i64, i64* %i, align 8
  %96 = add i64 %95, 1
  store i64 %96, i64* %i, align 8
  br label %83

; <label>:97                                      ; preds = %83
  %98 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.14, i32 0, i32 0))
  br label %102

; <label>:99                                      ; preds = %62, %58
  %100 = load i64, i64* %1, align 8
  %101 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.19, i32 0, i32 0), i64 %100)
  br label %102

; <label>:102                                     ; preds = %99, %97
  br label %103

; <label>:103                                     ; preds = %102, %53
  br label %104

; <label>:104                                     ; preds = %103, %44
  br label %105

; <label>:105                                     ; preds = %104, %35
  br label %106

; <label>:106                                     ; preds = %105, %16
  br label %107

; <label>:107                                     ; preds = %106, %10
  br label %108

; <label>:108                                     ; preds = %107, %4
  ret i64 39
}

; Function Attrs: uwtable
define i64 @prim_print(i64 %v) #0 {
  %1 = alloca i64, align 8
  %p = alloca i64*, align 8
  %vec = alloca i64*, align 8
  %len = alloca i64, align 8
  %i = alloca i64, align 8
  store i64 %v, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = icmp eq i64 %2, 0
  br i1 %3, label %4, label %6

; <label>:4                                       ; preds = %0
  %5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.20, i32 0, i32 0))
  br label %108

; <label>:6                                       ; preds = %0
  %7 = load i64, i64* %1, align 8
  %8 = and i64 %7, 7
  %9 = icmp eq i64 %8, 0
  br i1 %9, label %10, label %12

; <label>:10                                      ; preds = %6
  %11 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.11, i32 0, i32 0))
  br label %107

; <label>:12                                      ; preds = %6
  %13 = load i64, i64* %1, align 8
  %14 = and i64 %13, 7
  %15 = icmp eq i64 %14, 1
  br i1 %15, label %16, label %31

; <label>:16                                      ; preds = %12
  %17 = load i64, i64* %1, align 8
  %18 = and i64 %17, -8
  %19 = inttoptr i64 %18 to i64*
  store i64* %19, i64** %p, align 8
  %20 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.21, i32 0, i32 0))
  %21 = load i64*, i64** %p, align 8
  %22 = getelementptr inbounds i64, i64* %21, i64 0
  %23 = load i64, i64* %22, align 8
  %24 = call i64 @prim_print_aux(i64 %23)
  %25 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.13, i32 0, i32 0))
  %26 = load i64*, i64** %p, align 8
  %27 = getelementptr inbounds i64, i64* %26, i64 1
  %28 = load i64, i64* %27, align 8
  %29 = call i64 @prim_print_aux(i64 %28)
  %30 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.14, i32 0, i32 0))
  br label %106

; <label>:31                                      ; preds = %12
  %32 = load i64, i64* %1, align 8
  %33 = and i64 %32, 7
  %34 = icmp eq i64 %33, 2
  br i1 %34, label %35, label %40

; <label>:35                                      ; preds = %31
  %36 = load i64, i64* %1, align 8
  %37 = lshr i64 %36, 32
  %38 = trunc i64 %37 to i32
  %39 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.15, i32 0, i32 0), i32 %38)
  br label %105

; <label>:40                                      ; preds = %31
  %41 = load i64, i64* %1, align 8
  %42 = and i64 %41, 7
  %43 = icmp eq i64 %42, 3
  br i1 %43, label %44, label %49

; <label>:44                                      ; preds = %40
  %45 = load i64, i64* %1, align 8
  %46 = and i64 %45, -8
  %47 = inttoptr i64 %46 to i8*
  %48 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.16, i32 0, i32 0), i8* %47)
  br label %104

; <label>:49                                      ; preds = %40
  %50 = load i64, i64* %1, align 8
  %51 = and i64 %50, 7
  %52 = icmp eq i64 %51, 4
  br i1 %52, label %53, label %58

; <label>:53                                      ; preds = %49
  %54 = load i64, i64* %1, align 8
  %55 = and i64 %54, -8
  %56 = inttoptr i64 %55 to i8*
  %57 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.22, i32 0, i32 0), i8* %56)
  br label %103

; <label>:58                                      ; preds = %49
  %59 = load i64, i64* %1, align 8
  %60 = and i64 %59, 7
  %61 = icmp eq i64 %60, 6
  br i1 %61, label %62, label %99

; <label>:62                                      ; preds = %58
  %63 = load i64, i64* %1, align 8
  %64 = and i64 %63, -8
  %65 = inttoptr i64 %64 to i64*
  %66 = getelementptr inbounds i64, i64* %65, i64 0
  %67 = load i64, i64* %66, align 8
  %68 = and i64 %67, 7
  %69 = icmp eq i64 1, %68
  br i1 %69, label %70, label %99

; <label>:70                                      ; preds = %62
  %71 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.17, i32 0, i32 0))
  %72 = load i64, i64* %1, align 8
  %73 = and i64 %72, -8
  %74 = inttoptr i64 %73 to i64*
  store i64* %74, i64** %vec, align 8
  %75 = load i64*, i64** %vec, align 8
  %76 = getelementptr inbounds i64, i64* %75, i64 0
  %77 = load i64, i64* %76, align 8
  %78 = lshr i64 %77, 3
  store i64 %78, i64* %len, align 8
  %79 = load i64*, i64** %vec, align 8
  %80 = getelementptr inbounds i64, i64* %79, i64 1
  %81 = load i64, i64* %80, align 8
  %82 = call i64 @prim_print(i64 %81)
  store i64 2, i64* %i, align 8
  br label %83

; <label>:83                                      ; preds = %94, %70
  %84 = load i64, i64* %i, align 8
  %85 = load i64, i64* %len, align 8
  %86 = icmp ule i64 %84, %85
  br i1 %86, label %87, label %97

; <label>:87                                      ; preds = %83
  %88 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.18, i32 0, i32 0))
  %89 = load i64, i64* %i, align 8
  %90 = load i64*, i64** %vec, align 8
  %91 = getelementptr inbounds i64, i64* %90, i64 %89
  %92 = load i64, i64* %91, align 8
  %93 = call i64 @prim_print(i64 %92)
  br label %94

; <label>:94                                      ; preds = %87
  %95 = load i64, i64* %i, align 8
  %96 = add i64 %95, 1
  store i64 %96, i64* %i, align 8
  br label %83

; <label>:97                                      ; preds = %83
  %98 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.14, i32 0, i32 0))
  br label %102

; <label>:99                                      ; preds = %62, %58
  %100 = load i64, i64* %1, align 8
  %101 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.23, i32 0, i32 0), i64 %100)
  br label %102

; <label>:102                                     ; preds = %99, %97
  br label %103

; <label>:103                                     ; preds = %102, %53
  br label %104

; <label>:104                                     ; preds = %103, %44
  br label %105

; <label>:105                                     ; preds = %104, %35
  br label %106

; <label>:106                                     ; preds = %105, %16
  br label %107

; <label>:107                                     ; preds = %106, %10
  br label %108

; <label>:108                                     ; preds = %107, %4
  ret i64 39
}

; Function Attrs: uwtable
define i64 @applyprim_print(i64 %lst) #0 {
  %1 = alloca i64, align 8
  %v0 = alloca i64, align 8
  store i64 %lst, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = call i64 @expect_args1(i64 %2)
  store i64 %3, i64* %v0, align 8
  %4 = load i64, i64* %v0, align 8
  %5 = call i64 @prim_print(i64 %4)
  ret i64 %5
}

; Function Attrs: uwtable
define i64 @prim_halt(i64 %v) #0 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  store i64 %v, i64* %2, align 8
  %3 = load i64, i64* %2, align 8
  %4 = call i64 @prim_print(i64 %3)
  %5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.2, i32 0, i32 0))
  call void @exit(i32 0) #9
  unreachable
                                                  ; No predecessors!
  %7 = load i64, i64* %1, align 8
  ret i64 %7
}

; Function Attrs: uwtable
define i64 @applyprim_vector(i64 %lst) #0 {
  %1 = alloca i64, align 8
  %buffer = alloca i64*, align 8
  %l = alloca i64, align 8
  %mem = alloca i64*, align 8
  %i = alloca i64, align 8
  store i64 %lst, i64* %1, align 8
  %2 = call i64* @alloc(i64 4096)
  store i64* %2, i64** %buffer, align 8
  store i64 0, i64* %l, align 8
  br label %3

; <label>:3                                       ; preds = %12, %0
  %4 = load i64, i64* %1, align 8
  %5 = and i64 %4, 7
  %6 = icmp eq i64 %5, 1
  br i1 %6, label %7, label %10

; <label>:7                                       ; preds = %3
  %8 = load i64, i64* %l, align 8
  %9 = icmp ult i64 %8, 512
  br label %10

; <label>:10                                      ; preds = %7, %3
  %11 = phi i1 [ false, %3 ], [ %9, %7 ]
  br i1 %11, label %12, label %19

; <label>:12                                      ; preds = %10
  %13 = load i64, i64* %1, align 8
  %14 = call i64 @expect_cons(i64 %13, i64* %1)
  %15 = load i64, i64* %l, align 8
  %16 = add i64 %15, 1
  store i64 %16, i64* %l, align 8
  %17 = load i64*, i64** %buffer, align 8
  %18 = getelementptr inbounds i64, i64* %17, i64 %15
  store i64 %14, i64* %18, align 8
  br label %3

; <label>:19                                      ; preds = %10
  %20 = load i64, i64* %l, align 8
  %21 = add i64 %20, 1
  %22 = mul i64 %21, 8
  %23 = call i64* @alloc(i64 %22)
  store i64* %23, i64** %mem, align 8
  %24 = load i64, i64* %l, align 8
  %25 = shl i64 %24, 3
  %26 = or i64 %25, 1
  %27 = load i64*, i64** %mem, align 8
  %28 = getelementptr inbounds i64, i64* %27, i64 0
  store i64 %26, i64* %28, align 8
  store i64 0, i64* %i, align 8
  br label %29

; <label>:29                                      ; preds = %42, %19
  %30 = load i64, i64* %i, align 8
  %31 = load i64, i64* %l, align 8
  %32 = icmp ult i64 %30, %31
  br i1 %32, label %33, label %45

; <label>:33                                      ; preds = %29
  %34 = load i64, i64* %i, align 8
  %35 = load i64*, i64** %buffer, align 8
  %36 = getelementptr inbounds i64, i64* %35, i64 %34
  %37 = load i64, i64* %36, align 8
  %38 = load i64, i64* %i, align 8
  %39 = add i64 %38, 1
  %40 = load i64*, i64** %mem, align 8
  %41 = getelementptr inbounds i64, i64* %40, i64 %39
  store i64 %37, i64* %41, align 8
  br label %42

; <label>:42                                      ; preds = %33
  %43 = load i64, i64* %i, align 8
  %44 = add i64 %43, 1
  store i64 %44, i64* %i, align 8
  br label %29

; <label>:45                                      ; preds = %29
  %46 = load i64*, i64** %buffer, align 8
  %47 = icmp eq i64* %46, null
  br i1 %47, label %50, label %48

; <label>:48                                      ; preds = %45
  %49 = bitcast i64* %46 to i8*
  call void @_ZdaPv(i8* %49) #10
  br label %50

; <label>:50                                      ; preds = %48, %45
  %51 = load i64*, i64** %mem, align 8
  %52 = ptrtoint i64* %51 to i64
  %53 = or i64 %52, 6
  ret i64 %53
}

; Function Attrs: nobuiltin nounwind
declare void @_ZdaPv(i8*) #6

; Function Attrs: uwtable
define i64 @prim_make_45vector(i64 %lenv, i64 %iv) #0 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  %l = alloca i64, align 8
  %vec = alloca i64*, align 8
  %i = alloca i64, align 8
  store i64 %lenv, i64* %1, align 8
  store i64 %iv, i64* %2, align 8
  %3 = load i64, i64* %1, align 8
  %4 = and i64 %3, 7
  %5 = icmp ne i64 %4, 2
  br i1 %5, label %6, label %7

; <label>:6                                       ; preds = %0
  call void @fatal_err(i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.24, i32 0, i32 0))
  br label %7

; <label>:7                                       ; preds = %6, %0
  %8 = load i64, i64* %1, align 8
  %9 = and i64 %8, -8
  %10 = lshr i64 %9, 32
  %11 = trunc i64 %10 to i32
  %12 = sext i32 %11 to i64
  store i64 %12, i64* %l, align 8
  %13 = load i64, i64* %l, align 8
  %14 = add i64 %13, 1
  %15 = mul i64 %14, 8
  %16 = call i64* @alloc(i64 %15)
  store i64* %16, i64** %vec, align 8
  %17 = load i64, i64* %l, align 8
  %18 = shl i64 %17, 3
  %19 = or i64 %18, 1
  %20 = load i64*, i64** %vec, align 8
  %21 = getelementptr inbounds i64, i64* %20, i64 0
  store i64 %19, i64* %21, align 8
  store i64 1, i64* %i, align 8
  br label %22

; <label>:22                                      ; preds = %31, %7
  %23 = load i64, i64* %i, align 8
  %24 = load i64, i64* %l, align 8
  %25 = icmp ule i64 %23, %24
  br i1 %25, label %26, label %34

; <label>:26                                      ; preds = %22
  %27 = load i64, i64* %2, align 8
  %28 = load i64, i64* %i, align 8
  %29 = load i64*, i64** %vec, align 8
  %30 = getelementptr inbounds i64, i64* %29, i64 %28
  store i64 %27, i64* %30, align 8
  br label %31

; <label>:31                                      ; preds = %26
  %32 = load i64, i64* %i, align 8
  %33 = add i64 %32, 1
  store i64 %33, i64* %i, align 8
  br label %22

; <label>:34                                      ; preds = %22
  %35 = load i64*, i64** %vec, align 8
  %36 = ptrtoint i64* %35 to i64
  %37 = or i64 %36, 6
  ret i64 %37
}

; Function Attrs: uwtable
define i64 @applyprim_make_45vector(i64 %lst) #0 {
  %1 = alloca i64, align 8
  %rest = alloca i64, align 8
  %v0 = alloca i64, align 8
  %v1 = alloca i64, align 8
  store i64 %lst, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = call i64 @expect_cons(i64 %2, i64* %rest)
  store i64 %3, i64* %v0, align 8
  %4 = load i64, i64* %rest, align 8
  %5 = call i64 @expect_cons(i64 %4, i64* %rest)
  store i64 %5, i64* %v1, align 8
  %6 = load i64, i64* %rest, align 8
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %8, label %9

; <label>:8                                       ; preds = %0
  call void @fatal_err(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.25, i32 0, i32 0))
  br label %9

; <label>:9                                       ; preds = %8, %0
  %10 = load i64, i64* %v0, align 8
  %11 = load i64, i64* %v1, align 8
  %12 = call i64 @prim_make_45vector(i64 %10, i64 %11)
  ret i64 %12
}

; Function Attrs: uwtable
define i64 @prim_vector_45ref(i64 %v, i64 %i) #0 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  store i64 %v, i64* %1, align 8
  store i64 %i, i64* %2, align 8
  %3 = load i64, i64* %2, align 8
  %4 = and i64 %3, 7
  %5 = icmp ne i64 %4, 2
  br i1 %5, label %6, label %7

; <label>:6                                       ; preds = %0
  call void @fatal_err(i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.26, i32 0, i32 0))
  br label %7

; <label>:7                                       ; preds = %6, %0
  %8 = load i64, i64* %1, align 8
  %9 = and i64 %8, 7
  %10 = icmp ne i64 %9, 6
  br i1 %10, label %11, label %12

; <label>:11                                      ; preds = %7
  call void @fatal_err(i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.27, i32 0, i32 0))
  br label %12

; <label>:12                                      ; preds = %11, %7
  %13 = load i64, i64* %1, align 8
  %14 = and i64 %13, -8
  %15 = inttoptr i64 %14 to i64*
  %16 = getelementptr inbounds i64, i64* %15, i64 0
  %17 = load i64, i64* %16, align 8
  %18 = and i64 %17, 7
  %19 = icmp ne i64 %18, 1
  br i1 %19, label %20, label %21

; <label>:20                                      ; preds = %12
  call void @fatal_err(i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.28, i32 0, i32 0))
  br label %21

; <label>:21                                      ; preds = %20, %12
  %22 = load i64, i64* %2, align 8
  %23 = and i64 %22, -8
  %24 = lshr i64 %23, 32
  %25 = trunc i64 %24 to i32
  %26 = add nsw i32 1, %25
  %27 = sext i32 %26 to i64
  %28 = load i64, i64* %1, align 8
  %29 = and i64 %28, -8
  %30 = inttoptr i64 %29 to i64*
  %31 = getelementptr inbounds i64, i64* %30, i64 %27
  %32 = load i64, i64* %31, align 8
  ret i64 %32
}

; Function Attrs: uwtable
define i64 @applyprim_vector_45ref(i64 %lst) #0 {
  %1 = alloca i64, align 8
  %rest = alloca i64, align 8
  %v0 = alloca i64, align 8
  %v1 = alloca i64, align 8
  store i64 %lst, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = call i64 @expect_cons(i64 %2, i64* %rest)
  store i64 %3, i64* %v0, align 8
  %4 = load i64, i64* %rest, align 8
  %5 = call i64 @expect_cons(i64 %4, i64* %rest)
  store i64 %5, i64* %v1, align 8
  %6 = load i64, i64* %rest, align 8
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %8, label %9

; <label>:8                                       ; preds = %0
  call void @fatal_err(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.25, i32 0, i32 0))
  br label %9

; <label>:9                                       ; preds = %8, %0
  %10 = load i64, i64* %v0, align 8
  %11 = load i64, i64* %v1, align 8
  %12 = call i64 @prim_vector_45ref(i64 %10, i64 %11)
  ret i64 %12
}

; Function Attrs: uwtable
define i64 @prim_vector_45set_33(i64 %a, i64 %i, i64 %v) #0 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  store i64 %a, i64* %1, align 8
  store i64 %i, i64* %2, align 8
  store i64 %v, i64* %3, align 8
  %4 = load i64, i64* %2, align 8
  %5 = and i64 %4, 7
  %6 = icmp ne i64 %5, 2
  br i1 %6, label %7, label %8

; <label>:7                                       ; preds = %0
  call void @fatal_err(i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.26, i32 0, i32 0))
  br label %8

; <label>:8                                       ; preds = %7, %0
  %9 = load i64, i64* %1, align 8
  %10 = and i64 %9, 7
  %11 = icmp ne i64 %10, 6
  br i1 %11, label %12, label %13

; <label>:12                                      ; preds = %8
  call void @fatal_err(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.29, i32 0, i32 0))
  br label %13

; <label>:13                                      ; preds = %12, %8
  %14 = load i64, i64* %1, align 8
  %15 = and i64 %14, -8
  %16 = inttoptr i64 %15 to i64*
  %17 = getelementptr inbounds i64, i64* %16, i64 0
  %18 = load i64, i64* %17, align 8
  %19 = and i64 %18, 7
  %20 = icmp ne i64 %19, 1
  br i1 %20, label %21, label %22

; <label>:21                                      ; preds = %13
  call void @fatal_err(i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.28, i32 0, i32 0))
  br label %22

; <label>:22                                      ; preds = %21, %13
  %23 = load i64, i64* %3, align 8
  %24 = load i64, i64* %2, align 8
  %25 = and i64 %24, -8
  %26 = lshr i64 %25, 32
  %27 = trunc i64 %26 to i32
  %28 = add nsw i32 1, %27
  %29 = sext i32 %28 to i64
  %30 = load i64, i64* %1, align 8
  %31 = and i64 %30, -8
  %32 = inttoptr i64 %31 to i64*
  %33 = getelementptr inbounds i64, i64* %32, i64 %29
  store i64 %23, i64* %33, align 8
  ret i64 39
}

; Function Attrs: uwtable
define i64 @applyprim_vector_45set_33(i64 %lst) #0 {
  %1 = alloca i64, align 8
  %rest = alloca i64, align 8
  %v0 = alloca i64, align 8
  %v1 = alloca i64, align 8
  %v2 = alloca i64, align 8
  store i64 %lst, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = call i64 @expect_cons(i64 %2, i64* %rest)
  store i64 %3, i64* %v0, align 8
  %4 = load i64, i64* %rest, align 8
  %5 = call i64 @expect_cons(i64 %4, i64* %rest)
  store i64 %5, i64* %v1, align 8
  %6 = load i64, i64* %rest, align 8
  %7 = call i64 @expect_cons(i64 %6, i64* %rest)
  store i64 %7, i64* %v2, align 8
  %8 = load i64, i64* %rest, align 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %10, label %11

; <label>:10                                      ; preds = %0
  call void @fatal_err(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.25, i32 0, i32 0))
  br label %11

; <label>:11                                      ; preds = %10, %0
  %12 = load i64, i64* %v0, align 8
  %13 = load i64, i64* %v1, align 8
  %14 = load i64, i64* %v2, align 8
  %15 = call i64 @prim_vector_45set_33(i64 %12, i64 %13, i64 %14)
  ret i64 %15
}

; Function Attrs: nounwind uwtable
define i64 @prim_void() #5 {
  ret i64 39
}

; Function Attrs: nounwind uwtable
define i64 @prim_eq_63(i64 %a, i64 %b) #5 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  store i64 %a, i64* %2, align 8
  store i64 %b, i64* %3, align 8
  %4 = load i64, i64* %2, align 8
  %5 = load i64, i64* %3, align 8
  %6 = icmp eq i64 %4, %5
  br i1 %6, label %7, label %8

; <label>:7                                       ; preds = %0
  store i64 31, i64* %1, align 8
  br label %9

; <label>:8                                       ; preds = %0
  store i64 15, i64* %1, align 8
  br label %9

; <label>:9                                       ; preds = %8, %7
  %10 = load i64, i64* %1, align 8
  ret i64 %10
}

; Function Attrs: uwtable
define i64 @applyprim_eq_63(i64 %lst) #0 {
  %1 = alloca i64, align 8
  %rest = alloca i64, align 8
  %v0 = alloca i64, align 8
  %v1 = alloca i64, align 8
  store i64 %lst, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = call i64 @expect_cons(i64 %2, i64* %rest)
  store i64 %3, i64* %v0, align 8
  %4 = load i64, i64* %rest, align 8
  %5 = call i64 @expect_cons(i64 %4, i64* %rest)
  store i64 %5, i64* %v1, align 8
  %6 = load i64, i64* %rest, align 8
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %8, label %9

; <label>:8                                       ; preds = %0
  call void @fatal_err(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.25, i32 0, i32 0))
  br label %9

; <label>:9                                       ; preds = %8, %0
  %10 = load i64, i64* %v0, align 8
  %11 = load i64, i64* %v1, align 8
  %12 = call i64 @prim_eq_63(i64 %10, i64 %11)
  ret i64 %12
}

; Function Attrs: nounwind uwtable
define i64 @prim_eqv_63(i64 %a, i64 %b) #5 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  store i64 %a, i64* %2, align 8
  store i64 %b, i64* %3, align 8
  %4 = load i64, i64* %2, align 8
  %5 = load i64, i64* %3, align 8
  %6 = icmp eq i64 %4, %5
  br i1 %6, label %7, label %8

; <label>:7                                       ; preds = %0
  store i64 31, i64* %1, align 8
  br label %9

; <label>:8                                       ; preds = %0
  store i64 15, i64* %1, align 8
  br label %9

; <label>:9                                       ; preds = %8, %7
  %10 = load i64, i64* %1, align 8
  ret i64 %10
}

; Function Attrs: uwtable
define i64 @applyprim_eqv_63(i64 %lst) #0 {
  %1 = alloca i64, align 8
  %rest = alloca i64, align 8
  %v0 = alloca i64, align 8
  %v1 = alloca i64, align 8
  store i64 %lst, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = call i64 @expect_cons(i64 %2, i64* %rest)
  store i64 %3, i64* %v0, align 8
  %4 = load i64, i64* %rest, align 8
  %5 = call i64 @expect_cons(i64 %4, i64* %rest)
  store i64 %5, i64* %v1, align 8
  %6 = load i64, i64* %rest, align 8
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %8, label %9

; <label>:8                                       ; preds = %0
  call void @fatal_err(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.25, i32 0, i32 0))
  br label %9

; <label>:9                                       ; preds = %8, %0
  %10 = load i64, i64* %v0, align 8
  %11 = load i64, i64* %v1, align 8
  %12 = call i64 @prim_eqv_63(i64 %10, i64 %11)
  ret i64 %12
}

; Function Attrs: nounwind uwtable
define i64 @prim_number_63(i64 %a) #5 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  store i64 %a, i64* %2, align 8
  %3 = load i64, i64* %2, align 8
  %4 = and i64 %3, 7
  %5 = icmp eq i64 %4, 2
  br i1 %5, label %6, label %7

; <label>:6                                       ; preds = %0
  store i64 31, i64* %1, align 8
  br label %8

; <label>:7                                       ; preds = %0
  store i64 15, i64* %1, align 8
  br label %8

; <label>:8                                       ; preds = %7, %6
  %9 = load i64, i64* %1, align 8
  ret i64 %9
}

; Function Attrs: uwtable
define i64 @applyprim_number_63(i64 %lst) #0 {
  %1 = alloca i64, align 8
  %v0 = alloca i64, align 8
  store i64 %lst, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = call i64 @expect_args1(i64 %2)
  store i64 %3, i64* %v0, align 8
  %4 = load i64, i64* %v0, align 8
  %5 = call i64 @prim_number_63(i64 %4)
  ret i64 %5
}

; Function Attrs: nounwind uwtable
define i64 @prim_integer_63(i64 %a) #5 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  store i64 %a, i64* %2, align 8
  %3 = load i64, i64* %2, align 8
  %4 = and i64 %3, 7
  %5 = icmp eq i64 %4, 2
  br i1 %5, label %6, label %7

; <label>:6                                       ; preds = %0
  store i64 31, i64* %1, align 8
  br label %8

; <label>:7                                       ; preds = %0
  store i64 15, i64* %1, align 8
  br label %8

; <label>:8                                       ; preds = %7, %6
  %9 = load i64, i64* %1, align 8
  ret i64 %9
}

; Function Attrs: uwtable
define i64 @applyprim_integer_63(i64 %lst) #0 {
  %1 = alloca i64, align 8
  %v0 = alloca i64, align 8
  store i64 %lst, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = call i64 @expect_args1(i64 %2)
  store i64 %3, i64* %v0, align 8
  %4 = load i64, i64* %v0, align 8
  %5 = call i64 @prim_integer_63(i64 %4)
  ret i64 %5
}

; Function Attrs: nounwind uwtable
define i64 @prim_void_63(i64 %a) #5 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  store i64 %a, i64* %2, align 8
  %3 = load i64, i64* %2, align 8
  %4 = icmp eq i64 %3, 39
  br i1 %4, label %5, label %6

; <label>:5                                       ; preds = %0
  store i64 31, i64* %1, align 8
  br label %7

; <label>:6                                       ; preds = %0
  store i64 15, i64* %1, align 8
  br label %7

; <label>:7                                       ; preds = %6, %5
  %8 = load i64, i64* %1, align 8
  ret i64 %8
}

; Function Attrs: uwtable
define i64 @applyprim_void_63(i64 %lst) #0 {
  %1 = alloca i64, align 8
  %v0 = alloca i64, align 8
  store i64 %lst, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = call i64 @expect_args1(i64 %2)
  store i64 %3, i64* %v0, align 8
  %4 = load i64, i64* %v0, align 8
  %5 = call i64 @prim_void_63(i64 %4)
  ret i64 %5
}

; Function Attrs: uwtable
define i64 @prim_procedure_63(i64 %a) #0 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  %v = alloca i64*, align 8
  store i64 %a, i64* %2, align 8
  %3 = load i64, i64* %2, align 8
  %4 = and i64 %3, 7
  %5 = icmp eq i64 %4, 6
  br i1 %5, label %6, label %16

; <label>:6                                       ; preds = %0
  %7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.30, i32 0, i32 0))
  %8 = load i64, i64* %2, align 8
  %9 = and i64 %8, -8
  %10 = inttoptr i64 %9 to i64*
  store i64* %10, i64** %v, align 8
  %11 = load i64*, i64** %v, align 8
  %12 = getelementptr inbounds i64, i64* %11, i64 0
  %13 = load i64, i64* %12, align 8
  %14 = icmp eq i64 %13, 0
  %15 = zext i1 %14 to i64
  store i64 %15, i64* %1, align 8
  br label %18

; <label>:16                                      ; preds = %0
  %17 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.31, i32 0, i32 0))
  store i64 15, i64* %1, align 8
  br label %18

; <label>:18                                      ; preds = %16, %6
  %19 = load i64, i64* %1, align 8
  ret i64 %19
}

; Function Attrs: uwtable
define i64 @applyprim_procedure_63(i64 %lst) #0 {
  %1 = alloca i64, align 8
  %v0 = alloca i64, align 8
  store i64 %lst, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = call i64 @expect_args1(i64 %2)
  store i64 %3, i64* %v0, align 8
  %4 = load i64, i64* %v0, align 8
  %5 = call i64 @prim_procedure_63(i64 %4)
  ret i64 %5
}

; Function Attrs: uwtable
define i64 @validate_application(i64 %f) #0 {
  %1 = alloca i64, align 8
  store i64 %f, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = call i64 @prim_procedure_63(i64 %2)
  %4 = icmp eq i64 %3, 15
  br i1 %4, label %5, label %6

; <label>:5                                       ; preds = %0
  call void @fatal_err(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.32, i32 0, i32 0))
  br label %6

; <label>:6                                       ; preds = %5, %0
  ret i64 31
}

; Function Attrs: nounwind uwtable
define i64 @prim_null_63(i64 %p) #5 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  store i64 %p, i64* %2, align 8
  %3 = load i64, i64* %2, align 8
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %5, label %6

; <label>:5                                       ; preds = %0
  store i64 31, i64* %1, align 8
  br label %7

; <label>:6                                       ; preds = %0
  store i64 15, i64* %1, align 8
  br label %7

; <label>:7                                       ; preds = %6, %5
  %8 = load i64, i64* %1, align 8
  ret i64 %8
}

; Function Attrs: uwtable
define i64 @applyprim_null_63(i64 %lst) #0 {
  %1 = alloca i64, align 8
  %v0 = alloca i64, align 8
  store i64 %lst, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = call i64 @expect_args1(i64 %2)
  store i64 %3, i64* %v0, align 8
  %4 = load i64, i64* %v0, align 8
  %5 = call i64 @prim_null_63(i64 %4)
  ret i64 %5
}

; Function Attrs: nounwind uwtable
define i64 @prim_cons_63(i64 %p) #5 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  store i64 %p, i64* %2, align 8
  %3 = load i64, i64* %2, align 8
  %4 = and i64 %3, 7
  %5 = icmp eq i64 %4, 1
  br i1 %5, label %6, label %7

; <label>:6                                       ; preds = %0
  store i64 31, i64* %1, align 8
  br label %8

; <label>:7                                       ; preds = %0
  store i64 15, i64* %1, align 8
  br label %8

; <label>:8                                       ; preds = %7, %6
  %9 = load i64, i64* %1, align 8
  ret i64 %9
}

; Function Attrs: uwtable
define i64 @applyprim_cons_63(i64 %lst) #0 {
  %1 = alloca i64, align 8
  %v0 = alloca i64, align 8
  store i64 %lst, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = call i64 @expect_args1(i64 %2)
  store i64 %3, i64* %v0, align 8
  %4 = load i64, i64* %v0, align 8
  %5 = call i64 @prim_cons_63(i64 %4)
  ret i64 %5
}

; Function Attrs: uwtable
define i64 @prim_cons(i64 %a, i64 %b) #0 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  %p = alloca i64*, align 8
  store i64 %a, i64* %1, align 8
  store i64 %b, i64* %2, align 8
  %3 = call i64* @alloc(i64 16)
  store i64* %3, i64** %p, align 8
  %4 = load i64, i64* %1, align 8
  %5 = load i64*, i64** %p, align 8
  %6 = getelementptr inbounds i64, i64* %5, i64 0
  store i64 %4, i64* %6, align 8
  %7 = load i64, i64* %2, align 8
  %8 = load i64*, i64** %p, align 8
  %9 = getelementptr inbounds i64, i64* %8, i64 1
  store i64 %7, i64* %9, align 8
  %10 = load i64*, i64** %p, align 8
  %11 = ptrtoint i64* %10 to i64
  %12 = or i64 %11, 1
  ret i64 %12
}

; Function Attrs: uwtable
define i64 @applyprim_cons(i64 %lst) #0 {
  %1 = alloca i64, align 8
  %rest = alloca i64, align 8
  %v0 = alloca i64, align 8
  %v1 = alloca i64, align 8
  store i64 %lst, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = call i64 @expect_cons(i64 %2, i64* %rest)
  store i64 %3, i64* %v0, align 8
  %4 = load i64, i64* %rest, align 8
  %5 = call i64 @expect_cons(i64 %4, i64* %rest)
  store i64 %5, i64* %v1, align 8
  %6 = load i64, i64* %rest, align 8
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %8, label %9

; <label>:8                                       ; preds = %0
  call void @fatal_err(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.25, i32 0, i32 0))
  br label %9

; <label>:9                                       ; preds = %8, %0
  %10 = load i64, i64* %v0, align 8
  %11 = load i64, i64* %v1, align 8
  %12 = call i64 @prim_cons(i64 %10, i64 %11)
  ret i64 %12
}

; Function Attrs: uwtable
define i64 @prim_car(i64 %p) #0 {
  %1 = alloca i64, align 8
  %rest = alloca i64, align 8
  %v0 = alloca i64, align 8
  store i64 %p, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = call i64 @expect_cons(i64 %2, i64* %rest)
  store i64 %3, i64* %v0, align 8
  %4 = load i64, i64* %v0, align 8
  ret i64 %4
}

; Function Attrs: uwtable
define i64 @applyprim_car(i64 %lst) #0 {
  %1 = alloca i64, align 8
  %v0 = alloca i64, align 8
  store i64 %lst, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = call i64 @expect_args1(i64 %2)
  store i64 %3, i64* %v0, align 8
  %4 = load i64, i64* %v0, align 8
  %5 = call i64 @prim_car(i64 %4)
  ret i64 %5
}

; Function Attrs: uwtable
define i64 @prim_cdr(i64 %p) #0 {
  %1 = alloca i64, align 8
  %rest = alloca i64, align 8
  %v0 = alloca i64, align 8
  store i64 %p, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = call i64 @expect_cons(i64 %2, i64* %rest)
  store i64 %3, i64* %v0, align 8
  %4 = load i64, i64* %rest, align 8
  ret i64 %4
}

; Function Attrs: uwtable
define i64 @applyprim_cdr(i64 %lst) #0 {
  %1 = alloca i64, align 8
  %v0 = alloca i64, align 8
  store i64 %lst, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = call i64 @expect_args1(i64 %2)
  store i64 %3, i64* %v0, align 8
  %4 = load i64, i64* %v0, align 8
  %5 = call i64 @prim_cdr(i64 %4)
  ret i64 %5
}

; Function Attrs: uwtable
define i64 @prim__43(i64 %a, i64 %b) #0 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  store i64 %a, i64* %1, align 8
  store i64 %b, i64* %2, align 8
  %3 = load i64, i64* %1, align 8
  %4 = and i64 %3, 7
  %5 = icmp ne i64 %4, 2
  br i1 %5, label %6, label %7

; <label>:6                                       ; preds = %0
  call void @fatal_err(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.33, i32 0, i32 0))
  br label %7

; <label>:7                                       ; preds = %6, %0
  %8 = load i64, i64* %2, align 8
  %9 = and i64 %8, 7
  %10 = icmp ne i64 %9, 2
  br i1 %10, label %11, label %12

; <label>:11                                      ; preds = %7
  call void @fatal_err(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.34, i32 0, i32 0))
  br label %12

; <label>:12                                      ; preds = %11, %7
  %13 = load i64, i64* %1, align 8
  %14 = and i64 %13, -8
  %15 = lshr i64 %14, 32
  %16 = trunc i64 %15 to i32
  %17 = load i64, i64* %2, align 8
  %18 = and i64 %17, -8
  %19 = lshr i64 %18, 32
  %20 = trunc i64 %19 to i32
  %21 = add nsw i32 %16, %20
  %22 = zext i32 %21 to i64
  %23 = shl i64 %22, 32
  %24 = or i64 %23, 2
  ret i64 %24
}

; Function Attrs: uwtable
define i64 @applyprim__43(i64 %p) #0 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  %pp = alloca i64*, align 8
  store i64 %p, i64* %2, align 8
  %3 = load i64, i64* %2, align 8
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %5, label %6

; <label>:5                                       ; preds = %0
  store i64 2, i64* %1, align 8
  br label %32

; <label>:6                                       ; preds = %0
  %7 = load i64, i64* %2, align 8
  %8 = and i64 %7, 7
  %9 = icmp ne i64 %8, 1
  br i1 %9, label %10, label %11

; <label>:10                                      ; preds = %6
  call void @fatal_err(i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.35, i32 0, i32 0))
  br label %11

; <label>:11                                      ; preds = %10, %6
  %12 = load i64, i64* %2, align 8
  %13 = and i64 %12, -8
  %14 = inttoptr i64 %13 to i64*
  store i64* %14, i64** %pp, align 8
  %15 = load i64*, i64** %pp, align 8
  %16 = getelementptr inbounds i64, i64* %15, i64 0
  %17 = load i64, i64* %16, align 8
  %18 = and i64 %17, -8
  %19 = lshr i64 %18, 32
  %20 = trunc i64 %19 to i32
  %21 = load i64*, i64** %pp, align 8
  %22 = getelementptr inbounds i64, i64* %21, i64 1
  %23 = load i64, i64* %22, align 8
  %24 = call i64 @applyprim__43(i64 %23)
  %25 = and i64 %24, -8
  %26 = lshr i64 %25, 32
  %27 = trunc i64 %26 to i32
  %28 = add nsw i32 %20, %27
  %29 = zext i32 %28 to i64
  %30 = shl i64 %29, 32
  %31 = or i64 %30, 2
  store i64 %31, i64* %1, align 8
  br label %32

; <label>:32                                      ; preds = %11, %5
  %33 = load i64, i64* %1, align 8
  ret i64 %33
}

; Function Attrs: uwtable
define i64 @prim__45(i64 %a, i64 %b) #0 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  store i64 %a, i64* %1, align 8
  store i64 %b, i64* %2, align 8
  %3 = load i64, i64* %1, align 8
  %4 = and i64 %3, 7
  %5 = icmp ne i64 %4, 2
  br i1 %5, label %6, label %7

; <label>:6                                       ; preds = %0
  call void @fatal_err(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.33, i32 0, i32 0))
  br label %7

; <label>:7                                       ; preds = %6, %0
  %8 = load i64, i64* %2, align 8
  %9 = and i64 %8, 7
  %10 = icmp ne i64 %9, 2
  br i1 %10, label %11, label %12

; <label>:11                                      ; preds = %7
  call void @fatal_err(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.36, i32 0, i32 0))
  br label %12

; <label>:12                                      ; preds = %11, %7
  %13 = load i64, i64* %1, align 8
  %14 = and i64 %13, -8
  %15 = lshr i64 %14, 32
  %16 = trunc i64 %15 to i32
  %17 = load i64, i64* %2, align 8
  %18 = and i64 %17, -8
  %19 = lshr i64 %18, 32
  %20 = trunc i64 %19 to i32
  %21 = sub nsw i32 %16, %20
  %22 = zext i32 %21 to i64
  %23 = shl i64 %22, 32
  %24 = or i64 %23, 2
  ret i64 %24
}

; Function Attrs: uwtable
define i64 @applyprim__45(i64 %p) #0 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  %pp = alloca i64*, align 8
  store i64 %p, i64* %2, align 8
  %3 = load i64, i64* %2, align 8
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %5, label %6

; <label>:5                                       ; preds = %0
  store i64 2, i64* %1, align 8
  br label %48

; <label>:6                                       ; preds = %0
  %7 = load i64, i64* %2, align 8
  %8 = and i64 %7, 7
  %9 = icmp ne i64 %8, 1
  br i1 %9, label %10, label %11

; <label>:10                                      ; preds = %6
  call void @fatal_err(i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.37, i32 0, i32 0))
  br label %11

; <label>:11                                      ; preds = %10, %6
  %12 = load i64, i64* %2, align 8
  %13 = and i64 %12, -8
  %14 = inttoptr i64 %13 to i64*
  store i64* %14, i64** %pp, align 8
  %15 = load i64*, i64** %pp, align 8
  %16 = getelementptr inbounds i64, i64* %15, i64 1
  %17 = load i64, i64* %16, align 8
  %18 = icmp eq i64 %17, 0
  br i1 %18, label %19, label %30

; <label>:19                                      ; preds = %11
  %20 = load i64*, i64** %pp, align 8
  %21 = getelementptr inbounds i64, i64* %20, i64 0
  %22 = load i64, i64* %21, align 8
  %23 = and i64 %22, -8
  %24 = lshr i64 %23, 32
  %25 = trunc i64 %24 to i32
  %26 = sub nsw i32 0, %25
  %27 = zext i32 %26 to i64
  %28 = shl i64 %27, 32
  %29 = or i64 %28, 2
  store i64 %29, i64* %1, align 8
  br label %48

; <label>:30                                      ; preds = %11
  %31 = load i64*, i64** %pp, align 8
  %32 = getelementptr inbounds i64, i64* %31, i64 0
  %33 = load i64, i64* %32, align 8
  %34 = and i64 %33, -8
  %35 = lshr i64 %34, 32
  %36 = trunc i64 %35 to i32
  %37 = load i64*, i64** %pp, align 8
  %38 = getelementptr inbounds i64, i64* %37, i64 1
  %39 = load i64, i64* %38, align 8
  %40 = call i64 @applyprim__43(i64 %39)
  %41 = and i64 %40, -8
  %42 = lshr i64 %41, 32
  %43 = trunc i64 %42 to i32
  %44 = sub nsw i32 %36, %43
  %45 = zext i32 %44 to i64
  %46 = shl i64 %45, 32
  %47 = or i64 %46, 2
  store i64 %47, i64* %1, align 8
  br label %48

; <label>:48                                      ; preds = %30, %19, %5
  %49 = load i64, i64* %1, align 8
  ret i64 %49
}

; Function Attrs: uwtable
define i64 @prim__42(i64 %a, i64 %b) #0 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  store i64 %a, i64* %1, align 8
  store i64 %b, i64* %2, align 8
  %3 = load i64, i64* %1, align 8
  %4 = and i64 %3, 7
  %5 = icmp ne i64 %4, 2
  br i1 %5, label %6, label %7

; <label>:6                                       ; preds = %0
  call void @fatal_err(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.38, i32 0, i32 0))
  br label %7

; <label>:7                                       ; preds = %6, %0
  %8 = load i64, i64* %2, align 8
  %9 = and i64 %8, 7
  %10 = icmp ne i64 %9, 2
  br i1 %10, label %11, label %12

; <label>:11                                      ; preds = %7
  call void @fatal_err(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.39, i32 0, i32 0))
  br label %12

; <label>:12                                      ; preds = %11, %7
  %13 = load i64, i64* %1, align 8
  %14 = and i64 %13, -8
  %15 = lshr i64 %14, 32
  %16 = trunc i64 %15 to i32
  %17 = load i64, i64* %2, align 8
  %18 = and i64 %17, -8
  %19 = lshr i64 %18, 32
  %20 = trunc i64 %19 to i32
  %21 = mul nsw i32 %16, %20
  %22 = zext i32 %21 to i64
  %23 = shl i64 %22, 32
  %24 = or i64 %23, 2
  ret i64 %24
}

; Function Attrs: uwtable
define i64 @applyprim__42(i64 %p) #0 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  %pp = alloca i64*, align 8
  store i64 %p, i64* %2, align 8
  %3 = load i64, i64* %2, align 8
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %5, label %6

; <label>:5                                       ; preds = %0
  store i64 4294967298, i64* %1, align 8
  br label %32

; <label>:6                                       ; preds = %0
  %7 = load i64, i64* %2, align 8
  %8 = and i64 %7, 7
  %9 = icmp ne i64 %8, 1
  br i1 %9, label %10, label %11

; <label>:10                                      ; preds = %6
  call void @fatal_err(i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.35, i32 0, i32 0))
  br label %11

; <label>:11                                      ; preds = %10, %6
  %12 = load i64, i64* %2, align 8
  %13 = and i64 %12, -8
  %14 = inttoptr i64 %13 to i64*
  store i64* %14, i64** %pp, align 8
  %15 = load i64*, i64** %pp, align 8
  %16 = getelementptr inbounds i64, i64* %15, i64 0
  %17 = load i64, i64* %16, align 8
  %18 = and i64 %17, -8
  %19 = lshr i64 %18, 32
  %20 = trunc i64 %19 to i32
  %21 = load i64*, i64** %pp, align 8
  %22 = getelementptr inbounds i64, i64* %21, i64 1
  %23 = load i64, i64* %22, align 8
  %24 = call i64 @applyprim__42(i64 %23)
  %25 = and i64 %24, -8
  %26 = lshr i64 %25, 32
  %27 = trunc i64 %26 to i32
  %28 = mul nsw i32 %20, %27
  %29 = zext i32 %28 to i64
  %30 = shl i64 %29, 32
  %31 = or i64 %30, 2
  store i64 %31, i64* %1, align 8
  br label %32

; <label>:32                                      ; preds = %11, %5
  %33 = load i64, i64* %1, align 8
  ret i64 %33
}

; Function Attrs: uwtable
define i64 @prim__47(i64 %a, i64 %b) #0 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  store i64 %a, i64* %1, align 8
  store i64 %b, i64* %2, align 8
  %3 = load i64, i64* %1, align 8
  %4 = and i64 %3, 7
  %5 = icmp ne i64 %4, 2
  br i1 %5, label %6, label %7

; <label>:6                                       ; preds = %0
  call void @fatal_err(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.40, i32 0, i32 0))
  br label %7

; <label>:7                                       ; preds = %6, %0
  %8 = load i64, i64* %2, align 8
  %9 = and i64 %8, 7
  %10 = icmp ne i64 %9, 2
  br i1 %10, label %11, label %12

; <label>:11                                      ; preds = %7
  call void @fatal_err(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.41, i32 0, i32 0))
  br label %12

; <label>:12                                      ; preds = %11, %7
  %13 = load i64, i64* %2, align 8
  %14 = and i64 %13, -8
  %15 = lshr i64 %14, 32
  %16 = trunc i64 %15 to i32
  %17 = icmp eq i32 %16, 0
  br i1 %17, label %18, label %19

; <label>:18                                      ; preds = %12
  call void @fatal_err(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.42, i32 0, i32 0))
  br label %19

; <label>:19                                      ; preds = %18, %12
  %20 = load i64, i64* %1, align 8
  %21 = and i64 %20, -8
  %22 = lshr i64 %21, 32
  %23 = trunc i64 %22 to i32
  %24 = load i64, i64* %2, align 8
  %25 = and i64 %24, -8
  %26 = lshr i64 %25, 32
  %27 = trunc i64 %26 to i32
  %28 = sdiv i32 %23, %27
  %29 = zext i32 %28 to i64
  %30 = shl i64 %29, 32
  %31 = or i64 %30, 2
  ret i64 %31
}

; Function Attrs: uwtable
define i64 @prim__61(i64 %a, i64 %b) #0 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  store i64 %a, i64* %2, align 8
  store i64 %b, i64* %3, align 8
  %4 = load i64, i64* %2, align 8
  %5 = and i64 %4, 7
  %6 = icmp ne i64 %5, 2
  br i1 %6, label %7, label %8

; <label>:7                                       ; preds = %0
  call void @fatal_err(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.43, i32 0, i32 0))
  br label %8

; <label>:8                                       ; preds = %7, %0
  %9 = load i64, i64* %3, align 8
  %10 = and i64 %9, 7
  %11 = icmp ne i64 %10, 2
  br i1 %11, label %12, label %13

; <label>:12                                      ; preds = %8
  call void @fatal_err(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.44, i32 0, i32 0))
  br label %13

; <label>:13                                      ; preds = %12, %8
  %14 = load i64, i64* %2, align 8
  %15 = and i64 %14, -8
  %16 = lshr i64 %15, 32
  %17 = trunc i64 %16 to i32
  %18 = load i64, i64* %3, align 8
  %19 = and i64 %18, -8
  %20 = lshr i64 %19, 32
  %21 = trunc i64 %20 to i32
  %22 = icmp eq i32 %17, %21
  br i1 %22, label %23, label %24

; <label>:23                                      ; preds = %13
  store i64 31, i64* %1, align 8
  br label %25

; <label>:24                                      ; preds = %13
  store i64 15, i64* %1, align 8
  br label %25

; <label>:25                                      ; preds = %24, %23
  %26 = load i64, i64* %1, align 8
  ret i64 %26
}

; Function Attrs: uwtable
define i64 @prim__60(i64 %a, i64 %b) #0 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  store i64 %a, i64* %2, align 8
  store i64 %b, i64* %3, align 8
  %4 = load i64, i64* %2, align 8
  %5 = and i64 %4, 7
  %6 = icmp ne i64 %5, 2
  br i1 %6, label %7, label %8

; <label>:7                                       ; preds = %0
  call void @fatal_err(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.45, i32 0, i32 0))
  br label %8

; <label>:8                                       ; preds = %7, %0
  %9 = load i64, i64* %3, align 8
  %10 = and i64 %9, 7
  %11 = icmp ne i64 %10, 2
  br i1 %11, label %12, label %13

; <label>:12                                      ; preds = %8
  call void @fatal_err(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.46, i32 0, i32 0))
  br label %13

; <label>:13                                      ; preds = %12, %8
  %14 = load i64, i64* %2, align 8
  %15 = and i64 %14, -8
  %16 = lshr i64 %15, 32
  %17 = trunc i64 %16 to i32
  %18 = load i64, i64* %3, align 8
  %19 = and i64 %18, -8
  %20 = lshr i64 %19, 32
  %21 = trunc i64 %20 to i32
  %22 = icmp slt i32 %17, %21
  br i1 %22, label %23, label %24

; <label>:23                                      ; preds = %13
  store i64 31, i64* %1, align 8
  br label %25

; <label>:24                                      ; preds = %13
  store i64 15, i64* %1, align 8
  br label %25

; <label>:25                                      ; preds = %24, %23
  %26 = load i64, i64* %1, align 8
  ret i64 %26
}

; Function Attrs: uwtable
define i64 @prim__60_61(i64 %a, i64 %b) #0 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  store i64 %a, i64* %2, align 8
  store i64 %b, i64* %3, align 8
  %4 = load i64, i64* %2, align 8
  %5 = and i64 %4, 7
  %6 = icmp ne i64 %5, 2
  br i1 %6, label %7, label %8

; <label>:7                                       ; preds = %0
  call void @fatal_err(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.47, i32 0, i32 0))
  br label %8

; <label>:8                                       ; preds = %7, %0
  %9 = load i64, i64* %3, align 8
  %10 = and i64 %9, 7
  %11 = icmp ne i64 %10, 2
  br i1 %11, label %12, label %13

; <label>:12                                      ; preds = %8
  call void @fatal_err(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.48, i32 0, i32 0))
  br label %13

; <label>:13                                      ; preds = %12, %8
  %14 = load i64, i64* %2, align 8
  %15 = and i64 %14, -8
  %16 = lshr i64 %15, 32
  %17 = trunc i64 %16 to i32
  %18 = load i64, i64* %3, align 8
  %19 = and i64 %18, -8
  %20 = lshr i64 %19, 32
  %21 = trunc i64 %20 to i32
  %22 = icmp sle i32 %17, %21
  br i1 %22, label %23, label %24

; <label>:23                                      ; preds = %13
  store i64 31, i64* %1, align 8
  br label %25

; <label>:24                                      ; preds = %13
  store i64 15, i64* %1, align 8
  br label %25

; <label>:25                                      ; preds = %24, %23
  %26 = load i64, i64* %1, align 8
  ret i64 %26
}

; Function Attrs: uwtable
define i64 @prim__62(i64 %a, i64 %b) #0 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  store i64 %a, i64* %2, align 8
  store i64 %b, i64* %3, align 8
  %4 = load i64, i64* %2, align 8
  %5 = and i64 %4, 7
  %6 = icmp ne i64 %5, 2
  br i1 %6, label %7, label %8

; <label>:7                                       ; preds = %0
  call void @fatal_err(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.45, i32 0, i32 0))
  br label %8

; <label>:8                                       ; preds = %7, %0
  %9 = load i64, i64* %3, align 8
  %10 = and i64 %9, 7
  %11 = icmp ne i64 %10, 2
  br i1 %11, label %12, label %13

; <label>:12                                      ; preds = %8
  call void @fatal_err(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.46, i32 0, i32 0))
  br label %13

; <label>:13                                      ; preds = %12, %8
  %14 = load i64, i64* %2, align 8
  %15 = and i64 %14, -8
  %16 = lshr i64 %15, 32
  %17 = trunc i64 %16 to i32
  %18 = load i64, i64* %3, align 8
  %19 = and i64 %18, -8
  %20 = lshr i64 %19, 32
  %21 = trunc i64 %20 to i32
  %22 = icmp sgt i32 %17, %21
  br i1 %22, label %23, label %24

; <label>:23                                      ; preds = %13
  store i64 31, i64* %1, align 8
  br label %25

; <label>:24                                      ; preds = %13
  store i64 15, i64* %1, align 8
  br label %25

; <label>:25                                      ; preds = %24, %23
  %26 = load i64, i64* %1, align 8
  ret i64 %26
}

; Function Attrs: uwtable
define i64 @prim_not(i64 %a) #0 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  store i64 %a, i64* %2, align 8
  %3 = load i64, i64* %2, align 8
  %4 = icmp eq i64 %3, 15
  br i1 %4, label %5, label %6

; <label>:5                                       ; preds = %0
  store i64 31, i64* %1, align 8
  br label %13

; <label>:6                                       ; preds = %0
  %7 = load i64, i64* %2, align 8
  %8 = icmp eq i64 %7, 31
  br i1 %8, label %9, label %10

; <label>:9                                       ; preds = %6
  store i64 15, i64* %1, align 8
  br label %13

; <label>:10                                      ; preds = %6
  call void @fatal_err(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.49, i32 0, i32 0))
  br label %11

; <label>:11                                      ; preds = %10
  br label %12

; <label>:12                                      ; preds = %11
  store i64 0, i64* %1, align 8
  br label %13

; <label>:13                                      ; preds = %12, %9, %5
  %14 = load i64, i64* %1, align 8
  ret i64 %14
}

; Function Attrs: uwtable
define i64 @applyprim_not(i64 %lst) #0 {
  %1 = alloca i64, align 8
  %v0 = alloca i64, align 8
  store i64 %lst, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = call i64 @expect_args1(i64 %2)
  store i64 %3, i64* %v0, align 8
  %4 = load i64, i64* %v0, align 8
  %5 = call i64 @prim_not(i64 %4)
  ret i64 %5
}

; Function Attrs: uwtable
define i64 @prim_hash() #0 {
  %h = alloca %class.hamt*, align 8
  %hash = alloca i64*, align 8
  %1 = call noalias i8* @GC_malloc(i64 120)
  %2 = bitcast i8* %1 to %class.hamt*
  %3 = bitcast %class.hamt* %2 to i8*
  %4 = bitcast i8* %3 to %class.hamt*
  call void @_ZN4hamtI10scheme_key12scheme_valueEC2Ev(%class.hamt* %4)
  store %class.hamt* %4, %class.hamt** %h, align 8
  %5 = call i64* @alloc(i64 16)
  store i64* %5, i64** %hash, align 8
  %6 = load i64*, i64** %hash, align 8
  %7 = getelementptr inbounds i64, i64* %6, i64 0
  store i64 57, i64* %7, align 8
  %8 = load %class.hamt*, %class.hamt** %h, align 8
  %9 = ptrtoint %class.hamt* %8 to i64
  %10 = load i64*, i64** %hash, align 8
  %11 = getelementptr inbounds i64, i64* %10, i64 1
  store i64 %9, i64* %11, align 8
  %12 = load i64*, i64** %hash, align 8
  %13 = ptrtoint i64* %12 to i64
  %14 = or i64 %13, 6
  ret i64 %14
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN4hamtI10scheme_key12scheme_valueEC2Ev(%class.hamt* %this) unnamed_addr #0 comdat align 2 {
  %1 = alloca %class.hamt*, align 8
  store %class.hamt* %this, %class.hamt** %1, align 8
  %2 = load %class.hamt*, %class.hamt** %1, align 8
  %3 = getelementptr inbounds %class.hamt, %class.hamt* %2, i32 0, i32 0
  %4 = getelementptr inbounds [7 x %class.KV], [7 x %class.KV]* %3, i64 0, i64 0
  %5 = getelementptr inbounds %class.KV, %class.KV* %4, i64 7
  br label %6

; <label>:6                                       ; preds = %6, %0
  %7 = phi %class.KV* [ %4, %0 ], [ %8, %6 ]
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EEC2Ev(%class.KV* %7)
  %8 = getelementptr inbounds %class.KV, %class.KV* %7, i64 1
  %9 = icmp eq %class.KV* %8, %5
  br i1 %9, label %10, label %6

; <label>:10                                      ; preds = %6
  %11 = getelementptr inbounds %class.hamt, %class.hamt* %2, i32 0, i32 1
  store i64 0, i64* %11, align 8
  ret void
}

; Function Attrs: uwtable
define i64 @prim_hash_45set(i64 %h, i64 %key, i64 %value) #0 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %hash_object = alloca i64*, align 8
  %k = alloca %class.scheme_key*, align 8
  %v = alloca %class.scheme_value*, align 8
  %hash_ptr = alloca %class.hamt*, align 8
  store i64 %h, i64* %1, align 8
  store i64 %key, i64* %2, align 8
  store i64 %value, i64* %3, align 8
  %4 = load i64, i64* %1, align 8
  %5 = and i64 %4, -8
  %6 = inttoptr i64 %5 to i64*
  store i64* %6, i64** %hash_object, align 8
  %7 = call i64* @alloc(i64 8)
  %8 = bitcast i64* %7 to %class.scheme_key*
  %9 = bitcast %class.scheme_key* %8 to i8*
  %10 = bitcast i8* %9 to %class.scheme_key*
  %11 = load i64, i64* %2, align 8
  call void @_ZN10scheme_keyC2Em(%class.scheme_key* %10, i64 %11)
  store %class.scheme_key* %10, %class.scheme_key** %k, align 8
  %12 = call i64* @alloc(i64 8)
  %13 = bitcast i64* %12 to %class.scheme_value*
  %14 = bitcast %class.scheme_value* %13 to i8*
  %15 = bitcast i8* %14 to %class.scheme_value*
  %16 = load i64, i64* %3, align 8
  call void @_ZN12scheme_valueC2Em(%class.scheme_value* %15, i64 %16)
  store %class.scheme_value* %15, %class.scheme_value** %v, align 8
  %17 = load i64*, i64** %hash_object, align 8
  %18 = getelementptr inbounds i64, i64* %17, i64 1
  %19 = load i64, i64* %18, align 8
  %20 = inttoptr i64 %19 to %class.hamt*
  store %class.hamt* %20, %class.hamt** %hash_ptr, align 8
  %21 = load %class.hamt*, %class.hamt** %hash_ptr, align 8
  %22 = load %class.scheme_key*, %class.scheme_key** %k, align 8
  %23 = load %class.scheme_value*, %class.scheme_value** %v, align 8
  %24 = call %class.hamt* @_ZNK4hamtI10scheme_key12scheme_valueE6insertEPKS0_PKS1_(%class.hamt* %21, %class.scheme_key* %22, %class.scheme_value* %23)
  store %class.hamt* %24, %class.hamt** %hash_ptr, align 8
  %25 = load %class.hamt*, %class.hamt** %hash_ptr, align 8
  %26 = ptrtoint %class.hamt* %25 to i64
  %27 = load i64*, i64** %hash_object, align 8
  %28 = getelementptr inbounds i64, i64* %27, i64 1
  store i64 %26, i64* %28, align 8
  %29 = load i64*, i64** %hash_object, align 8
  %30 = ptrtoint i64* %29 to i64
  %31 = or i64 %30, 6
  ret i64 %31
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN10scheme_keyC2Em(%class.scheme_key* %this, i64 %key) unnamed_addr #5 comdat align 2 {
  %1 = alloca %class.scheme_key*, align 8
  %2 = alloca i64, align 8
  store %class.scheme_key* %this, %class.scheme_key** %1, align 8
  store i64 %key, i64* %2, align 8
  %3 = load %class.scheme_key*, %class.scheme_key** %1, align 8
  %4 = getelementptr inbounds %class.scheme_key, %class.scheme_key* %3, i32 0, i32 0
  %5 = load i64, i64* %2, align 8
  store i64 %5, i64* %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN12scheme_valueC2Em(%class.scheme_value* %this, i64 %value) unnamed_addr #5 comdat align 2 {
  %1 = alloca %class.scheme_value*, align 8
  %2 = alloca i64, align 8
  store %class.scheme_value* %this, %class.scheme_value** %1, align 8
  store i64 %value, i64* %2, align 8
  %3 = load %class.scheme_value*, %class.scheme_value** %1, align 8
  %4 = getelementptr inbounds %class.scheme_value, %class.scheme_value* %3, i32 0, i32 0
  %5 = load i64, i64* %2, align 8
  store i64 %5, i64* %4, align 8
  ret void
}

; Function Attrs: uwtable
define linkonce_odr %class.hamt* @_ZNK4hamtI10scheme_key12scheme_valueE6insertEPKS0_PKS1_(%class.hamt* %this, %class.scheme_key* %key, %class.scheme_value* %val) #0 comdat align 2 {
  %1 = alloca %class.hamt*, align 8
  %2 = alloca %class.scheme_key*, align 8
  %3 = alloca %class.scheme_value*, align 8
  %h = alloca i64, align 8
  %hpiece = alloca i64, align 8
  %new_root = alloca %class.hamt*, align 8
  store %class.hamt* %this, %class.hamt** %1, align 8
  store %class.scheme_key* %key, %class.scheme_key** %2, align 8
  store %class.scheme_value* %val, %class.scheme_value** %3, align 8
  %4 = load %class.hamt*, %class.hamt** %1, align 8
  %5 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %6 = call i64 @_ZNK10scheme_key4hashEv(%class.scheme_key* %5)
  store i64 %6, i64* %h, align 8
  %7 = load i64, i64* %h, align 8
  %8 = and i64 %7, 15
  %9 = urem i64 %8, 7
  store i64 %9, i64* %hpiece, align 8
  %10 = call noalias i8* @GC_malloc(i64 120)
  %11 = bitcast i8* %10 to %class.hamt*
  store %class.hamt* %11, %class.hamt** %new_root, align 8
  %12 = load %class.hamt*, %class.hamt** %new_root, align 8
  %13 = bitcast %class.hamt* %12 to i8*
  %14 = bitcast %class.hamt* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* %14, i64 120, i32 8, i1 false)
  %15 = load i64, i64* %hpiece, align 8
  %16 = getelementptr inbounds %class.hamt, %class.hamt* %4, i32 0, i32 0
  %17 = getelementptr inbounds [7 x %class.KV], [7 x %class.KV]* %16, i64 0, i64 %15
  %18 = getelementptr inbounds %class.KV, %class.KV* %17, i32 0, i32 0
  %19 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Key"* %18 to i64*
  %20 = load i64, i64* %19, align 8
  %21 = icmp eq i64 %20, 0
  br i1 %21, label %22, label %35

; <label>:22                                      ; preds = %0
  %23 = load i64, i64* %hpiece, align 8
  %24 = load %class.hamt*, %class.hamt** %new_root, align 8
  %25 = getelementptr inbounds %class.hamt, %class.hamt* %24, i32 0, i32 0
  %26 = getelementptr inbounds [7 x %class.KV], [7 x %class.KV]* %25, i64 0, i64 %23
  %27 = bitcast %class.KV* %26 to i8*
  %28 = bitcast i8* %27 to %class.KV*
  %29 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %30 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EEC2EPKS0_PKS1_(%class.KV* %28, %class.scheme_key* %29, %class.scheme_value* %30)
  %31 = load %class.hamt*, %class.hamt** %new_root, align 8
  %32 = getelementptr inbounds %class.hamt, %class.hamt* %31, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %34 = add i64 %33, 1
  store i64 %34, i64* %32, align 8
  br label %115

; <label>:35                                      ; preds = %0
  %36 = load i64, i64* %hpiece, align 8
  %37 = getelementptr inbounds %class.hamt, %class.hamt* %4, i32 0, i32 0
  %38 = getelementptr inbounds [7 x %class.KV], [7 x %class.KV]* %37, i64 0, i64 %36
  %39 = getelementptr inbounds %class.KV, %class.KV* %38, i32 0, i32 0
  %40 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Key"* %39 to i64*
  %41 = load i64, i64* %40, align 8
  %42 = and i64 %41, 1
  %43 = icmp eq i64 %42, 0
  br i1 %43, label %44, label %98

; <label>:44                                      ; preds = %35
  %45 = load i64, i64* %hpiece, align 8
  %46 = getelementptr inbounds %class.hamt, %class.hamt* %4, i32 0, i32 0
  %47 = getelementptr inbounds [7 x %class.KV], [7 x %class.KV]* %46, i64 0, i64 %45
  %48 = getelementptr inbounds %class.KV, %class.KV* %47, i32 0, i32 0
  %49 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Key"* %48 to %class.scheme_key**
  %50 = load %class.scheme_key*, %class.scheme_key** %49, align 8
  %51 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %52 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %50, %class.scheme_key* dereferenceable(8) %51)
  br i1 %52, label %53, label %62

; <label>:53                                      ; preds = %44
  %54 = load i64, i64* %hpiece, align 8
  %55 = load %class.hamt*, %class.hamt** %new_root, align 8
  %56 = getelementptr inbounds %class.hamt, %class.hamt* %55, i32 0, i32 0
  %57 = getelementptr inbounds [7 x %class.KV], [7 x %class.KV]* %56, i64 0, i64 %54
  %58 = bitcast %class.KV* %57 to i8*
  %59 = bitcast i8* %58 to %class.KV*
  %60 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %61 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EEC2EPKS0_PKS1_(%class.KV* %59, %class.scheme_key* %60, %class.scheme_value* %61)
  br label %97

; <label>:62                                      ; preds = %44
  %63 = load %class.hamt*, %class.hamt** %new_root, align 8
  %64 = getelementptr inbounds %class.hamt, %class.hamt* %63, i32 0, i32 1
  %65 = load i64, i64* %64, align 8
  %66 = add i64 %65, 1
  store i64 %66, i64* %64, align 8
  %67 = load i64, i64* %hpiece, align 8
  %68 = load %class.hamt*, %class.hamt** %new_root, align 8
  %69 = getelementptr inbounds %class.hamt, %class.hamt* %68, i32 0, i32 0
  %70 = getelementptr inbounds [7 x %class.KV], [7 x %class.KV]* %69, i64 0, i64 %67
  %71 = bitcast %class.KV* %70 to i8*
  %72 = bitcast i8* %71 to %class.KV*
  %73 = load i64, i64* %hpiece, align 8
  %74 = getelementptr inbounds %class.hamt, %class.hamt* %4, i32 0, i32 0
  %75 = getelementptr inbounds [7 x %class.KV], [7 x %class.KV]* %74, i64 0, i64 %73
  %76 = getelementptr inbounds %class.KV, %class.KV* %75, i32 0, i32 0
  %77 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Key"* %76 to %class.scheme_key**
  %78 = load %class.scheme_key*, %class.scheme_key** %77, align 8
  %79 = call i64 @_ZNK10scheme_key4hashEv(%class.scheme_key* %78)
  %80 = lshr i64 %79, 4
  %81 = load i64, i64* %hpiece, align 8
  %82 = getelementptr inbounds %class.hamt, %class.hamt* %4, i32 0, i32 0
  %83 = getelementptr inbounds [7 x %class.KV], [7 x %class.KV]* %82, i64 0, i64 %81
  %84 = getelementptr inbounds %class.KV, %class.KV* %83, i32 0, i32 0
  %85 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Key"* %84 to %class.scheme_key**
  %86 = load %class.scheme_key*, %class.scheme_key** %85, align 8
  %87 = load i64, i64* %hpiece, align 8
  %88 = getelementptr inbounds %class.hamt, %class.hamt* %4, i32 0, i32 0
  %89 = getelementptr inbounds [7 x %class.KV], [7 x %class.KV]* %88, i64 0, i64 %87
  %90 = getelementptr inbounds %class.KV, %class.KV* %89, i32 0, i32 1
  %91 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Val"* %90 to %class.scheme_value**
  %92 = load %class.scheme_value*, %class.scheme_value** %91, align 8
  %93 = load i64, i64* %h, align 8
  %94 = lshr i64 %93, 4
  %95 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %96 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV* sret %72, i64 %80, %class.scheme_key* %86, %class.scheme_value* %92, i64 %94, %class.scheme_key* %95, %class.scheme_value* %96)
  br label %97

; <label>:97                                      ; preds = %62, %53
  br label %114

; <label>:98                                      ; preds = %35
  %99 = load i64, i64* %hpiece, align 8
  %100 = load %class.hamt*, %class.hamt** %new_root, align 8
  %101 = getelementptr inbounds %class.hamt, %class.hamt* %100, i32 0, i32 0
  %102 = getelementptr inbounds [7 x %class.KV], [7 x %class.KV]* %101, i64 0, i64 %99
  %103 = bitcast %class.KV* %102 to i8*
  %104 = bitcast i8* %103 to %class.KV*
  %105 = load i64, i64* %hpiece, align 8
  %106 = getelementptr inbounds %class.hamt, %class.hamt* %4, i32 0, i32 0
  %107 = getelementptr inbounds [7 x %class.KV], [7 x %class.KV]* %106, i64 0, i64 %105
  %108 = load i64, i64* %h, align 8
  %109 = lshr i64 %108, 4
  %110 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %111 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  %112 = load %class.hamt*, %class.hamt** %new_root, align 8
  %113 = getelementptr inbounds %class.hamt, %class.hamt* %112, i32 0, i32 1
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EE12insert_innerERKS2_mPKS0_PKS1_Pm(%class.KV* sret %104, %class.KV* dereferenceable(16) %107, i64 %109, %class.scheme_key* %110, %class.scheme_value* %111, i64* %113)
  br label %114

; <label>:114                                     ; preds = %98, %97
  br label %115

; <label>:115                                     ; preds = %114, %22
  %116 = load %class.hamt*, %class.hamt** %new_root, align 8
  ret %class.hamt* %116
}

; Function Attrs: uwtable
define i64 @prim_hash_45remove(i64 %h, i64 %key) #0 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  %hash_object = alloca i64*, align 8
  %k = alloca %class.scheme_key*, align 8
  %hash_ptr = alloca %class.hamt*, align 8
  store i64 %h, i64* %1, align 8
  store i64 %key, i64* %2, align 8
  %3 = load i64, i64* %1, align 8
  %4 = and i64 %3, -8
  %5 = inttoptr i64 %4 to i64*
  store i64* %5, i64** %hash_object, align 8
  %6 = call i64* @alloc(i64 8)
  %7 = bitcast i64* %6 to %class.scheme_key*
  %8 = bitcast %class.scheme_key* %7 to i8*
  %9 = bitcast i8* %8 to %class.scheme_key*
  %10 = load i64, i64* %2, align 8
  call void @_ZN10scheme_keyC2Em(%class.scheme_key* %9, i64 %10)
  store %class.scheme_key* %9, %class.scheme_key** %k, align 8
  %11 = load i64*, i64** %hash_object, align 8
  %12 = getelementptr inbounds i64, i64* %11, i64 1
  %13 = load i64, i64* %12, align 8
  %14 = inttoptr i64 %13 to %class.hamt*
  store %class.hamt* %14, %class.hamt** %hash_ptr, align 8
  %15 = load %class.hamt*, %class.hamt** %hash_ptr, align 8
  %16 = load %class.scheme_key*, %class.scheme_key** %k, align 8
  %17 = call %class.hamt* @_ZNK4hamtI10scheme_key12scheme_valueE6removeEPKS0_(%class.hamt* %15, %class.scheme_key* %16)
  store %class.hamt* %17, %class.hamt** %hash_ptr, align 8
  %18 = load %class.hamt*, %class.hamt** %hash_ptr, align 8
  %19 = ptrtoint %class.hamt* %18 to i64
  %20 = load i64*, i64** %hash_object, align 8
  %21 = getelementptr inbounds i64, i64* %20, i64 1
  store i64 %19, i64* %21, align 8
  %22 = load i64*, i64** %hash_object, align 8
  %23 = ptrtoint i64* %22 to i64
  %24 = or i64 %23, 6
  ret i64 %24
}

; Function Attrs: uwtable
define linkonce_odr %class.hamt* @_ZNK4hamtI10scheme_key12scheme_valueE6removeEPKS0_(%class.hamt* %this, %class.scheme_key* %key) #0 comdat align 2 {
  %1 = alloca %class.hamt*, align 8
  %2 = alloca %class.hamt*, align 8
  %3 = alloca %class.scheme_key*, align 8
  %h = alloca i64, align 8
  %hpiece = alloca i64, align 8
  %new_root = alloca %class.hamt*, align 8
  %temp_count = alloca i64, align 8
  %kv = alloca %class.KV, align 8
  %new_root1 = alloca %class.hamt*, align 8
  store %class.hamt* %this, %class.hamt** %2, align 8
  store %class.scheme_key* %key, %class.scheme_key** %3, align 8
  %4 = load %class.hamt*, %class.hamt** %2, align 8
  %5 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %6 = call i64 @_ZNK10scheme_key4hashEv(%class.scheme_key* %5)
  store i64 %6, i64* %h, align 8
  %7 = load i64, i64* %h, align 8
  %8 = and i64 %7, 15
  %9 = urem i64 %8, 7
  store i64 %9, i64* %hpiece, align 8
  %10 = load i64, i64* %hpiece, align 8
  %11 = getelementptr inbounds %class.hamt, %class.hamt* %4, i32 0, i32 0
  %12 = getelementptr inbounds [7 x %class.KV], [7 x %class.KV]* %11, i64 0, i64 %10
  %13 = getelementptr inbounds %class.KV, %class.KV* %12, i32 0, i32 0
  %14 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Key"* %13 to i64*
  %15 = load i64, i64* %14, align 8
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %17, label %18

; <label>:17                                      ; preds = %0
  store %class.hamt* %4, %class.hamt** %1, align 8
  br label %83

; <label>:18                                      ; preds = %0
  %19 = load i64, i64* %hpiece, align 8
  %20 = getelementptr inbounds %class.hamt, %class.hamt* %4, i32 0, i32 0
  %21 = getelementptr inbounds [7 x %class.KV], [7 x %class.KV]* %20, i64 0, i64 %19
  %22 = getelementptr inbounds %class.KV, %class.KV* %21, i32 0, i32 0
  %23 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Key"* %22 to i64*
  %24 = load i64, i64* %23, align 8
  %25 = and i64 %24, 1
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %27, label %53

; <label>:27                                      ; preds = %18
  %28 = load i64, i64* %hpiece, align 8
  %29 = getelementptr inbounds %class.hamt, %class.hamt* %4, i32 0, i32 0
  %30 = getelementptr inbounds [7 x %class.KV], [7 x %class.KV]* %29, i64 0, i64 %28
  %31 = getelementptr inbounds %class.KV, %class.KV* %30, i32 0, i32 0
  %32 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Key"* %31 to %class.scheme_key**
  %33 = load %class.scheme_key*, %class.scheme_key** %32, align 8
  %34 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %35 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %33, %class.scheme_key* dereferenceable(8) %34)
  br i1 %35, label %36, label %52

; <label>:36                                      ; preds = %27
  %37 = call noalias i8* @GC_malloc(i64 120)
  %38 = bitcast i8* %37 to %class.hamt*
  store %class.hamt* %38, %class.hamt** %new_root, align 8
  %39 = load %class.hamt*, %class.hamt** %new_root, align 8
  %40 = bitcast %class.hamt* %39 to i8*
  %41 = bitcast %class.hamt* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %40, i8* %41, i64 120, i32 8, i1 false)
  %42 = load i64, i64* %hpiece, align 8
  %43 = load %class.hamt*, %class.hamt** %new_root, align 8
  %44 = getelementptr inbounds %class.hamt, %class.hamt* %43, i64 %42
  %45 = bitcast %class.hamt* %44 to i8*
  %46 = bitcast i8* %45 to %class.KV*
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EEC2EPKS0_PKS1_(%class.KV* %46, %class.scheme_key* null, %class.scheme_value* null)
  %47 = load %class.hamt*, %class.hamt** %new_root, align 8
  %48 = getelementptr inbounds %class.hamt, %class.hamt* %47, i32 0, i32 1
  %49 = load i64, i64* %48, align 8
  %50 = add i64 %49, -1
  store i64 %50, i64* %48, align 8
  %51 = load %class.hamt*, %class.hamt** %new_root, align 8
  store %class.hamt* %51, %class.hamt** %1, align 8
  br label %83

; <label>:52                                      ; preds = %27
  store %class.hamt* %4, %class.hamt** %1, align 8
  br label %83

; <label>:53                                      ; preds = %18
  %54 = getelementptr inbounds %class.hamt, %class.hamt* %4, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  store i64 %55, i64* %temp_count, align 8
  %56 = load i64, i64* %hpiece, align 8
  %57 = getelementptr inbounds %class.hamt, %class.hamt* %4, i32 0, i32 0
  %58 = getelementptr inbounds [7 x %class.KV], [7 x %class.KV]* %57, i64 0, i64 %56
  %59 = load i64, i64* %h, align 8
  %60 = lshr i64 %59, 4
  %61 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EE12remove_innerERKS2_mPKS0_Pm(%class.KV* sret %kv, %class.KV* dereferenceable(16) %58, i64 %60, %class.scheme_key* %61, i64* %temp_count)
  %62 = load i64, i64* %hpiece, align 8
  %63 = getelementptr inbounds %class.hamt, %class.hamt* %4, i32 0, i32 0
  %64 = getelementptr inbounds [7 x %class.KV], [7 x %class.KV]* %63, i64 0, i64 %62
  %65 = call zeroext i1 @_ZNK2KVI10scheme_key12scheme_valueLj0EEeqERKS2_(%class.KV* %kv, %class.KV* dereferenceable(16) %64)
  br i1 %65, label %66, label %67

; <label>:66                                      ; preds = %53
  store %class.hamt* %4, %class.hamt** %1, align 8
  br label %83

; <label>:67                                      ; preds = %53
  %68 = call noalias i8* @GC_malloc(i64 120)
  %69 = bitcast i8* %68 to %class.hamt*
  store %class.hamt* %69, %class.hamt** %new_root1, align 8
  %70 = load %class.hamt*, %class.hamt** %new_root1, align 8
  %71 = bitcast %class.hamt* %70 to i8*
  %72 = bitcast %class.hamt* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %71, i8* %72, i64 120, i32 8, i1 false)
  %73 = load i64, i64* %hpiece, align 8
  %74 = load %class.hamt*, %class.hamt** %new_root1, align 8
  %75 = getelementptr inbounds %class.hamt, %class.hamt* %74, i32 0, i32 0
  %76 = getelementptr inbounds [7 x %class.KV], [7 x %class.KV]* %75, i64 0, i64 %73
  %77 = bitcast %class.KV* %76 to i8*
  %78 = bitcast i8* %77 to %class.KV*
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EEC2ERKS2_(%class.KV* %78, %class.KV* dereferenceable(16) %kv)
  %79 = load i64, i64* %temp_count, align 8
  %80 = load %class.hamt*, %class.hamt** %new_root1, align 8
  %81 = getelementptr inbounds %class.hamt, %class.hamt* %80, i32 0, i32 1
  store i64 %79, i64* %81, align 8
  %82 = load %class.hamt*, %class.hamt** %new_root1, align 8
  store %class.hamt* %82, %class.hamt** %1, align 8
  br label %83

; <label>:83                                      ; preds = %67, %66, %52, %36, %17
  %84 = load %class.hamt*, %class.hamt** %1, align 8
  ret %class.hamt* %84
}

; Function Attrs: uwtable
define i64 @prim_hash_45ref(i64 %h, i64 %key) #0 {
  %1 = alloca i64, align 8
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %hash_object = alloca i64*, align 8
  %hash_ptr = alloca %class.hamt*, align 8
  %s = alloca %class.scheme_key*, align 8
  %v = alloca %class.scheme_value*, align 8
  store i64 %h, i64* %2, align 8
  store i64 %key, i64* %3, align 8
  %4 = load i64, i64* %2, align 8
  %5 = and i64 %4, -8
  %6 = inttoptr i64 %5 to i64*
  store i64* %6, i64** %hash_object, align 8
  %7 = load i64*, i64** %hash_object, align 8
  %8 = getelementptr inbounds i64, i64* %7, i64 1
  %9 = load i64, i64* %8, align 8
  %10 = inttoptr i64 %9 to %class.hamt*
  store %class.hamt* %10, %class.hamt** %hash_ptr, align 8
  %11 = call i64* @alloc(i64 8)
  %12 = bitcast i64* %11 to %class.scheme_key*
  %13 = bitcast %class.scheme_key* %12 to i8*
  %14 = bitcast i8* %13 to %class.scheme_key*
  %15 = load i64, i64* %3, align 8
  call void @_ZN10scheme_keyC2Em(%class.scheme_key* %14, i64 %15)
  store %class.scheme_key* %14, %class.scheme_key** %s, align 8
  %16 = load %class.hamt*, %class.hamt** %hash_ptr, align 8
  %17 = load %class.scheme_key*, %class.scheme_key** %s, align 8
  %18 = call %class.scheme_value* @_ZNK4hamtI10scheme_key12scheme_valueE3getEPKS0_(%class.hamt* %16, %class.scheme_key* %17)
  store %class.scheme_value* %18, %class.scheme_value** %v, align 8
  %19 = load %class.scheme_value*, %class.scheme_value** %v, align 8
  %20 = icmp eq %class.scheme_value* %19, null
  br i1 %20, label %21, label %23

; <label>:21                                      ; preds = %0
  %22 = call i64 @const_init_int(i64 0)
  store i64 %22, i64* %1, align 8
  br label %27

; <label>:23                                      ; preds = %0
  %24 = load %class.scheme_value*, %class.scheme_value** %v, align 8
  %25 = getelementptr inbounds %class.scheme_value, %class.scheme_value* %24, i32 0, i32 0
  %26 = load i64, i64* %25, align 8
  store i64 %26, i64* %1, align 8
  br label %27

; <label>:27                                      ; preds = %23, %21
  %28 = load i64, i64* %1, align 8
  ret i64 %28
}

; Function Attrs: uwtable
define linkonce_odr %class.scheme_value* @_ZNK4hamtI10scheme_key12scheme_valueE3getEPKS0_(%class.hamt* %this, %class.scheme_key* %key) #0 comdat align 2 {
  %1 = alloca %class.scheme_value*, align 8
  %2 = alloca %class.hamt*, align 8
  %3 = alloca %class.scheme_key*, align 8
  %h = alloca i64, align 8
  %hpiece = alloca i64, align 8
  store %class.hamt* %this, %class.hamt** %2, align 8
  store %class.scheme_key* %key, %class.scheme_key** %3, align 8
  %4 = load %class.hamt*, %class.hamt** %2, align 8
  %5 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %6 = call i64 @_ZNK10scheme_key4hashEv(%class.scheme_key* %5)
  store i64 %6, i64* %h, align 8
  %7 = load i64, i64* %h, align 8
  %8 = and i64 %7, 15
  %9 = urem i64 %8, 7
  store i64 %9, i64* %hpiece, align 8
  %10 = load i64, i64* %hpiece, align 8
  %11 = getelementptr inbounds %class.hamt, %class.hamt* %4, i32 0, i32 0
  %12 = getelementptr inbounds [7 x %class.KV], [7 x %class.KV]* %11, i64 0, i64 %10
  %13 = getelementptr inbounds %class.KV, %class.KV* %12, i32 0, i32 0
  %14 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Key"* %13 to i64*
  %15 = load i64, i64* %14, align 8
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %17, label %18

; <label>:17                                      ; preds = %0
  store %class.scheme_value* null, %class.scheme_value** %1, align 8
  br label %52

; <label>:18                                      ; preds = %0
  %19 = load i64, i64* %hpiece, align 8
  %20 = getelementptr inbounds %class.hamt, %class.hamt* %4, i32 0, i32 0
  %21 = getelementptr inbounds [7 x %class.KV], [7 x %class.KV]* %20, i64 0, i64 %19
  %22 = getelementptr inbounds %class.KV, %class.KV* %21, i32 0, i32 0
  %23 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Key"* %22 to i64*
  %24 = load i64, i64* %23, align 8
  %25 = and i64 %24, 1
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %27, label %44

; <label>:27                                      ; preds = %18
  %28 = load i64, i64* %hpiece, align 8
  %29 = getelementptr inbounds %class.hamt, %class.hamt* %4, i32 0, i32 0
  %30 = getelementptr inbounds [7 x %class.KV], [7 x %class.KV]* %29, i64 0, i64 %28
  %31 = getelementptr inbounds %class.KV, %class.KV* %30, i32 0, i32 0
  %32 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Key"* %31 to %class.scheme_key**
  %33 = load %class.scheme_key*, %class.scheme_key** %32, align 8
  %34 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %35 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %33, %class.scheme_key* dereferenceable(8) %34)
  br i1 %35, label %36, label %43

; <label>:36                                      ; preds = %27
  %37 = load i64, i64* %hpiece, align 8
  %38 = getelementptr inbounds %class.hamt, %class.hamt* %4, i32 0, i32 0
  %39 = getelementptr inbounds [7 x %class.KV], [7 x %class.KV]* %38, i64 0, i64 %37
  %40 = getelementptr inbounds %class.KV, %class.KV* %39, i32 0, i32 1
  %41 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Val"* %40 to %class.scheme_value**
  %42 = load %class.scheme_value*, %class.scheme_value** %41, align 8
  store %class.scheme_value* %42, %class.scheme_value** %1, align 8
  br label %52

; <label>:43                                      ; preds = %27
  store %class.scheme_value* null, %class.scheme_value** %1, align 8
  br label %52

; <label>:44                                      ; preds = %18
  %45 = load i64, i64* %hpiece, align 8
  %46 = getelementptr inbounds %class.hamt, %class.hamt* %4, i32 0, i32 0
  %47 = getelementptr inbounds [7 x %class.KV], [7 x %class.KV]* %46, i64 0, i64 %45
  %48 = load i64, i64* %h, align 8
  %49 = lshr i64 %48, 4
  %50 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %51 = call %class.scheme_value* @_ZN2KVI10scheme_key12scheme_valueLj0EE10inner_findERKS2_mPKS0_(%class.KV* dereferenceable(16) %47, i64 %49, %class.scheme_key* %50)
  store %class.scheme_value* %51, %class.scheme_value** %1, align 8
  br label %52

; <label>:52                                      ; preds = %44, %43, %36, %17
  %53 = load %class.scheme_value*, %class.scheme_value** %1, align 8
  ret %class.scheme_value* %53
}

; Function Attrs: uwtable
define i64 @prim_hash_45count(i64 %h) #0 {
  %1 = alloca i64, align 8
  %hash_object = alloca i64*, align 8
  %hash_ptr = alloca %class.hamt*, align 8
  store i64 %h, i64* %1, align 8
  %2 = load i64, i64* %1, align 8
  %3 = and i64 %2, -8
  %4 = inttoptr i64 %3 to i64*
  store i64* %4, i64** %hash_object, align 8
  %5 = load i64*, i64** %hash_object, align 8
  %6 = getelementptr inbounds i64, i64* %5, i64 1
  %7 = load i64, i64* %6, align 8
  %8 = inttoptr i64 %7 to %class.hamt*
  store %class.hamt* %8, %class.hamt** %hash_ptr, align 8
  %9 = load %class.hamt*, %class.hamt** %hash_ptr, align 8
  %10 = call i64 @_ZNK4hamtI10scheme_key12scheme_valueE4sizeEv(%class.hamt* %9)
  %11 = call i64 @const_init_int(i64 %10)
  ret i64 %11
}

; Function Attrs: nounwind uwtable
define linkonce_odr i64 @_ZNK4hamtI10scheme_key12scheme_valueE4sizeEv(%class.hamt* %this) #5 comdat align 2 {
  %1 = alloca %class.hamt*, align 8
  store %class.hamt* %this, %class.hamt** %1, align 8
  %2 = load %class.hamt*, %class.hamt** %1, align 8
  %3 = getelementptr inbounds %class.hamt, %class.hamt* %2, i32 0, i32 1
  %4 = load i64, i64* %3, align 8
  ret i64 %4
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj0EEC2Ev(%class.KV* %this) unnamed_addr #0 comdat align 2 {
  %1 = alloca %class.KV*, align 8
  store %class.KV* %this, %class.KV** %1, align 8
  %2 = load %class.KV*, %class.KV** %1, align 8
  %3 = getelementptr inbounds %class.KV, %class.KV* %2, i32 0, i32 0
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EE3KeyC2Em(%"union.KV<scheme_key, scheme_value, 0>::Key"* %3, i64 0)
  %4 = getelementptr inbounds %class.KV, %class.KV* %2, i32 0, i32 1
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EE3ValC2EPKS1_(%"union.KV<scheme_key, scheme_value, 0>::Val"* %4, %class.scheme_value* null)
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj0EE3KeyC2Em(%"union.KV<scheme_key, scheme_value, 0>::Key"* %this, i64 %bm) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 0>::Key"*, align 8
  %2 = alloca i64, align 8
  store %"union.KV<scheme_key, scheme_value, 0>::Key"* %this, %"union.KV<scheme_key, scheme_value, 0>::Key"** %1, align 8
  store i64 %bm, i64* %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 0>::Key"*, %"union.KV<scheme_key, scheme_value, 0>::Key"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Key"* %3 to i64*
  %5 = load i64, i64* %2, align 8
  store i64 %5, i64* %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj0EE3ValC2EPKS1_(%"union.KV<scheme_key, scheme_value, 0>::Val"* %this, %class.scheme_value* %val) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 0>::Val"*, align 8
  %2 = alloca %class.scheme_value*, align 8
  store %"union.KV<scheme_key, scheme_value, 0>::Val"* %this, %"union.KV<scheme_key, scheme_value, 0>::Val"** %1, align 8
  store %class.scheme_value* %val, %class.scheme_value** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 0>::Val"*, %"union.KV<scheme_key, scheme_value, 0>::Val"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Val"* %3 to %class.scheme_value**
  %5 = load %class.scheme_value*, %class.scheme_value** %2, align 8
  store %class.scheme_value* %5, %class.scheme_value** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr i64 @_ZNK10scheme_key4hashEv(%class.scheme_key* %this) #5 comdat align 2 {
  %1 = alloca %class.scheme_key*, align 8
  %data = alloca i8*, align 8
  %h = alloca i64, align 8
  %i = alloca i32, align 4
  store %class.scheme_key* %this, %class.scheme_key** %1, align 8
  %2 = load %class.scheme_key*, %class.scheme_key** %1, align 8
  %3 = bitcast %class.scheme_key* %2 to i8*
  store i8* %3, i8** %data, align 8
  store i64 -3750763034362895579, i64* %h, align 8
  store i32 0, i32* %i, align 4
  br label %4

; <label>:4                                       ; preds = %24, %0
  %5 = load i32, i32* %i, align 4
  %6 = zext i32 %5 to i64
  %7 = icmp ult i64 %6, 8
  br i1 %7, label %8, label %26

; <label>:8                                       ; preds = %4
  %9 = load i64, i64* %h, align 8
  %10 = load i8*, i8** %data, align 8
  %11 = load i8, i8* %10, align 1
  %12 = zext i8 %11 to i64
  %13 = xor i64 %9, %12
  store i64 %13, i64* %h, align 8
  %14 = load i64, i64* %h, align 8
  %15 = mul i64 %14, 1099511628211
  store i64 %15, i64* %h, align 8
  br label %16

; <label>:16                                      ; preds = %8
  %17 = load i32, i32* %i, align 4
  %18 = add i32 %17, 1
  store i32 %18, i32* %i, align 4
  %19 = icmp ne i32 %18, 0
  br i1 %19, label %20, label %24

; <label>:20                                      ; preds = %16
  %21 = load i8*, i8** %data, align 8
  %22 = getelementptr inbounds i8, i8* %21, i32 1
  store i8* %22, i8** %data, align 8
  %23 = icmp ne i8* %22, null
  br label %24

; <label>:24                                      ; preds = %20, %16
  %25 = phi i1 [ false, %16 ], [ %23, %20 ]
  br label %4

; <label>:26                                      ; preds = %4
  %27 = load i64, i64* %h, align 8
  ret i64 %27
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #7

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj0EEC2EPKS0_PKS1_(%class.KV* %this, %class.scheme_key* %key, %class.scheme_value* %val) unnamed_addr #0 comdat align 2 {
  %1 = alloca %class.KV*, align 8
  %2 = alloca %class.scheme_key*, align 8
  %3 = alloca %class.scheme_value*, align 8
  store %class.KV* %this, %class.KV** %1, align 8
  store %class.scheme_key* %key, %class.scheme_key** %2, align 8
  store %class.scheme_value* %val, %class.scheme_value** %3, align 8
  %4 = load %class.KV*, %class.KV** %1, align 8
  %5 = getelementptr inbounds %class.KV, %class.KV* %4, i32 0, i32 0
  %6 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EE3KeyC2EPKS0_(%"union.KV<scheme_key, scheme_value, 0>::Key"* %5, %class.scheme_key* %6)
  %7 = getelementptr inbounds %class.KV, %class.KV* %4, i32 0, i32 1
  %8 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EE3ValC2EPKS1_(%"union.KV<scheme_key, scheme_value, 0>::Val"* %7, %class.scheme_value* %8)
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %this, %class.scheme_key* dereferenceable(8) %k) #5 comdat align 2 {
  %1 = alloca %class.scheme_key*, align 8
  %2 = alloca %class.scheme_key*, align 8
  store %class.scheme_key* %this, %class.scheme_key** %1, align 8
  store %class.scheme_key* %k, %class.scheme_key** %2, align 8
  %3 = load %class.scheme_key*, %class.scheme_key** %1, align 8
  %4 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %5 = getelementptr inbounds %class.scheme_key, %class.scheme_key* %4, i32 0, i32 0
  %6 = load i64, i64* %5, align 8
  %7 = getelementptr inbounds %class.scheme_key, %class.scheme_key* %3, i32 0, i32 0
  %8 = load i64, i64* %7, align 8
  %9 = icmp eq i64 %6, %8
  ret i1 %9
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj0EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV* noalias sret %agg.result, i64 %h0, %class.scheme_key* %k0, %class.scheme_value* %v0, i64 %h1, %class.scheme_key* %k1, %class.scheme_value* %v1) #0 comdat align 2 {
  %1 = alloca i64, align 8
  %2 = alloca %class.scheme_key*, align 8
  %3 = alloca %class.scheme_value*, align 8
  %4 = alloca i64, align 8
  %5 = alloca %class.scheme_key*, align 8
  %6 = alloca %class.scheme_value*, align 8
  %h0piece = alloca i32, align 4
  %h1piece = alloca i32, align 4
  %childkv = alloca %class.KV.0, align 8
  %node = alloca %class.KV.0*, align 8
  %node1 = alloca %class.KV.0*, align 8
  store i64 %h0, i64* %1, align 8
  store %class.scheme_key* %k0, %class.scheme_key** %2, align 8
  store %class.scheme_value* %v0, %class.scheme_value** %3, align 8
  store i64 %h1, i64* %4, align 8
  store %class.scheme_key* %k1, %class.scheme_key** %5, align 8
  store %class.scheme_value* %v1, %class.scheme_value** %6, align 8
  %7 = load i64, i64* %1, align 8
  %8 = and i64 %7, 63
  %9 = urem i64 %8, 63
  %10 = trunc i64 %9 to i32
  store i32 %10, i32* %h0piece, align 4
  %11 = load i64, i64* %4, align 8
  %12 = and i64 %11, 63
  %13 = urem i64 %12, 63
  %14 = trunc i64 %13 to i32
  store i32 %14, i32* %h1piece, align 4
  %15 = load i32, i32* %h0piece, align 4
  %16 = load i32, i32* %h1piece, align 4
  %17 = icmp eq i32 %15, %16
  br i1 %17, label %18, label %39

; <label>:18                                      ; preds = %0
  %19 = load i64, i64* %1, align 8
  %20 = lshr i64 %19, 6
  %21 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %22 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  %23 = load i64, i64* %4, align 8
  %24 = lshr i64 %23, 6
  %25 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %26 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.0* sret %childkv, i64 %20, %class.scheme_key* %21, %class.scheme_value* %22, i64 %24, %class.scheme_key* %25, %class.scheme_value* %26)
  %27 = call noalias i8* @GC_malloc(i64 16)
  %28 = bitcast i8* %27 to %class.KV.0*
  store %class.KV.0* %28, %class.KV.0** %node, align 8
  %29 = load %class.KV.0*, %class.KV.0** %node, align 8
  %30 = getelementptr inbounds %class.KV.0, %class.KV.0* %29, i64 0
  %31 = bitcast %class.KV.0* %30 to i8*
  %32 = bitcast i8* %31 to %class.KV.0*
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EEC2ERKS2_(%class.KV.0* %32, %class.KV.0* dereferenceable(16) %childkv)
  %33 = load i32, i32* %h0piece, align 4
  %34 = zext i32 %33 to i64
  %35 = shl i64 1, %34
  %36 = shl i64 %35, 1
  %37 = or i64 %36, 1
  %38 = load %class.KV.0*, %class.KV.0** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EEC2EmPKS_IS0_S1_Lj1EE(%class.KV* %agg.result, i64 %37, %class.KV.0* %38)
  br label %82

; <label>:39                                      ; preds = %0
  %40 = call noalias i8* @GC_malloc(i64 32)
  %41 = bitcast i8* %40 to %class.KV.0*
  store %class.KV.0* %41, %class.KV.0** %node1, align 8
  %42 = load i32, i32* %h1piece, align 4
  %43 = load i32, i32* %h0piece, align 4
  %44 = icmp ult i32 %42, %43
  br i1 %44, label %45, label %58

; <label>:45                                      ; preds = %39
  %46 = load %class.KV.0*, %class.KV.0** %node1, align 8
  %47 = getelementptr inbounds %class.KV.0, %class.KV.0* %46, i64 0
  %48 = bitcast %class.KV.0* %47 to i8*
  %49 = bitcast i8* %48 to %class.KV.0*
  %50 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %51 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EEC2EPKS0_PKS1_(%class.KV.0* %49, %class.scheme_key* %50, %class.scheme_value* %51)
  %52 = load %class.KV.0*, %class.KV.0** %node1, align 8
  %53 = getelementptr inbounds %class.KV.0, %class.KV.0* %52, i64 1
  %54 = bitcast %class.KV.0* %53 to i8*
  %55 = bitcast i8* %54 to %class.KV.0*
  %56 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %57 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EEC2EPKS0_PKS1_(%class.KV.0* %55, %class.scheme_key* %56, %class.scheme_value* %57)
  br label %71

; <label>:58                                      ; preds = %39
  %59 = load %class.KV.0*, %class.KV.0** %node1, align 8
  %60 = getelementptr inbounds %class.KV.0, %class.KV.0* %59, i64 0
  %61 = bitcast %class.KV.0* %60 to i8*
  %62 = bitcast i8* %61 to %class.KV.0*
  %63 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %64 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EEC2EPKS0_PKS1_(%class.KV.0* %62, %class.scheme_key* %63, %class.scheme_value* %64)
  %65 = load %class.KV.0*, %class.KV.0** %node1, align 8
  %66 = getelementptr inbounds %class.KV.0, %class.KV.0* %65, i64 1
  %67 = bitcast %class.KV.0* %66 to i8*
  %68 = bitcast i8* %67 to %class.KV.0*
  %69 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %70 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EEC2EPKS0_PKS1_(%class.KV.0* %68, %class.scheme_key* %69, %class.scheme_value* %70)
  br label %71

; <label>:71                                      ; preds = %58, %45
  %72 = load i32, i32* %h0piece, align 4
  %73 = zext i32 %72 to i64
  %74 = shl i64 1, %73
  %75 = load i32, i32* %h1piece, align 4
  %76 = zext i32 %75 to i64
  %77 = shl i64 1, %76
  %78 = or i64 %74, %77
  %79 = shl i64 %78, 1
  %80 = or i64 %79, 1
  %81 = load %class.KV.0*, %class.KV.0** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EEC2EmPKS_IS0_S1_Lj1EE(%class.KV* %agg.result, i64 %80, %class.KV.0* %81)
  br label %82

; <label>:82                                      ; preds = %71, %18
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj0EE12insert_innerERKS2_mPKS0_PKS1_Pm(%class.KV* noalias sret %agg.result, %class.KV* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key, %class.scheme_value* %val, i64* %cptr) #0 comdat align 2 {
  %1 = alloca %class.KV*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.scheme_key*, align 8
  %4 = alloca %class.scheme_value*, align 8
  %5 = alloca i64*, align 8
  %data = alloca %class.KV.0*, align 8
  %bm = alloca i64, align 8
  %hpiece = alloca i32, align 4
  %count = alloca i32, align 4
  %i = alloca i32, align 4
  %exists = alloca i8, align 1
  %node = alloca %class.KV.0*, align 8
  %6 = alloca %class.KV.0, align 8
  %childkv = alloca %class.KV.0, align 8
  %node1 = alloca %class.KV.0*, align 8
  %childkv2 = alloca %class.KV.0, align 8
  %node3 = alloca %class.KV.0*, align 8
  %node4 = alloca %class.KV.0*, align 8
  store %class.KV* %kv, %class.KV** %1, align 8
  store i64 %h, i64* %2, align 8
  store %class.scheme_key* %key, %class.scheme_key** %3, align 8
  store %class.scheme_value* %val, %class.scheme_value** %4, align 8
  store i64* %cptr, i64** %5, align 8
  %7 = load %class.KV*, %class.KV** %1, align 8
  %8 = getelementptr inbounds %class.KV, %class.KV* %7, i32 0, i32 1
  %9 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Val"* %8 to %class.KV.0**
  %10 = load %class.KV.0*, %class.KV.0** %9, align 8
  store %class.KV.0* %10, %class.KV.0** %data, align 8
  %11 = load %class.KV*, %class.KV** %1, align 8
  %12 = getelementptr inbounds %class.KV, %class.KV* %11, i32 0, i32 0
  %13 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Key"* %12 to i64*
  %14 = load i64, i64* %13, align 8
  %15 = lshr i64 %14, 1
  store i64 %15, i64* %bm, align 8
  %16 = load i64, i64* %2, align 8
  %17 = and i64 %16, 63
  %18 = urem i64 %17, 63
  %19 = trunc i64 %18 to i32
  store i32 %19, i32* %hpiece, align 4
  %20 = load i64, i64* %bm, align 8
  %21 = call i64 @llvm.ctpop.i64(i64 %20)
  %22 = trunc i64 %21 to i32
  store i32 %22, i32* %count, align 4
  %23 = load i64, i64* %bm, align 8
  %24 = shl i64 %23, 1
  %25 = load i32, i32* %hpiece, align 4
  %26 = sub i32 63, %25
  %27 = zext i32 %26 to i64
  %28 = shl i64 %24, %27
  %29 = call i64 @llvm.ctpop.i64(i64 %28)
  %30 = trunc i64 %29 to i32
  store i32 %30, i32* %i, align 4
  %31 = load i64, i64* %bm, align 8
  %32 = load i32, i32* %hpiece, align 4
  %33 = zext i32 %32 to i64
  %34 = shl i64 1, %33
  %35 = and i64 %31, %34
  %36 = icmp ne i64 %35, 0
  %37 = zext i1 %36 to i8
  store i8 %37, i8* %exists, align 1
  %38 = load i8, i8* %exists, align 1
  %39 = trunc i8 %38 to i1
  br i1 %39, label %40, label %131

; <label>:40                                      ; preds = %0
  %41 = load i32, i32* %i, align 4
  %42 = zext i32 %41 to i64
  %43 = load %class.KV.0*, %class.KV.0** %data, align 8
  %44 = getelementptr inbounds %class.KV.0, %class.KV.0* %43, i64 %42
  %45 = getelementptr inbounds %class.KV.0, %class.KV.0* %44, i32 0, i32 0
  %46 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Key"* %45 to i64*
  %47 = load i64, i64* %46, align 8
  %48 = and i64 %47, 1
  %49 = icmp eq i64 %48, 0
  br i1 %49, label %50, label %112

; <label>:50                                      ; preds = %40
  %51 = load i32, i32* %i, align 4
  %52 = zext i32 %51 to i64
  %53 = load %class.KV.0*, %class.KV.0** %data, align 8
  %54 = getelementptr inbounds %class.KV.0, %class.KV.0* %53, i64 %52
  %55 = getelementptr inbounds %class.KV.0, %class.KV.0* %54, i32 0, i32 0
  %56 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Key"* %55 to %class.scheme_key**
  %57 = load %class.scheme_key*, %class.scheme_key** %56, align 8
  %58 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %59 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %57, %class.scheme_key* dereferenceable(8) %58)
  br i1 %59, label %60, label %72

; <label>:60                                      ; preds = %50
  %61 = load %class.KV.0*, %class.KV.0** %data, align 8
  %62 = load i32, i32* %count, align 4
  %63 = load i32, i32* %i, align 4
  %64 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %65 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EEC2EPKS0_PKS1_(%class.KV.0* %6, %class.scheme_key* %64, %class.scheme_value* %65)
  %66 = call %class.KV.0* @_ZN2KVI10scheme_key12scheme_valueLj1EE11update_nodeEPKS2_jjRS3_(%class.KV.0* %61, i32 %62, i32 %63, %class.KV.0* dereferenceable(16) %6)
  store %class.KV.0* %66, %class.KV.0** %node, align 8
  %67 = load %class.KV*, %class.KV** %1, align 8
  %68 = getelementptr inbounds %class.KV, %class.KV* %67, i32 0, i32 0
  %69 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Key"* %68 to i64*
  %70 = load i64, i64* %69, align 8
  %71 = load %class.KV.0*, %class.KV.0** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EEC2EmPKS_IS0_S1_Lj1EE(%class.KV* %agg.result, i64 %70, %class.KV.0* %71)
  br label %180

; <label>:72                                      ; preds = %50
  %73 = load i64*, i64** %5, align 8
  %74 = load i64, i64* %73, align 8
  %75 = add i64 %74, 1
  store i64 %75, i64* %73, align 8
  %76 = load i32, i32* %i, align 4
  %77 = zext i32 %76 to i64
  %78 = load %class.KV.0*, %class.KV.0** %data, align 8
  %79 = getelementptr inbounds %class.KV.0, %class.KV.0* %78, i64 %77
  %80 = getelementptr inbounds %class.KV.0, %class.KV.0* %79, i32 0, i32 0
  %81 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Key"* %80 to %class.scheme_key**
  %82 = load %class.scheme_key*, %class.scheme_key** %81, align 8
  %83 = call i64 @_ZNK10scheme_key4hashEv(%class.scheme_key* %82)
  %84 = lshr i64 %83, 10
  %85 = load i32, i32* %i, align 4
  %86 = zext i32 %85 to i64
  %87 = load %class.KV.0*, %class.KV.0** %data, align 8
  %88 = getelementptr inbounds %class.KV.0, %class.KV.0* %87, i64 %86
  %89 = getelementptr inbounds %class.KV.0, %class.KV.0* %88, i32 0, i32 0
  %90 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Key"* %89 to %class.scheme_key**
  %91 = load %class.scheme_key*, %class.scheme_key** %90, align 8
  %92 = load i32, i32* %i, align 4
  %93 = zext i32 %92 to i64
  %94 = load %class.KV.0*, %class.KV.0** %data, align 8
  %95 = getelementptr inbounds %class.KV.0, %class.KV.0* %94, i64 %93
  %96 = getelementptr inbounds %class.KV.0, %class.KV.0* %95, i32 0, i32 1
  %97 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Val"* %96 to %class.scheme_value**
  %98 = load %class.scheme_value*, %class.scheme_value** %97, align 8
  %99 = load i64, i64* %2, align 8
  %100 = lshr i64 %99, 6
  %101 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %102 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.0* sret %childkv, i64 %84, %class.scheme_key* %91, %class.scheme_value* %98, i64 %100, %class.scheme_key* %101, %class.scheme_value* %102)
  %103 = load %class.KV.0*, %class.KV.0** %data, align 8
  %104 = load i32, i32* %count, align 4
  %105 = load i32, i32* %i, align 4
  %106 = call %class.KV.0* @_ZN2KVI10scheme_key12scheme_valueLj1EE11update_nodeEPKS2_jjRS3_(%class.KV.0* %103, i32 %104, i32 %105, %class.KV.0* dereferenceable(16) %childkv)
  store %class.KV.0* %106, %class.KV.0** %node1, align 8
  %107 = load %class.KV*, %class.KV** %1, align 8
  %108 = getelementptr inbounds %class.KV, %class.KV* %107, i32 0, i32 0
  %109 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Key"* %108 to i64*
  %110 = load i64, i64* %109, align 8
  %111 = load %class.KV.0*, %class.KV.0** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EEC2EmPKS_IS0_S1_Lj1EE(%class.KV* %agg.result, i64 %110, %class.KV.0* %111)
  br label %180

; <label>:112                                     ; preds = %40
  %113 = load i32, i32* %i, align 4
  %114 = zext i32 %113 to i64
  %115 = load %class.KV.0*, %class.KV.0** %data, align 8
  %116 = getelementptr inbounds %class.KV.0, %class.KV.0* %115, i64 %114
  %117 = load i64, i64* %2, align 8
  %118 = lshr i64 %117, 6
  %119 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %120 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  %121 = load i64*, i64** %5, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EE12insert_innerERKS2_mPKS0_PKS1_Pm(%class.KV.0* sret %childkv2, %class.KV.0* dereferenceable(16) %116, i64 %118, %class.scheme_key* %119, %class.scheme_value* %120, i64* %121)
  %122 = load %class.KV.0*, %class.KV.0** %data, align 8
  %123 = load i32, i32* %count, align 4
  %124 = load i32, i32* %i, align 4
  %125 = call %class.KV.0* @_ZN2KVI10scheme_key12scheme_valueLj1EE11update_nodeEPKS2_jjRS3_(%class.KV.0* %122, i32 %123, i32 %124, %class.KV.0* dereferenceable(16) %childkv2)
  store %class.KV.0* %125, %class.KV.0** %node3, align 8
  %126 = load %class.KV*, %class.KV** %1, align 8
  %127 = getelementptr inbounds %class.KV, %class.KV* %126, i32 0, i32 0
  %128 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Key"* %127 to i64*
  %129 = load i64, i64* %128, align 8
  %130 = load %class.KV.0*, %class.KV.0** %node3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EEC2EmPKS_IS0_S1_Lj1EE(%class.KV* %agg.result, i64 %129, %class.KV.0* %130)
  br label %180

; <label>:131                                     ; preds = %0
  %132 = load i64*, i64** %5, align 8
  %133 = load i64, i64* %132, align 8
  %134 = add i64 %133, 1
  store i64 %134, i64* %132, align 8
  %135 = load i32, i32* %count, align 4
  %136 = add i32 %135, 1
  %137 = zext i32 %136 to i64
  %138 = mul i64 %137, 16
  %139 = call noalias i8* @GC_malloc(i64 %138)
  %140 = bitcast i8* %139 to %class.KV.0*
  store %class.KV.0* %140, %class.KV.0** %node4, align 8
  %141 = load %class.KV.0*, %class.KV.0** %node4, align 8
  %142 = bitcast %class.KV.0* %141 to i8*
  %143 = load %class.KV.0*, %class.KV.0** %data, align 8
  %144 = bitcast %class.KV.0* %143 to i8*
  %145 = load i32, i32* %i, align 4
  %146 = zext i32 %145 to i64
  %147 = mul i64 %146, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %142, i8* %144, i64 %147, i32 8, i1 false)
  %148 = load i32, i32* %i, align 4
  %149 = add i32 %148, 1
  %150 = zext i32 %149 to i64
  %151 = load %class.KV.0*, %class.KV.0** %node4, align 8
  %152 = getelementptr inbounds %class.KV.0, %class.KV.0* %151, i64 %150
  %153 = bitcast %class.KV.0* %152 to i8*
  %154 = load i32, i32* %i, align 4
  %155 = zext i32 %154 to i64
  %156 = load %class.KV.0*, %class.KV.0** %data, align 8
  %157 = getelementptr inbounds %class.KV.0, %class.KV.0* %156, i64 %155
  %158 = bitcast %class.KV.0* %157 to i8*
  %159 = load i32, i32* %count, align 4
  %160 = load i32, i32* %i, align 4
  %161 = sub i32 %159, %160
  %162 = zext i32 %161 to i64
  %163 = mul i64 %162, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %153, i8* %158, i64 %163, i32 8, i1 false)
  %164 = load %class.KV.0*, %class.KV.0** %node4, align 8
  %165 = load i32, i32* %i, align 4
  %166 = zext i32 %165 to i64
  %167 = getelementptr inbounds %class.KV.0, %class.KV.0* %164, i64 %166
  %168 = bitcast %class.KV.0* %167 to i8*
  %169 = bitcast i8* %168 to %class.KV.0*
  %170 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %171 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EEC2EPKS0_PKS1_(%class.KV.0* %169, %class.scheme_key* %170, %class.scheme_value* %171)
  %172 = load i64, i64* %bm, align 8
  %173 = load i32, i32* %hpiece, align 4
  %174 = zext i32 %173 to i64
  %175 = shl i64 1, %174
  %176 = or i64 %172, %175
  %177 = shl i64 %176, 1
  %178 = or i64 %177, 1
  %179 = load %class.KV.0*, %class.KV.0** %node4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EEC2EmPKS_IS0_S1_Lj1EE(%class.KV* %agg.result, i64 %178, %class.KV.0* %179)
  br label %180

; <label>:180                                     ; preds = %131, %112, %72, %60
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj0EE3KeyC2EPKS0_(%"union.KV<scheme_key, scheme_value, 0>::Key"* %this, %class.scheme_key* %key) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 0>::Key"*, align 8
  %2 = alloca %class.scheme_key*, align 8
  store %"union.KV<scheme_key, scheme_value, 0>::Key"* %this, %"union.KV<scheme_key, scheme_value, 0>::Key"** %1, align 8
  store %class.scheme_key* %key, %class.scheme_key** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 0>::Key"*, %"union.KV<scheme_key, scheme_value, 0>::Key"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Key"* %3 to %class.scheme_key**
  %5 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  store %class.scheme_key* %5, %class.scheme_key** %4, align 8
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj1EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.0* noalias sret %agg.result, i64 %h0, %class.scheme_key* %k0, %class.scheme_value* %v0, i64 %h1, %class.scheme_key* %k1, %class.scheme_value* %v1) #0 comdat align 2 {
  %1 = alloca i64, align 8
  %2 = alloca %class.scheme_key*, align 8
  %3 = alloca %class.scheme_value*, align 8
  %4 = alloca i64, align 8
  %5 = alloca %class.scheme_key*, align 8
  %6 = alloca %class.scheme_value*, align 8
  %h0piece = alloca i32, align 4
  %h1piece = alloca i32, align 4
  %childkv = alloca %class.KV.1, align 8
  %node = alloca %class.KV.1*, align 8
  %node1 = alloca %class.KV.1*, align 8
  store i64 %h0, i64* %1, align 8
  store %class.scheme_key* %k0, %class.scheme_key** %2, align 8
  store %class.scheme_value* %v0, %class.scheme_value** %3, align 8
  store i64 %h1, i64* %4, align 8
  store %class.scheme_key* %k1, %class.scheme_key** %5, align 8
  store %class.scheme_value* %v1, %class.scheme_value** %6, align 8
  %7 = load i64, i64* %1, align 8
  %8 = and i64 %7, 63
  %9 = urem i64 %8, 63
  %10 = trunc i64 %9 to i32
  store i32 %10, i32* %h0piece, align 4
  %11 = load i64, i64* %4, align 8
  %12 = and i64 %11, 63
  %13 = urem i64 %12, 63
  %14 = trunc i64 %13 to i32
  store i32 %14, i32* %h1piece, align 4
  %15 = load i32, i32* %h0piece, align 4
  %16 = load i32, i32* %h1piece, align 4
  %17 = icmp eq i32 %15, %16
  br i1 %17, label %18, label %39

; <label>:18                                      ; preds = %0
  %19 = load i64, i64* %1, align 8
  %20 = lshr i64 %19, 6
  %21 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %22 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  %23 = load i64, i64* %4, align 8
  %24 = lshr i64 %23, 6
  %25 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %26 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.1* sret %childkv, i64 %20, %class.scheme_key* %21, %class.scheme_value* %22, i64 %24, %class.scheme_key* %25, %class.scheme_value* %26)
  %27 = call noalias i8* @GC_malloc(i64 16)
  %28 = bitcast i8* %27 to %class.KV.1*
  store %class.KV.1* %28, %class.KV.1** %node, align 8
  %29 = load %class.KV.1*, %class.KV.1** %node, align 8
  %30 = getelementptr inbounds %class.KV.1, %class.KV.1* %29, i64 0
  %31 = bitcast %class.KV.1* %30 to i8*
  %32 = bitcast i8* %31 to %class.KV.1*
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EEC2ERKS2_(%class.KV.1* %32, %class.KV.1* dereferenceable(16) %childkv)
  %33 = load i32, i32* %h0piece, align 4
  %34 = zext i32 %33 to i64
  %35 = shl i64 1, %34
  %36 = shl i64 %35, 1
  %37 = or i64 %36, 1
  %38 = load %class.KV.1*, %class.KV.1** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EEC2EmPKS_IS0_S1_Lj2EE(%class.KV.0* %agg.result, i64 %37, %class.KV.1* %38)
  br label %82

; <label>:39                                      ; preds = %0
  %40 = call noalias i8* @GC_malloc(i64 32)
  %41 = bitcast i8* %40 to %class.KV.1*
  store %class.KV.1* %41, %class.KV.1** %node1, align 8
  %42 = load i32, i32* %h1piece, align 4
  %43 = load i32, i32* %h0piece, align 4
  %44 = icmp ult i32 %42, %43
  br i1 %44, label %45, label %58

; <label>:45                                      ; preds = %39
  %46 = load %class.KV.1*, %class.KV.1** %node1, align 8
  %47 = getelementptr inbounds %class.KV.1, %class.KV.1* %46, i64 0
  %48 = bitcast %class.KV.1* %47 to i8*
  %49 = bitcast i8* %48 to %class.KV.1*
  %50 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %51 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EEC2EPKS0_PKS1_(%class.KV.1* %49, %class.scheme_key* %50, %class.scheme_value* %51)
  %52 = load %class.KV.1*, %class.KV.1** %node1, align 8
  %53 = getelementptr inbounds %class.KV.1, %class.KV.1* %52, i64 1
  %54 = bitcast %class.KV.1* %53 to i8*
  %55 = bitcast i8* %54 to %class.KV.1*
  %56 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %57 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EEC2EPKS0_PKS1_(%class.KV.1* %55, %class.scheme_key* %56, %class.scheme_value* %57)
  br label %71

; <label>:58                                      ; preds = %39
  %59 = load %class.KV.1*, %class.KV.1** %node1, align 8
  %60 = getelementptr inbounds %class.KV.1, %class.KV.1* %59, i64 0
  %61 = bitcast %class.KV.1* %60 to i8*
  %62 = bitcast i8* %61 to %class.KV.1*
  %63 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %64 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EEC2EPKS0_PKS1_(%class.KV.1* %62, %class.scheme_key* %63, %class.scheme_value* %64)
  %65 = load %class.KV.1*, %class.KV.1** %node1, align 8
  %66 = getelementptr inbounds %class.KV.1, %class.KV.1* %65, i64 1
  %67 = bitcast %class.KV.1* %66 to i8*
  %68 = bitcast i8* %67 to %class.KV.1*
  %69 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %70 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EEC2EPKS0_PKS1_(%class.KV.1* %68, %class.scheme_key* %69, %class.scheme_value* %70)
  br label %71

; <label>:71                                      ; preds = %58, %45
  %72 = load i32, i32* %h0piece, align 4
  %73 = zext i32 %72 to i64
  %74 = shl i64 1, %73
  %75 = load i32, i32* %h1piece, align 4
  %76 = zext i32 %75 to i64
  %77 = shl i64 1, %76
  %78 = or i64 %74, %77
  %79 = shl i64 %78, 1
  %80 = or i64 %79, 1
  %81 = load %class.KV.1*, %class.KV.1** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EEC2EmPKS_IS0_S1_Lj2EE(%class.KV.0* %agg.result, i64 %80, %class.KV.1* %81)
  br label %82

; <label>:82                                      ; preds = %71, %18
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj1EEC2ERKS2_(%class.KV.0* %this, %class.KV.0* dereferenceable(16) %o) unnamed_addr #5 comdat align 2 {
  %1 = alloca %class.KV.0*, align 8
  %2 = alloca %class.KV.0*, align 8
  store %class.KV.0* %this, %class.KV.0** %1, align 8
  store %class.KV.0* %o, %class.KV.0** %2, align 8
  %3 = load %class.KV.0*, %class.KV.0** %1, align 8
  %4 = getelementptr inbounds %class.KV.0, %class.KV.0* %3, i32 0, i32 0
  %5 = load %class.KV.0*, %class.KV.0** %2, align 8
  %6 = getelementptr inbounds %class.KV.0, %class.KV.0* %5, i32 0, i32 0
  %7 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Key"* %4 to i8*
  %8 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Key"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 8, i32 8, i1 false)
  %9 = getelementptr inbounds %class.KV.0, %class.KV.0* %3, i32 0, i32 1
  %10 = load %class.KV.0*, %class.KV.0** %2, align 8
  %11 = getelementptr inbounds %class.KV.0, %class.KV.0* %10, i32 0, i32 1
  %12 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Val"* %9 to i8*
  %13 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Val"* %11 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %12, i8* %13, i64 8, i32 8, i1 false)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj0EEC2EmPKS_IS0_S1_Lj1EE(%class.KV* %this, i64 %bm, %class.KV.0* %kv) unnamed_addr #0 comdat align 2 {
  %1 = alloca %class.KV*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.KV.0*, align 8
  store %class.KV* %this, %class.KV** %1, align 8
  store i64 %bm, i64* %2, align 8
  store %class.KV.0* %kv, %class.KV.0** %3, align 8
  %4 = load %class.KV*, %class.KV** %1, align 8
  %5 = getelementptr inbounds %class.KV, %class.KV* %4, i32 0, i32 0
  %6 = load i64, i64* %2, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EE3KeyC2Em(%"union.KV<scheme_key, scheme_value, 0>::Key"* %5, i64 %6)
  %7 = getelementptr inbounds %class.KV, %class.KV* %4, i32 0, i32 1
  %8 = load %class.KV.0*, %class.KV.0** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EE3ValC2EPKS_IS0_S1_Lj1EE(%"union.KV<scheme_key, scheme_value, 0>::Val"* %7, %class.KV.0* %8)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj1EEC2EPKS0_PKS1_(%class.KV.0* %this, %class.scheme_key* %key, %class.scheme_value* %val) unnamed_addr #0 comdat align 2 {
  %1 = alloca %class.KV.0*, align 8
  %2 = alloca %class.scheme_key*, align 8
  %3 = alloca %class.scheme_value*, align 8
  store %class.KV.0* %this, %class.KV.0** %1, align 8
  store %class.scheme_key* %key, %class.scheme_key** %2, align 8
  store %class.scheme_value* %val, %class.scheme_value** %3, align 8
  %4 = load %class.KV.0*, %class.KV.0** %1, align 8
  %5 = getelementptr inbounds %class.KV.0, %class.KV.0* %4, i32 0, i32 0
  %6 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EE3KeyC2EPKS0_(%"union.KV<scheme_key, scheme_value, 1>::Key"* %5, %class.scheme_key* %6)
  %7 = getelementptr inbounds %class.KV.0, %class.KV.0* %4, i32 0, i32 1
  %8 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EE3ValC2EPKS1_(%"union.KV<scheme_key, scheme_value, 1>::Val"* %7, %class.scheme_value* %8)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj2EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.1* noalias sret %agg.result, i64 %h0, %class.scheme_key* %k0, %class.scheme_value* %v0, i64 %h1, %class.scheme_key* %k1, %class.scheme_value* %v1) #0 comdat align 2 {
  %1 = alloca i64, align 8
  %2 = alloca %class.scheme_key*, align 8
  %3 = alloca %class.scheme_value*, align 8
  %4 = alloca i64, align 8
  %5 = alloca %class.scheme_key*, align 8
  %6 = alloca %class.scheme_value*, align 8
  %h0piece = alloca i32, align 4
  %h1piece = alloca i32, align 4
  %childkv = alloca %class.KV.2, align 8
  %node = alloca %class.KV.2*, align 8
  %node1 = alloca %class.KV.2*, align 8
  store i64 %h0, i64* %1, align 8
  store %class.scheme_key* %k0, %class.scheme_key** %2, align 8
  store %class.scheme_value* %v0, %class.scheme_value** %3, align 8
  store i64 %h1, i64* %4, align 8
  store %class.scheme_key* %k1, %class.scheme_key** %5, align 8
  store %class.scheme_value* %v1, %class.scheme_value** %6, align 8
  %7 = load i64, i64* %1, align 8
  %8 = and i64 %7, 63
  %9 = urem i64 %8, 63
  %10 = trunc i64 %9 to i32
  store i32 %10, i32* %h0piece, align 4
  %11 = load i64, i64* %4, align 8
  %12 = and i64 %11, 63
  %13 = urem i64 %12, 63
  %14 = trunc i64 %13 to i32
  store i32 %14, i32* %h1piece, align 4
  %15 = load i32, i32* %h0piece, align 4
  %16 = load i32, i32* %h1piece, align 4
  %17 = icmp eq i32 %15, %16
  br i1 %17, label %18, label %39

; <label>:18                                      ; preds = %0
  %19 = load i64, i64* %1, align 8
  %20 = lshr i64 %19, 6
  %21 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %22 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  %23 = load i64, i64* %4, align 8
  %24 = lshr i64 %23, 6
  %25 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %26 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.2* sret %childkv, i64 %20, %class.scheme_key* %21, %class.scheme_value* %22, i64 %24, %class.scheme_key* %25, %class.scheme_value* %26)
  %27 = call noalias i8* @GC_malloc(i64 16)
  %28 = bitcast i8* %27 to %class.KV.2*
  store %class.KV.2* %28, %class.KV.2** %node, align 8
  %29 = load %class.KV.2*, %class.KV.2** %node, align 8
  %30 = getelementptr inbounds %class.KV.2, %class.KV.2* %29, i64 0
  %31 = bitcast %class.KV.2* %30 to i8*
  %32 = bitcast i8* %31 to %class.KV.2*
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EEC2ERKS2_(%class.KV.2* %32, %class.KV.2* dereferenceable(16) %childkv)
  %33 = load i32, i32* %h0piece, align 4
  %34 = zext i32 %33 to i64
  %35 = shl i64 1, %34
  %36 = shl i64 %35, 1
  %37 = or i64 %36, 1
  %38 = load %class.KV.2*, %class.KV.2** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EEC2EmPKS_IS0_S1_Lj3EE(%class.KV.1* %agg.result, i64 %37, %class.KV.2* %38)
  br label %82

; <label>:39                                      ; preds = %0
  %40 = call noalias i8* @GC_malloc(i64 32)
  %41 = bitcast i8* %40 to %class.KV.2*
  store %class.KV.2* %41, %class.KV.2** %node1, align 8
  %42 = load i32, i32* %h1piece, align 4
  %43 = load i32, i32* %h0piece, align 4
  %44 = icmp ult i32 %42, %43
  br i1 %44, label %45, label %58

; <label>:45                                      ; preds = %39
  %46 = load %class.KV.2*, %class.KV.2** %node1, align 8
  %47 = getelementptr inbounds %class.KV.2, %class.KV.2* %46, i64 0
  %48 = bitcast %class.KV.2* %47 to i8*
  %49 = bitcast i8* %48 to %class.KV.2*
  %50 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %51 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EEC2EPKS0_PKS1_(%class.KV.2* %49, %class.scheme_key* %50, %class.scheme_value* %51)
  %52 = load %class.KV.2*, %class.KV.2** %node1, align 8
  %53 = getelementptr inbounds %class.KV.2, %class.KV.2* %52, i64 1
  %54 = bitcast %class.KV.2* %53 to i8*
  %55 = bitcast i8* %54 to %class.KV.2*
  %56 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %57 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EEC2EPKS0_PKS1_(%class.KV.2* %55, %class.scheme_key* %56, %class.scheme_value* %57)
  br label %71

; <label>:58                                      ; preds = %39
  %59 = load %class.KV.2*, %class.KV.2** %node1, align 8
  %60 = getelementptr inbounds %class.KV.2, %class.KV.2* %59, i64 0
  %61 = bitcast %class.KV.2* %60 to i8*
  %62 = bitcast i8* %61 to %class.KV.2*
  %63 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %64 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EEC2EPKS0_PKS1_(%class.KV.2* %62, %class.scheme_key* %63, %class.scheme_value* %64)
  %65 = load %class.KV.2*, %class.KV.2** %node1, align 8
  %66 = getelementptr inbounds %class.KV.2, %class.KV.2* %65, i64 1
  %67 = bitcast %class.KV.2* %66 to i8*
  %68 = bitcast i8* %67 to %class.KV.2*
  %69 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %70 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EEC2EPKS0_PKS1_(%class.KV.2* %68, %class.scheme_key* %69, %class.scheme_value* %70)
  br label %71

; <label>:71                                      ; preds = %58, %45
  %72 = load i32, i32* %h0piece, align 4
  %73 = zext i32 %72 to i64
  %74 = shl i64 1, %73
  %75 = load i32, i32* %h1piece, align 4
  %76 = zext i32 %75 to i64
  %77 = shl i64 1, %76
  %78 = or i64 %74, %77
  %79 = shl i64 %78, 1
  %80 = or i64 %79, 1
  %81 = load %class.KV.2*, %class.KV.2** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EEC2EmPKS_IS0_S1_Lj3EE(%class.KV.1* %agg.result, i64 %80, %class.KV.2* %81)
  br label %82

; <label>:82                                      ; preds = %71, %18
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj2EEC2ERKS2_(%class.KV.1* %this, %class.KV.1* dereferenceable(16) %o) unnamed_addr #5 comdat align 2 {
  %1 = alloca %class.KV.1*, align 8
  %2 = alloca %class.KV.1*, align 8
  store %class.KV.1* %this, %class.KV.1** %1, align 8
  store %class.KV.1* %o, %class.KV.1** %2, align 8
  %3 = load %class.KV.1*, %class.KV.1** %1, align 8
  %4 = getelementptr inbounds %class.KV.1, %class.KV.1* %3, i32 0, i32 0
  %5 = load %class.KV.1*, %class.KV.1** %2, align 8
  %6 = getelementptr inbounds %class.KV.1, %class.KV.1* %5, i32 0, i32 0
  %7 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Key"* %4 to i8*
  %8 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Key"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 8, i32 8, i1 false)
  %9 = getelementptr inbounds %class.KV.1, %class.KV.1* %3, i32 0, i32 1
  %10 = load %class.KV.1*, %class.KV.1** %2, align 8
  %11 = getelementptr inbounds %class.KV.1, %class.KV.1* %10, i32 0, i32 1
  %12 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Val"* %9 to i8*
  %13 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Val"* %11 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %12, i8* %13, i64 8, i32 8, i1 false)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj1EEC2EmPKS_IS0_S1_Lj2EE(%class.KV.0* %this, i64 %bm, %class.KV.1* %kv) unnamed_addr #0 comdat align 2 {
  %1 = alloca %class.KV.0*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.KV.1*, align 8
  store %class.KV.0* %this, %class.KV.0** %1, align 8
  store i64 %bm, i64* %2, align 8
  store %class.KV.1* %kv, %class.KV.1** %3, align 8
  %4 = load %class.KV.0*, %class.KV.0** %1, align 8
  %5 = getelementptr inbounds %class.KV.0, %class.KV.0* %4, i32 0, i32 0
  %6 = load i64, i64* %2, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EE3KeyC2Em(%"union.KV<scheme_key, scheme_value, 1>::Key"* %5, i64 %6)
  %7 = getelementptr inbounds %class.KV.0, %class.KV.0* %4, i32 0, i32 1
  %8 = load %class.KV.1*, %class.KV.1** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EE3ValC2EPKS_IS0_S1_Lj2EE(%"union.KV<scheme_key, scheme_value, 1>::Val"* %7, %class.KV.1* %8)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj2EEC2EPKS0_PKS1_(%class.KV.1* %this, %class.scheme_key* %key, %class.scheme_value* %val) unnamed_addr #0 comdat align 2 {
  %1 = alloca %class.KV.1*, align 8
  %2 = alloca %class.scheme_key*, align 8
  %3 = alloca %class.scheme_value*, align 8
  store %class.KV.1* %this, %class.KV.1** %1, align 8
  store %class.scheme_key* %key, %class.scheme_key** %2, align 8
  store %class.scheme_value* %val, %class.scheme_value** %3, align 8
  %4 = load %class.KV.1*, %class.KV.1** %1, align 8
  %5 = getelementptr inbounds %class.KV.1, %class.KV.1* %4, i32 0, i32 0
  %6 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EE3KeyC2EPKS0_(%"union.KV<scheme_key, scheme_value, 2>::Key"* %5, %class.scheme_key* %6)
  %7 = getelementptr inbounds %class.KV.1, %class.KV.1* %4, i32 0, i32 1
  %8 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EE3ValC2EPKS1_(%"union.KV<scheme_key, scheme_value, 2>::Val"* %7, %class.scheme_value* %8)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj3EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.2* noalias sret %agg.result, i64 %h0, %class.scheme_key* %k0, %class.scheme_value* %v0, i64 %h1, %class.scheme_key* %k1, %class.scheme_value* %v1) #0 comdat align 2 {
  %1 = alloca i64, align 8
  %2 = alloca %class.scheme_key*, align 8
  %3 = alloca %class.scheme_value*, align 8
  %4 = alloca i64, align 8
  %5 = alloca %class.scheme_key*, align 8
  %6 = alloca %class.scheme_value*, align 8
  %h0piece = alloca i32, align 4
  %h1piece = alloca i32, align 4
  %childkv = alloca %class.KV.3, align 8
  %node = alloca %class.KV.3*, align 8
  %node1 = alloca %class.KV.3*, align 8
  store i64 %h0, i64* %1, align 8
  store %class.scheme_key* %k0, %class.scheme_key** %2, align 8
  store %class.scheme_value* %v0, %class.scheme_value** %3, align 8
  store i64 %h1, i64* %4, align 8
  store %class.scheme_key* %k1, %class.scheme_key** %5, align 8
  store %class.scheme_value* %v1, %class.scheme_value** %6, align 8
  %7 = load i64, i64* %1, align 8
  %8 = and i64 %7, 63
  %9 = urem i64 %8, 63
  %10 = trunc i64 %9 to i32
  store i32 %10, i32* %h0piece, align 4
  %11 = load i64, i64* %4, align 8
  %12 = and i64 %11, 63
  %13 = urem i64 %12, 63
  %14 = trunc i64 %13 to i32
  store i32 %14, i32* %h1piece, align 4
  %15 = load i32, i32* %h0piece, align 4
  %16 = load i32, i32* %h1piece, align 4
  %17 = icmp eq i32 %15, %16
  br i1 %17, label %18, label %39

; <label>:18                                      ; preds = %0
  %19 = load i64, i64* %1, align 8
  %20 = lshr i64 %19, 6
  %21 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %22 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  %23 = load i64, i64* %4, align 8
  %24 = lshr i64 %23, 6
  %25 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %26 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.3* sret %childkv, i64 %20, %class.scheme_key* %21, %class.scheme_value* %22, i64 %24, %class.scheme_key* %25, %class.scheme_value* %26)
  %27 = call noalias i8* @GC_malloc(i64 16)
  %28 = bitcast i8* %27 to %class.KV.3*
  store %class.KV.3* %28, %class.KV.3** %node, align 8
  %29 = load %class.KV.3*, %class.KV.3** %node, align 8
  %30 = getelementptr inbounds %class.KV.3, %class.KV.3* %29, i64 0
  %31 = bitcast %class.KV.3* %30 to i8*
  %32 = bitcast i8* %31 to %class.KV.3*
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EEC2ERKS2_(%class.KV.3* %32, %class.KV.3* dereferenceable(16) %childkv)
  %33 = load i32, i32* %h0piece, align 4
  %34 = zext i32 %33 to i64
  %35 = shl i64 1, %34
  %36 = shl i64 %35, 1
  %37 = or i64 %36, 1
  %38 = load %class.KV.3*, %class.KV.3** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EEC2EmPKS_IS0_S1_Lj4EE(%class.KV.2* %agg.result, i64 %37, %class.KV.3* %38)
  br label %82

; <label>:39                                      ; preds = %0
  %40 = call noalias i8* @GC_malloc(i64 32)
  %41 = bitcast i8* %40 to %class.KV.3*
  store %class.KV.3* %41, %class.KV.3** %node1, align 8
  %42 = load i32, i32* %h1piece, align 4
  %43 = load i32, i32* %h0piece, align 4
  %44 = icmp ult i32 %42, %43
  br i1 %44, label %45, label %58

; <label>:45                                      ; preds = %39
  %46 = load %class.KV.3*, %class.KV.3** %node1, align 8
  %47 = getelementptr inbounds %class.KV.3, %class.KV.3* %46, i64 0
  %48 = bitcast %class.KV.3* %47 to i8*
  %49 = bitcast i8* %48 to %class.KV.3*
  %50 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %51 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EEC2EPKS0_PKS1_(%class.KV.3* %49, %class.scheme_key* %50, %class.scheme_value* %51)
  %52 = load %class.KV.3*, %class.KV.3** %node1, align 8
  %53 = getelementptr inbounds %class.KV.3, %class.KV.3* %52, i64 1
  %54 = bitcast %class.KV.3* %53 to i8*
  %55 = bitcast i8* %54 to %class.KV.3*
  %56 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %57 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EEC2EPKS0_PKS1_(%class.KV.3* %55, %class.scheme_key* %56, %class.scheme_value* %57)
  br label %71

; <label>:58                                      ; preds = %39
  %59 = load %class.KV.3*, %class.KV.3** %node1, align 8
  %60 = getelementptr inbounds %class.KV.3, %class.KV.3* %59, i64 0
  %61 = bitcast %class.KV.3* %60 to i8*
  %62 = bitcast i8* %61 to %class.KV.3*
  %63 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %64 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EEC2EPKS0_PKS1_(%class.KV.3* %62, %class.scheme_key* %63, %class.scheme_value* %64)
  %65 = load %class.KV.3*, %class.KV.3** %node1, align 8
  %66 = getelementptr inbounds %class.KV.3, %class.KV.3* %65, i64 1
  %67 = bitcast %class.KV.3* %66 to i8*
  %68 = bitcast i8* %67 to %class.KV.3*
  %69 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %70 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EEC2EPKS0_PKS1_(%class.KV.3* %68, %class.scheme_key* %69, %class.scheme_value* %70)
  br label %71

; <label>:71                                      ; preds = %58, %45
  %72 = load i32, i32* %h0piece, align 4
  %73 = zext i32 %72 to i64
  %74 = shl i64 1, %73
  %75 = load i32, i32* %h1piece, align 4
  %76 = zext i32 %75 to i64
  %77 = shl i64 1, %76
  %78 = or i64 %74, %77
  %79 = shl i64 %78, 1
  %80 = or i64 %79, 1
  %81 = load %class.KV.3*, %class.KV.3** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EEC2EmPKS_IS0_S1_Lj4EE(%class.KV.2* %agg.result, i64 %80, %class.KV.3* %81)
  br label %82

; <label>:82                                      ; preds = %71, %18
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj3EEC2ERKS2_(%class.KV.2* %this, %class.KV.2* dereferenceable(16) %o) unnamed_addr #5 comdat align 2 {
  %1 = alloca %class.KV.2*, align 8
  %2 = alloca %class.KV.2*, align 8
  store %class.KV.2* %this, %class.KV.2** %1, align 8
  store %class.KV.2* %o, %class.KV.2** %2, align 8
  %3 = load %class.KV.2*, %class.KV.2** %1, align 8
  %4 = getelementptr inbounds %class.KV.2, %class.KV.2* %3, i32 0, i32 0
  %5 = load %class.KV.2*, %class.KV.2** %2, align 8
  %6 = getelementptr inbounds %class.KV.2, %class.KV.2* %5, i32 0, i32 0
  %7 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Key"* %4 to i8*
  %8 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Key"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 8, i32 8, i1 false)
  %9 = getelementptr inbounds %class.KV.2, %class.KV.2* %3, i32 0, i32 1
  %10 = load %class.KV.2*, %class.KV.2** %2, align 8
  %11 = getelementptr inbounds %class.KV.2, %class.KV.2* %10, i32 0, i32 1
  %12 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Val"* %9 to i8*
  %13 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Val"* %11 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %12, i8* %13, i64 8, i32 8, i1 false)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj2EEC2EmPKS_IS0_S1_Lj3EE(%class.KV.1* %this, i64 %bm, %class.KV.2* %kv) unnamed_addr #0 comdat align 2 {
  %1 = alloca %class.KV.1*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.KV.2*, align 8
  store %class.KV.1* %this, %class.KV.1** %1, align 8
  store i64 %bm, i64* %2, align 8
  store %class.KV.2* %kv, %class.KV.2** %3, align 8
  %4 = load %class.KV.1*, %class.KV.1** %1, align 8
  %5 = getelementptr inbounds %class.KV.1, %class.KV.1* %4, i32 0, i32 0
  %6 = load i64, i64* %2, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EE3KeyC2Em(%"union.KV<scheme_key, scheme_value, 2>::Key"* %5, i64 %6)
  %7 = getelementptr inbounds %class.KV.1, %class.KV.1* %4, i32 0, i32 1
  %8 = load %class.KV.2*, %class.KV.2** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EE3ValC2EPKS_IS0_S1_Lj3EE(%"union.KV<scheme_key, scheme_value, 2>::Val"* %7, %class.KV.2* %8)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj3EEC2EPKS0_PKS1_(%class.KV.2* %this, %class.scheme_key* %key, %class.scheme_value* %val) unnamed_addr #0 comdat align 2 {
  %1 = alloca %class.KV.2*, align 8
  %2 = alloca %class.scheme_key*, align 8
  %3 = alloca %class.scheme_value*, align 8
  store %class.KV.2* %this, %class.KV.2** %1, align 8
  store %class.scheme_key* %key, %class.scheme_key** %2, align 8
  store %class.scheme_value* %val, %class.scheme_value** %3, align 8
  %4 = load %class.KV.2*, %class.KV.2** %1, align 8
  %5 = getelementptr inbounds %class.KV.2, %class.KV.2* %4, i32 0, i32 0
  %6 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EE3KeyC2EPKS0_(%"union.KV<scheme_key, scheme_value, 3>::Key"* %5, %class.scheme_key* %6)
  %7 = getelementptr inbounds %class.KV.2, %class.KV.2* %4, i32 0, i32 1
  %8 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EE3ValC2EPKS1_(%"union.KV<scheme_key, scheme_value, 3>::Val"* %7, %class.scheme_value* %8)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj4EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.3* noalias sret %agg.result, i64 %h0, %class.scheme_key* %k0, %class.scheme_value* %v0, i64 %h1, %class.scheme_key* %k1, %class.scheme_value* %v1) #0 comdat align 2 {
  %1 = alloca i64, align 8
  %2 = alloca %class.scheme_key*, align 8
  %3 = alloca %class.scheme_value*, align 8
  %4 = alloca i64, align 8
  %5 = alloca %class.scheme_key*, align 8
  %6 = alloca %class.scheme_value*, align 8
  %h0piece = alloca i32, align 4
  %h1piece = alloca i32, align 4
  %childkv = alloca %class.KV.4, align 8
  %node = alloca %class.KV.4*, align 8
  %node1 = alloca %class.KV.4*, align 8
  store i64 %h0, i64* %1, align 8
  store %class.scheme_key* %k0, %class.scheme_key** %2, align 8
  store %class.scheme_value* %v0, %class.scheme_value** %3, align 8
  store i64 %h1, i64* %4, align 8
  store %class.scheme_key* %k1, %class.scheme_key** %5, align 8
  store %class.scheme_value* %v1, %class.scheme_value** %6, align 8
  %7 = load i64, i64* %1, align 8
  %8 = and i64 %7, 63
  %9 = urem i64 %8, 63
  %10 = trunc i64 %9 to i32
  store i32 %10, i32* %h0piece, align 4
  %11 = load i64, i64* %4, align 8
  %12 = and i64 %11, 63
  %13 = urem i64 %12, 63
  %14 = trunc i64 %13 to i32
  store i32 %14, i32* %h1piece, align 4
  %15 = load i32, i32* %h0piece, align 4
  %16 = load i32, i32* %h1piece, align 4
  %17 = icmp eq i32 %15, %16
  br i1 %17, label %18, label %39

; <label>:18                                      ; preds = %0
  %19 = load i64, i64* %1, align 8
  %20 = lshr i64 %19, 6
  %21 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %22 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  %23 = load i64, i64* %4, align 8
  %24 = lshr i64 %23, 6
  %25 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %26 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.4* sret %childkv, i64 %20, %class.scheme_key* %21, %class.scheme_value* %22, i64 %24, %class.scheme_key* %25, %class.scheme_value* %26)
  %27 = call noalias i8* @GC_malloc(i64 16)
  %28 = bitcast i8* %27 to %class.KV.4*
  store %class.KV.4* %28, %class.KV.4** %node, align 8
  %29 = load %class.KV.4*, %class.KV.4** %node, align 8
  %30 = getelementptr inbounds %class.KV.4, %class.KV.4* %29, i64 0
  %31 = bitcast %class.KV.4* %30 to i8*
  %32 = bitcast i8* %31 to %class.KV.4*
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EEC2ERKS2_(%class.KV.4* %32, %class.KV.4* dereferenceable(16) %childkv)
  %33 = load i32, i32* %h0piece, align 4
  %34 = zext i32 %33 to i64
  %35 = shl i64 1, %34
  %36 = shl i64 %35, 1
  %37 = or i64 %36, 1
  %38 = load %class.KV.4*, %class.KV.4** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EEC2EmPKS_IS0_S1_Lj5EE(%class.KV.3* %agg.result, i64 %37, %class.KV.4* %38)
  br label %82

; <label>:39                                      ; preds = %0
  %40 = call noalias i8* @GC_malloc(i64 32)
  %41 = bitcast i8* %40 to %class.KV.4*
  store %class.KV.4* %41, %class.KV.4** %node1, align 8
  %42 = load i32, i32* %h1piece, align 4
  %43 = load i32, i32* %h0piece, align 4
  %44 = icmp ult i32 %42, %43
  br i1 %44, label %45, label %58

; <label>:45                                      ; preds = %39
  %46 = load %class.KV.4*, %class.KV.4** %node1, align 8
  %47 = getelementptr inbounds %class.KV.4, %class.KV.4* %46, i64 0
  %48 = bitcast %class.KV.4* %47 to i8*
  %49 = bitcast i8* %48 to %class.KV.4*
  %50 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %51 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EEC2EPKS0_PKS1_(%class.KV.4* %49, %class.scheme_key* %50, %class.scheme_value* %51)
  %52 = load %class.KV.4*, %class.KV.4** %node1, align 8
  %53 = getelementptr inbounds %class.KV.4, %class.KV.4* %52, i64 1
  %54 = bitcast %class.KV.4* %53 to i8*
  %55 = bitcast i8* %54 to %class.KV.4*
  %56 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %57 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EEC2EPKS0_PKS1_(%class.KV.4* %55, %class.scheme_key* %56, %class.scheme_value* %57)
  br label %71

; <label>:58                                      ; preds = %39
  %59 = load %class.KV.4*, %class.KV.4** %node1, align 8
  %60 = getelementptr inbounds %class.KV.4, %class.KV.4* %59, i64 0
  %61 = bitcast %class.KV.4* %60 to i8*
  %62 = bitcast i8* %61 to %class.KV.4*
  %63 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %64 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EEC2EPKS0_PKS1_(%class.KV.4* %62, %class.scheme_key* %63, %class.scheme_value* %64)
  %65 = load %class.KV.4*, %class.KV.4** %node1, align 8
  %66 = getelementptr inbounds %class.KV.4, %class.KV.4* %65, i64 1
  %67 = bitcast %class.KV.4* %66 to i8*
  %68 = bitcast i8* %67 to %class.KV.4*
  %69 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %70 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EEC2EPKS0_PKS1_(%class.KV.4* %68, %class.scheme_key* %69, %class.scheme_value* %70)
  br label %71

; <label>:71                                      ; preds = %58, %45
  %72 = load i32, i32* %h0piece, align 4
  %73 = zext i32 %72 to i64
  %74 = shl i64 1, %73
  %75 = load i32, i32* %h1piece, align 4
  %76 = zext i32 %75 to i64
  %77 = shl i64 1, %76
  %78 = or i64 %74, %77
  %79 = shl i64 %78, 1
  %80 = or i64 %79, 1
  %81 = load %class.KV.4*, %class.KV.4** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EEC2EmPKS_IS0_S1_Lj5EE(%class.KV.3* %agg.result, i64 %80, %class.KV.4* %81)
  br label %82

; <label>:82                                      ; preds = %71, %18
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj4EEC2ERKS2_(%class.KV.3* %this, %class.KV.3* dereferenceable(16) %o) unnamed_addr #5 comdat align 2 {
  %1 = alloca %class.KV.3*, align 8
  %2 = alloca %class.KV.3*, align 8
  store %class.KV.3* %this, %class.KV.3** %1, align 8
  store %class.KV.3* %o, %class.KV.3** %2, align 8
  %3 = load %class.KV.3*, %class.KV.3** %1, align 8
  %4 = getelementptr inbounds %class.KV.3, %class.KV.3* %3, i32 0, i32 0
  %5 = load %class.KV.3*, %class.KV.3** %2, align 8
  %6 = getelementptr inbounds %class.KV.3, %class.KV.3* %5, i32 0, i32 0
  %7 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Key"* %4 to i8*
  %8 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Key"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 8, i32 8, i1 false)
  %9 = getelementptr inbounds %class.KV.3, %class.KV.3* %3, i32 0, i32 1
  %10 = load %class.KV.3*, %class.KV.3** %2, align 8
  %11 = getelementptr inbounds %class.KV.3, %class.KV.3* %10, i32 0, i32 1
  %12 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Val"* %9 to i8*
  %13 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Val"* %11 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %12, i8* %13, i64 8, i32 8, i1 false)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj3EEC2EmPKS_IS0_S1_Lj4EE(%class.KV.2* %this, i64 %bm, %class.KV.3* %kv) unnamed_addr #0 comdat align 2 {
  %1 = alloca %class.KV.2*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.KV.3*, align 8
  store %class.KV.2* %this, %class.KV.2** %1, align 8
  store i64 %bm, i64* %2, align 8
  store %class.KV.3* %kv, %class.KV.3** %3, align 8
  %4 = load %class.KV.2*, %class.KV.2** %1, align 8
  %5 = getelementptr inbounds %class.KV.2, %class.KV.2* %4, i32 0, i32 0
  %6 = load i64, i64* %2, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EE3KeyC2Em(%"union.KV<scheme_key, scheme_value, 3>::Key"* %5, i64 %6)
  %7 = getelementptr inbounds %class.KV.2, %class.KV.2* %4, i32 0, i32 1
  %8 = load %class.KV.3*, %class.KV.3** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EE3ValC2EPKS_IS0_S1_Lj4EE(%"union.KV<scheme_key, scheme_value, 3>::Val"* %7, %class.KV.3* %8)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj4EEC2EPKS0_PKS1_(%class.KV.3* %this, %class.scheme_key* %key, %class.scheme_value* %val) unnamed_addr #0 comdat align 2 {
  %1 = alloca %class.KV.3*, align 8
  %2 = alloca %class.scheme_key*, align 8
  %3 = alloca %class.scheme_value*, align 8
  store %class.KV.3* %this, %class.KV.3** %1, align 8
  store %class.scheme_key* %key, %class.scheme_key** %2, align 8
  store %class.scheme_value* %val, %class.scheme_value** %3, align 8
  %4 = load %class.KV.3*, %class.KV.3** %1, align 8
  %5 = getelementptr inbounds %class.KV.3, %class.KV.3* %4, i32 0, i32 0
  %6 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EE3KeyC2EPKS0_(%"union.KV<scheme_key, scheme_value, 4>::Key"* %5, %class.scheme_key* %6)
  %7 = getelementptr inbounds %class.KV.3, %class.KV.3* %4, i32 0, i32 1
  %8 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EE3ValC2EPKS1_(%"union.KV<scheme_key, scheme_value, 4>::Val"* %7, %class.scheme_value* %8)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj5EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.4* noalias sret %agg.result, i64 %h0, %class.scheme_key* %k0, %class.scheme_value* %v0, i64 %h1, %class.scheme_key* %k1, %class.scheme_value* %v1) #0 comdat align 2 {
  %1 = alloca i64, align 8
  %2 = alloca %class.scheme_key*, align 8
  %3 = alloca %class.scheme_value*, align 8
  %4 = alloca i64, align 8
  %5 = alloca %class.scheme_key*, align 8
  %6 = alloca %class.scheme_value*, align 8
  %h0piece = alloca i32, align 4
  %h1piece = alloca i32, align 4
  %childkv = alloca %class.KV.5, align 8
  %node = alloca %class.KV.5*, align 8
  %node1 = alloca %class.KV.5*, align 8
  store i64 %h0, i64* %1, align 8
  store %class.scheme_key* %k0, %class.scheme_key** %2, align 8
  store %class.scheme_value* %v0, %class.scheme_value** %3, align 8
  store i64 %h1, i64* %4, align 8
  store %class.scheme_key* %k1, %class.scheme_key** %5, align 8
  store %class.scheme_value* %v1, %class.scheme_value** %6, align 8
  %7 = load i64, i64* %1, align 8
  %8 = and i64 %7, 63
  %9 = urem i64 %8, 63
  %10 = trunc i64 %9 to i32
  store i32 %10, i32* %h0piece, align 4
  %11 = load i64, i64* %4, align 8
  %12 = and i64 %11, 63
  %13 = urem i64 %12, 63
  %14 = trunc i64 %13 to i32
  store i32 %14, i32* %h1piece, align 4
  %15 = load i32, i32* %h0piece, align 4
  %16 = load i32, i32* %h1piece, align 4
  %17 = icmp eq i32 %15, %16
  br i1 %17, label %18, label %39

; <label>:18                                      ; preds = %0
  %19 = load i64, i64* %1, align 8
  %20 = lshr i64 %19, 6
  %21 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %22 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  %23 = load i64, i64* %4, align 8
  %24 = lshr i64 %23, 6
  %25 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %26 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.5* sret %childkv, i64 %20, %class.scheme_key* %21, %class.scheme_value* %22, i64 %24, %class.scheme_key* %25, %class.scheme_value* %26)
  %27 = call noalias i8* @GC_malloc(i64 16)
  %28 = bitcast i8* %27 to %class.KV.5*
  store %class.KV.5* %28, %class.KV.5** %node, align 8
  %29 = load %class.KV.5*, %class.KV.5** %node, align 8
  %30 = getelementptr inbounds %class.KV.5, %class.KV.5* %29, i64 0
  %31 = bitcast %class.KV.5* %30 to i8*
  %32 = bitcast i8* %31 to %class.KV.5*
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EEC2ERKS2_(%class.KV.5* %32, %class.KV.5* dereferenceable(16) %childkv)
  %33 = load i32, i32* %h0piece, align 4
  %34 = zext i32 %33 to i64
  %35 = shl i64 1, %34
  %36 = shl i64 %35, 1
  %37 = or i64 %36, 1
  %38 = load %class.KV.5*, %class.KV.5** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EEC2EmPKS_IS0_S1_Lj6EE(%class.KV.4* %agg.result, i64 %37, %class.KV.5* %38)
  br label %82

; <label>:39                                      ; preds = %0
  %40 = call noalias i8* @GC_malloc(i64 32)
  %41 = bitcast i8* %40 to %class.KV.5*
  store %class.KV.5* %41, %class.KV.5** %node1, align 8
  %42 = load i32, i32* %h1piece, align 4
  %43 = load i32, i32* %h0piece, align 4
  %44 = icmp ult i32 %42, %43
  br i1 %44, label %45, label %58

; <label>:45                                      ; preds = %39
  %46 = load %class.KV.5*, %class.KV.5** %node1, align 8
  %47 = getelementptr inbounds %class.KV.5, %class.KV.5* %46, i64 0
  %48 = bitcast %class.KV.5* %47 to i8*
  %49 = bitcast i8* %48 to %class.KV.5*
  %50 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %51 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EEC2EPKS0_PKS1_(%class.KV.5* %49, %class.scheme_key* %50, %class.scheme_value* %51)
  %52 = load %class.KV.5*, %class.KV.5** %node1, align 8
  %53 = getelementptr inbounds %class.KV.5, %class.KV.5* %52, i64 1
  %54 = bitcast %class.KV.5* %53 to i8*
  %55 = bitcast i8* %54 to %class.KV.5*
  %56 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %57 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EEC2EPKS0_PKS1_(%class.KV.5* %55, %class.scheme_key* %56, %class.scheme_value* %57)
  br label %71

; <label>:58                                      ; preds = %39
  %59 = load %class.KV.5*, %class.KV.5** %node1, align 8
  %60 = getelementptr inbounds %class.KV.5, %class.KV.5* %59, i64 0
  %61 = bitcast %class.KV.5* %60 to i8*
  %62 = bitcast i8* %61 to %class.KV.5*
  %63 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %64 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EEC2EPKS0_PKS1_(%class.KV.5* %62, %class.scheme_key* %63, %class.scheme_value* %64)
  %65 = load %class.KV.5*, %class.KV.5** %node1, align 8
  %66 = getelementptr inbounds %class.KV.5, %class.KV.5* %65, i64 1
  %67 = bitcast %class.KV.5* %66 to i8*
  %68 = bitcast i8* %67 to %class.KV.5*
  %69 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %70 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EEC2EPKS0_PKS1_(%class.KV.5* %68, %class.scheme_key* %69, %class.scheme_value* %70)
  br label %71

; <label>:71                                      ; preds = %58, %45
  %72 = load i32, i32* %h0piece, align 4
  %73 = zext i32 %72 to i64
  %74 = shl i64 1, %73
  %75 = load i32, i32* %h1piece, align 4
  %76 = zext i32 %75 to i64
  %77 = shl i64 1, %76
  %78 = or i64 %74, %77
  %79 = shl i64 %78, 1
  %80 = or i64 %79, 1
  %81 = load %class.KV.5*, %class.KV.5** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EEC2EmPKS_IS0_S1_Lj6EE(%class.KV.4* %agg.result, i64 %80, %class.KV.5* %81)
  br label %82

; <label>:82                                      ; preds = %71, %18
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj5EEC2ERKS2_(%class.KV.4* %this, %class.KV.4* dereferenceable(16) %o) unnamed_addr #5 comdat align 2 {
  %1 = alloca %class.KV.4*, align 8
  %2 = alloca %class.KV.4*, align 8
  store %class.KV.4* %this, %class.KV.4** %1, align 8
  store %class.KV.4* %o, %class.KV.4** %2, align 8
  %3 = load %class.KV.4*, %class.KV.4** %1, align 8
  %4 = getelementptr inbounds %class.KV.4, %class.KV.4* %3, i32 0, i32 0
  %5 = load %class.KV.4*, %class.KV.4** %2, align 8
  %6 = getelementptr inbounds %class.KV.4, %class.KV.4* %5, i32 0, i32 0
  %7 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Key"* %4 to i8*
  %8 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Key"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 8, i32 8, i1 false)
  %9 = getelementptr inbounds %class.KV.4, %class.KV.4* %3, i32 0, i32 1
  %10 = load %class.KV.4*, %class.KV.4** %2, align 8
  %11 = getelementptr inbounds %class.KV.4, %class.KV.4* %10, i32 0, i32 1
  %12 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Val"* %9 to i8*
  %13 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Val"* %11 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %12, i8* %13, i64 8, i32 8, i1 false)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj4EEC2EmPKS_IS0_S1_Lj5EE(%class.KV.3* %this, i64 %bm, %class.KV.4* %kv) unnamed_addr #0 comdat align 2 {
  %1 = alloca %class.KV.3*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.KV.4*, align 8
  store %class.KV.3* %this, %class.KV.3** %1, align 8
  store i64 %bm, i64* %2, align 8
  store %class.KV.4* %kv, %class.KV.4** %3, align 8
  %4 = load %class.KV.3*, %class.KV.3** %1, align 8
  %5 = getelementptr inbounds %class.KV.3, %class.KV.3* %4, i32 0, i32 0
  %6 = load i64, i64* %2, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EE3KeyC2Em(%"union.KV<scheme_key, scheme_value, 4>::Key"* %5, i64 %6)
  %7 = getelementptr inbounds %class.KV.3, %class.KV.3* %4, i32 0, i32 1
  %8 = load %class.KV.4*, %class.KV.4** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EE3ValC2EPKS_IS0_S1_Lj5EE(%"union.KV<scheme_key, scheme_value, 4>::Val"* %7, %class.KV.4* %8)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj5EEC2EPKS0_PKS1_(%class.KV.4* %this, %class.scheme_key* %key, %class.scheme_value* %val) unnamed_addr #0 comdat align 2 {
  %1 = alloca %class.KV.4*, align 8
  %2 = alloca %class.scheme_key*, align 8
  %3 = alloca %class.scheme_value*, align 8
  store %class.KV.4* %this, %class.KV.4** %1, align 8
  store %class.scheme_key* %key, %class.scheme_key** %2, align 8
  store %class.scheme_value* %val, %class.scheme_value** %3, align 8
  %4 = load %class.KV.4*, %class.KV.4** %1, align 8
  %5 = getelementptr inbounds %class.KV.4, %class.KV.4* %4, i32 0, i32 0
  %6 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EE3KeyC2EPKS0_(%"union.KV<scheme_key, scheme_value, 5>::Key"* %5, %class.scheme_key* %6)
  %7 = getelementptr inbounds %class.KV.4, %class.KV.4* %4, i32 0, i32 1
  %8 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EE3ValC2EPKS1_(%"union.KV<scheme_key, scheme_value, 5>::Val"* %7, %class.scheme_value* %8)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj6EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.5* noalias sret %agg.result, i64 %h0, %class.scheme_key* %k0, %class.scheme_value* %v0, i64 %h1, %class.scheme_key* %k1, %class.scheme_value* %v1) #0 comdat align 2 {
  %1 = alloca i64, align 8
  %2 = alloca %class.scheme_key*, align 8
  %3 = alloca %class.scheme_value*, align 8
  %4 = alloca i64, align 8
  %5 = alloca %class.scheme_key*, align 8
  %6 = alloca %class.scheme_value*, align 8
  %h0piece = alloca i32, align 4
  %h1piece = alloca i32, align 4
  %childkv = alloca %class.KV.6, align 8
  %node = alloca %class.KV.6*, align 8
  %node1 = alloca %class.KV.6*, align 8
  store i64 %h0, i64* %1, align 8
  store %class.scheme_key* %k0, %class.scheme_key** %2, align 8
  store %class.scheme_value* %v0, %class.scheme_value** %3, align 8
  store i64 %h1, i64* %4, align 8
  store %class.scheme_key* %k1, %class.scheme_key** %5, align 8
  store %class.scheme_value* %v1, %class.scheme_value** %6, align 8
  %7 = load i64, i64* %1, align 8
  %8 = and i64 %7, 63
  %9 = urem i64 %8, 63
  %10 = trunc i64 %9 to i32
  store i32 %10, i32* %h0piece, align 4
  %11 = load i64, i64* %4, align 8
  %12 = and i64 %11, 63
  %13 = urem i64 %12, 63
  %14 = trunc i64 %13 to i32
  store i32 %14, i32* %h1piece, align 4
  %15 = load i32, i32* %h0piece, align 4
  %16 = load i32, i32* %h1piece, align 4
  %17 = icmp eq i32 %15, %16
  br i1 %17, label %18, label %39

; <label>:18                                      ; preds = %0
  %19 = load i64, i64* %1, align 8
  %20 = lshr i64 %19, 6
  %21 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %22 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  %23 = load i64, i64* %4, align 8
  %24 = lshr i64 %23, 6
  %25 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %26 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.6* sret %childkv, i64 %20, %class.scheme_key* %21, %class.scheme_value* %22, i64 %24, %class.scheme_key* %25, %class.scheme_value* %26)
  %27 = call noalias i8* @GC_malloc(i64 16)
  %28 = bitcast i8* %27 to %class.KV.6*
  store %class.KV.6* %28, %class.KV.6** %node, align 8
  %29 = load %class.KV.6*, %class.KV.6** %node, align 8
  %30 = getelementptr inbounds %class.KV.6, %class.KV.6* %29, i64 0
  %31 = bitcast %class.KV.6* %30 to i8*
  %32 = bitcast i8* %31 to %class.KV.6*
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EEC2ERKS2_(%class.KV.6* %32, %class.KV.6* dereferenceable(16) %childkv)
  %33 = load i32, i32* %h0piece, align 4
  %34 = zext i32 %33 to i64
  %35 = shl i64 1, %34
  %36 = shl i64 %35, 1
  %37 = or i64 %36, 1
  %38 = load %class.KV.6*, %class.KV.6** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EEC2EmPKS_IS0_S1_Lj7EE(%class.KV.5* %agg.result, i64 %37, %class.KV.6* %38)
  br label %82

; <label>:39                                      ; preds = %0
  %40 = call noalias i8* @GC_malloc(i64 32)
  %41 = bitcast i8* %40 to %class.KV.6*
  store %class.KV.6* %41, %class.KV.6** %node1, align 8
  %42 = load i32, i32* %h1piece, align 4
  %43 = load i32, i32* %h0piece, align 4
  %44 = icmp ult i32 %42, %43
  br i1 %44, label %45, label %58

; <label>:45                                      ; preds = %39
  %46 = load %class.KV.6*, %class.KV.6** %node1, align 8
  %47 = getelementptr inbounds %class.KV.6, %class.KV.6* %46, i64 0
  %48 = bitcast %class.KV.6* %47 to i8*
  %49 = bitcast i8* %48 to %class.KV.6*
  %50 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %51 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EEC2EPKS0_PKS1_(%class.KV.6* %49, %class.scheme_key* %50, %class.scheme_value* %51)
  %52 = load %class.KV.6*, %class.KV.6** %node1, align 8
  %53 = getelementptr inbounds %class.KV.6, %class.KV.6* %52, i64 1
  %54 = bitcast %class.KV.6* %53 to i8*
  %55 = bitcast i8* %54 to %class.KV.6*
  %56 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %57 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EEC2EPKS0_PKS1_(%class.KV.6* %55, %class.scheme_key* %56, %class.scheme_value* %57)
  br label %71

; <label>:58                                      ; preds = %39
  %59 = load %class.KV.6*, %class.KV.6** %node1, align 8
  %60 = getelementptr inbounds %class.KV.6, %class.KV.6* %59, i64 0
  %61 = bitcast %class.KV.6* %60 to i8*
  %62 = bitcast i8* %61 to %class.KV.6*
  %63 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %64 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EEC2EPKS0_PKS1_(%class.KV.6* %62, %class.scheme_key* %63, %class.scheme_value* %64)
  %65 = load %class.KV.6*, %class.KV.6** %node1, align 8
  %66 = getelementptr inbounds %class.KV.6, %class.KV.6* %65, i64 1
  %67 = bitcast %class.KV.6* %66 to i8*
  %68 = bitcast i8* %67 to %class.KV.6*
  %69 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %70 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EEC2EPKS0_PKS1_(%class.KV.6* %68, %class.scheme_key* %69, %class.scheme_value* %70)
  br label %71

; <label>:71                                      ; preds = %58, %45
  %72 = load i32, i32* %h0piece, align 4
  %73 = zext i32 %72 to i64
  %74 = shl i64 1, %73
  %75 = load i32, i32* %h1piece, align 4
  %76 = zext i32 %75 to i64
  %77 = shl i64 1, %76
  %78 = or i64 %74, %77
  %79 = shl i64 %78, 1
  %80 = or i64 %79, 1
  %81 = load %class.KV.6*, %class.KV.6** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EEC2EmPKS_IS0_S1_Lj7EE(%class.KV.5* %agg.result, i64 %80, %class.KV.6* %81)
  br label %82

; <label>:82                                      ; preds = %71, %18
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj6EEC2ERKS2_(%class.KV.5* %this, %class.KV.5* dereferenceable(16) %o) unnamed_addr #5 comdat align 2 {
  %1 = alloca %class.KV.5*, align 8
  %2 = alloca %class.KV.5*, align 8
  store %class.KV.5* %this, %class.KV.5** %1, align 8
  store %class.KV.5* %o, %class.KV.5** %2, align 8
  %3 = load %class.KV.5*, %class.KV.5** %1, align 8
  %4 = getelementptr inbounds %class.KV.5, %class.KV.5* %3, i32 0, i32 0
  %5 = load %class.KV.5*, %class.KV.5** %2, align 8
  %6 = getelementptr inbounds %class.KV.5, %class.KV.5* %5, i32 0, i32 0
  %7 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Key"* %4 to i8*
  %8 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Key"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 8, i32 8, i1 false)
  %9 = getelementptr inbounds %class.KV.5, %class.KV.5* %3, i32 0, i32 1
  %10 = load %class.KV.5*, %class.KV.5** %2, align 8
  %11 = getelementptr inbounds %class.KV.5, %class.KV.5* %10, i32 0, i32 1
  %12 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Val"* %9 to i8*
  %13 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Val"* %11 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %12, i8* %13, i64 8, i32 8, i1 false)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj5EEC2EmPKS_IS0_S1_Lj6EE(%class.KV.4* %this, i64 %bm, %class.KV.5* %kv) unnamed_addr #0 comdat align 2 {
  %1 = alloca %class.KV.4*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.KV.5*, align 8
  store %class.KV.4* %this, %class.KV.4** %1, align 8
  store i64 %bm, i64* %2, align 8
  store %class.KV.5* %kv, %class.KV.5** %3, align 8
  %4 = load %class.KV.4*, %class.KV.4** %1, align 8
  %5 = getelementptr inbounds %class.KV.4, %class.KV.4* %4, i32 0, i32 0
  %6 = load i64, i64* %2, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EE3KeyC2Em(%"union.KV<scheme_key, scheme_value, 5>::Key"* %5, i64 %6)
  %7 = getelementptr inbounds %class.KV.4, %class.KV.4* %4, i32 0, i32 1
  %8 = load %class.KV.5*, %class.KV.5** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EE3ValC2EPKS_IS0_S1_Lj6EE(%"union.KV<scheme_key, scheme_value, 5>::Val"* %7, %class.KV.5* %8)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj6EEC2EPKS0_PKS1_(%class.KV.5* %this, %class.scheme_key* %key, %class.scheme_value* %val) unnamed_addr #0 comdat align 2 {
  %1 = alloca %class.KV.5*, align 8
  %2 = alloca %class.scheme_key*, align 8
  %3 = alloca %class.scheme_value*, align 8
  store %class.KV.5* %this, %class.KV.5** %1, align 8
  store %class.scheme_key* %key, %class.scheme_key** %2, align 8
  store %class.scheme_value* %val, %class.scheme_value** %3, align 8
  %4 = load %class.KV.5*, %class.KV.5** %1, align 8
  %5 = getelementptr inbounds %class.KV.5, %class.KV.5* %4, i32 0, i32 0
  %6 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EE3KeyC2EPKS0_(%"union.KV<scheme_key, scheme_value, 6>::Key"* %5, %class.scheme_key* %6)
  %7 = getelementptr inbounds %class.KV.5, %class.KV.5* %4, i32 0, i32 1
  %8 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EE3ValC2EPKS1_(%"union.KV<scheme_key, scheme_value, 6>::Val"* %7, %class.scheme_value* %8)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj7EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.6* noalias sret %agg.result, i64 %h0, %class.scheme_key* %k0, %class.scheme_value* %v0, i64 %h1, %class.scheme_key* %k1, %class.scheme_value* %v1) #0 comdat align 2 {
  %1 = alloca i64, align 8
  %2 = alloca %class.scheme_key*, align 8
  %3 = alloca %class.scheme_value*, align 8
  %4 = alloca i64, align 8
  %5 = alloca %class.scheme_key*, align 8
  %6 = alloca %class.scheme_value*, align 8
  %h0piece = alloca i32, align 4
  %h1piece = alloca i32, align 4
  %childkv = alloca %class.KV.7, align 8
  %node = alloca %class.KV.7*, align 8
  %node1 = alloca %class.KV.7*, align 8
  store i64 %h0, i64* %1, align 8
  store %class.scheme_key* %k0, %class.scheme_key** %2, align 8
  store %class.scheme_value* %v0, %class.scheme_value** %3, align 8
  store i64 %h1, i64* %4, align 8
  store %class.scheme_key* %k1, %class.scheme_key** %5, align 8
  store %class.scheme_value* %v1, %class.scheme_value** %6, align 8
  %7 = load i64, i64* %1, align 8
  %8 = and i64 %7, 63
  %9 = urem i64 %8, 63
  %10 = trunc i64 %9 to i32
  store i32 %10, i32* %h0piece, align 4
  %11 = load i64, i64* %4, align 8
  %12 = and i64 %11, 63
  %13 = urem i64 %12, 63
  %14 = trunc i64 %13 to i32
  store i32 %14, i32* %h1piece, align 4
  %15 = load i32, i32* %h0piece, align 4
  %16 = load i32, i32* %h1piece, align 4
  %17 = icmp eq i32 %15, %16
  br i1 %17, label %18, label %39

; <label>:18                                      ; preds = %0
  %19 = load i64, i64* %1, align 8
  %20 = lshr i64 %19, 6
  %21 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %22 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  %23 = load i64, i64* %4, align 8
  %24 = lshr i64 %23, 6
  %25 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %26 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.7* sret %childkv, i64 %20, %class.scheme_key* %21, %class.scheme_value* %22, i64 %24, %class.scheme_key* %25, %class.scheme_value* %26)
  %27 = call noalias i8* @GC_malloc(i64 16)
  %28 = bitcast i8* %27 to %class.KV.7*
  store %class.KV.7* %28, %class.KV.7** %node, align 8
  %29 = load %class.KV.7*, %class.KV.7** %node, align 8
  %30 = getelementptr inbounds %class.KV.7, %class.KV.7* %29, i64 0
  %31 = bitcast %class.KV.7* %30 to i8*
  %32 = bitcast i8* %31 to %class.KV.7*
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EEC2ERKS2_(%class.KV.7* %32, %class.KV.7* dereferenceable(16) %childkv)
  %33 = load i32, i32* %h0piece, align 4
  %34 = zext i32 %33 to i64
  %35 = shl i64 1, %34
  %36 = shl i64 %35, 1
  %37 = or i64 %36, 1
  %38 = load %class.KV.7*, %class.KV.7** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EEC2EmPKS_IS0_S1_Lj8EE(%class.KV.6* %agg.result, i64 %37, %class.KV.7* %38)
  br label %82

; <label>:39                                      ; preds = %0
  %40 = call noalias i8* @GC_malloc(i64 32)
  %41 = bitcast i8* %40 to %class.KV.7*
  store %class.KV.7* %41, %class.KV.7** %node1, align 8
  %42 = load i32, i32* %h1piece, align 4
  %43 = load i32, i32* %h0piece, align 4
  %44 = icmp ult i32 %42, %43
  br i1 %44, label %45, label %58

; <label>:45                                      ; preds = %39
  %46 = load %class.KV.7*, %class.KV.7** %node1, align 8
  %47 = getelementptr inbounds %class.KV.7, %class.KV.7* %46, i64 0
  %48 = bitcast %class.KV.7* %47 to i8*
  %49 = bitcast i8* %48 to %class.KV.7*
  %50 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %51 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EEC2EPKS0_PKS1_(%class.KV.7* %49, %class.scheme_key* %50, %class.scheme_value* %51)
  %52 = load %class.KV.7*, %class.KV.7** %node1, align 8
  %53 = getelementptr inbounds %class.KV.7, %class.KV.7* %52, i64 1
  %54 = bitcast %class.KV.7* %53 to i8*
  %55 = bitcast i8* %54 to %class.KV.7*
  %56 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %57 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EEC2EPKS0_PKS1_(%class.KV.7* %55, %class.scheme_key* %56, %class.scheme_value* %57)
  br label %71

; <label>:58                                      ; preds = %39
  %59 = load %class.KV.7*, %class.KV.7** %node1, align 8
  %60 = getelementptr inbounds %class.KV.7, %class.KV.7* %59, i64 0
  %61 = bitcast %class.KV.7* %60 to i8*
  %62 = bitcast i8* %61 to %class.KV.7*
  %63 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %64 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EEC2EPKS0_PKS1_(%class.KV.7* %62, %class.scheme_key* %63, %class.scheme_value* %64)
  %65 = load %class.KV.7*, %class.KV.7** %node1, align 8
  %66 = getelementptr inbounds %class.KV.7, %class.KV.7* %65, i64 1
  %67 = bitcast %class.KV.7* %66 to i8*
  %68 = bitcast i8* %67 to %class.KV.7*
  %69 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %70 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EEC2EPKS0_PKS1_(%class.KV.7* %68, %class.scheme_key* %69, %class.scheme_value* %70)
  br label %71

; <label>:71                                      ; preds = %58, %45
  %72 = load i32, i32* %h0piece, align 4
  %73 = zext i32 %72 to i64
  %74 = shl i64 1, %73
  %75 = load i32, i32* %h1piece, align 4
  %76 = zext i32 %75 to i64
  %77 = shl i64 1, %76
  %78 = or i64 %74, %77
  %79 = shl i64 %78, 1
  %80 = or i64 %79, 1
  %81 = load %class.KV.7*, %class.KV.7** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EEC2EmPKS_IS0_S1_Lj8EE(%class.KV.6* %agg.result, i64 %80, %class.KV.7* %81)
  br label %82

; <label>:82                                      ; preds = %71, %18
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj7EEC2ERKS2_(%class.KV.6* %this, %class.KV.6* dereferenceable(16) %o) unnamed_addr #5 comdat align 2 {
  %1 = alloca %class.KV.6*, align 8
  %2 = alloca %class.KV.6*, align 8
  store %class.KV.6* %this, %class.KV.6** %1, align 8
  store %class.KV.6* %o, %class.KV.6** %2, align 8
  %3 = load %class.KV.6*, %class.KV.6** %1, align 8
  %4 = getelementptr inbounds %class.KV.6, %class.KV.6* %3, i32 0, i32 0
  %5 = load %class.KV.6*, %class.KV.6** %2, align 8
  %6 = getelementptr inbounds %class.KV.6, %class.KV.6* %5, i32 0, i32 0
  %7 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Key"* %4 to i8*
  %8 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Key"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 8, i32 8, i1 false)
  %9 = getelementptr inbounds %class.KV.6, %class.KV.6* %3, i32 0, i32 1
  %10 = load %class.KV.6*, %class.KV.6** %2, align 8
  %11 = getelementptr inbounds %class.KV.6, %class.KV.6* %10, i32 0, i32 1
  %12 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Val"* %9 to i8*
  %13 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Val"* %11 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %12, i8* %13, i64 8, i32 8, i1 false)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj6EEC2EmPKS_IS0_S1_Lj7EE(%class.KV.5* %this, i64 %bm, %class.KV.6* %kv) unnamed_addr #0 comdat align 2 {
  %1 = alloca %class.KV.5*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.KV.6*, align 8
  store %class.KV.5* %this, %class.KV.5** %1, align 8
  store i64 %bm, i64* %2, align 8
  store %class.KV.6* %kv, %class.KV.6** %3, align 8
  %4 = load %class.KV.5*, %class.KV.5** %1, align 8
  %5 = getelementptr inbounds %class.KV.5, %class.KV.5* %4, i32 0, i32 0
  %6 = load i64, i64* %2, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EE3KeyC2Em(%"union.KV<scheme_key, scheme_value, 6>::Key"* %5, i64 %6)
  %7 = getelementptr inbounds %class.KV.5, %class.KV.5* %4, i32 0, i32 1
  %8 = load %class.KV.6*, %class.KV.6** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EE3ValC2EPKS_IS0_S1_Lj7EE(%"union.KV<scheme_key, scheme_value, 6>::Val"* %7, %class.KV.6* %8)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj7EEC2EPKS0_PKS1_(%class.KV.6* %this, %class.scheme_key* %key, %class.scheme_value* %val) unnamed_addr #0 comdat align 2 {
  %1 = alloca %class.KV.6*, align 8
  %2 = alloca %class.scheme_key*, align 8
  %3 = alloca %class.scheme_value*, align 8
  store %class.KV.6* %this, %class.KV.6** %1, align 8
  store %class.scheme_key* %key, %class.scheme_key** %2, align 8
  store %class.scheme_value* %val, %class.scheme_value** %3, align 8
  %4 = load %class.KV.6*, %class.KV.6** %1, align 8
  %5 = getelementptr inbounds %class.KV.6, %class.KV.6* %4, i32 0, i32 0
  %6 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EE3KeyC2EPKS0_(%"union.KV<scheme_key, scheme_value, 7>::Key"* %5, %class.scheme_key* %6)
  %7 = getelementptr inbounds %class.KV.6, %class.KV.6* %4, i32 0, i32 1
  %8 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EE3ValC2EPKS1_(%"union.KV<scheme_key, scheme_value, 7>::Val"* %7, %class.scheme_value* %8)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj8EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.7* noalias sret %agg.result, i64 %h0, %class.scheme_key* %k0, %class.scheme_value* %v0, i64 %h1, %class.scheme_key* %k1, %class.scheme_value* %v1) #0 comdat align 2 {
  %1 = alloca i64, align 8
  %2 = alloca %class.scheme_key*, align 8
  %3 = alloca %class.scheme_value*, align 8
  %4 = alloca i64, align 8
  %5 = alloca %class.scheme_key*, align 8
  %6 = alloca %class.scheme_value*, align 8
  %h0piece = alloca i32, align 4
  %h1piece = alloca i32, align 4
  %childkv = alloca %class.KV.8, align 8
  %node = alloca %class.KV.8*, align 8
  %node1 = alloca %class.KV.8*, align 8
  store i64 %h0, i64* %1, align 8
  store %class.scheme_key* %k0, %class.scheme_key** %2, align 8
  store %class.scheme_value* %v0, %class.scheme_value** %3, align 8
  store i64 %h1, i64* %4, align 8
  store %class.scheme_key* %k1, %class.scheme_key** %5, align 8
  store %class.scheme_value* %v1, %class.scheme_value** %6, align 8
  %7 = load i64, i64* %1, align 8
  %8 = and i64 %7, 63
  %9 = urem i64 %8, 63
  %10 = trunc i64 %9 to i32
  store i32 %10, i32* %h0piece, align 4
  %11 = load i64, i64* %4, align 8
  %12 = and i64 %11, 63
  %13 = urem i64 %12, 63
  %14 = trunc i64 %13 to i32
  store i32 %14, i32* %h1piece, align 4
  %15 = load i32, i32* %h0piece, align 4
  %16 = load i32, i32* %h1piece, align 4
  %17 = icmp eq i32 %15, %16
  br i1 %17, label %18, label %39

; <label>:18                                      ; preds = %0
  %19 = load i64, i64* %1, align 8
  %20 = lshr i64 %19, 6
  %21 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %22 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  %23 = load i64, i64* %4, align 8
  %24 = lshr i64 %23, 6
  %25 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %26 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.8* sret %childkv, i64 %20, %class.scheme_key* %21, %class.scheme_value* %22, i64 %24, %class.scheme_key* %25, %class.scheme_value* %26)
  %27 = call noalias i8* @GC_malloc(i64 16)
  %28 = bitcast i8* %27 to %class.KV.8*
  store %class.KV.8* %28, %class.KV.8** %node, align 8
  %29 = load %class.KV.8*, %class.KV.8** %node, align 8
  %30 = getelementptr inbounds %class.KV.8, %class.KV.8* %29, i64 0
  %31 = bitcast %class.KV.8* %30 to i8*
  %32 = bitcast i8* %31 to %class.KV.8*
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EEC2ERKS2_(%class.KV.8* %32, %class.KV.8* dereferenceable(16) %childkv)
  %33 = load i32, i32* %h0piece, align 4
  %34 = zext i32 %33 to i64
  %35 = shl i64 1, %34
  %36 = shl i64 %35, 1
  %37 = or i64 %36, 1
  %38 = load %class.KV.8*, %class.KV.8** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EEC2EmPKS_IS0_S1_Lj9EE(%class.KV.7* %agg.result, i64 %37, %class.KV.8* %38)
  br label %82

; <label>:39                                      ; preds = %0
  %40 = call noalias i8* @GC_malloc(i64 32)
  %41 = bitcast i8* %40 to %class.KV.8*
  store %class.KV.8* %41, %class.KV.8** %node1, align 8
  %42 = load i32, i32* %h1piece, align 4
  %43 = load i32, i32* %h0piece, align 4
  %44 = icmp ult i32 %42, %43
  br i1 %44, label %45, label %58

; <label>:45                                      ; preds = %39
  %46 = load %class.KV.8*, %class.KV.8** %node1, align 8
  %47 = getelementptr inbounds %class.KV.8, %class.KV.8* %46, i64 0
  %48 = bitcast %class.KV.8* %47 to i8*
  %49 = bitcast i8* %48 to %class.KV.8*
  %50 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %51 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EEC2EPKS0_PKS1_(%class.KV.8* %49, %class.scheme_key* %50, %class.scheme_value* %51)
  %52 = load %class.KV.8*, %class.KV.8** %node1, align 8
  %53 = getelementptr inbounds %class.KV.8, %class.KV.8* %52, i64 1
  %54 = bitcast %class.KV.8* %53 to i8*
  %55 = bitcast i8* %54 to %class.KV.8*
  %56 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %57 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EEC2EPKS0_PKS1_(%class.KV.8* %55, %class.scheme_key* %56, %class.scheme_value* %57)
  br label %71

; <label>:58                                      ; preds = %39
  %59 = load %class.KV.8*, %class.KV.8** %node1, align 8
  %60 = getelementptr inbounds %class.KV.8, %class.KV.8* %59, i64 0
  %61 = bitcast %class.KV.8* %60 to i8*
  %62 = bitcast i8* %61 to %class.KV.8*
  %63 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %64 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EEC2EPKS0_PKS1_(%class.KV.8* %62, %class.scheme_key* %63, %class.scheme_value* %64)
  %65 = load %class.KV.8*, %class.KV.8** %node1, align 8
  %66 = getelementptr inbounds %class.KV.8, %class.KV.8* %65, i64 1
  %67 = bitcast %class.KV.8* %66 to i8*
  %68 = bitcast i8* %67 to %class.KV.8*
  %69 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %70 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EEC2EPKS0_PKS1_(%class.KV.8* %68, %class.scheme_key* %69, %class.scheme_value* %70)
  br label %71

; <label>:71                                      ; preds = %58, %45
  %72 = load i32, i32* %h0piece, align 4
  %73 = zext i32 %72 to i64
  %74 = shl i64 1, %73
  %75 = load i32, i32* %h1piece, align 4
  %76 = zext i32 %75 to i64
  %77 = shl i64 1, %76
  %78 = or i64 %74, %77
  %79 = shl i64 %78, 1
  %80 = or i64 %79, 1
  %81 = load %class.KV.8*, %class.KV.8** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EEC2EmPKS_IS0_S1_Lj9EE(%class.KV.7* %agg.result, i64 %80, %class.KV.8* %81)
  br label %82

; <label>:82                                      ; preds = %71, %18
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj8EEC2ERKS2_(%class.KV.7* %this, %class.KV.7* dereferenceable(16) %o) unnamed_addr #5 comdat align 2 {
  %1 = alloca %class.KV.7*, align 8
  %2 = alloca %class.KV.7*, align 8
  store %class.KV.7* %this, %class.KV.7** %1, align 8
  store %class.KV.7* %o, %class.KV.7** %2, align 8
  %3 = load %class.KV.7*, %class.KV.7** %1, align 8
  %4 = getelementptr inbounds %class.KV.7, %class.KV.7* %3, i32 0, i32 0
  %5 = load %class.KV.7*, %class.KV.7** %2, align 8
  %6 = getelementptr inbounds %class.KV.7, %class.KV.7* %5, i32 0, i32 0
  %7 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Key"* %4 to i8*
  %8 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Key"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 8, i32 8, i1 false)
  %9 = getelementptr inbounds %class.KV.7, %class.KV.7* %3, i32 0, i32 1
  %10 = load %class.KV.7*, %class.KV.7** %2, align 8
  %11 = getelementptr inbounds %class.KV.7, %class.KV.7* %10, i32 0, i32 1
  %12 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Val"* %9 to i8*
  %13 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Val"* %11 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %12, i8* %13, i64 8, i32 8, i1 false)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj7EEC2EmPKS_IS0_S1_Lj8EE(%class.KV.6* %this, i64 %bm, %class.KV.7* %kv) unnamed_addr #0 comdat align 2 {
  %1 = alloca %class.KV.6*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.KV.7*, align 8
  store %class.KV.6* %this, %class.KV.6** %1, align 8
  store i64 %bm, i64* %2, align 8
  store %class.KV.7* %kv, %class.KV.7** %3, align 8
  %4 = load %class.KV.6*, %class.KV.6** %1, align 8
  %5 = getelementptr inbounds %class.KV.6, %class.KV.6* %4, i32 0, i32 0
  %6 = load i64, i64* %2, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EE3KeyC2Em(%"union.KV<scheme_key, scheme_value, 7>::Key"* %5, i64 %6)
  %7 = getelementptr inbounds %class.KV.6, %class.KV.6* %4, i32 0, i32 1
  %8 = load %class.KV.7*, %class.KV.7** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EE3ValC2EPKS_IS0_S1_Lj8EE(%"union.KV<scheme_key, scheme_value, 7>::Val"* %7, %class.KV.7* %8)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj8EEC2EPKS0_PKS1_(%class.KV.7* %this, %class.scheme_key* %key, %class.scheme_value* %val) unnamed_addr #0 comdat align 2 {
  %1 = alloca %class.KV.7*, align 8
  %2 = alloca %class.scheme_key*, align 8
  %3 = alloca %class.scheme_value*, align 8
  store %class.KV.7* %this, %class.KV.7** %1, align 8
  store %class.scheme_key* %key, %class.scheme_key** %2, align 8
  store %class.scheme_value* %val, %class.scheme_value** %3, align 8
  %4 = load %class.KV.7*, %class.KV.7** %1, align 8
  %5 = getelementptr inbounds %class.KV.7, %class.KV.7* %4, i32 0, i32 0
  %6 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EE3KeyC2EPKS0_(%"union.KV<scheme_key, scheme_value, 8>::Key"* %5, %class.scheme_key* %6)
  %7 = getelementptr inbounds %class.KV.7, %class.KV.7* %4, i32 0, i32 1
  %8 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EE3ValC2EPKS1_(%"union.KV<scheme_key, scheme_value, 8>::Val"* %7, %class.scheme_value* %8)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj9EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.8* noalias sret %agg.result, i64 %h0, %class.scheme_key* %k0, %class.scheme_value* %v0, i64 %h1, %class.scheme_key* %k1, %class.scheme_value* %v1) #0 comdat align 2 {
  %1 = alloca i64, align 8
  %2 = alloca %class.scheme_key*, align 8
  %3 = alloca %class.scheme_value*, align 8
  %4 = alloca i64, align 8
  %5 = alloca %class.scheme_key*, align 8
  %6 = alloca %class.scheme_value*, align 8
  %h0piece = alloca i32, align 4
  %h1piece = alloca i32, align 4
  %childkv = alloca %class.KV.9, align 8
  %node = alloca %class.KV.9*, align 8
  %node1 = alloca %class.KV.9*, align 8
  store i64 %h0, i64* %1, align 8
  store %class.scheme_key* %k0, %class.scheme_key** %2, align 8
  store %class.scheme_value* %v0, %class.scheme_value** %3, align 8
  store i64 %h1, i64* %4, align 8
  store %class.scheme_key* %k1, %class.scheme_key** %5, align 8
  store %class.scheme_value* %v1, %class.scheme_value** %6, align 8
  %7 = load i64, i64* %1, align 8
  %8 = and i64 %7, 63
  %9 = urem i64 %8, 63
  %10 = trunc i64 %9 to i32
  store i32 %10, i32* %h0piece, align 4
  %11 = load i64, i64* %4, align 8
  %12 = and i64 %11, 63
  %13 = urem i64 %12, 63
  %14 = trunc i64 %13 to i32
  store i32 %14, i32* %h1piece, align 4
  %15 = load i32, i32* %h0piece, align 4
  %16 = load i32, i32* %h1piece, align 4
  %17 = icmp eq i32 %15, %16
  br i1 %17, label %18, label %39

; <label>:18                                      ; preds = %0
  %19 = load i64, i64* %1, align 8
  %20 = lshr i64 %19, 6
  %21 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %22 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  %23 = load i64, i64* %4, align 8
  %24 = lshr i64 %23, 6
  %25 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %26 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj10EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.9* sret %childkv, i64 %20, %class.scheme_key* %21, %class.scheme_value* %22, i64 %24, %class.scheme_key* %25, %class.scheme_value* %26)
  %27 = call noalias i8* @GC_malloc(i64 16)
  %28 = bitcast i8* %27 to %class.KV.9*
  store %class.KV.9* %28, %class.KV.9** %node, align 8
  %29 = load %class.KV.9*, %class.KV.9** %node, align 8
  %30 = getelementptr inbounds %class.KV.9, %class.KV.9* %29, i64 0
  %31 = bitcast %class.KV.9* %30 to i8*
  %32 = bitcast i8* %31 to %class.KV.9*
  call void @_ZN2KVI10scheme_key12scheme_valueLj10EEC2ERKS2_(%class.KV.9* %32, %class.KV.9* dereferenceable(16) %childkv)
  %33 = load i32, i32* %h0piece, align 4
  %34 = zext i32 %33 to i64
  %35 = shl i64 1, %34
  %36 = shl i64 %35, 1
  %37 = or i64 %36, 1
  %38 = load %class.KV.9*, %class.KV.9** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EEC2EmPKS_IS0_S1_Lj10EE(%class.KV.8* %agg.result, i64 %37, %class.KV.9* %38)
  br label %82

; <label>:39                                      ; preds = %0
  %40 = call noalias i8* @GC_malloc(i64 32)
  %41 = bitcast i8* %40 to %class.KV.9*
  store %class.KV.9* %41, %class.KV.9** %node1, align 8
  %42 = load i32, i32* %h1piece, align 4
  %43 = load i32, i32* %h0piece, align 4
  %44 = icmp ult i32 %42, %43
  br i1 %44, label %45, label %58

; <label>:45                                      ; preds = %39
  %46 = load %class.KV.9*, %class.KV.9** %node1, align 8
  %47 = getelementptr inbounds %class.KV.9, %class.KV.9* %46, i64 0
  %48 = bitcast %class.KV.9* %47 to i8*
  %49 = bitcast i8* %48 to %class.KV.9*
  %50 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %51 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj10EEC2EPKS0_PKS1_(%class.KV.9* %49, %class.scheme_key* %50, %class.scheme_value* %51)
  %52 = load %class.KV.9*, %class.KV.9** %node1, align 8
  %53 = getelementptr inbounds %class.KV.9, %class.KV.9* %52, i64 1
  %54 = bitcast %class.KV.9* %53 to i8*
  %55 = bitcast i8* %54 to %class.KV.9*
  %56 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %57 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj10EEC2EPKS0_PKS1_(%class.KV.9* %55, %class.scheme_key* %56, %class.scheme_value* %57)
  br label %71

; <label>:58                                      ; preds = %39
  %59 = load %class.KV.9*, %class.KV.9** %node1, align 8
  %60 = getelementptr inbounds %class.KV.9, %class.KV.9* %59, i64 0
  %61 = bitcast %class.KV.9* %60 to i8*
  %62 = bitcast i8* %61 to %class.KV.9*
  %63 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %64 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj10EEC2EPKS0_PKS1_(%class.KV.9* %62, %class.scheme_key* %63, %class.scheme_value* %64)
  %65 = load %class.KV.9*, %class.KV.9** %node1, align 8
  %66 = getelementptr inbounds %class.KV.9, %class.KV.9* %65, i64 1
  %67 = bitcast %class.KV.9* %66 to i8*
  %68 = bitcast i8* %67 to %class.KV.9*
  %69 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %70 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj10EEC2EPKS0_PKS1_(%class.KV.9* %68, %class.scheme_key* %69, %class.scheme_value* %70)
  br label %71

; <label>:71                                      ; preds = %58, %45
  %72 = load i32, i32* %h0piece, align 4
  %73 = zext i32 %72 to i64
  %74 = shl i64 1, %73
  %75 = load i32, i32* %h1piece, align 4
  %76 = zext i32 %75 to i64
  %77 = shl i64 1, %76
  %78 = or i64 %74, %77
  %79 = shl i64 %78, 1
  %80 = or i64 %79, 1
  %81 = load %class.KV.9*, %class.KV.9** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EEC2EmPKS_IS0_S1_Lj10EE(%class.KV.8* %agg.result, i64 %80, %class.KV.9* %81)
  br label %82

; <label>:82                                      ; preds = %71, %18
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj9EEC2ERKS2_(%class.KV.8* %this, %class.KV.8* dereferenceable(16) %o) unnamed_addr #5 comdat align 2 {
  %1 = alloca %class.KV.8*, align 8
  %2 = alloca %class.KV.8*, align 8
  store %class.KV.8* %this, %class.KV.8** %1, align 8
  store %class.KV.8* %o, %class.KV.8** %2, align 8
  %3 = load %class.KV.8*, %class.KV.8** %1, align 8
  %4 = getelementptr inbounds %class.KV.8, %class.KV.8* %3, i32 0, i32 0
  %5 = load %class.KV.8*, %class.KV.8** %2, align 8
  %6 = getelementptr inbounds %class.KV.8, %class.KV.8* %5, i32 0, i32 0
  %7 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Key"* %4 to i8*
  %8 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Key"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 8, i32 8, i1 false)
  %9 = getelementptr inbounds %class.KV.8, %class.KV.8* %3, i32 0, i32 1
  %10 = load %class.KV.8*, %class.KV.8** %2, align 8
  %11 = getelementptr inbounds %class.KV.8, %class.KV.8* %10, i32 0, i32 1
  %12 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Val"* %9 to i8*
  %13 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Val"* %11 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %12, i8* %13, i64 8, i32 8, i1 false)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj8EEC2EmPKS_IS0_S1_Lj9EE(%class.KV.7* %this, i64 %bm, %class.KV.8* %kv) unnamed_addr #0 comdat align 2 {
  %1 = alloca %class.KV.7*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.KV.8*, align 8
  store %class.KV.7* %this, %class.KV.7** %1, align 8
  store i64 %bm, i64* %2, align 8
  store %class.KV.8* %kv, %class.KV.8** %3, align 8
  %4 = load %class.KV.7*, %class.KV.7** %1, align 8
  %5 = getelementptr inbounds %class.KV.7, %class.KV.7* %4, i32 0, i32 0
  %6 = load i64, i64* %2, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EE3KeyC2Em(%"union.KV<scheme_key, scheme_value, 8>::Key"* %5, i64 %6)
  %7 = getelementptr inbounds %class.KV.7, %class.KV.7* %4, i32 0, i32 1
  %8 = load %class.KV.8*, %class.KV.8** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EE3ValC2EPKS_IS0_S1_Lj9EE(%"union.KV<scheme_key, scheme_value, 8>::Val"* %7, %class.KV.8* %8)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj9EEC2EPKS0_PKS1_(%class.KV.8* %this, %class.scheme_key* %key, %class.scheme_value* %val) unnamed_addr #0 comdat align 2 {
  %1 = alloca %class.KV.8*, align 8
  %2 = alloca %class.scheme_key*, align 8
  %3 = alloca %class.scheme_value*, align 8
  store %class.KV.8* %this, %class.KV.8** %1, align 8
  store %class.scheme_key* %key, %class.scheme_key** %2, align 8
  store %class.scheme_value* %val, %class.scheme_value** %3, align 8
  %4 = load %class.KV.8*, %class.KV.8** %1, align 8
  %5 = getelementptr inbounds %class.KV.8, %class.KV.8* %4, i32 0, i32 0
  %6 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EE3KeyC2EPKS0_(%"union.KV<scheme_key, scheme_value, 9>::Key"* %5, %class.scheme_key* %6)
  %7 = getelementptr inbounds %class.KV.8, %class.KV.8* %4, i32 0, i32 1
  %8 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EE3ValC2EPKS1_(%"union.KV<scheme_key, scheme_value, 9>::Val"* %7, %class.scheme_value* %8)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj10EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.9* noalias sret %agg.result, i64 %h0, %class.scheme_key* %k0, %class.scheme_value* %v0, i64 %h1, %class.scheme_key* %k1, %class.scheme_value* %v1) #0 comdat align 2 {
  %1 = alloca i64, align 8
  %2 = alloca %class.scheme_key*, align 8
  %3 = alloca %class.scheme_value*, align 8
  %4 = alloca i64, align 8
  %5 = alloca %class.scheme_key*, align 8
  %6 = alloca %class.scheme_value*, align 8
  %ll1 = alloca %class.LL*, align 8
  %ll0 = alloca %class.LL*, align 8
  store i64 %h0, i64* %1, align 8
  store %class.scheme_key* %k0, %class.scheme_key** %2, align 8
  store %class.scheme_value* %v0, %class.scheme_value** %3, align 8
  store i64 %h1, i64* %4, align 8
  store %class.scheme_key* %k1, %class.scheme_key** %5, align 8
  store %class.scheme_value* %v1, %class.scheme_value** %6, align 8
  %7 = call noalias i8* @GC_malloc(i64 24)
  %8 = bitcast i8* %7 to %class.LL*
  %9 = bitcast %class.LL* %8 to i8*
  %10 = bitcast i8* %9 to %class.LL*
  %11 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  %12 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2LLI10scheme_key12scheme_valueEC2EPKS0_PKS1_PKS2_(%class.LL* %10, %class.scheme_key* %11, %class.scheme_value* %12, %class.LL* null)
  store %class.LL* %10, %class.LL** %ll1, align 8
  %13 = call noalias i8* @GC_malloc(i64 24)
  %14 = bitcast i8* %13 to %class.LL*
  %15 = bitcast %class.LL* %14 to i8*
  %16 = bitcast i8* %15 to %class.LL*
  %17 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %18 = load %class.scheme_value*, %class.scheme_value** %6, align 8
  %19 = load %class.LL*, %class.LL** %ll1, align 8
  call void @_ZN2LLI10scheme_key12scheme_valueEC2EPKS0_PKS1_PKS2_(%class.LL* %16, %class.scheme_key* %17, %class.scheme_value* %18, %class.LL* %19)
  store %class.LL* %16, %class.LL** %ll0, align 8
  %20 = load %class.LL*, %class.LL** %ll0, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj10EEC2EmPK2LLIS0_S1_E(%class.KV.9* %agg.result, i64 1, %class.LL* %20)
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj10EEC2ERKS2_(%class.KV.9* %this, %class.KV.9* dereferenceable(16) %o) unnamed_addr #5 comdat align 2 {
  %1 = alloca %class.KV.9*, align 8
  %2 = alloca %class.KV.9*, align 8
  store %class.KV.9* %this, %class.KV.9** %1, align 8
  store %class.KV.9* %o, %class.KV.9** %2, align 8
  %3 = load %class.KV.9*, %class.KV.9** %1, align 8
  %4 = getelementptr inbounds %class.KV.9, %class.KV.9* %3, i32 0, i32 0
  %5 = load %class.KV.9*, %class.KV.9** %2, align 8
  %6 = getelementptr inbounds %class.KV.9, %class.KV.9* %5, i32 0, i32 0
  %7 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Key"* %4 to i8*
  %8 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Key"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 8, i32 8, i1 false)
  %9 = getelementptr inbounds %class.KV.9, %class.KV.9* %3, i32 0, i32 1
  %10 = load %class.KV.9*, %class.KV.9** %2, align 8
  %11 = getelementptr inbounds %class.KV.9, %class.KV.9* %10, i32 0, i32 1
  %12 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Val"* %9 to i8*
  %13 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Val"* %11 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %12, i8* %13, i64 8, i32 8, i1 false)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj9EEC2EmPKS_IS0_S1_Lj10EE(%class.KV.8* %this, i64 %bm, %class.KV.9* %kv) unnamed_addr #0 comdat align 2 {
  %1 = alloca %class.KV.8*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.KV.9*, align 8
  store %class.KV.8* %this, %class.KV.8** %1, align 8
  store i64 %bm, i64* %2, align 8
  store %class.KV.9* %kv, %class.KV.9** %3, align 8
  %4 = load %class.KV.8*, %class.KV.8** %1, align 8
  %5 = getelementptr inbounds %class.KV.8, %class.KV.8* %4, i32 0, i32 0
  %6 = load i64, i64* %2, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EE3KeyC2Em(%"union.KV<scheme_key, scheme_value, 9>::Key"* %5, i64 %6)
  %7 = getelementptr inbounds %class.KV.8, %class.KV.8* %4, i32 0, i32 1
  %8 = load %class.KV.9*, %class.KV.9** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EE3ValC2EPKS_IS0_S1_Lj10EE(%"union.KV<scheme_key, scheme_value, 9>::Val"* %7, %class.KV.9* %8)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj10EEC2EPKS0_PKS1_(%class.KV.9* %this, %class.scheme_key* %key, %class.scheme_value* %val) unnamed_addr #0 comdat align 2 {
  %1 = alloca %class.KV.9*, align 8
  %2 = alloca %class.scheme_key*, align 8
  %3 = alloca %class.scheme_value*, align 8
  store %class.KV.9* %this, %class.KV.9** %1, align 8
  store %class.scheme_key* %key, %class.scheme_key** %2, align 8
  store %class.scheme_value* %val, %class.scheme_value** %3, align 8
  %4 = load %class.KV.9*, %class.KV.9** %1, align 8
  %5 = getelementptr inbounds %class.KV.9, %class.KV.9* %4, i32 0, i32 0
  %6 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj10EE3KeyC2EPKS0_(%"union.KV<scheme_key, scheme_value, 10>::Key"* %5, %class.scheme_key* %6)
  %7 = getelementptr inbounds %class.KV.9, %class.KV.9* %4, i32 0, i32 1
  %8 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj10EE3ValC2EPKS1_(%"union.KV<scheme_key, scheme_value, 10>::Val"* %7, %class.scheme_value* %8)
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2LLI10scheme_key12scheme_valueEC2EPKS0_PKS1_PKS2_(%class.LL* %this, %class.scheme_key* %k, %class.scheme_value* %v, %class.LL* %next) unnamed_addr #5 comdat align 2 {
  %1 = alloca %class.LL*, align 8
  %2 = alloca %class.scheme_key*, align 8
  %3 = alloca %class.scheme_value*, align 8
  %4 = alloca %class.LL*, align 8
  store %class.LL* %this, %class.LL** %1, align 8
  store %class.scheme_key* %k, %class.scheme_key** %2, align 8
  store %class.scheme_value* %v, %class.scheme_value** %3, align 8
  store %class.LL* %next, %class.LL** %4, align 8
  %5 = load %class.LL*, %class.LL** %1, align 8
  %6 = getelementptr inbounds %class.LL, %class.LL* %5, i32 0, i32 0
  %7 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  store %class.scheme_key* %7, %class.scheme_key** %6, align 8
  %8 = getelementptr inbounds %class.LL, %class.LL* %5, i32 0, i32 1
  %9 = load %class.scheme_value*, %class.scheme_value** %3, align 8
  store %class.scheme_value* %9, %class.scheme_value** %8, align 8
  %10 = getelementptr inbounds %class.LL, %class.LL* %5, i32 0, i32 2
  %11 = load %class.LL*, %class.LL** %4, align 8
  store %class.LL* %11, %class.LL** %10, align 8
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj10EEC2EmPK2LLIS0_S1_E(%class.KV.9* %this, i64 %bm, %class.LL* %ll) unnamed_addr #0 comdat align 2 {
  %1 = alloca %class.KV.9*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.LL*, align 8
  store %class.KV.9* %this, %class.KV.9** %1, align 8
  store i64 %bm, i64* %2, align 8
  store %class.LL* %ll, %class.LL** %3, align 8
  %4 = load %class.KV.9*, %class.KV.9** %1, align 8
  %5 = getelementptr inbounds %class.KV.9, %class.KV.9* %4, i32 0, i32 0
  %6 = load i64, i64* %2, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj10EE3KeyC2Em(%"union.KV<scheme_key, scheme_value, 10>::Key"* %5, i64 %6)
  %7 = getelementptr inbounds %class.KV.9, %class.KV.9* %4, i32 0, i32 1
  %8 = load %class.LL*, %class.LL** %3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj10EE3ValC2EPK2LLIS0_S1_E(%"union.KV<scheme_key, scheme_value, 10>::Val"* %7, %class.LL* %8)
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj10EE3KeyC2Em(%"union.KV<scheme_key, scheme_value, 10>::Key"* %this, i64 %bm) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 10>::Key"*, align 8
  %2 = alloca i64, align 8
  store %"union.KV<scheme_key, scheme_value, 10>::Key"* %this, %"union.KV<scheme_key, scheme_value, 10>::Key"** %1, align 8
  store i64 %bm, i64* %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 10>::Key"*, %"union.KV<scheme_key, scheme_value, 10>::Key"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Key"* %3 to i64*
  %5 = load i64, i64* %2, align 8
  store i64 %5, i64* %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj10EE3ValC2EPK2LLIS0_S1_E(%"union.KV<scheme_key, scheme_value, 10>::Val"* %this, %class.LL* %ll) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 10>::Val"*, align 8
  %2 = alloca %class.LL*, align 8
  store %"union.KV<scheme_key, scheme_value, 10>::Val"* %this, %"union.KV<scheme_key, scheme_value, 10>::Val"** %1, align 8
  store %class.LL* %ll, %class.LL** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 10>::Val"*, %"union.KV<scheme_key, scheme_value, 10>::Val"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Val"* %3 to %class.LL**
  %5 = load %class.LL*, %class.LL** %2, align 8
  store %class.LL* %5, %class.LL** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj9EE3KeyC2Em(%"union.KV<scheme_key, scheme_value, 9>::Key"* %this, i64 %bm) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 9>::Key"*, align 8
  %2 = alloca i64, align 8
  store %"union.KV<scheme_key, scheme_value, 9>::Key"* %this, %"union.KV<scheme_key, scheme_value, 9>::Key"** %1, align 8
  store i64 %bm, i64* %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 9>::Key"*, %"union.KV<scheme_key, scheme_value, 9>::Key"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Key"* %3 to i64*
  %5 = load i64, i64* %2, align 8
  store i64 %5, i64* %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj9EE3ValC2EPKS_IS0_S1_Lj10EE(%"union.KV<scheme_key, scheme_value, 9>::Val"* %this, %class.KV.9* %node) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 9>::Val"*, align 8
  %2 = alloca %class.KV.9*, align 8
  store %"union.KV<scheme_key, scheme_value, 9>::Val"* %this, %"union.KV<scheme_key, scheme_value, 9>::Val"** %1, align 8
  store %class.KV.9* %node, %class.KV.9** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 9>::Val"*, %"union.KV<scheme_key, scheme_value, 9>::Val"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Val"* %3 to %class.KV.9**
  %5 = load %class.KV.9*, %class.KV.9** %2, align 8
  store %class.KV.9* %5, %class.KV.9** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj10EE3KeyC2EPKS0_(%"union.KV<scheme_key, scheme_value, 10>::Key"* %this, %class.scheme_key* %key) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 10>::Key"*, align 8
  %2 = alloca %class.scheme_key*, align 8
  store %"union.KV<scheme_key, scheme_value, 10>::Key"* %this, %"union.KV<scheme_key, scheme_value, 10>::Key"** %1, align 8
  store %class.scheme_key* %key, %class.scheme_key** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 10>::Key"*, %"union.KV<scheme_key, scheme_value, 10>::Key"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Key"* %3 to %class.scheme_key**
  %5 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  store %class.scheme_key* %5, %class.scheme_key** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj10EE3ValC2EPKS1_(%"union.KV<scheme_key, scheme_value, 10>::Val"* %this, %class.scheme_value* %val) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 10>::Val"*, align 8
  %2 = alloca %class.scheme_value*, align 8
  store %"union.KV<scheme_key, scheme_value, 10>::Val"* %this, %"union.KV<scheme_key, scheme_value, 10>::Val"** %1, align 8
  store %class.scheme_value* %val, %class.scheme_value** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 10>::Val"*, %"union.KV<scheme_key, scheme_value, 10>::Val"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Val"* %3 to %class.scheme_value**
  %5 = load %class.scheme_value*, %class.scheme_value** %2, align 8
  store %class.scheme_value* %5, %class.scheme_value** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj8EE3KeyC2Em(%"union.KV<scheme_key, scheme_value, 8>::Key"* %this, i64 %bm) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 8>::Key"*, align 8
  %2 = alloca i64, align 8
  store %"union.KV<scheme_key, scheme_value, 8>::Key"* %this, %"union.KV<scheme_key, scheme_value, 8>::Key"** %1, align 8
  store i64 %bm, i64* %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 8>::Key"*, %"union.KV<scheme_key, scheme_value, 8>::Key"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Key"* %3 to i64*
  %5 = load i64, i64* %2, align 8
  store i64 %5, i64* %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj8EE3ValC2EPKS_IS0_S1_Lj9EE(%"union.KV<scheme_key, scheme_value, 8>::Val"* %this, %class.KV.8* %node) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 8>::Val"*, align 8
  %2 = alloca %class.KV.8*, align 8
  store %"union.KV<scheme_key, scheme_value, 8>::Val"* %this, %"union.KV<scheme_key, scheme_value, 8>::Val"** %1, align 8
  store %class.KV.8* %node, %class.KV.8** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 8>::Val"*, %"union.KV<scheme_key, scheme_value, 8>::Val"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Val"* %3 to %class.KV.8**
  %5 = load %class.KV.8*, %class.KV.8** %2, align 8
  store %class.KV.8* %5, %class.KV.8** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj9EE3KeyC2EPKS0_(%"union.KV<scheme_key, scheme_value, 9>::Key"* %this, %class.scheme_key* %key) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 9>::Key"*, align 8
  %2 = alloca %class.scheme_key*, align 8
  store %"union.KV<scheme_key, scheme_value, 9>::Key"* %this, %"union.KV<scheme_key, scheme_value, 9>::Key"** %1, align 8
  store %class.scheme_key* %key, %class.scheme_key** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 9>::Key"*, %"union.KV<scheme_key, scheme_value, 9>::Key"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Key"* %3 to %class.scheme_key**
  %5 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  store %class.scheme_key* %5, %class.scheme_key** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj9EE3ValC2EPKS1_(%"union.KV<scheme_key, scheme_value, 9>::Val"* %this, %class.scheme_value* %val) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 9>::Val"*, align 8
  %2 = alloca %class.scheme_value*, align 8
  store %"union.KV<scheme_key, scheme_value, 9>::Val"* %this, %"union.KV<scheme_key, scheme_value, 9>::Val"** %1, align 8
  store %class.scheme_value* %val, %class.scheme_value** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 9>::Val"*, %"union.KV<scheme_key, scheme_value, 9>::Val"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Val"* %3 to %class.scheme_value**
  %5 = load %class.scheme_value*, %class.scheme_value** %2, align 8
  store %class.scheme_value* %5, %class.scheme_value** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj7EE3KeyC2Em(%"union.KV<scheme_key, scheme_value, 7>::Key"* %this, i64 %bm) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 7>::Key"*, align 8
  %2 = alloca i64, align 8
  store %"union.KV<scheme_key, scheme_value, 7>::Key"* %this, %"union.KV<scheme_key, scheme_value, 7>::Key"** %1, align 8
  store i64 %bm, i64* %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 7>::Key"*, %"union.KV<scheme_key, scheme_value, 7>::Key"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Key"* %3 to i64*
  %5 = load i64, i64* %2, align 8
  store i64 %5, i64* %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj7EE3ValC2EPKS_IS0_S1_Lj8EE(%"union.KV<scheme_key, scheme_value, 7>::Val"* %this, %class.KV.7* %node) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 7>::Val"*, align 8
  %2 = alloca %class.KV.7*, align 8
  store %"union.KV<scheme_key, scheme_value, 7>::Val"* %this, %"union.KV<scheme_key, scheme_value, 7>::Val"** %1, align 8
  store %class.KV.7* %node, %class.KV.7** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 7>::Val"*, %"union.KV<scheme_key, scheme_value, 7>::Val"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Val"* %3 to %class.KV.7**
  %5 = load %class.KV.7*, %class.KV.7** %2, align 8
  store %class.KV.7* %5, %class.KV.7** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj8EE3KeyC2EPKS0_(%"union.KV<scheme_key, scheme_value, 8>::Key"* %this, %class.scheme_key* %key) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 8>::Key"*, align 8
  %2 = alloca %class.scheme_key*, align 8
  store %"union.KV<scheme_key, scheme_value, 8>::Key"* %this, %"union.KV<scheme_key, scheme_value, 8>::Key"** %1, align 8
  store %class.scheme_key* %key, %class.scheme_key** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 8>::Key"*, %"union.KV<scheme_key, scheme_value, 8>::Key"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Key"* %3 to %class.scheme_key**
  %5 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  store %class.scheme_key* %5, %class.scheme_key** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj8EE3ValC2EPKS1_(%"union.KV<scheme_key, scheme_value, 8>::Val"* %this, %class.scheme_value* %val) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 8>::Val"*, align 8
  %2 = alloca %class.scheme_value*, align 8
  store %"union.KV<scheme_key, scheme_value, 8>::Val"* %this, %"union.KV<scheme_key, scheme_value, 8>::Val"** %1, align 8
  store %class.scheme_value* %val, %class.scheme_value** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 8>::Val"*, %"union.KV<scheme_key, scheme_value, 8>::Val"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Val"* %3 to %class.scheme_value**
  %5 = load %class.scheme_value*, %class.scheme_value** %2, align 8
  store %class.scheme_value* %5, %class.scheme_value** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj6EE3KeyC2Em(%"union.KV<scheme_key, scheme_value, 6>::Key"* %this, i64 %bm) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 6>::Key"*, align 8
  %2 = alloca i64, align 8
  store %"union.KV<scheme_key, scheme_value, 6>::Key"* %this, %"union.KV<scheme_key, scheme_value, 6>::Key"** %1, align 8
  store i64 %bm, i64* %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 6>::Key"*, %"union.KV<scheme_key, scheme_value, 6>::Key"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Key"* %3 to i64*
  %5 = load i64, i64* %2, align 8
  store i64 %5, i64* %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj6EE3ValC2EPKS_IS0_S1_Lj7EE(%"union.KV<scheme_key, scheme_value, 6>::Val"* %this, %class.KV.6* %node) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 6>::Val"*, align 8
  %2 = alloca %class.KV.6*, align 8
  store %"union.KV<scheme_key, scheme_value, 6>::Val"* %this, %"union.KV<scheme_key, scheme_value, 6>::Val"** %1, align 8
  store %class.KV.6* %node, %class.KV.6** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 6>::Val"*, %"union.KV<scheme_key, scheme_value, 6>::Val"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Val"* %3 to %class.KV.6**
  %5 = load %class.KV.6*, %class.KV.6** %2, align 8
  store %class.KV.6* %5, %class.KV.6** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj7EE3KeyC2EPKS0_(%"union.KV<scheme_key, scheme_value, 7>::Key"* %this, %class.scheme_key* %key) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 7>::Key"*, align 8
  %2 = alloca %class.scheme_key*, align 8
  store %"union.KV<scheme_key, scheme_value, 7>::Key"* %this, %"union.KV<scheme_key, scheme_value, 7>::Key"** %1, align 8
  store %class.scheme_key* %key, %class.scheme_key** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 7>::Key"*, %"union.KV<scheme_key, scheme_value, 7>::Key"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Key"* %3 to %class.scheme_key**
  %5 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  store %class.scheme_key* %5, %class.scheme_key** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj7EE3ValC2EPKS1_(%"union.KV<scheme_key, scheme_value, 7>::Val"* %this, %class.scheme_value* %val) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 7>::Val"*, align 8
  %2 = alloca %class.scheme_value*, align 8
  store %"union.KV<scheme_key, scheme_value, 7>::Val"* %this, %"union.KV<scheme_key, scheme_value, 7>::Val"** %1, align 8
  store %class.scheme_value* %val, %class.scheme_value** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 7>::Val"*, %"union.KV<scheme_key, scheme_value, 7>::Val"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Val"* %3 to %class.scheme_value**
  %5 = load %class.scheme_value*, %class.scheme_value** %2, align 8
  store %class.scheme_value* %5, %class.scheme_value** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj5EE3KeyC2Em(%"union.KV<scheme_key, scheme_value, 5>::Key"* %this, i64 %bm) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 5>::Key"*, align 8
  %2 = alloca i64, align 8
  store %"union.KV<scheme_key, scheme_value, 5>::Key"* %this, %"union.KV<scheme_key, scheme_value, 5>::Key"** %1, align 8
  store i64 %bm, i64* %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 5>::Key"*, %"union.KV<scheme_key, scheme_value, 5>::Key"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Key"* %3 to i64*
  %5 = load i64, i64* %2, align 8
  store i64 %5, i64* %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj5EE3ValC2EPKS_IS0_S1_Lj6EE(%"union.KV<scheme_key, scheme_value, 5>::Val"* %this, %class.KV.5* %node) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 5>::Val"*, align 8
  %2 = alloca %class.KV.5*, align 8
  store %"union.KV<scheme_key, scheme_value, 5>::Val"* %this, %"union.KV<scheme_key, scheme_value, 5>::Val"** %1, align 8
  store %class.KV.5* %node, %class.KV.5** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 5>::Val"*, %"union.KV<scheme_key, scheme_value, 5>::Val"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Val"* %3 to %class.KV.5**
  %5 = load %class.KV.5*, %class.KV.5** %2, align 8
  store %class.KV.5* %5, %class.KV.5** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj6EE3KeyC2EPKS0_(%"union.KV<scheme_key, scheme_value, 6>::Key"* %this, %class.scheme_key* %key) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 6>::Key"*, align 8
  %2 = alloca %class.scheme_key*, align 8
  store %"union.KV<scheme_key, scheme_value, 6>::Key"* %this, %"union.KV<scheme_key, scheme_value, 6>::Key"** %1, align 8
  store %class.scheme_key* %key, %class.scheme_key** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 6>::Key"*, %"union.KV<scheme_key, scheme_value, 6>::Key"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Key"* %3 to %class.scheme_key**
  %5 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  store %class.scheme_key* %5, %class.scheme_key** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj6EE3ValC2EPKS1_(%"union.KV<scheme_key, scheme_value, 6>::Val"* %this, %class.scheme_value* %val) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 6>::Val"*, align 8
  %2 = alloca %class.scheme_value*, align 8
  store %"union.KV<scheme_key, scheme_value, 6>::Val"* %this, %"union.KV<scheme_key, scheme_value, 6>::Val"** %1, align 8
  store %class.scheme_value* %val, %class.scheme_value** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 6>::Val"*, %"union.KV<scheme_key, scheme_value, 6>::Val"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Val"* %3 to %class.scheme_value**
  %5 = load %class.scheme_value*, %class.scheme_value** %2, align 8
  store %class.scheme_value* %5, %class.scheme_value** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj4EE3KeyC2Em(%"union.KV<scheme_key, scheme_value, 4>::Key"* %this, i64 %bm) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 4>::Key"*, align 8
  %2 = alloca i64, align 8
  store %"union.KV<scheme_key, scheme_value, 4>::Key"* %this, %"union.KV<scheme_key, scheme_value, 4>::Key"** %1, align 8
  store i64 %bm, i64* %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 4>::Key"*, %"union.KV<scheme_key, scheme_value, 4>::Key"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Key"* %3 to i64*
  %5 = load i64, i64* %2, align 8
  store i64 %5, i64* %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj4EE3ValC2EPKS_IS0_S1_Lj5EE(%"union.KV<scheme_key, scheme_value, 4>::Val"* %this, %class.KV.4* %node) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 4>::Val"*, align 8
  %2 = alloca %class.KV.4*, align 8
  store %"union.KV<scheme_key, scheme_value, 4>::Val"* %this, %"union.KV<scheme_key, scheme_value, 4>::Val"** %1, align 8
  store %class.KV.4* %node, %class.KV.4** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 4>::Val"*, %"union.KV<scheme_key, scheme_value, 4>::Val"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Val"* %3 to %class.KV.4**
  %5 = load %class.KV.4*, %class.KV.4** %2, align 8
  store %class.KV.4* %5, %class.KV.4** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj5EE3KeyC2EPKS0_(%"union.KV<scheme_key, scheme_value, 5>::Key"* %this, %class.scheme_key* %key) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 5>::Key"*, align 8
  %2 = alloca %class.scheme_key*, align 8
  store %"union.KV<scheme_key, scheme_value, 5>::Key"* %this, %"union.KV<scheme_key, scheme_value, 5>::Key"** %1, align 8
  store %class.scheme_key* %key, %class.scheme_key** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 5>::Key"*, %"union.KV<scheme_key, scheme_value, 5>::Key"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Key"* %3 to %class.scheme_key**
  %5 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  store %class.scheme_key* %5, %class.scheme_key** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj5EE3ValC2EPKS1_(%"union.KV<scheme_key, scheme_value, 5>::Val"* %this, %class.scheme_value* %val) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 5>::Val"*, align 8
  %2 = alloca %class.scheme_value*, align 8
  store %"union.KV<scheme_key, scheme_value, 5>::Val"* %this, %"union.KV<scheme_key, scheme_value, 5>::Val"** %1, align 8
  store %class.scheme_value* %val, %class.scheme_value** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 5>::Val"*, %"union.KV<scheme_key, scheme_value, 5>::Val"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Val"* %3 to %class.scheme_value**
  %5 = load %class.scheme_value*, %class.scheme_value** %2, align 8
  store %class.scheme_value* %5, %class.scheme_value** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj3EE3KeyC2Em(%"union.KV<scheme_key, scheme_value, 3>::Key"* %this, i64 %bm) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 3>::Key"*, align 8
  %2 = alloca i64, align 8
  store %"union.KV<scheme_key, scheme_value, 3>::Key"* %this, %"union.KV<scheme_key, scheme_value, 3>::Key"** %1, align 8
  store i64 %bm, i64* %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 3>::Key"*, %"union.KV<scheme_key, scheme_value, 3>::Key"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Key"* %3 to i64*
  %5 = load i64, i64* %2, align 8
  store i64 %5, i64* %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj3EE3ValC2EPKS_IS0_S1_Lj4EE(%"union.KV<scheme_key, scheme_value, 3>::Val"* %this, %class.KV.3* %node) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 3>::Val"*, align 8
  %2 = alloca %class.KV.3*, align 8
  store %"union.KV<scheme_key, scheme_value, 3>::Val"* %this, %"union.KV<scheme_key, scheme_value, 3>::Val"** %1, align 8
  store %class.KV.3* %node, %class.KV.3** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 3>::Val"*, %"union.KV<scheme_key, scheme_value, 3>::Val"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Val"* %3 to %class.KV.3**
  %5 = load %class.KV.3*, %class.KV.3** %2, align 8
  store %class.KV.3* %5, %class.KV.3** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj4EE3KeyC2EPKS0_(%"union.KV<scheme_key, scheme_value, 4>::Key"* %this, %class.scheme_key* %key) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 4>::Key"*, align 8
  %2 = alloca %class.scheme_key*, align 8
  store %"union.KV<scheme_key, scheme_value, 4>::Key"* %this, %"union.KV<scheme_key, scheme_value, 4>::Key"** %1, align 8
  store %class.scheme_key* %key, %class.scheme_key** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 4>::Key"*, %"union.KV<scheme_key, scheme_value, 4>::Key"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Key"* %3 to %class.scheme_key**
  %5 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  store %class.scheme_key* %5, %class.scheme_key** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj4EE3ValC2EPKS1_(%"union.KV<scheme_key, scheme_value, 4>::Val"* %this, %class.scheme_value* %val) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 4>::Val"*, align 8
  %2 = alloca %class.scheme_value*, align 8
  store %"union.KV<scheme_key, scheme_value, 4>::Val"* %this, %"union.KV<scheme_key, scheme_value, 4>::Val"** %1, align 8
  store %class.scheme_value* %val, %class.scheme_value** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 4>::Val"*, %"union.KV<scheme_key, scheme_value, 4>::Val"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Val"* %3 to %class.scheme_value**
  %5 = load %class.scheme_value*, %class.scheme_value** %2, align 8
  store %class.scheme_value* %5, %class.scheme_value** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj2EE3KeyC2Em(%"union.KV<scheme_key, scheme_value, 2>::Key"* %this, i64 %bm) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 2>::Key"*, align 8
  %2 = alloca i64, align 8
  store %"union.KV<scheme_key, scheme_value, 2>::Key"* %this, %"union.KV<scheme_key, scheme_value, 2>::Key"** %1, align 8
  store i64 %bm, i64* %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 2>::Key"*, %"union.KV<scheme_key, scheme_value, 2>::Key"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Key"* %3 to i64*
  %5 = load i64, i64* %2, align 8
  store i64 %5, i64* %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj2EE3ValC2EPKS_IS0_S1_Lj3EE(%"union.KV<scheme_key, scheme_value, 2>::Val"* %this, %class.KV.2* %node) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 2>::Val"*, align 8
  %2 = alloca %class.KV.2*, align 8
  store %"union.KV<scheme_key, scheme_value, 2>::Val"* %this, %"union.KV<scheme_key, scheme_value, 2>::Val"** %1, align 8
  store %class.KV.2* %node, %class.KV.2** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 2>::Val"*, %"union.KV<scheme_key, scheme_value, 2>::Val"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Val"* %3 to %class.KV.2**
  %5 = load %class.KV.2*, %class.KV.2** %2, align 8
  store %class.KV.2* %5, %class.KV.2** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj3EE3KeyC2EPKS0_(%"union.KV<scheme_key, scheme_value, 3>::Key"* %this, %class.scheme_key* %key) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 3>::Key"*, align 8
  %2 = alloca %class.scheme_key*, align 8
  store %"union.KV<scheme_key, scheme_value, 3>::Key"* %this, %"union.KV<scheme_key, scheme_value, 3>::Key"** %1, align 8
  store %class.scheme_key* %key, %class.scheme_key** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 3>::Key"*, %"union.KV<scheme_key, scheme_value, 3>::Key"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Key"* %3 to %class.scheme_key**
  %5 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  store %class.scheme_key* %5, %class.scheme_key** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj3EE3ValC2EPKS1_(%"union.KV<scheme_key, scheme_value, 3>::Val"* %this, %class.scheme_value* %val) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 3>::Val"*, align 8
  %2 = alloca %class.scheme_value*, align 8
  store %"union.KV<scheme_key, scheme_value, 3>::Val"* %this, %"union.KV<scheme_key, scheme_value, 3>::Val"** %1, align 8
  store %class.scheme_value* %val, %class.scheme_value** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 3>::Val"*, %"union.KV<scheme_key, scheme_value, 3>::Val"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Val"* %3 to %class.scheme_value**
  %5 = load %class.scheme_value*, %class.scheme_value** %2, align 8
  store %class.scheme_value* %5, %class.scheme_value** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj1EE3KeyC2Em(%"union.KV<scheme_key, scheme_value, 1>::Key"* %this, i64 %bm) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 1>::Key"*, align 8
  %2 = alloca i64, align 8
  store %"union.KV<scheme_key, scheme_value, 1>::Key"* %this, %"union.KV<scheme_key, scheme_value, 1>::Key"** %1, align 8
  store i64 %bm, i64* %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 1>::Key"*, %"union.KV<scheme_key, scheme_value, 1>::Key"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Key"* %3 to i64*
  %5 = load i64, i64* %2, align 8
  store i64 %5, i64* %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj1EE3ValC2EPKS_IS0_S1_Lj2EE(%"union.KV<scheme_key, scheme_value, 1>::Val"* %this, %class.KV.1* %node) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 1>::Val"*, align 8
  %2 = alloca %class.KV.1*, align 8
  store %"union.KV<scheme_key, scheme_value, 1>::Val"* %this, %"union.KV<scheme_key, scheme_value, 1>::Val"** %1, align 8
  store %class.KV.1* %node, %class.KV.1** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 1>::Val"*, %"union.KV<scheme_key, scheme_value, 1>::Val"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Val"* %3 to %class.KV.1**
  %5 = load %class.KV.1*, %class.KV.1** %2, align 8
  store %class.KV.1* %5, %class.KV.1** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj2EE3KeyC2EPKS0_(%"union.KV<scheme_key, scheme_value, 2>::Key"* %this, %class.scheme_key* %key) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 2>::Key"*, align 8
  %2 = alloca %class.scheme_key*, align 8
  store %"union.KV<scheme_key, scheme_value, 2>::Key"* %this, %"union.KV<scheme_key, scheme_value, 2>::Key"** %1, align 8
  store %class.scheme_key* %key, %class.scheme_key** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 2>::Key"*, %"union.KV<scheme_key, scheme_value, 2>::Key"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Key"* %3 to %class.scheme_key**
  %5 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  store %class.scheme_key* %5, %class.scheme_key** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj2EE3ValC2EPKS1_(%"union.KV<scheme_key, scheme_value, 2>::Val"* %this, %class.scheme_value* %val) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 2>::Val"*, align 8
  %2 = alloca %class.scheme_value*, align 8
  store %"union.KV<scheme_key, scheme_value, 2>::Val"* %this, %"union.KV<scheme_key, scheme_value, 2>::Val"** %1, align 8
  store %class.scheme_value* %val, %class.scheme_value** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 2>::Val"*, %"union.KV<scheme_key, scheme_value, 2>::Val"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Val"* %3 to %class.scheme_value**
  %5 = load %class.scheme_value*, %class.scheme_value** %2, align 8
  store %class.scheme_value* %5, %class.scheme_value** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj0EE3ValC2EPKS_IS0_S1_Lj1EE(%"union.KV<scheme_key, scheme_value, 0>::Val"* %this, %class.KV.0* %node) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 0>::Val"*, align 8
  %2 = alloca %class.KV.0*, align 8
  store %"union.KV<scheme_key, scheme_value, 0>::Val"* %this, %"union.KV<scheme_key, scheme_value, 0>::Val"** %1, align 8
  store %class.KV.0* %node, %class.KV.0** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 0>::Val"*, %"union.KV<scheme_key, scheme_value, 0>::Val"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Val"* %3 to %class.KV.0**
  %5 = load %class.KV.0*, %class.KV.0** %2, align 8
  store %class.KV.0* %5, %class.KV.0** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj1EE3KeyC2EPKS0_(%"union.KV<scheme_key, scheme_value, 1>::Key"* %this, %class.scheme_key* %key) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 1>::Key"*, align 8
  %2 = alloca %class.scheme_key*, align 8
  store %"union.KV<scheme_key, scheme_value, 1>::Key"* %this, %"union.KV<scheme_key, scheme_value, 1>::Key"** %1, align 8
  store %class.scheme_key* %key, %class.scheme_key** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 1>::Key"*, %"union.KV<scheme_key, scheme_value, 1>::Key"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Key"* %3 to %class.scheme_key**
  %5 = load %class.scheme_key*, %class.scheme_key** %2, align 8
  store %class.scheme_key* %5, %class.scheme_key** %4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj1EE3ValC2EPKS1_(%"union.KV<scheme_key, scheme_value, 1>::Val"* %this, %class.scheme_value* %val) unnamed_addr #5 comdat align 2 {
  %1 = alloca %"union.KV<scheme_key, scheme_value, 1>::Val"*, align 8
  %2 = alloca %class.scheme_value*, align 8
  store %"union.KV<scheme_key, scheme_value, 1>::Val"* %this, %"union.KV<scheme_key, scheme_value, 1>::Val"** %1, align 8
  store %class.scheme_value* %val, %class.scheme_value** %2, align 8
  %3 = load %"union.KV<scheme_key, scheme_value, 1>::Val"*, %"union.KV<scheme_key, scheme_value, 1>::Val"** %1, align 8
  %4 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Val"* %3 to %class.scheme_value**
  %5 = load %class.scheme_value*, %class.scheme_value** %2, align 8
  store %class.scheme_value* %5, %class.scheme_value** %4, align 8
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @llvm.ctpop.i64(i64) #8

; Function Attrs: uwtable
define linkonce_odr %class.KV.0* @_ZN2KVI10scheme_key12scheme_valueLj1EE11update_nodeEPKS2_jjRS3_(%class.KV.0* %old, i32 %count, i32 %i, %class.KV.0* dereferenceable(16) %kv) #0 comdat align 2 {
  %1 = alloca %class.KV.0*, align 8
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  %4 = alloca %class.KV.0*, align 8
  %copy = alloca %class.KV.0*, align 8
  store %class.KV.0* %old, %class.KV.0** %1, align 8
  store i32 %count, i32* %2, align 4
  store i32 %i, i32* %3, align 4
  store %class.KV.0* %kv, %class.KV.0** %4, align 8
  %5 = load i32, i32* %2, align 4
  %6 = zext i32 %5 to i64
  %7 = mul i64 %6, 16
  %8 = call noalias i8* @GC_malloc(i64 %7)
  %9 = bitcast i8* %8 to %class.KV.0*
  store %class.KV.0* %9, %class.KV.0** %copy, align 8
  %10 = load %class.KV.0*, %class.KV.0** %copy, align 8
  %11 = bitcast %class.KV.0* %10 to i8*
  %12 = load %class.KV.0*, %class.KV.0** %1, align 8
  %13 = bitcast %class.KV.0* %12 to i8*
  %14 = load i32, i32* %2, align 4
  %15 = zext i32 %14 to i64
  %16 = mul i64 %15, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %13, i64 %16, i32 8, i1 false)
  %17 = load %class.KV.0*, %class.KV.0** %copy, align 8
  %18 = load i32, i32* %3, align 4
  %19 = zext i32 %18 to i64
  %20 = getelementptr inbounds %class.KV.0, %class.KV.0* %17, i64 %19
  %21 = bitcast %class.KV.0* %20 to i8*
  %22 = bitcast i8* %21 to %class.KV.0*
  %23 = load %class.KV.0*, %class.KV.0** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EEC2ERKS2_(%class.KV.0* %22, %class.KV.0* dereferenceable(16) %23)
  %24 = load %class.KV.0*, %class.KV.0** %copy, align 8
  ret %class.KV.0* %24
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj1EE12insert_innerERKS2_mPKS0_PKS1_Pm(%class.KV.0* noalias sret %agg.result, %class.KV.0* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key, %class.scheme_value* %val, i64* %cptr) #0 comdat align 2 {
  %1 = alloca %class.KV.0*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.scheme_key*, align 8
  %4 = alloca %class.scheme_value*, align 8
  %5 = alloca i64*, align 8
  %data = alloca %class.KV.1*, align 8
  %bm = alloca i64, align 8
  %hpiece = alloca i32, align 4
  %count = alloca i32, align 4
  %i = alloca i32, align 4
  %exists = alloca i8, align 1
  %node = alloca %class.KV.1*, align 8
  %6 = alloca %class.KV.1, align 8
  %childkv = alloca %class.KV.1, align 8
  %node1 = alloca %class.KV.1*, align 8
  %childkv2 = alloca %class.KV.1, align 8
  %node3 = alloca %class.KV.1*, align 8
  %node4 = alloca %class.KV.1*, align 8
  store %class.KV.0* %kv, %class.KV.0** %1, align 8
  store i64 %h, i64* %2, align 8
  store %class.scheme_key* %key, %class.scheme_key** %3, align 8
  store %class.scheme_value* %val, %class.scheme_value** %4, align 8
  store i64* %cptr, i64** %5, align 8
  %7 = load %class.KV.0*, %class.KV.0** %1, align 8
  %8 = getelementptr inbounds %class.KV.0, %class.KV.0* %7, i32 0, i32 1
  %9 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Val"* %8 to %class.KV.1**
  %10 = load %class.KV.1*, %class.KV.1** %9, align 8
  store %class.KV.1* %10, %class.KV.1** %data, align 8
  %11 = load %class.KV.0*, %class.KV.0** %1, align 8
  %12 = getelementptr inbounds %class.KV.0, %class.KV.0* %11, i32 0, i32 0
  %13 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Key"* %12 to i64*
  %14 = load i64, i64* %13, align 8
  %15 = lshr i64 %14, 1
  store i64 %15, i64* %bm, align 8
  %16 = load i64, i64* %2, align 8
  %17 = and i64 %16, 63
  %18 = urem i64 %17, 63
  %19 = trunc i64 %18 to i32
  store i32 %19, i32* %hpiece, align 4
  %20 = load i64, i64* %bm, align 8
  %21 = call i64 @llvm.ctpop.i64(i64 %20)
  %22 = trunc i64 %21 to i32
  store i32 %22, i32* %count, align 4
  %23 = load i64, i64* %bm, align 8
  %24 = shl i64 %23, 1
  %25 = load i32, i32* %hpiece, align 4
  %26 = sub i32 63, %25
  %27 = zext i32 %26 to i64
  %28 = shl i64 %24, %27
  %29 = call i64 @llvm.ctpop.i64(i64 %28)
  %30 = trunc i64 %29 to i32
  store i32 %30, i32* %i, align 4
  %31 = load i64, i64* %bm, align 8
  %32 = load i32, i32* %hpiece, align 4
  %33 = zext i32 %32 to i64
  %34 = shl i64 1, %33
  %35 = and i64 %31, %34
  %36 = icmp ne i64 %35, 0
  %37 = zext i1 %36 to i8
  store i8 %37, i8* %exists, align 1
  %38 = load i8, i8* %exists, align 1
  %39 = trunc i8 %38 to i1
  br i1 %39, label %40, label %131

; <label>:40                                      ; preds = %0
  %41 = load i32, i32* %i, align 4
  %42 = zext i32 %41 to i64
  %43 = load %class.KV.1*, %class.KV.1** %data, align 8
  %44 = getelementptr inbounds %class.KV.1, %class.KV.1* %43, i64 %42
  %45 = getelementptr inbounds %class.KV.1, %class.KV.1* %44, i32 0, i32 0
  %46 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Key"* %45 to i64*
  %47 = load i64, i64* %46, align 8
  %48 = and i64 %47, 1
  %49 = icmp eq i64 %48, 0
  br i1 %49, label %50, label %112

; <label>:50                                      ; preds = %40
  %51 = load i32, i32* %i, align 4
  %52 = zext i32 %51 to i64
  %53 = load %class.KV.1*, %class.KV.1** %data, align 8
  %54 = getelementptr inbounds %class.KV.1, %class.KV.1* %53, i64 %52
  %55 = getelementptr inbounds %class.KV.1, %class.KV.1* %54, i32 0, i32 0
  %56 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Key"* %55 to %class.scheme_key**
  %57 = load %class.scheme_key*, %class.scheme_key** %56, align 8
  %58 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %59 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %57, %class.scheme_key* dereferenceable(8) %58)
  br i1 %59, label %60, label %72

; <label>:60                                      ; preds = %50
  %61 = load %class.KV.1*, %class.KV.1** %data, align 8
  %62 = load i32, i32* %count, align 4
  %63 = load i32, i32* %i, align 4
  %64 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %65 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EEC2EPKS0_PKS1_(%class.KV.1* %6, %class.scheme_key* %64, %class.scheme_value* %65)
  %66 = call %class.KV.1* @_ZN2KVI10scheme_key12scheme_valueLj2EE11update_nodeEPKS2_jjRS3_(%class.KV.1* %61, i32 %62, i32 %63, %class.KV.1* dereferenceable(16) %6)
  store %class.KV.1* %66, %class.KV.1** %node, align 8
  %67 = load %class.KV.0*, %class.KV.0** %1, align 8
  %68 = getelementptr inbounds %class.KV.0, %class.KV.0* %67, i32 0, i32 0
  %69 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Key"* %68 to i64*
  %70 = load i64, i64* %69, align 8
  %71 = load %class.KV.1*, %class.KV.1** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EEC2EmPKS_IS0_S1_Lj2EE(%class.KV.0* %agg.result, i64 %70, %class.KV.1* %71)
  br label %180

; <label>:72                                      ; preds = %50
  %73 = load i64*, i64** %5, align 8
  %74 = load i64, i64* %73, align 8
  %75 = add i64 %74, 1
  store i64 %75, i64* %73, align 8
  %76 = load i32, i32* %i, align 4
  %77 = zext i32 %76 to i64
  %78 = load %class.KV.1*, %class.KV.1** %data, align 8
  %79 = getelementptr inbounds %class.KV.1, %class.KV.1* %78, i64 %77
  %80 = getelementptr inbounds %class.KV.1, %class.KV.1* %79, i32 0, i32 0
  %81 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Key"* %80 to %class.scheme_key**
  %82 = load %class.scheme_key*, %class.scheme_key** %81, align 8
  %83 = call i64 @_ZNK10scheme_key4hashEv(%class.scheme_key* %82)
  %84 = lshr i64 %83, 16
  %85 = load i32, i32* %i, align 4
  %86 = zext i32 %85 to i64
  %87 = load %class.KV.1*, %class.KV.1** %data, align 8
  %88 = getelementptr inbounds %class.KV.1, %class.KV.1* %87, i64 %86
  %89 = getelementptr inbounds %class.KV.1, %class.KV.1* %88, i32 0, i32 0
  %90 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Key"* %89 to %class.scheme_key**
  %91 = load %class.scheme_key*, %class.scheme_key** %90, align 8
  %92 = load i32, i32* %i, align 4
  %93 = zext i32 %92 to i64
  %94 = load %class.KV.1*, %class.KV.1** %data, align 8
  %95 = getelementptr inbounds %class.KV.1, %class.KV.1* %94, i64 %93
  %96 = getelementptr inbounds %class.KV.1, %class.KV.1* %95, i32 0, i32 1
  %97 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Val"* %96 to %class.scheme_value**
  %98 = load %class.scheme_value*, %class.scheme_value** %97, align 8
  %99 = load i64, i64* %2, align 8
  %100 = lshr i64 %99, 6
  %101 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %102 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.1* sret %childkv, i64 %84, %class.scheme_key* %91, %class.scheme_value* %98, i64 %100, %class.scheme_key* %101, %class.scheme_value* %102)
  %103 = load %class.KV.1*, %class.KV.1** %data, align 8
  %104 = load i32, i32* %count, align 4
  %105 = load i32, i32* %i, align 4
  %106 = call %class.KV.1* @_ZN2KVI10scheme_key12scheme_valueLj2EE11update_nodeEPKS2_jjRS3_(%class.KV.1* %103, i32 %104, i32 %105, %class.KV.1* dereferenceable(16) %childkv)
  store %class.KV.1* %106, %class.KV.1** %node1, align 8
  %107 = load %class.KV.0*, %class.KV.0** %1, align 8
  %108 = getelementptr inbounds %class.KV.0, %class.KV.0* %107, i32 0, i32 0
  %109 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Key"* %108 to i64*
  %110 = load i64, i64* %109, align 8
  %111 = load %class.KV.1*, %class.KV.1** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EEC2EmPKS_IS0_S1_Lj2EE(%class.KV.0* %agg.result, i64 %110, %class.KV.1* %111)
  br label %180

; <label>:112                                     ; preds = %40
  %113 = load i32, i32* %i, align 4
  %114 = zext i32 %113 to i64
  %115 = load %class.KV.1*, %class.KV.1** %data, align 8
  %116 = getelementptr inbounds %class.KV.1, %class.KV.1* %115, i64 %114
  %117 = load i64, i64* %2, align 8
  %118 = lshr i64 %117, 6
  %119 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %120 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  %121 = load i64*, i64** %5, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EE12insert_innerERKS2_mPKS0_PKS1_Pm(%class.KV.1* sret %childkv2, %class.KV.1* dereferenceable(16) %116, i64 %118, %class.scheme_key* %119, %class.scheme_value* %120, i64* %121)
  %122 = load %class.KV.1*, %class.KV.1** %data, align 8
  %123 = load i32, i32* %count, align 4
  %124 = load i32, i32* %i, align 4
  %125 = call %class.KV.1* @_ZN2KVI10scheme_key12scheme_valueLj2EE11update_nodeEPKS2_jjRS3_(%class.KV.1* %122, i32 %123, i32 %124, %class.KV.1* dereferenceable(16) %childkv2)
  store %class.KV.1* %125, %class.KV.1** %node3, align 8
  %126 = load %class.KV.0*, %class.KV.0** %1, align 8
  %127 = getelementptr inbounds %class.KV.0, %class.KV.0* %126, i32 0, i32 0
  %128 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Key"* %127 to i64*
  %129 = load i64, i64* %128, align 8
  %130 = load %class.KV.1*, %class.KV.1** %node3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EEC2EmPKS_IS0_S1_Lj2EE(%class.KV.0* %agg.result, i64 %129, %class.KV.1* %130)
  br label %180

; <label>:131                                     ; preds = %0
  %132 = load i64*, i64** %5, align 8
  %133 = load i64, i64* %132, align 8
  %134 = add i64 %133, 1
  store i64 %134, i64* %132, align 8
  %135 = load i32, i32* %count, align 4
  %136 = add i32 %135, 1
  %137 = zext i32 %136 to i64
  %138 = mul i64 %137, 16
  %139 = call noalias i8* @GC_malloc(i64 %138)
  %140 = bitcast i8* %139 to %class.KV.1*
  store %class.KV.1* %140, %class.KV.1** %node4, align 8
  %141 = load %class.KV.1*, %class.KV.1** %node4, align 8
  %142 = bitcast %class.KV.1* %141 to i8*
  %143 = load %class.KV.1*, %class.KV.1** %data, align 8
  %144 = bitcast %class.KV.1* %143 to i8*
  %145 = load i32, i32* %i, align 4
  %146 = zext i32 %145 to i64
  %147 = mul i64 %146, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %142, i8* %144, i64 %147, i32 8, i1 false)
  %148 = load i32, i32* %i, align 4
  %149 = add i32 %148, 1
  %150 = zext i32 %149 to i64
  %151 = load %class.KV.1*, %class.KV.1** %node4, align 8
  %152 = getelementptr inbounds %class.KV.1, %class.KV.1* %151, i64 %150
  %153 = bitcast %class.KV.1* %152 to i8*
  %154 = load i32, i32* %i, align 4
  %155 = zext i32 %154 to i64
  %156 = load %class.KV.1*, %class.KV.1** %data, align 8
  %157 = getelementptr inbounds %class.KV.1, %class.KV.1* %156, i64 %155
  %158 = bitcast %class.KV.1* %157 to i8*
  %159 = load i32, i32* %count, align 4
  %160 = load i32, i32* %i, align 4
  %161 = sub i32 %159, %160
  %162 = zext i32 %161 to i64
  %163 = mul i64 %162, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %153, i8* %158, i64 %163, i32 8, i1 false)
  %164 = load %class.KV.1*, %class.KV.1** %node4, align 8
  %165 = load i32, i32* %i, align 4
  %166 = zext i32 %165 to i64
  %167 = getelementptr inbounds %class.KV.1, %class.KV.1* %164, i64 %166
  %168 = bitcast %class.KV.1* %167 to i8*
  %169 = bitcast i8* %168 to %class.KV.1*
  %170 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %171 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EEC2EPKS0_PKS1_(%class.KV.1* %169, %class.scheme_key* %170, %class.scheme_value* %171)
  %172 = load i64, i64* %bm, align 8
  %173 = load i32, i32* %hpiece, align 4
  %174 = zext i32 %173 to i64
  %175 = shl i64 1, %174
  %176 = or i64 %172, %175
  %177 = shl i64 %176, 1
  %178 = or i64 %177, 1
  %179 = load %class.KV.1*, %class.KV.1** %node4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EEC2EmPKS_IS0_S1_Lj2EE(%class.KV.0* %agg.result, i64 %178, %class.KV.1* %179)
  br label %180

; <label>:180                                     ; preds = %131, %112, %72, %60
  ret void
}

; Function Attrs: uwtable
define linkonce_odr %class.KV.1* @_ZN2KVI10scheme_key12scheme_valueLj2EE11update_nodeEPKS2_jjRS3_(%class.KV.1* %old, i32 %count, i32 %i, %class.KV.1* dereferenceable(16) %kv) #0 comdat align 2 {
  %1 = alloca %class.KV.1*, align 8
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  %4 = alloca %class.KV.1*, align 8
  %copy = alloca %class.KV.1*, align 8
  store %class.KV.1* %old, %class.KV.1** %1, align 8
  store i32 %count, i32* %2, align 4
  store i32 %i, i32* %3, align 4
  store %class.KV.1* %kv, %class.KV.1** %4, align 8
  %5 = load i32, i32* %2, align 4
  %6 = zext i32 %5 to i64
  %7 = mul i64 %6, 16
  %8 = call noalias i8* @GC_malloc(i64 %7)
  %9 = bitcast i8* %8 to %class.KV.1*
  store %class.KV.1* %9, %class.KV.1** %copy, align 8
  %10 = load %class.KV.1*, %class.KV.1** %copy, align 8
  %11 = bitcast %class.KV.1* %10 to i8*
  %12 = load %class.KV.1*, %class.KV.1** %1, align 8
  %13 = bitcast %class.KV.1* %12 to i8*
  %14 = load i32, i32* %2, align 4
  %15 = zext i32 %14 to i64
  %16 = mul i64 %15, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %13, i64 %16, i32 8, i1 false)
  %17 = load %class.KV.1*, %class.KV.1** %copy, align 8
  %18 = load i32, i32* %3, align 4
  %19 = zext i32 %18 to i64
  %20 = getelementptr inbounds %class.KV.1, %class.KV.1* %17, i64 %19
  %21 = bitcast %class.KV.1* %20 to i8*
  %22 = bitcast i8* %21 to %class.KV.1*
  %23 = load %class.KV.1*, %class.KV.1** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EEC2ERKS2_(%class.KV.1* %22, %class.KV.1* dereferenceable(16) %23)
  %24 = load %class.KV.1*, %class.KV.1** %copy, align 8
  ret %class.KV.1* %24
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj2EE12insert_innerERKS2_mPKS0_PKS1_Pm(%class.KV.1* noalias sret %agg.result, %class.KV.1* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key, %class.scheme_value* %val, i64* %cptr) #0 comdat align 2 {
  %1 = alloca %class.KV.1*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.scheme_key*, align 8
  %4 = alloca %class.scheme_value*, align 8
  %5 = alloca i64*, align 8
  %data = alloca %class.KV.2*, align 8
  %bm = alloca i64, align 8
  %hpiece = alloca i32, align 4
  %count = alloca i32, align 4
  %i = alloca i32, align 4
  %exists = alloca i8, align 1
  %node = alloca %class.KV.2*, align 8
  %6 = alloca %class.KV.2, align 8
  %childkv = alloca %class.KV.2, align 8
  %node1 = alloca %class.KV.2*, align 8
  %childkv2 = alloca %class.KV.2, align 8
  %node3 = alloca %class.KV.2*, align 8
  %node4 = alloca %class.KV.2*, align 8
  store %class.KV.1* %kv, %class.KV.1** %1, align 8
  store i64 %h, i64* %2, align 8
  store %class.scheme_key* %key, %class.scheme_key** %3, align 8
  store %class.scheme_value* %val, %class.scheme_value** %4, align 8
  store i64* %cptr, i64** %5, align 8
  %7 = load %class.KV.1*, %class.KV.1** %1, align 8
  %8 = getelementptr inbounds %class.KV.1, %class.KV.1* %7, i32 0, i32 1
  %9 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Val"* %8 to %class.KV.2**
  %10 = load %class.KV.2*, %class.KV.2** %9, align 8
  store %class.KV.2* %10, %class.KV.2** %data, align 8
  %11 = load %class.KV.1*, %class.KV.1** %1, align 8
  %12 = getelementptr inbounds %class.KV.1, %class.KV.1* %11, i32 0, i32 0
  %13 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Key"* %12 to i64*
  %14 = load i64, i64* %13, align 8
  %15 = lshr i64 %14, 1
  store i64 %15, i64* %bm, align 8
  %16 = load i64, i64* %2, align 8
  %17 = and i64 %16, 63
  %18 = urem i64 %17, 63
  %19 = trunc i64 %18 to i32
  store i32 %19, i32* %hpiece, align 4
  %20 = load i64, i64* %bm, align 8
  %21 = call i64 @llvm.ctpop.i64(i64 %20)
  %22 = trunc i64 %21 to i32
  store i32 %22, i32* %count, align 4
  %23 = load i64, i64* %bm, align 8
  %24 = shl i64 %23, 1
  %25 = load i32, i32* %hpiece, align 4
  %26 = sub i32 63, %25
  %27 = zext i32 %26 to i64
  %28 = shl i64 %24, %27
  %29 = call i64 @llvm.ctpop.i64(i64 %28)
  %30 = trunc i64 %29 to i32
  store i32 %30, i32* %i, align 4
  %31 = load i64, i64* %bm, align 8
  %32 = load i32, i32* %hpiece, align 4
  %33 = zext i32 %32 to i64
  %34 = shl i64 1, %33
  %35 = and i64 %31, %34
  %36 = icmp ne i64 %35, 0
  %37 = zext i1 %36 to i8
  store i8 %37, i8* %exists, align 1
  %38 = load i8, i8* %exists, align 1
  %39 = trunc i8 %38 to i1
  br i1 %39, label %40, label %131

; <label>:40                                      ; preds = %0
  %41 = load i32, i32* %i, align 4
  %42 = zext i32 %41 to i64
  %43 = load %class.KV.2*, %class.KV.2** %data, align 8
  %44 = getelementptr inbounds %class.KV.2, %class.KV.2* %43, i64 %42
  %45 = getelementptr inbounds %class.KV.2, %class.KV.2* %44, i32 0, i32 0
  %46 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Key"* %45 to i64*
  %47 = load i64, i64* %46, align 8
  %48 = and i64 %47, 1
  %49 = icmp eq i64 %48, 0
  br i1 %49, label %50, label %112

; <label>:50                                      ; preds = %40
  %51 = load i32, i32* %i, align 4
  %52 = zext i32 %51 to i64
  %53 = load %class.KV.2*, %class.KV.2** %data, align 8
  %54 = getelementptr inbounds %class.KV.2, %class.KV.2* %53, i64 %52
  %55 = getelementptr inbounds %class.KV.2, %class.KV.2* %54, i32 0, i32 0
  %56 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Key"* %55 to %class.scheme_key**
  %57 = load %class.scheme_key*, %class.scheme_key** %56, align 8
  %58 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %59 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %57, %class.scheme_key* dereferenceable(8) %58)
  br i1 %59, label %60, label %72

; <label>:60                                      ; preds = %50
  %61 = load %class.KV.2*, %class.KV.2** %data, align 8
  %62 = load i32, i32* %count, align 4
  %63 = load i32, i32* %i, align 4
  %64 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %65 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EEC2EPKS0_PKS1_(%class.KV.2* %6, %class.scheme_key* %64, %class.scheme_value* %65)
  %66 = call %class.KV.2* @_ZN2KVI10scheme_key12scheme_valueLj3EE11update_nodeEPKS2_jjRS3_(%class.KV.2* %61, i32 %62, i32 %63, %class.KV.2* dereferenceable(16) %6)
  store %class.KV.2* %66, %class.KV.2** %node, align 8
  %67 = load %class.KV.1*, %class.KV.1** %1, align 8
  %68 = getelementptr inbounds %class.KV.1, %class.KV.1* %67, i32 0, i32 0
  %69 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Key"* %68 to i64*
  %70 = load i64, i64* %69, align 8
  %71 = load %class.KV.2*, %class.KV.2** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EEC2EmPKS_IS0_S1_Lj3EE(%class.KV.1* %agg.result, i64 %70, %class.KV.2* %71)
  br label %180

; <label>:72                                      ; preds = %50
  %73 = load i64*, i64** %5, align 8
  %74 = load i64, i64* %73, align 8
  %75 = add i64 %74, 1
  store i64 %75, i64* %73, align 8
  %76 = load i32, i32* %i, align 4
  %77 = zext i32 %76 to i64
  %78 = load %class.KV.2*, %class.KV.2** %data, align 8
  %79 = getelementptr inbounds %class.KV.2, %class.KV.2* %78, i64 %77
  %80 = getelementptr inbounds %class.KV.2, %class.KV.2* %79, i32 0, i32 0
  %81 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Key"* %80 to %class.scheme_key**
  %82 = load %class.scheme_key*, %class.scheme_key** %81, align 8
  %83 = call i64 @_ZNK10scheme_key4hashEv(%class.scheme_key* %82)
  %84 = lshr i64 %83, 22
  %85 = load i32, i32* %i, align 4
  %86 = zext i32 %85 to i64
  %87 = load %class.KV.2*, %class.KV.2** %data, align 8
  %88 = getelementptr inbounds %class.KV.2, %class.KV.2* %87, i64 %86
  %89 = getelementptr inbounds %class.KV.2, %class.KV.2* %88, i32 0, i32 0
  %90 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Key"* %89 to %class.scheme_key**
  %91 = load %class.scheme_key*, %class.scheme_key** %90, align 8
  %92 = load i32, i32* %i, align 4
  %93 = zext i32 %92 to i64
  %94 = load %class.KV.2*, %class.KV.2** %data, align 8
  %95 = getelementptr inbounds %class.KV.2, %class.KV.2* %94, i64 %93
  %96 = getelementptr inbounds %class.KV.2, %class.KV.2* %95, i32 0, i32 1
  %97 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Val"* %96 to %class.scheme_value**
  %98 = load %class.scheme_value*, %class.scheme_value** %97, align 8
  %99 = load i64, i64* %2, align 8
  %100 = lshr i64 %99, 6
  %101 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %102 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.2* sret %childkv, i64 %84, %class.scheme_key* %91, %class.scheme_value* %98, i64 %100, %class.scheme_key* %101, %class.scheme_value* %102)
  %103 = load %class.KV.2*, %class.KV.2** %data, align 8
  %104 = load i32, i32* %count, align 4
  %105 = load i32, i32* %i, align 4
  %106 = call %class.KV.2* @_ZN2KVI10scheme_key12scheme_valueLj3EE11update_nodeEPKS2_jjRS3_(%class.KV.2* %103, i32 %104, i32 %105, %class.KV.2* dereferenceable(16) %childkv)
  store %class.KV.2* %106, %class.KV.2** %node1, align 8
  %107 = load %class.KV.1*, %class.KV.1** %1, align 8
  %108 = getelementptr inbounds %class.KV.1, %class.KV.1* %107, i32 0, i32 0
  %109 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Key"* %108 to i64*
  %110 = load i64, i64* %109, align 8
  %111 = load %class.KV.2*, %class.KV.2** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EEC2EmPKS_IS0_S1_Lj3EE(%class.KV.1* %agg.result, i64 %110, %class.KV.2* %111)
  br label %180

; <label>:112                                     ; preds = %40
  %113 = load i32, i32* %i, align 4
  %114 = zext i32 %113 to i64
  %115 = load %class.KV.2*, %class.KV.2** %data, align 8
  %116 = getelementptr inbounds %class.KV.2, %class.KV.2* %115, i64 %114
  %117 = load i64, i64* %2, align 8
  %118 = lshr i64 %117, 6
  %119 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %120 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  %121 = load i64*, i64** %5, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EE12insert_innerERKS2_mPKS0_PKS1_Pm(%class.KV.2* sret %childkv2, %class.KV.2* dereferenceable(16) %116, i64 %118, %class.scheme_key* %119, %class.scheme_value* %120, i64* %121)
  %122 = load %class.KV.2*, %class.KV.2** %data, align 8
  %123 = load i32, i32* %count, align 4
  %124 = load i32, i32* %i, align 4
  %125 = call %class.KV.2* @_ZN2KVI10scheme_key12scheme_valueLj3EE11update_nodeEPKS2_jjRS3_(%class.KV.2* %122, i32 %123, i32 %124, %class.KV.2* dereferenceable(16) %childkv2)
  store %class.KV.2* %125, %class.KV.2** %node3, align 8
  %126 = load %class.KV.1*, %class.KV.1** %1, align 8
  %127 = getelementptr inbounds %class.KV.1, %class.KV.1* %126, i32 0, i32 0
  %128 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Key"* %127 to i64*
  %129 = load i64, i64* %128, align 8
  %130 = load %class.KV.2*, %class.KV.2** %node3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EEC2EmPKS_IS0_S1_Lj3EE(%class.KV.1* %agg.result, i64 %129, %class.KV.2* %130)
  br label %180

; <label>:131                                     ; preds = %0
  %132 = load i64*, i64** %5, align 8
  %133 = load i64, i64* %132, align 8
  %134 = add i64 %133, 1
  store i64 %134, i64* %132, align 8
  %135 = load i32, i32* %count, align 4
  %136 = add i32 %135, 1
  %137 = zext i32 %136 to i64
  %138 = mul i64 %137, 16
  %139 = call noalias i8* @GC_malloc(i64 %138)
  %140 = bitcast i8* %139 to %class.KV.2*
  store %class.KV.2* %140, %class.KV.2** %node4, align 8
  %141 = load %class.KV.2*, %class.KV.2** %node4, align 8
  %142 = bitcast %class.KV.2* %141 to i8*
  %143 = load %class.KV.2*, %class.KV.2** %data, align 8
  %144 = bitcast %class.KV.2* %143 to i8*
  %145 = load i32, i32* %i, align 4
  %146 = zext i32 %145 to i64
  %147 = mul i64 %146, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %142, i8* %144, i64 %147, i32 8, i1 false)
  %148 = load i32, i32* %i, align 4
  %149 = add i32 %148, 1
  %150 = zext i32 %149 to i64
  %151 = load %class.KV.2*, %class.KV.2** %node4, align 8
  %152 = getelementptr inbounds %class.KV.2, %class.KV.2* %151, i64 %150
  %153 = bitcast %class.KV.2* %152 to i8*
  %154 = load i32, i32* %i, align 4
  %155 = zext i32 %154 to i64
  %156 = load %class.KV.2*, %class.KV.2** %data, align 8
  %157 = getelementptr inbounds %class.KV.2, %class.KV.2* %156, i64 %155
  %158 = bitcast %class.KV.2* %157 to i8*
  %159 = load i32, i32* %count, align 4
  %160 = load i32, i32* %i, align 4
  %161 = sub i32 %159, %160
  %162 = zext i32 %161 to i64
  %163 = mul i64 %162, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %153, i8* %158, i64 %163, i32 8, i1 false)
  %164 = load %class.KV.2*, %class.KV.2** %node4, align 8
  %165 = load i32, i32* %i, align 4
  %166 = zext i32 %165 to i64
  %167 = getelementptr inbounds %class.KV.2, %class.KV.2* %164, i64 %166
  %168 = bitcast %class.KV.2* %167 to i8*
  %169 = bitcast i8* %168 to %class.KV.2*
  %170 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %171 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EEC2EPKS0_PKS1_(%class.KV.2* %169, %class.scheme_key* %170, %class.scheme_value* %171)
  %172 = load i64, i64* %bm, align 8
  %173 = load i32, i32* %hpiece, align 4
  %174 = zext i32 %173 to i64
  %175 = shl i64 1, %174
  %176 = or i64 %172, %175
  %177 = shl i64 %176, 1
  %178 = or i64 %177, 1
  %179 = load %class.KV.2*, %class.KV.2** %node4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EEC2EmPKS_IS0_S1_Lj3EE(%class.KV.1* %agg.result, i64 %178, %class.KV.2* %179)
  br label %180

; <label>:180                                     ; preds = %131, %112, %72, %60
  ret void
}

; Function Attrs: uwtable
define linkonce_odr %class.KV.2* @_ZN2KVI10scheme_key12scheme_valueLj3EE11update_nodeEPKS2_jjRS3_(%class.KV.2* %old, i32 %count, i32 %i, %class.KV.2* dereferenceable(16) %kv) #0 comdat align 2 {
  %1 = alloca %class.KV.2*, align 8
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  %4 = alloca %class.KV.2*, align 8
  %copy = alloca %class.KV.2*, align 8
  store %class.KV.2* %old, %class.KV.2** %1, align 8
  store i32 %count, i32* %2, align 4
  store i32 %i, i32* %3, align 4
  store %class.KV.2* %kv, %class.KV.2** %4, align 8
  %5 = load i32, i32* %2, align 4
  %6 = zext i32 %5 to i64
  %7 = mul i64 %6, 16
  %8 = call noalias i8* @GC_malloc(i64 %7)
  %9 = bitcast i8* %8 to %class.KV.2*
  store %class.KV.2* %9, %class.KV.2** %copy, align 8
  %10 = load %class.KV.2*, %class.KV.2** %copy, align 8
  %11 = bitcast %class.KV.2* %10 to i8*
  %12 = load %class.KV.2*, %class.KV.2** %1, align 8
  %13 = bitcast %class.KV.2* %12 to i8*
  %14 = load i32, i32* %2, align 4
  %15 = zext i32 %14 to i64
  %16 = mul i64 %15, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %13, i64 %16, i32 8, i1 false)
  %17 = load %class.KV.2*, %class.KV.2** %copy, align 8
  %18 = load i32, i32* %3, align 4
  %19 = zext i32 %18 to i64
  %20 = getelementptr inbounds %class.KV.2, %class.KV.2* %17, i64 %19
  %21 = bitcast %class.KV.2* %20 to i8*
  %22 = bitcast i8* %21 to %class.KV.2*
  %23 = load %class.KV.2*, %class.KV.2** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EEC2ERKS2_(%class.KV.2* %22, %class.KV.2* dereferenceable(16) %23)
  %24 = load %class.KV.2*, %class.KV.2** %copy, align 8
  ret %class.KV.2* %24
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj3EE12insert_innerERKS2_mPKS0_PKS1_Pm(%class.KV.2* noalias sret %agg.result, %class.KV.2* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key, %class.scheme_value* %val, i64* %cptr) #0 comdat align 2 {
  %1 = alloca %class.KV.2*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.scheme_key*, align 8
  %4 = alloca %class.scheme_value*, align 8
  %5 = alloca i64*, align 8
  %data = alloca %class.KV.3*, align 8
  %bm = alloca i64, align 8
  %hpiece = alloca i32, align 4
  %count = alloca i32, align 4
  %i = alloca i32, align 4
  %exists = alloca i8, align 1
  %node = alloca %class.KV.3*, align 8
  %6 = alloca %class.KV.3, align 8
  %childkv = alloca %class.KV.3, align 8
  %node1 = alloca %class.KV.3*, align 8
  %childkv2 = alloca %class.KV.3, align 8
  %node3 = alloca %class.KV.3*, align 8
  %node4 = alloca %class.KV.3*, align 8
  store %class.KV.2* %kv, %class.KV.2** %1, align 8
  store i64 %h, i64* %2, align 8
  store %class.scheme_key* %key, %class.scheme_key** %3, align 8
  store %class.scheme_value* %val, %class.scheme_value** %4, align 8
  store i64* %cptr, i64** %5, align 8
  %7 = load %class.KV.2*, %class.KV.2** %1, align 8
  %8 = getelementptr inbounds %class.KV.2, %class.KV.2* %7, i32 0, i32 1
  %9 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Val"* %8 to %class.KV.3**
  %10 = load %class.KV.3*, %class.KV.3** %9, align 8
  store %class.KV.3* %10, %class.KV.3** %data, align 8
  %11 = load %class.KV.2*, %class.KV.2** %1, align 8
  %12 = getelementptr inbounds %class.KV.2, %class.KV.2* %11, i32 0, i32 0
  %13 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Key"* %12 to i64*
  %14 = load i64, i64* %13, align 8
  %15 = lshr i64 %14, 1
  store i64 %15, i64* %bm, align 8
  %16 = load i64, i64* %2, align 8
  %17 = and i64 %16, 63
  %18 = urem i64 %17, 63
  %19 = trunc i64 %18 to i32
  store i32 %19, i32* %hpiece, align 4
  %20 = load i64, i64* %bm, align 8
  %21 = call i64 @llvm.ctpop.i64(i64 %20)
  %22 = trunc i64 %21 to i32
  store i32 %22, i32* %count, align 4
  %23 = load i64, i64* %bm, align 8
  %24 = shl i64 %23, 1
  %25 = load i32, i32* %hpiece, align 4
  %26 = sub i32 63, %25
  %27 = zext i32 %26 to i64
  %28 = shl i64 %24, %27
  %29 = call i64 @llvm.ctpop.i64(i64 %28)
  %30 = trunc i64 %29 to i32
  store i32 %30, i32* %i, align 4
  %31 = load i64, i64* %bm, align 8
  %32 = load i32, i32* %hpiece, align 4
  %33 = zext i32 %32 to i64
  %34 = shl i64 1, %33
  %35 = and i64 %31, %34
  %36 = icmp ne i64 %35, 0
  %37 = zext i1 %36 to i8
  store i8 %37, i8* %exists, align 1
  %38 = load i8, i8* %exists, align 1
  %39 = trunc i8 %38 to i1
  br i1 %39, label %40, label %131

; <label>:40                                      ; preds = %0
  %41 = load i32, i32* %i, align 4
  %42 = zext i32 %41 to i64
  %43 = load %class.KV.3*, %class.KV.3** %data, align 8
  %44 = getelementptr inbounds %class.KV.3, %class.KV.3* %43, i64 %42
  %45 = getelementptr inbounds %class.KV.3, %class.KV.3* %44, i32 0, i32 0
  %46 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Key"* %45 to i64*
  %47 = load i64, i64* %46, align 8
  %48 = and i64 %47, 1
  %49 = icmp eq i64 %48, 0
  br i1 %49, label %50, label %112

; <label>:50                                      ; preds = %40
  %51 = load i32, i32* %i, align 4
  %52 = zext i32 %51 to i64
  %53 = load %class.KV.3*, %class.KV.3** %data, align 8
  %54 = getelementptr inbounds %class.KV.3, %class.KV.3* %53, i64 %52
  %55 = getelementptr inbounds %class.KV.3, %class.KV.3* %54, i32 0, i32 0
  %56 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Key"* %55 to %class.scheme_key**
  %57 = load %class.scheme_key*, %class.scheme_key** %56, align 8
  %58 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %59 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %57, %class.scheme_key* dereferenceable(8) %58)
  br i1 %59, label %60, label %72

; <label>:60                                      ; preds = %50
  %61 = load %class.KV.3*, %class.KV.3** %data, align 8
  %62 = load i32, i32* %count, align 4
  %63 = load i32, i32* %i, align 4
  %64 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %65 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EEC2EPKS0_PKS1_(%class.KV.3* %6, %class.scheme_key* %64, %class.scheme_value* %65)
  %66 = call %class.KV.3* @_ZN2KVI10scheme_key12scheme_valueLj4EE11update_nodeEPKS2_jjRS3_(%class.KV.3* %61, i32 %62, i32 %63, %class.KV.3* dereferenceable(16) %6)
  store %class.KV.3* %66, %class.KV.3** %node, align 8
  %67 = load %class.KV.2*, %class.KV.2** %1, align 8
  %68 = getelementptr inbounds %class.KV.2, %class.KV.2* %67, i32 0, i32 0
  %69 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Key"* %68 to i64*
  %70 = load i64, i64* %69, align 8
  %71 = load %class.KV.3*, %class.KV.3** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EEC2EmPKS_IS0_S1_Lj4EE(%class.KV.2* %agg.result, i64 %70, %class.KV.3* %71)
  br label %180

; <label>:72                                      ; preds = %50
  %73 = load i64*, i64** %5, align 8
  %74 = load i64, i64* %73, align 8
  %75 = add i64 %74, 1
  store i64 %75, i64* %73, align 8
  %76 = load i32, i32* %i, align 4
  %77 = zext i32 %76 to i64
  %78 = load %class.KV.3*, %class.KV.3** %data, align 8
  %79 = getelementptr inbounds %class.KV.3, %class.KV.3* %78, i64 %77
  %80 = getelementptr inbounds %class.KV.3, %class.KV.3* %79, i32 0, i32 0
  %81 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Key"* %80 to %class.scheme_key**
  %82 = load %class.scheme_key*, %class.scheme_key** %81, align 8
  %83 = call i64 @_ZNK10scheme_key4hashEv(%class.scheme_key* %82)
  %84 = lshr i64 %83, 28
  %85 = load i32, i32* %i, align 4
  %86 = zext i32 %85 to i64
  %87 = load %class.KV.3*, %class.KV.3** %data, align 8
  %88 = getelementptr inbounds %class.KV.3, %class.KV.3* %87, i64 %86
  %89 = getelementptr inbounds %class.KV.3, %class.KV.3* %88, i32 0, i32 0
  %90 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Key"* %89 to %class.scheme_key**
  %91 = load %class.scheme_key*, %class.scheme_key** %90, align 8
  %92 = load i32, i32* %i, align 4
  %93 = zext i32 %92 to i64
  %94 = load %class.KV.3*, %class.KV.3** %data, align 8
  %95 = getelementptr inbounds %class.KV.3, %class.KV.3* %94, i64 %93
  %96 = getelementptr inbounds %class.KV.3, %class.KV.3* %95, i32 0, i32 1
  %97 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Val"* %96 to %class.scheme_value**
  %98 = load %class.scheme_value*, %class.scheme_value** %97, align 8
  %99 = load i64, i64* %2, align 8
  %100 = lshr i64 %99, 6
  %101 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %102 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.3* sret %childkv, i64 %84, %class.scheme_key* %91, %class.scheme_value* %98, i64 %100, %class.scheme_key* %101, %class.scheme_value* %102)
  %103 = load %class.KV.3*, %class.KV.3** %data, align 8
  %104 = load i32, i32* %count, align 4
  %105 = load i32, i32* %i, align 4
  %106 = call %class.KV.3* @_ZN2KVI10scheme_key12scheme_valueLj4EE11update_nodeEPKS2_jjRS3_(%class.KV.3* %103, i32 %104, i32 %105, %class.KV.3* dereferenceable(16) %childkv)
  store %class.KV.3* %106, %class.KV.3** %node1, align 8
  %107 = load %class.KV.2*, %class.KV.2** %1, align 8
  %108 = getelementptr inbounds %class.KV.2, %class.KV.2* %107, i32 0, i32 0
  %109 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Key"* %108 to i64*
  %110 = load i64, i64* %109, align 8
  %111 = load %class.KV.3*, %class.KV.3** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EEC2EmPKS_IS0_S1_Lj4EE(%class.KV.2* %agg.result, i64 %110, %class.KV.3* %111)
  br label %180

; <label>:112                                     ; preds = %40
  %113 = load i32, i32* %i, align 4
  %114 = zext i32 %113 to i64
  %115 = load %class.KV.3*, %class.KV.3** %data, align 8
  %116 = getelementptr inbounds %class.KV.3, %class.KV.3* %115, i64 %114
  %117 = load i64, i64* %2, align 8
  %118 = lshr i64 %117, 6
  %119 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %120 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  %121 = load i64*, i64** %5, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EE12insert_innerERKS2_mPKS0_PKS1_Pm(%class.KV.3* sret %childkv2, %class.KV.3* dereferenceable(16) %116, i64 %118, %class.scheme_key* %119, %class.scheme_value* %120, i64* %121)
  %122 = load %class.KV.3*, %class.KV.3** %data, align 8
  %123 = load i32, i32* %count, align 4
  %124 = load i32, i32* %i, align 4
  %125 = call %class.KV.3* @_ZN2KVI10scheme_key12scheme_valueLj4EE11update_nodeEPKS2_jjRS3_(%class.KV.3* %122, i32 %123, i32 %124, %class.KV.3* dereferenceable(16) %childkv2)
  store %class.KV.3* %125, %class.KV.3** %node3, align 8
  %126 = load %class.KV.2*, %class.KV.2** %1, align 8
  %127 = getelementptr inbounds %class.KV.2, %class.KV.2* %126, i32 0, i32 0
  %128 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Key"* %127 to i64*
  %129 = load i64, i64* %128, align 8
  %130 = load %class.KV.3*, %class.KV.3** %node3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EEC2EmPKS_IS0_S1_Lj4EE(%class.KV.2* %agg.result, i64 %129, %class.KV.3* %130)
  br label %180

; <label>:131                                     ; preds = %0
  %132 = load i64*, i64** %5, align 8
  %133 = load i64, i64* %132, align 8
  %134 = add i64 %133, 1
  store i64 %134, i64* %132, align 8
  %135 = load i32, i32* %count, align 4
  %136 = add i32 %135, 1
  %137 = zext i32 %136 to i64
  %138 = mul i64 %137, 16
  %139 = call noalias i8* @GC_malloc(i64 %138)
  %140 = bitcast i8* %139 to %class.KV.3*
  store %class.KV.3* %140, %class.KV.3** %node4, align 8
  %141 = load %class.KV.3*, %class.KV.3** %node4, align 8
  %142 = bitcast %class.KV.3* %141 to i8*
  %143 = load %class.KV.3*, %class.KV.3** %data, align 8
  %144 = bitcast %class.KV.3* %143 to i8*
  %145 = load i32, i32* %i, align 4
  %146 = zext i32 %145 to i64
  %147 = mul i64 %146, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %142, i8* %144, i64 %147, i32 8, i1 false)
  %148 = load i32, i32* %i, align 4
  %149 = add i32 %148, 1
  %150 = zext i32 %149 to i64
  %151 = load %class.KV.3*, %class.KV.3** %node4, align 8
  %152 = getelementptr inbounds %class.KV.3, %class.KV.3* %151, i64 %150
  %153 = bitcast %class.KV.3* %152 to i8*
  %154 = load i32, i32* %i, align 4
  %155 = zext i32 %154 to i64
  %156 = load %class.KV.3*, %class.KV.3** %data, align 8
  %157 = getelementptr inbounds %class.KV.3, %class.KV.3* %156, i64 %155
  %158 = bitcast %class.KV.3* %157 to i8*
  %159 = load i32, i32* %count, align 4
  %160 = load i32, i32* %i, align 4
  %161 = sub i32 %159, %160
  %162 = zext i32 %161 to i64
  %163 = mul i64 %162, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %153, i8* %158, i64 %163, i32 8, i1 false)
  %164 = load %class.KV.3*, %class.KV.3** %node4, align 8
  %165 = load i32, i32* %i, align 4
  %166 = zext i32 %165 to i64
  %167 = getelementptr inbounds %class.KV.3, %class.KV.3* %164, i64 %166
  %168 = bitcast %class.KV.3* %167 to i8*
  %169 = bitcast i8* %168 to %class.KV.3*
  %170 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %171 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EEC2EPKS0_PKS1_(%class.KV.3* %169, %class.scheme_key* %170, %class.scheme_value* %171)
  %172 = load i64, i64* %bm, align 8
  %173 = load i32, i32* %hpiece, align 4
  %174 = zext i32 %173 to i64
  %175 = shl i64 1, %174
  %176 = or i64 %172, %175
  %177 = shl i64 %176, 1
  %178 = or i64 %177, 1
  %179 = load %class.KV.3*, %class.KV.3** %node4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EEC2EmPKS_IS0_S1_Lj4EE(%class.KV.2* %agg.result, i64 %178, %class.KV.3* %179)
  br label %180

; <label>:180                                     ; preds = %131, %112, %72, %60
  ret void
}

; Function Attrs: uwtable
define linkonce_odr %class.KV.3* @_ZN2KVI10scheme_key12scheme_valueLj4EE11update_nodeEPKS2_jjRS3_(%class.KV.3* %old, i32 %count, i32 %i, %class.KV.3* dereferenceable(16) %kv) #0 comdat align 2 {
  %1 = alloca %class.KV.3*, align 8
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  %4 = alloca %class.KV.3*, align 8
  %copy = alloca %class.KV.3*, align 8
  store %class.KV.3* %old, %class.KV.3** %1, align 8
  store i32 %count, i32* %2, align 4
  store i32 %i, i32* %3, align 4
  store %class.KV.3* %kv, %class.KV.3** %4, align 8
  %5 = load i32, i32* %2, align 4
  %6 = zext i32 %5 to i64
  %7 = mul i64 %6, 16
  %8 = call noalias i8* @GC_malloc(i64 %7)
  %9 = bitcast i8* %8 to %class.KV.3*
  store %class.KV.3* %9, %class.KV.3** %copy, align 8
  %10 = load %class.KV.3*, %class.KV.3** %copy, align 8
  %11 = bitcast %class.KV.3* %10 to i8*
  %12 = load %class.KV.3*, %class.KV.3** %1, align 8
  %13 = bitcast %class.KV.3* %12 to i8*
  %14 = load i32, i32* %2, align 4
  %15 = zext i32 %14 to i64
  %16 = mul i64 %15, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %13, i64 %16, i32 8, i1 false)
  %17 = load %class.KV.3*, %class.KV.3** %copy, align 8
  %18 = load i32, i32* %3, align 4
  %19 = zext i32 %18 to i64
  %20 = getelementptr inbounds %class.KV.3, %class.KV.3* %17, i64 %19
  %21 = bitcast %class.KV.3* %20 to i8*
  %22 = bitcast i8* %21 to %class.KV.3*
  %23 = load %class.KV.3*, %class.KV.3** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EEC2ERKS2_(%class.KV.3* %22, %class.KV.3* dereferenceable(16) %23)
  %24 = load %class.KV.3*, %class.KV.3** %copy, align 8
  ret %class.KV.3* %24
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj4EE12insert_innerERKS2_mPKS0_PKS1_Pm(%class.KV.3* noalias sret %agg.result, %class.KV.3* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key, %class.scheme_value* %val, i64* %cptr) #0 comdat align 2 {
  %1 = alloca %class.KV.3*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.scheme_key*, align 8
  %4 = alloca %class.scheme_value*, align 8
  %5 = alloca i64*, align 8
  %data = alloca %class.KV.4*, align 8
  %bm = alloca i64, align 8
  %hpiece = alloca i32, align 4
  %count = alloca i32, align 4
  %i = alloca i32, align 4
  %exists = alloca i8, align 1
  %node = alloca %class.KV.4*, align 8
  %6 = alloca %class.KV.4, align 8
  %childkv = alloca %class.KV.4, align 8
  %node1 = alloca %class.KV.4*, align 8
  %childkv2 = alloca %class.KV.4, align 8
  %node3 = alloca %class.KV.4*, align 8
  %node4 = alloca %class.KV.4*, align 8
  store %class.KV.3* %kv, %class.KV.3** %1, align 8
  store i64 %h, i64* %2, align 8
  store %class.scheme_key* %key, %class.scheme_key** %3, align 8
  store %class.scheme_value* %val, %class.scheme_value** %4, align 8
  store i64* %cptr, i64** %5, align 8
  %7 = load %class.KV.3*, %class.KV.3** %1, align 8
  %8 = getelementptr inbounds %class.KV.3, %class.KV.3* %7, i32 0, i32 1
  %9 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Val"* %8 to %class.KV.4**
  %10 = load %class.KV.4*, %class.KV.4** %9, align 8
  store %class.KV.4* %10, %class.KV.4** %data, align 8
  %11 = load %class.KV.3*, %class.KV.3** %1, align 8
  %12 = getelementptr inbounds %class.KV.3, %class.KV.3* %11, i32 0, i32 0
  %13 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Key"* %12 to i64*
  %14 = load i64, i64* %13, align 8
  %15 = lshr i64 %14, 1
  store i64 %15, i64* %bm, align 8
  %16 = load i64, i64* %2, align 8
  %17 = and i64 %16, 63
  %18 = urem i64 %17, 63
  %19 = trunc i64 %18 to i32
  store i32 %19, i32* %hpiece, align 4
  %20 = load i64, i64* %bm, align 8
  %21 = call i64 @llvm.ctpop.i64(i64 %20)
  %22 = trunc i64 %21 to i32
  store i32 %22, i32* %count, align 4
  %23 = load i64, i64* %bm, align 8
  %24 = shl i64 %23, 1
  %25 = load i32, i32* %hpiece, align 4
  %26 = sub i32 63, %25
  %27 = zext i32 %26 to i64
  %28 = shl i64 %24, %27
  %29 = call i64 @llvm.ctpop.i64(i64 %28)
  %30 = trunc i64 %29 to i32
  store i32 %30, i32* %i, align 4
  %31 = load i64, i64* %bm, align 8
  %32 = load i32, i32* %hpiece, align 4
  %33 = zext i32 %32 to i64
  %34 = shl i64 1, %33
  %35 = and i64 %31, %34
  %36 = icmp ne i64 %35, 0
  %37 = zext i1 %36 to i8
  store i8 %37, i8* %exists, align 1
  %38 = load i8, i8* %exists, align 1
  %39 = trunc i8 %38 to i1
  br i1 %39, label %40, label %131

; <label>:40                                      ; preds = %0
  %41 = load i32, i32* %i, align 4
  %42 = zext i32 %41 to i64
  %43 = load %class.KV.4*, %class.KV.4** %data, align 8
  %44 = getelementptr inbounds %class.KV.4, %class.KV.4* %43, i64 %42
  %45 = getelementptr inbounds %class.KV.4, %class.KV.4* %44, i32 0, i32 0
  %46 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Key"* %45 to i64*
  %47 = load i64, i64* %46, align 8
  %48 = and i64 %47, 1
  %49 = icmp eq i64 %48, 0
  br i1 %49, label %50, label %112

; <label>:50                                      ; preds = %40
  %51 = load i32, i32* %i, align 4
  %52 = zext i32 %51 to i64
  %53 = load %class.KV.4*, %class.KV.4** %data, align 8
  %54 = getelementptr inbounds %class.KV.4, %class.KV.4* %53, i64 %52
  %55 = getelementptr inbounds %class.KV.4, %class.KV.4* %54, i32 0, i32 0
  %56 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Key"* %55 to %class.scheme_key**
  %57 = load %class.scheme_key*, %class.scheme_key** %56, align 8
  %58 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %59 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %57, %class.scheme_key* dereferenceable(8) %58)
  br i1 %59, label %60, label %72

; <label>:60                                      ; preds = %50
  %61 = load %class.KV.4*, %class.KV.4** %data, align 8
  %62 = load i32, i32* %count, align 4
  %63 = load i32, i32* %i, align 4
  %64 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %65 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EEC2EPKS0_PKS1_(%class.KV.4* %6, %class.scheme_key* %64, %class.scheme_value* %65)
  %66 = call %class.KV.4* @_ZN2KVI10scheme_key12scheme_valueLj5EE11update_nodeEPKS2_jjRS3_(%class.KV.4* %61, i32 %62, i32 %63, %class.KV.4* dereferenceable(16) %6)
  store %class.KV.4* %66, %class.KV.4** %node, align 8
  %67 = load %class.KV.3*, %class.KV.3** %1, align 8
  %68 = getelementptr inbounds %class.KV.3, %class.KV.3* %67, i32 0, i32 0
  %69 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Key"* %68 to i64*
  %70 = load i64, i64* %69, align 8
  %71 = load %class.KV.4*, %class.KV.4** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EEC2EmPKS_IS0_S1_Lj5EE(%class.KV.3* %agg.result, i64 %70, %class.KV.4* %71)
  br label %180

; <label>:72                                      ; preds = %50
  %73 = load i64*, i64** %5, align 8
  %74 = load i64, i64* %73, align 8
  %75 = add i64 %74, 1
  store i64 %75, i64* %73, align 8
  %76 = load i32, i32* %i, align 4
  %77 = zext i32 %76 to i64
  %78 = load %class.KV.4*, %class.KV.4** %data, align 8
  %79 = getelementptr inbounds %class.KV.4, %class.KV.4* %78, i64 %77
  %80 = getelementptr inbounds %class.KV.4, %class.KV.4* %79, i32 0, i32 0
  %81 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Key"* %80 to %class.scheme_key**
  %82 = load %class.scheme_key*, %class.scheme_key** %81, align 8
  %83 = call i64 @_ZNK10scheme_key4hashEv(%class.scheme_key* %82)
  %84 = lshr i64 %83, 34
  %85 = load i32, i32* %i, align 4
  %86 = zext i32 %85 to i64
  %87 = load %class.KV.4*, %class.KV.4** %data, align 8
  %88 = getelementptr inbounds %class.KV.4, %class.KV.4* %87, i64 %86
  %89 = getelementptr inbounds %class.KV.4, %class.KV.4* %88, i32 0, i32 0
  %90 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Key"* %89 to %class.scheme_key**
  %91 = load %class.scheme_key*, %class.scheme_key** %90, align 8
  %92 = load i32, i32* %i, align 4
  %93 = zext i32 %92 to i64
  %94 = load %class.KV.4*, %class.KV.4** %data, align 8
  %95 = getelementptr inbounds %class.KV.4, %class.KV.4* %94, i64 %93
  %96 = getelementptr inbounds %class.KV.4, %class.KV.4* %95, i32 0, i32 1
  %97 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Val"* %96 to %class.scheme_value**
  %98 = load %class.scheme_value*, %class.scheme_value** %97, align 8
  %99 = load i64, i64* %2, align 8
  %100 = lshr i64 %99, 6
  %101 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %102 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.4* sret %childkv, i64 %84, %class.scheme_key* %91, %class.scheme_value* %98, i64 %100, %class.scheme_key* %101, %class.scheme_value* %102)
  %103 = load %class.KV.4*, %class.KV.4** %data, align 8
  %104 = load i32, i32* %count, align 4
  %105 = load i32, i32* %i, align 4
  %106 = call %class.KV.4* @_ZN2KVI10scheme_key12scheme_valueLj5EE11update_nodeEPKS2_jjRS3_(%class.KV.4* %103, i32 %104, i32 %105, %class.KV.4* dereferenceable(16) %childkv)
  store %class.KV.4* %106, %class.KV.4** %node1, align 8
  %107 = load %class.KV.3*, %class.KV.3** %1, align 8
  %108 = getelementptr inbounds %class.KV.3, %class.KV.3* %107, i32 0, i32 0
  %109 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Key"* %108 to i64*
  %110 = load i64, i64* %109, align 8
  %111 = load %class.KV.4*, %class.KV.4** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EEC2EmPKS_IS0_S1_Lj5EE(%class.KV.3* %agg.result, i64 %110, %class.KV.4* %111)
  br label %180

; <label>:112                                     ; preds = %40
  %113 = load i32, i32* %i, align 4
  %114 = zext i32 %113 to i64
  %115 = load %class.KV.4*, %class.KV.4** %data, align 8
  %116 = getelementptr inbounds %class.KV.4, %class.KV.4* %115, i64 %114
  %117 = load i64, i64* %2, align 8
  %118 = lshr i64 %117, 6
  %119 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %120 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  %121 = load i64*, i64** %5, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EE12insert_innerERKS2_mPKS0_PKS1_Pm(%class.KV.4* sret %childkv2, %class.KV.4* dereferenceable(16) %116, i64 %118, %class.scheme_key* %119, %class.scheme_value* %120, i64* %121)
  %122 = load %class.KV.4*, %class.KV.4** %data, align 8
  %123 = load i32, i32* %count, align 4
  %124 = load i32, i32* %i, align 4
  %125 = call %class.KV.4* @_ZN2KVI10scheme_key12scheme_valueLj5EE11update_nodeEPKS2_jjRS3_(%class.KV.4* %122, i32 %123, i32 %124, %class.KV.4* dereferenceable(16) %childkv2)
  store %class.KV.4* %125, %class.KV.4** %node3, align 8
  %126 = load %class.KV.3*, %class.KV.3** %1, align 8
  %127 = getelementptr inbounds %class.KV.3, %class.KV.3* %126, i32 0, i32 0
  %128 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Key"* %127 to i64*
  %129 = load i64, i64* %128, align 8
  %130 = load %class.KV.4*, %class.KV.4** %node3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EEC2EmPKS_IS0_S1_Lj5EE(%class.KV.3* %agg.result, i64 %129, %class.KV.4* %130)
  br label %180

; <label>:131                                     ; preds = %0
  %132 = load i64*, i64** %5, align 8
  %133 = load i64, i64* %132, align 8
  %134 = add i64 %133, 1
  store i64 %134, i64* %132, align 8
  %135 = load i32, i32* %count, align 4
  %136 = add i32 %135, 1
  %137 = zext i32 %136 to i64
  %138 = mul i64 %137, 16
  %139 = call noalias i8* @GC_malloc(i64 %138)
  %140 = bitcast i8* %139 to %class.KV.4*
  store %class.KV.4* %140, %class.KV.4** %node4, align 8
  %141 = load %class.KV.4*, %class.KV.4** %node4, align 8
  %142 = bitcast %class.KV.4* %141 to i8*
  %143 = load %class.KV.4*, %class.KV.4** %data, align 8
  %144 = bitcast %class.KV.4* %143 to i8*
  %145 = load i32, i32* %i, align 4
  %146 = zext i32 %145 to i64
  %147 = mul i64 %146, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %142, i8* %144, i64 %147, i32 8, i1 false)
  %148 = load i32, i32* %i, align 4
  %149 = add i32 %148, 1
  %150 = zext i32 %149 to i64
  %151 = load %class.KV.4*, %class.KV.4** %node4, align 8
  %152 = getelementptr inbounds %class.KV.4, %class.KV.4* %151, i64 %150
  %153 = bitcast %class.KV.4* %152 to i8*
  %154 = load i32, i32* %i, align 4
  %155 = zext i32 %154 to i64
  %156 = load %class.KV.4*, %class.KV.4** %data, align 8
  %157 = getelementptr inbounds %class.KV.4, %class.KV.4* %156, i64 %155
  %158 = bitcast %class.KV.4* %157 to i8*
  %159 = load i32, i32* %count, align 4
  %160 = load i32, i32* %i, align 4
  %161 = sub i32 %159, %160
  %162 = zext i32 %161 to i64
  %163 = mul i64 %162, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %153, i8* %158, i64 %163, i32 8, i1 false)
  %164 = load %class.KV.4*, %class.KV.4** %node4, align 8
  %165 = load i32, i32* %i, align 4
  %166 = zext i32 %165 to i64
  %167 = getelementptr inbounds %class.KV.4, %class.KV.4* %164, i64 %166
  %168 = bitcast %class.KV.4* %167 to i8*
  %169 = bitcast i8* %168 to %class.KV.4*
  %170 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %171 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EEC2EPKS0_PKS1_(%class.KV.4* %169, %class.scheme_key* %170, %class.scheme_value* %171)
  %172 = load i64, i64* %bm, align 8
  %173 = load i32, i32* %hpiece, align 4
  %174 = zext i32 %173 to i64
  %175 = shl i64 1, %174
  %176 = or i64 %172, %175
  %177 = shl i64 %176, 1
  %178 = or i64 %177, 1
  %179 = load %class.KV.4*, %class.KV.4** %node4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EEC2EmPKS_IS0_S1_Lj5EE(%class.KV.3* %agg.result, i64 %178, %class.KV.4* %179)
  br label %180

; <label>:180                                     ; preds = %131, %112, %72, %60
  ret void
}

; Function Attrs: uwtable
define linkonce_odr %class.KV.4* @_ZN2KVI10scheme_key12scheme_valueLj5EE11update_nodeEPKS2_jjRS3_(%class.KV.4* %old, i32 %count, i32 %i, %class.KV.4* dereferenceable(16) %kv) #0 comdat align 2 {
  %1 = alloca %class.KV.4*, align 8
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  %4 = alloca %class.KV.4*, align 8
  %copy = alloca %class.KV.4*, align 8
  store %class.KV.4* %old, %class.KV.4** %1, align 8
  store i32 %count, i32* %2, align 4
  store i32 %i, i32* %3, align 4
  store %class.KV.4* %kv, %class.KV.4** %4, align 8
  %5 = load i32, i32* %2, align 4
  %6 = zext i32 %5 to i64
  %7 = mul i64 %6, 16
  %8 = call noalias i8* @GC_malloc(i64 %7)
  %9 = bitcast i8* %8 to %class.KV.4*
  store %class.KV.4* %9, %class.KV.4** %copy, align 8
  %10 = load %class.KV.4*, %class.KV.4** %copy, align 8
  %11 = bitcast %class.KV.4* %10 to i8*
  %12 = load %class.KV.4*, %class.KV.4** %1, align 8
  %13 = bitcast %class.KV.4* %12 to i8*
  %14 = load i32, i32* %2, align 4
  %15 = zext i32 %14 to i64
  %16 = mul i64 %15, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %13, i64 %16, i32 8, i1 false)
  %17 = load %class.KV.4*, %class.KV.4** %copy, align 8
  %18 = load i32, i32* %3, align 4
  %19 = zext i32 %18 to i64
  %20 = getelementptr inbounds %class.KV.4, %class.KV.4* %17, i64 %19
  %21 = bitcast %class.KV.4* %20 to i8*
  %22 = bitcast i8* %21 to %class.KV.4*
  %23 = load %class.KV.4*, %class.KV.4** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EEC2ERKS2_(%class.KV.4* %22, %class.KV.4* dereferenceable(16) %23)
  %24 = load %class.KV.4*, %class.KV.4** %copy, align 8
  ret %class.KV.4* %24
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj5EE12insert_innerERKS2_mPKS0_PKS1_Pm(%class.KV.4* noalias sret %agg.result, %class.KV.4* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key, %class.scheme_value* %val, i64* %cptr) #0 comdat align 2 {
  %1 = alloca %class.KV.4*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.scheme_key*, align 8
  %4 = alloca %class.scheme_value*, align 8
  %5 = alloca i64*, align 8
  %data = alloca %class.KV.5*, align 8
  %bm = alloca i64, align 8
  %hpiece = alloca i32, align 4
  %count = alloca i32, align 4
  %i = alloca i32, align 4
  %exists = alloca i8, align 1
  %node = alloca %class.KV.5*, align 8
  %6 = alloca %class.KV.5, align 8
  %childkv = alloca %class.KV.5, align 8
  %node1 = alloca %class.KV.5*, align 8
  %childkv2 = alloca %class.KV.5, align 8
  %node3 = alloca %class.KV.5*, align 8
  %node4 = alloca %class.KV.5*, align 8
  store %class.KV.4* %kv, %class.KV.4** %1, align 8
  store i64 %h, i64* %2, align 8
  store %class.scheme_key* %key, %class.scheme_key** %3, align 8
  store %class.scheme_value* %val, %class.scheme_value** %4, align 8
  store i64* %cptr, i64** %5, align 8
  %7 = load %class.KV.4*, %class.KV.4** %1, align 8
  %8 = getelementptr inbounds %class.KV.4, %class.KV.4* %7, i32 0, i32 1
  %9 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Val"* %8 to %class.KV.5**
  %10 = load %class.KV.5*, %class.KV.5** %9, align 8
  store %class.KV.5* %10, %class.KV.5** %data, align 8
  %11 = load %class.KV.4*, %class.KV.4** %1, align 8
  %12 = getelementptr inbounds %class.KV.4, %class.KV.4* %11, i32 0, i32 0
  %13 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Key"* %12 to i64*
  %14 = load i64, i64* %13, align 8
  %15 = lshr i64 %14, 1
  store i64 %15, i64* %bm, align 8
  %16 = load i64, i64* %2, align 8
  %17 = and i64 %16, 63
  %18 = urem i64 %17, 63
  %19 = trunc i64 %18 to i32
  store i32 %19, i32* %hpiece, align 4
  %20 = load i64, i64* %bm, align 8
  %21 = call i64 @llvm.ctpop.i64(i64 %20)
  %22 = trunc i64 %21 to i32
  store i32 %22, i32* %count, align 4
  %23 = load i64, i64* %bm, align 8
  %24 = shl i64 %23, 1
  %25 = load i32, i32* %hpiece, align 4
  %26 = sub i32 63, %25
  %27 = zext i32 %26 to i64
  %28 = shl i64 %24, %27
  %29 = call i64 @llvm.ctpop.i64(i64 %28)
  %30 = trunc i64 %29 to i32
  store i32 %30, i32* %i, align 4
  %31 = load i64, i64* %bm, align 8
  %32 = load i32, i32* %hpiece, align 4
  %33 = zext i32 %32 to i64
  %34 = shl i64 1, %33
  %35 = and i64 %31, %34
  %36 = icmp ne i64 %35, 0
  %37 = zext i1 %36 to i8
  store i8 %37, i8* %exists, align 1
  %38 = load i8, i8* %exists, align 1
  %39 = trunc i8 %38 to i1
  br i1 %39, label %40, label %131

; <label>:40                                      ; preds = %0
  %41 = load i32, i32* %i, align 4
  %42 = zext i32 %41 to i64
  %43 = load %class.KV.5*, %class.KV.5** %data, align 8
  %44 = getelementptr inbounds %class.KV.5, %class.KV.5* %43, i64 %42
  %45 = getelementptr inbounds %class.KV.5, %class.KV.5* %44, i32 0, i32 0
  %46 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Key"* %45 to i64*
  %47 = load i64, i64* %46, align 8
  %48 = and i64 %47, 1
  %49 = icmp eq i64 %48, 0
  br i1 %49, label %50, label %112

; <label>:50                                      ; preds = %40
  %51 = load i32, i32* %i, align 4
  %52 = zext i32 %51 to i64
  %53 = load %class.KV.5*, %class.KV.5** %data, align 8
  %54 = getelementptr inbounds %class.KV.5, %class.KV.5* %53, i64 %52
  %55 = getelementptr inbounds %class.KV.5, %class.KV.5* %54, i32 0, i32 0
  %56 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Key"* %55 to %class.scheme_key**
  %57 = load %class.scheme_key*, %class.scheme_key** %56, align 8
  %58 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %59 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %57, %class.scheme_key* dereferenceable(8) %58)
  br i1 %59, label %60, label %72

; <label>:60                                      ; preds = %50
  %61 = load %class.KV.5*, %class.KV.5** %data, align 8
  %62 = load i32, i32* %count, align 4
  %63 = load i32, i32* %i, align 4
  %64 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %65 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EEC2EPKS0_PKS1_(%class.KV.5* %6, %class.scheme_key* %64, %class.scheme_value* %65)
  %66 = call %class.KV.5* @_ZN2KVI10scheme_key12scheme_valueLj6EE11update_nodeEPKS2_jjRS3_(%class.KV.5* %61, i32 %62, i32 %63, %class.KV.5* dereferenceable(16) %6)
  store %class.KV.5* %66, %class.KV.5** %node, align 8
  %67 = load %class.KV.4*, %class.KV.4** %1, align 8
  %68 = getelementptr inbounds %class.KV.4, %class.KV.4* %67, i32 0, i32 0
  %69 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Key"* %68 to i64*
  %70 = load i64, i64* %69, align 8
  %71 = load %class.KV.5*, %class.KV.5** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EEC2EmPKS_IS0_S1_Lj6EE(%class.KV.4* %agg.result, i64 %70, %class.KV.5* %71)
  br label %180

; <label>:72                                      ; preds = %50
  %73 = load i64*, i64** %5, align 8
  %74 = load i64, i64* %73, align 8
  %75 = add i64 %74, 1
  store i64 %75, i64* %73, align 8
  %76 = load i32, i32* %i, align 4
  %77 = zext i32 %76 to i64
  %78 = load %class.KV.5*, %class.KV.5** %data, align 8
  %79 = getelementptr inbounds %class.KV.5, %class.KV.5* %78, i64 %77
  %80 = getelementptr inbounds %class.KV.5, %class.KV.5* %79, i32 0, i32 0
  %81 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Key"* %80 to %class.scheme_key**
  %82 = load %class.scheme_key*, %class.scheme_key** %81, align 8
  %83 = call i64 @_ZNK10scheme_key4hashEv(%class.scheme_key* %82)
  %84 = lshr i64 %83, 40
  %85 = load i32, i32* %i, align 4
  %86 = zext i32 %85 to i64
  %87 = load %class.KV.5*, %class.KV.5** %data, align 8
  %88 = getelementptr inbounds %class.KV.5, %class.KV.5* %87, i64 %86
  %89 = getelementptr inbounds %class.KV.5, %class.KV.5* %88, i32 0, i32 0
  %90 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Key"* %89 to %class.scheme_key**
  %91 = load %class.scheme_key*, %class.scheme_key** %90, align 8
  %92 = load i32, i32* %i, align 4
  %93 = zext i32 %92 to i64
  %94 = load %class.KV.5*, %class.KV.5** %data, align 8
  %95 = getelementptr inbounds %class.KV.5, %class.KV.5* %94, i64 %93
  %96 = getelementptr inbounds %class.KV.5, %class.KV.5* %95, i32 0, i32 1
  %97 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Val"* %96 to %class.scheme_value**
  %98 = load %class.scheme_value*, %class.scheme_value** %97, align 8
  %99 = load i64, i64* %2, align 8
  %100 = lshr i64 %99, 6
  %101 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %102 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.5* sret %childkv, i64 %84, %class.scheme_key* %91, %class.scheme_value* %98, i64 %100, %class.scheme_key* %101, %class.scheme_value* %102)
  %103 = load %class.KV.5*, %class.KV.5** %data, align 8
  %104 = load i32, i32* %count, align 4
  %105 = load i32, i32* %i, align 4
  %106 = call %class.KV.5* @_ZN2KVI10scheme_key12scheme_valueLj6EE11update_nodeEPKS2_jjRS3_(%class.KV.5* %103, i32 %104, i32 %105, %class.KV.5* dereferenceable(16) %childkv)
  store %class.KV.5* %106, %class.KV.5** %node1, align 8
  %107 = load %class.KV.4*, %class.KV.4** %1, align 8
  %108 = getelementptr inbounds %class.KV.4, %class.KV.4* %107, i32 0, i32 0
  %109 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Key"* %108 to i64*
  %110 = load i64, i64* %109, align 8
  %111 = load %class.KV.5*, %class.KV.5** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EEC2EmPKS_IS0_S1_Lj6EE(%class.KV.4* %agg.result, i64 %110, %class.KV.5* %111)
  br label %180

; <label>:112                                     ; preds = %40
  %113 = load i32, i32* %i, align 4
  %114 = zext i32 %113 to i64
  %115 = load %class.KV.5*, %class.KV.5** %data, align 8
  %116 = getelementptr inbounds %class.KV.5, %class.KV.5* %115, i64 %114
  %117 = load i64, i64* %2, align 8
  %118 = lshr i64 %117, 6
  %119 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %120 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  %121 = load i64*, i64** %5, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EE12insert_innerERKS2_mPKS0_PKS1_Pm(%class.KV.5* sret %childkv2, %class.KV.5* dereferenceable(16) %116, i64 %118, %class.scheme_key* %119, %class.scheme_value* %120, i64* %121)
  %122 = load %class.KV.5*, %class.KV.5** %data, align 8
  %123 = load i32, i32* %count, align 4
  %124 = load i32, i32* %i, align 4
  %125 = call %class.KV.5* @_ZN2KVI10scheme_key12scheme_valueLj6EE11update_nodeEPKS2_jjRS3_(%class.KV.5* %122, i32 %123, i32 %124, %class.KV.5* dereferenceable(16) %childkv2)
  store %class.KV.5* %125, %class.KV.5** %node3, align 8
  %126 = load %class.KV.4*, %class.KV.4** %1, align 8
  %127 = getelementptr inbounds %class.KV.4, %class.KV.4* %126, i32 0, i32 0
  %128 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Key"* %127 to i64*
  %129 = load i64, i64* %128, align 8
  %130 = load %class.KV.5*, %class.KV.5** %node3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EEC2EmPKS_IS0_S1_Lj6EE(%class.KV.4* %agg.result, i64 %129, %class.KV.5* %130)
  br label %180

; <label>:131                                     ; preds = %0
  %132 = load i64*, i64** %5, align 8
  %133 = load i64, i64* %132, align 8
  %134 = add i64 %133, 1
  store i64 %134, i64* %132, align 8
  %135 = load i32, i32* %count, align 4
  %136 = add i32 %135, 1
  %137 = zext i32 %136 to i64
  %138 = mul i64 %137, 16
  %139 = call noalias i8* @GC_malloc(i64 %138)
  %140 = bitcast i8* %139 to %class.KV.5*
  store %class.KV.5* %140, %class.KV.5** %node4, align 8
  %141 = load %class.KV.5*, %class.KV.5** %node4, align 8
  %142 = bitcast %class.KV.5* %141 to i8*
  %143 = load %class.KV.5*, %class.KV.5** %data, align 8
  %144 = bitcast %class.KV.5* %143 to i8*
  %145 = load i32, i32* %i, align 4
  %146 = zext i32 %145 to i64
  %147 = mul i64 %146, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %142, i8* %144, i64 %147, i32 8, i1 false)
  %148 = load i32, i32* %i, align 4
  %149 = add i32 %148, 1
  %150 = zext i32 %149 to i64
  %151 = load %class.KV.5*, %class.KV.5** %node4, align 8
  %152 = getelementptr inbounds %class.KV.5, %class.KV.5* %151, i64 %150
  %153 = bitcast %class.KV.5* %152 to i8*
  %154 = load i32, i32* %i, align 4
  %155 = zext i32 %154 to i64
  %156 = load %class.KV.5*, %class.KV.5** %data, align 8
  %157 = getelementptr inbounds %class.KV.5, %class.KV.5* %156, i64 %155
  %158 = bitcast %class.KV.5* %157 to i8*
  %159 = load i32, i32* %count, align 4
  %160 = load i32, i32* %i, align 4
  %161 = sub i32 %159, %160
  %162 = zext i32 %161 to i64
  %163 = mul i64 %162, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %153, i8* %158, i64 %163, i32 8, i1 false)
  %164 = load %class.KV.5*, %class.KV.5** %node4, align 8
  %165 = load i32, i32* %i, align 4
  %166 = zext i32 %165 to i64
  %167 = getelementptr inbounds %class.KV.5, %class.KV.5* %164, i64 %166
  %168 = bitcast %class.KV.5* %167 to i8*
  %169 = bitcast i8* %168 to %class.KV.5*
  %170 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %171 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EEC2EPKS0_PKS1_(%class.KV.5* %169, %class.scheme_key* %170, %class.scheme_value* %171)
  %172 = load i64, i64* %bm, align 8
  %173 = load i32, i32* %hpiece, align 4
  %174 = zext i32 %173 to i64
  %175 = shl i64 1, %174
  %176 = or i64 %172, %175
  %177 = shl i64 %176, 1
  %178 = or i64 %177, 1
  %179 = load %class.KV.5*, %class.KV.5** %node4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EEC2EmPKS_IS0_S1_Lj6EE(%class.KV.4* %agg.result, i64 %178, %class.KV.5* %179)
  br label %180

; <label>:180                                     ; preds = %131, %112, %72, %60
  ret void
}

; Function Attrs: uwtable
define linkonce_odr %class.KV.5* @_ZN2KVI10scheme_key12scheme_valueLj6EE11update_nodeEPKS2_jjRS3_(%class.KV.5* %old, i32 %count, i32 %i, %class.KV.5* dereferenceable(16) %kv) #0 comdat align 2 {
  %1 = alloca %class.KV.5*, align 8
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  %4 = alloca %class.KV.5*, align 8
  %copy = alloca %class.KV.5*, align 8
  store %class.KV.5* %old, %class.KV.5** %1, align 8
  store i32 %count, i32* %2, align 4
  store i32 %i, i32* %3, align 4
  store %class.KV.5* %kv, %class.KV.5** %4, align 8
  %5 = load i32, i32* %2, align 4
  %6 = zext i32 %5 to i64
  %7 = mul i64 %6, 16
  %8 = call noalias i8* @GC_malloc(i64 %7)
  %9 = bitcast i8* %8 to %class.KV.5*
  store %class.KV.5* %9, %class.KV.5** %copy, align 8
  %10 = load %class.KV.5*, %class.KV.5** %copy, align 8
  %11 = bitcast %class.KV.5* %10 to i8*
  %12 = load %class.KV.5*, %class.KV.5** %1, align 8
  %13 = bitcast %class.KV.5* %12 to i8*
  %14 = load i32, i32* %2, align 4
  %15 = zext i32 %14 to i64
  %16 = mul i64 %15, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %13, i64 %16, i32 8, i1 false)
  %17 = load %class.KV.5*, %class.KV.5** %copy, align 8
  %18 = load i32, i32* %3, align 4
  %19 = zext i32 %18 to i64
  %20 = getelementptr inbounds %class.KV.5, %class.KV.5* %17, i64 %19
  %21 = bitcast %class.KV.5* %20 to i8*
  %22 = bitcast i8* %21 to %class.KV.5*
  %23 = load %class.KV.5*, %class.KV.5** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EEC2ERKS2_(%class.KV.5* %22, %class.KV.5* dereferenceable(16) %23)
  %24 = load %class.KV.5*, %class.KV.5** %copy, align 8
  ret %class.KV.5* %24
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj6EE12insert_innerERKS2_mPKS0_PKS1_Pm(%class.KV.5* noalias sret %agg.result, %class.KV.5* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key, %class.scheme_value* %val, i64* %cptr) #0 comdat align 2 {
  %1 = alloca %class.KV.5*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.scheme_key*, align 8
  %4 = alloca %class.scheme_value*, align 8
  %5 = alloca i64*, align 8
  %data = alloca %class.KV.6*, align 8
  %bm = alloca i64, align 8
  %hpiece = alloca i32, align 4
  %count = alloca i32, align 4
  %i = alloca i32, align 4
  %exists = alloca i8, align 1
  %node = alloca %class.KV.6*, align 8
  %6 = alloca %class.KV.6, align 8
  %childkv = alloca %class.KV.6, align 8
  %node1 = alloca %class.KV.6*, align 8
  %childkv2 = alloca %class.KV.6, align 8
  %node3 = alloca %class.KV.6*, align 8
  %node4 = alloca %class.KV.6*, align 8
  store %class.KV.5* %kv, %class.KV.5** %1, align 8
  store i64 %h, i64* %2, align 8
  store %class.scheme_key* %key, %class.scheme_key** %3, align 8
  store %class.scheme_value* %val, %class.scheme_value** %4, align 8
  store i64* %cptr, i64** %5, align 8
  %7 = load %class.KV.5*, %class.KV.5** %1, align 8
  %8 = getelementptr inbounds %class.KV.5, %class.KV.5* %7, i32 0, i32 1
  %9 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Val"* %8 to %class.KV.6**
  %10 = load %class.KV.6*, %class.KV.6** %9, align 8
  store %class.KV.6* %10, %class.KV.6** %data, align 8
  %11 = load %class.KV.5*, %class.KV.5** %1, align 8
  %12 = getelementptr inbounds %class.KV.5, %class.KV.5* %11, i32 0, i32 0
  %13 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Key"* %12 to i64*
  %14 = load i64, i64* %13, align 8
  %15 = lshr i64 %14, 1
  store i64 %15, i64* %bm, align 8
  %16 = load i64, i64* %2, align 8
  %17 = and i64 %16, 63
  %18 = urem i64 %17, 63
  %19 = trunc i64 %18 to i32
  store i32 %19, i32* %hpiece, align 4
  %20 = load i64, i64* %bm, align 8
  %21 = call i64 @llvm.ctpop.i64(i64 %20)
  %22 = trunc i64 %21 to i32
  store i32 %22, i32* %count, align 4
  %23 = load i64, i64* %bm, align 8
  %24 = shl i64 %23, 1
  %25 = load i32, i32* %hpiece, align 4
  %26 = sub i32 63, %25
  %27 = zext i32 %26 to i64
  %28 = shl i64 %24, %27
  %29 = call i64 @llvm.ctpop.i64(i64 %28)
  %30 = trunc i64 %29 to i32
  store i32 %30, i32* %i, align 4
  %31 = load i64, i64* %bm, align 8
  %32 = load i32, i32* %hpiece, align 4
  %33 = zext i32 %32 to i64
  %34 = shl i64 1, %33
  %35 = and i64 %31, %34
  %36 = icmp ne i64 %35, 0
  %37 = zext i1 %36 to i8
  store i8 %37, i8* %exists, align 1
  %38 = load i8, i8* %exists, align 1
  %39 = trunc i8 %38 to i1
  br i1 %39, label %40, label %131

; <label>:40                                      ; preds = %0
  %41 = load i32, i32* %i, align 4
  %42 = zext i32 %41 to i64
  %43 = load %class.KV.6*, %class.KV.6** %data, align 8
  %44 = getelementptr inbounds %class.KV.6, %class.KV.6* %43, i64 %42
  %45 = getelementptr inbounds %class.KV.6, %class.KV.6* %44, i32 0, i32 0
  %46 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Key"* %45 to i64*
  %47 = load i64, i64* %46, align 8
  %48 = and i64 %47, 1
  %49 = icmp eq i64 %48, 0
  br i1 %49, label %50, label %112

; <label>:50                                      ; preds = %40
  %51 = load i32, i32* %i, align 4
  %52 = zext i32 %51 to i64
  %53 = load %class.KV.6*, %class.KV.6** %data, align 8
  %54 = getelementptr inbounds %class.KV.6, %class.KV.6* %53, i64 %52
  %55 = getelementptr inbounds %class.KV.6, %class.KV.6* %54, i32 0, i32 0
  %56 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Key"* %55 to %class.scheme_key**
  %57 = load %class.scheme_key*, %class.scheme_key** %56, align 8
  %58 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %59 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %57, %class.scheme_key* dereferenceable(8) %58)
  br i1 %59, label %60, label %72

; <label>:60                                      ; preds = %50
  %61 = load %class.KV.6*, %class.KV.6** %data, align 8
  %62 = load i32, i32* %count, align 4
  %63 = load i32, i32* %i, align 4
  %64 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %65 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EEC2EPKS0_PKS1_(%class.KV.6* %6, %class.scheme_key* %64, %class.scheme_value* %65)
  %66 = call %class.KV.6* @_ZN2KVI10scheme_key12scheme_valueLj7EE11update_nodeEPKS2_jjRS3_(%class.KV.6* %61, i32 %62, i32 %63, %class.KV.6* dereferenceable(16) %6)
  store %class.KV.6* %66, %class.KV.6** %node, align 8
  %67 = load %class.KV.5*, %class.KV.5** %1, align 8
  %68 = getelementptr inbounds %class.KV.5, %class.KV.5* %67, i32 0, i32 0
  %69 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Key"* %68 to i64*
  %70 = load i64, i64* %69, align 8
  %71 = load %class.KV.6*, %class.KV.6** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EEC2EmPKS_IS0_S1_Lj7EE(%class.KV.5* %agg.result, i64 %70, %class.KV.6* %71)
  br label %180

; <label>:72                                      ; preds = %50
  %73 = load i64*, i64** %5, align 8
  %74 = load i64, i64* %73, align 8
  %75 = add i64 %74, 1
  store i64 %75, i64* %73, align 8
  %76 = load i32, i32* %i, align 4
  %77 = zext i32 %76 to i64
  %78 = load %class.KV.6*, %class.KV.6** %data, align 8
  %79 = getelementptr inbounds %class.KV.6, %class.KV.6* %78, i64 %77
  %80 = getelementptr inbounds %class.KV.6, %class.KV.6* %79, i32 0, i32 0
  %81 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Key"* %80 to %class.scheme_key**
  %82 = load %class.scheme_key*, %class.scheme_key** %81, align 8
  %83 = call i64 @_ZNK10scheme_key4hashEv(%class.scheme_key* %82)
  %84 = lshr i64 %83, 46
  %85 = load i32, i32* %i, align 4
  %86 = zext i32 %85 to i64
  %87 = load %class.KV.6*, %class.KV.6** %data, align 8
  %88 = getelementptr inbounds %class.KV.6, %class.KV.6* %87, i64 %86
  %89 = getelementptr inbounds %class.KV.6, %class.KV.6* %88, i32 0, i32 0
  %90 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Key"* %89 to %class.scheme_key**
  %91 = load %class.scheme_key*, %class.scheme_key** %90, align 8
  %92 = load i32, i32* %i, align 4
  %93 = zext i32 %92 to i64
  %94 = load %class.KV.6*, %class.KV.6** %data, align 8
  %95 = getelementptr inbounds %class.KV.6, %class.KV.6* %94, i64 %93
  %96 = getelementptr inbounds %class.KV.6, %class.KV.6* %95, i32 0, i32 1
  %97 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Val"* %96 to %class.scheme_value**
  %98 = load %class.scheme_value*, %class.scheme_value** %97, align 8
  %99 = load i64, i64* %2, align 8
  %100 = lshr i64 %99, 6
  %101 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %102 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.6* sret %childkv, i64 %84, %class.scheme_key* %91, %class.scheme_value* %98, i64 %100, %class.scheme_key* %101, %class.scheme_value* %102)
  %103 = load %class.KV.6*, %class.KV.6** %data, align 8
  %104 = load i32, i32* %count, align 4
  %105 = load i32, i32* %i, align 4
  %106 = call %class.KV.6* @_ZN2KVI10scheme_key12scheme_valueLj7EE11update_nodeEPKS2_jjRS3_(%class.KV.6* %103, i32 %104, i32 %105, %class.KV.6* dereferenceable(16) %childkv)
  store %class.KV.6* %106, %class.KV.6** %node1, align 8
  %107 = load %class.KV.5*, %class.KV.5** %1, align 8
  %108 = getelementptr inbounds %class.KV.5, %class.KV.5* %107, i32 0, i32 0
  %109 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Key"* %108 to i64*
  %110 = load i64, i64* %109, align 8
  %111 = load %class.KV.6*, %class.KV.6** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EEC2EmPKS_IS0_S1_Lj7EE(%class.KV.5* %agg.result, i64 %110, %class.KV.6* %111)
  br label %180

; <label>:112                                     ; preds = %40
  %113 = load i32, i32* %i, align 4
  %114 = zext i32 %113 to i64
  %115 = load %class.KV.6*, %class.KV.6** %data, align 8
  %116 = getelementptr inbounds %class.KV.6, %class.KV.6* %115, i64 %114
  %117 = load i64, i64* %2, align 8
  %118 = lshr i64 %117, 6
  %119 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %120 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  %121 = load i64*, i64** %5, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EE12insert_innerERKS2_mPKS0_PKS1_Pm(%class.KV.6* sret %childkv2, %class.KV.6* dereferenceable(16) %116, i64 %118, %class.scheme_key* %119, %class.scheme_value* %120, i64* %121)
  %122 = load %class.KV.6*, %class.KV.6** %data, align 8
  %123 = load i32, i32* %count, align 4
  %124 = load i32, i32* %i, align 4
  %125 = call %class.KV.6* @_ZN2KVI10scheme_key12scheme_valueLj7EE11update_nodeEPKS2_jjRS3_(%class.KV.6* %122, i32 %123, i32 %124, %class.KV.6* dereferenceable(16) %childkv2)
  store %class.KV.6* %125, %class.KV.6** %node3, align 8
  %126 = load %class.KV.5*, %class.KV.5** %1, align 8
  %127 = getelementptr inbounds %class.KV.5, %class.KV.5* %126, i32 0, i32 0
  %128 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Key"* %127 to i64*
  %129 = load i64, i64* %128, align 8
  %130 = load %class.KV.6*, %class.KV.6** %node3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EEC2EmPKS_IS0_S1_Lj7EE(%class.KV.5* %agg.result, i64 %129, %class.KV.6* %130)
  br label %180

; <label>:131                                     ; preds = %0
  %132 = load i64*, i64** %5, align 8
  %133 = load i64, i64* %132, align 8
  %134 = add i64 %133, 1
  store i64 %134, i64* %132, align 8
  %135 = load i32, i32* %count, align 4
  %136 = add i32 %135, 1
  %137 = zext i32 %136 to i64
  %138 = mul i64 %137, 16
  %139 = call noalias i8* @GC_malloc(i64 %138)
  %140 = bitcast i8* %139 to %class.KV.6*
  store %class.KV.6* %140, %class.KV.6** %node4, align 8
  %141 = load %class.KV.6*, %class.KV.6** %node4, align 8
  %142 = bitcast %class.KV.6* %141 to i8*
  %143 = load %class.KV.6*, %class.KV.6** %data, align 8
  %144 = bitcast %class.KV.6* %143 to i8*
  %145 = load i32, i32* %i, align 4
  %146 = zext i32 %145 to i64
  %147 = mul i64 %146, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %142, i8* %144, i64 %147, i32 8, i1 false)
  %148 = load i32, i32* %i, align 4
  %149 = add i32 %148, 1
  %150 = zext i32 %149 to i64
  %151 = load %class.KV.6*, %class.KV.6** %node4, align 8
  %152 = getelementptr inbounds %class.KV.6, %class.KV.6* %151, i64 %150
  %153 = bitcast %class.KV.6* %152 to i8*
  %154 = load i32, i32* %i, align 4
  %155 = zext i32 %154 to i64
  %156 = load %class.KV.6*, %class.KV.6** %data, align 8
  %157 = getelementptr inbounds %class.KV.6, %class.KV.6* %156, i64 %155
  %158 = bitcast %class.KV.6* %157 to i8*
  %159 = load i32, i32* %count, align 4
  %160 = load i32, i32* %i, align 4
  %161 = sub i32 %159, %160
  %162 = zext i32 %161 to i64
  %163 = mul i64 %162, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %153, i8* %158, i64 %163, i32 8, i1 false)
  %164 = load %class.KV.6*, %class.KV.6** %node4, align 8
  %165 = load i32, i32* %i, align 4
  %166 = zext i32 %165 to i64
  %167 = getelementptr inbounds %class.KV.6, %class.KV.6* %164, i64 %166
  %168 = bitcast %class.KV.6* %167 to i8*
  %169 = bitcast i8* %168 to %class.KV.6*
  %170 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %171 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EEC2EPKS0_PKS1_(%class.KV.6* %169, %class.scheme_key* %170, %class.scheme_value* %171)
  %172 = load i64, i64* %bm, align 8
  %173 = load i32, i32* %hpiece, align 4
  %174 = zext i32 %173 to i64
  %175 = shl i64 1, %174
  %176 = or i64 %172, %175
  %177 = shl i64 %176, 1
  %178 = or i64 %177, 1
  %179 = load %class.KV.6*, %class.KV.6** %node4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EEC2EmPKS_IS0_S1_Lj7EE(%class.KV.5* %agg.result, i64 %178, %class.KV.6* %179)
  br label %180

; <label>:180                                     ; preds = %131, %112, %72, %60
  ret void
}

; Function Attrs: uwtable
define linkonce_odr %class.KV.6* @_ZN2KVI10scheme_key12scheme_valueLj7EE11update_nodeEPKS2_jjRS3_(%class.KV.6* %old, i32 %count, i32 %i, %class.KV.6* dereferenceable(16) %kv) #0 comdat align 2 {
  %1 = alloca %class.KV.6*, align 8
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  %4 = alloca %class.KV.6*, align 8
  %copy = alloca %class.KV.6*, align 8
  store %class.KV.6* %old, %class.KV.6** %1, align 8
  store i32 %count, i32* %2, align 4
  store i32 %i, i32* %3, align 4
  store %class.KV.6* %kv, %class.KV.6** %4, align 8
  %5 = load i32, i32* %2, align 4
  %6 = zext i32 %5 to i64
  %7 = mul i64 %6, 16
  %8 = call noalias i8* @GC_malloc(i64 %7)
  %9 = bitcast i8* %8 to %class.KV.6*
  store %class.KV.6* %9, %class.KV.6** %copy, align 8
  %10 = load %class.KV.6*, %class.KV.6** %copy, align 8
  %11 = bitcast %class.KV.6* %10 to i8*
  %12 = load %class.KV.6*, %class.KV.6** %1, align 8
  %13 = bitcast %class.KV.6* %12 to i8*
  %14 = load i32, i32* %2, align 4
  %15 = zext i32 %14 to i64
  %16 = mul i64 %15, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %13, i64 %16, i32 8, i1 false)
  %17 = load %class.KV.6*, %class.KV.6** %copy, align 8
  %18 = load i32, i32* %3, align 4
  %19 = zext i32 %18 to i64
  %20 = getelementptr inbounds %class.KV.6, %class.KV.6* %17, i64 %19
  %21 = bitcast %class.KV.6* %20 to i8*
  %22 = bitcast i8* %21 to %class.KV.6*
  %23 = load %class.KV.6*, %class.KV.6** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EEC2ERKS2_(%class.KV.6* %22, %class.KV.6* dereferenceable(16) %23)
  %24 = load %class.KV.6*, %class.KV.6** %copy, align 8
  ret %class.KV.6* %24
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj7EE12insert_innerERKS2_mPKS0_PKS1_Pm(%class.KV.6* noalias sret %agg.result, %class.KV.6* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key, %class.scheme_value* %val, i64* %cptr) #0 comdat align 2 {
  %1 = alloca %class.KV.6*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.scheme_key*, align 8
  %4 = alloca %class.scheme_value*, align 8
  %5 = alloca i64*, align 8
  %data = alloca %class.KV.7*, align 8
  %bm = alloca i64, align 8
  %hpiece = alloca i32, align 4
  %count = alloca i32, align 4
  %i = alloca i32, align 4
  %exists = alloca i8, align 1
  %node = alloca %class.KV.7*, align 8
  %6 = alloca %class.KV.7, align 8
  %childkv = alloca %class.KV.7, align 8
  %node1 = alloca %class.KV.7*, align 8
  %childkv2 = alloca %class.KV.7, align 8
  %node3 = alloca %class.KV.7*, align 8
  %node4 = alloca %class.KV.7*, align 8
  store %class.KV.6* %kv, %class.KV.6** %1, align 8
  store i64 %h, i64* %2, align 8
  store %class.scheme_key* %key, %class.scheme_key** %3, align 8
  store %class.scheme_value* %val, %class.scheme_value** %4, align 8
  store i64* %cptr, i64** %5, align 8
  %7 = load %class.KV.6*, %class.KV.6** %1, align 8
  %8 = getelementptr inbounds %class.KV.6, %class.KV.6* %7, i32 0, i32 1
  %9 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Val"* %8 to %class.KV.7**
  %10 = load %class.KV.7*, %class.KV.7** %9, align 8
  store %class.KV.7* %10, %class.KV.7** %data, align 8
  %11 = load %class.KV.6*, %class.KV.6** %1, align 8
  %12 = getelementptr inbounds %class.KV.6, %class.KV.6* %11, i32 0, i32 0
  %13 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Key"* %12 to i64*
  %14 = load i64, i64* %13, align 8
  %15 = lshr i64 %14, 1
  store i64 %15, i64* %bm, align 8
  %16 = load i64, i64* %2, align 8
  %17 = and i64 %16, 63
  %18 = urem i64 %17, 63
  %19 = trunc i64 %18 to i32
  store i32 %19, i32* %hpiece, align 4
  %20 = load i64, i64* %bm, align 8
  %21 = call i64 @llvm.ctpop.i64(i64 %20)
  %22 = trunc i64 %21 to i32
  store i32 %22, i32* %count, align 4
  %23 = load i64, i64* %bm, align 8
  %24 = shl i64 %23, 1
  %25 = load i32, i32* %hpiece, align 4
  %26 = sub i32 63, %25
  %27 = zext i32 %26 to i64
  %28 = shl i64 %24, %27
  %29 = call i64 @llvm.ctpop.i64(i64 %28)
  %30 = trunc i64 %29 to i32
  store i32 %30, i32* %i, align 4
  %31 = load i64, i64* %bm, align 8
  %32 = load i32, i32* %hpiece, align 4
  %33 = zext i32 %32 to i64
  %34 = shl i64 1, %33
  %35 = and i64 %31, %34
  %36 = icmp ne i64 %35, 0
  %37 = zext i1 %36 to i8
  store i8 %37, i8* %exists, align 1
  %38 = load i8, i8* %exists, align 1
  %39 = trunc i8 %38 to i1
  br i1 %39, label %40, label %131

; <label>:40                                      ; preds = %0
  %41 = load i32, i32* %i, align 4
  %42 = zext i32 %41 to i64
  %43 = load %class.KV.7*, %class.KV.7** %data, align 8
  %44 = getelementptr inbounds %class.KV.7, %class.KV.7* %43, i64 %42
  %45 = getelementptr inbounds %class.KV.7, %class.KV.7* %44, i32 0, i32 0
  %46 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Key"* %45 to i64*
  %47 = load i64, i64* %46, align 8
  %48 = and i64 %47, 1
  %49 = icmp eq i64 %48, 0
  br i1 %49, label %50, label %112

; <label>:50                                      ; preds = %40
  %51 = load i32, i32* %i, align 4
  %52 = zext i32 %51 to i64
  %53 = load %class.KV.7*, %class.KV.7** %data, align 8
  %54 = getelementptr inbounds %class.KV.7, %class.KV.7* %53, i64 %52
  %55 = getelementptr inbounds %class.KV.7, %class.KV.7* %54, i32 0, i32 0
  %56 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Key"* %55 to %class.scheme_key**
  %57 = load %class.scheme_key*, %class.scheme_key** %56, align 8
  %58 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %59 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %57, %class.scheme_key* dereferenceable(8) %58)
  br i1 %59, label %60, label %72

; <label>:60                                      ; preds = %50
  %61 = load %class.KV.7*, %class.KV.7** %data, align 8
  %62 = load i32, i32* %count, align 4
  %63 = load i32, i32* %i, align 4
  %64 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %65 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EEC2EPKS0_PKS1_(%class.KV.7* %6, %class.scheme_key* %64, %class.scheme_value* %65)
  %66 = call %class.KV.7* @_ZN2KVI10scheme_key12scheme_valueLj8EE11update_nodeEPKS2_jjRS3_(%class.KV.7* %61, i32 %62, i32 %63, %class.KV.7* dereferenceable(16) %6)
  store %class.KV.7* %66, %class.KV.7** %node, align 8
  %67 = load %class.KV.6*, %class.KV.6** %1, align 8
  %68 = getelementptr inbounds %class.KV.6, %class.KV.6* %67, i32 0, i32 0
  %69 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Key"* %68 to i64*
  %70 = load i64, i64* %69, align 8
  %71 = load %class.KV.7*, %class.KV.7** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EEC2EmPKS_IS0_S1_Lj8EE(%class.KV.6* %agg.result, i64 %70, %class.KV.7* %71)
  br label %180

; <label>:72                                      ; preds = %50
  %73 = load i64*, i64** %5, align 8
  %74 = load i64, i64* %73, align 8
  %75 = add i64 %74, 1
  store i64 %75, i64* %73, align 8
  %76 = load i32, i32* %i, align 4
  %77 = zext i32 %76 to i64
  %78 = load %class.KV.7*, %class.KV.7** %data, align 8
  %79 = getelementptr inbounds %class.KV.7, %class.KV.7* %78, i64 %77
  %80 = getelementptr inbounds %class.KV.7, %class.KV.7* %79, i32 0, i32 0
  %81 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Key"* %80 to %class.scheme_key**
  %82 = load %class.scheme_key*, %class.scheme_key** %81, align 8
  %83 = call i64 @_ZNK10scheme_key4hashEv(%class.scheme_key* %82)
  %84 = lshr i64 %83, 52
  %85 = load i32, i32* %i, align 4
  %86 = zext i32 %85 to i64
  %87 = load %class.KV.7*, %class.KV.7** %data, align 8
  %88 = getelementptr inbounds %class.KV.7, %class.KV.7* %87, i64 %86
  %89 = getelementptr inbounds %class.KV.7, %class.KV.7* %88, i32 0, i32 0
  %90 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Key"* %89 to %class.scheme_key**
  %91 = load %class.scheme_key*, %class.scheme_key** %90, align 8
  %92 = load i32, i32* %i, align 4
  %93 = zext i32 %92 to i64
  %94 = load %class.KV.7*, %class.KV.7** %data, align 8
  %95 = getelementptr inbounds %class.KV.7, %class.KV.7* %94, i64 %93
  %96 = getelementptr inbounds %class.KV.7, %class.KV.7* %95, i32 0, i32 1
  %97 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Val"* %96 to %class.scheme_value**
  %98 = load %class.scheme_value*, %class.scheme_value** %97, align 8
  %99 = load i64, i64* %2, align 8
  %100 = lshr i64 %99, 6
  %101 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %102 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.7* sret %childkv, i64 %84, %class.scheme_key* %91, %class.scheme_value* %98, i64 %100, %class.scheme_key* %101, %class.scheme_value* %102)
  %103 = load %class.KV.7*, %class.KV.7** %data, align 8
  %104 = load i32, i32* %count, align 4
  %105 = load i32, i32* %i, align 4
  %106 = call %class.KV.7* @_ZN2KVI10scheme_key12scheme_valueLj8EE11update_nodeEPKS2_jjRS3_(%class.KV.7* %103, i32 %104, i32 %105, %class.KV.7* dereferenceable(16) %childkv)
  store %class.KV.7* %106, %class.KV.7** %node1, align 8
  %107 = load %class.KV.6*, %class.KV.6** %1, align 8
  %108 = getelementptr inbounds %class.KV.6, %class.KV.6* %107, i32 0, i32 0
  %109 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Key"* %108 to i64*
  %110 = load i64, i64* %109, align 8
  %111 = load %class.KV.7*, %class.KV.7** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EEC2EmPKS_IS0_S1_Lj8EE(%class.KV.6* %agg.result, i64 %110, %class.KV.7* %111)
  br label %180

; <label>:112                                     ; preds = %40
  %113 = load i32, i32* %i, align 4
  %114 = zext i32 %113 to i64
  %115 = load %class.KV.7*, %class.KV.7** %data, align 8
  %116 = getelementptr inbounds %class.KV.7, %class.KV.7* %115, i64 %114
  %117 = load i64, i64* %2, align 8
  %118 = lshr i64 %117, 6
  %119 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %120 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  %121 = load i64*, i64** %5, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EE12insert_innerERKS2_mPKS0_PKS1_Pm(%class.KV.7* sret %childkv2, %class.KV.7* dereferenceable(16) %116, i64 %118, %class.scheme_key* %119, %class.scheme_value* %120, i64* %121)
  %122 = load %class.KV.7*, %class.KV.7** %data, align 8
  %123 = load i32, i32* %count, align 4
  %124 = load i32, i32* %i, align 4
  %125 = call %class.KV.7* @_ZN2KVI10scheme_key12scheme_valueLj8EE11update_nodeEPKS2_jjRS3_(%class.KV.7* %122, i32 %123, i32 %124, %class.KV.7* dereferenceable(16) %childkv2)
  store %class.KV.7* %125, %class.KV.7** %node3, align 8
  %126 = load %class.KV.6*, %class.KV.6** %1, align 8
  %127 = getelementptr inbounds %class.KV.6, %class.KV.6* %126, i32 0, i32 0
  %128 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Key"* %127 to i64*
  %129 = load i64, i64* %128, align 8
  %130 = load %class.KV.7*, %class.KV.7** %node3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EEC2EmPKS_IS0_S1_Lj8EE(%class.KV.6* %agg.result, i64 %129, %class.KV.7* %130)
  br label %180

; <label>:131                                     ; preds = %0
  %132 = load i64*, i64** %5, align 8
  %133 = load i64, i64* %132, align 8
  %134 = add i64 %133, 1
  store i64 %134, i64* %132, align 8
  %135 = load i32, i32* %count, align 4
  %136 = add i32 %135, 1
  %137 = zext i32 %136 to i64
  %138 = mul i64 %137, 16
  %139 = call noalias i8* @GC_malloc(i64 %138)
  %140 = bitcast i8* %139 to %class.KV.7*
  store %class.KV.7* %140, %class.KV.7** %node4, align 8
  %141 = load %class.KV.7*, %class.KV.7** %node4, align 8
  %142 = bitcast %class.KV.7* %141 to i8*
  %143 = load %class.KV.7*, %class.KV.7** %data, align 8
  %144 = bitcast %class.KV.7* %143 to i8*
  %145 = load i32, i32* %i, align 4
  %146 = zext i32 %145 to i64
  %147 = mul i64 %146, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %142, i8* %144, i64 %147, i32 8, i1 false)
  %148 = load i32, i32* %i, align 4
  %149 = add i32 %148, 1
  %150 = zext i32 %149 to i64
  %151 = load %class.KV.7*, %class.KV.7** %node4, align 8
  %152 = getelementptr inbounds %class.KV.7, %class.KV.7* %151, i64 %150
  %153 = bitcast %class.KV.7* %152 to i8*
  %154 = load i32, i32* %i, align 4
  %155 = zext i32 %154 to i64
  %156 = load %class.KV.7*, %class.KV.7** %data, align 8
  %157 = getelementptr inbounds %class.KV.7, %class.KV.7* %156, i64 %155
  %158 = bitcast %class.KV.7* %157 to i8*
  %159 = load i32, i32* %count, align 4
  %160 = load i32, i32* %i, align 4
  %161 = sub i32 %159, %160
  %162 = zext i32 %161 to i64
  %163 = mul i64 %162, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %153, i8* %158, i64 %163, i32 8, i1 false)
  %164 = load %class.KV.7*, %class.KV.7** %node4, align 8
  %165 = load i32, i32* %i, align 4
  %166 = zext i32 %165 to i64
  %167 = getelementptr inbounds %class.KV.7, %class.KV.7* %164, i64 %166
  %168 = bitcast %class.KV.7* %167 to i8*
  %169 = bitcast i8* %168 to %class.KV.7*
  %170 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %171 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EEC2EPKS0_PKS1_(%class.KV.7* %169, %class.scheme_key* %170, %class.scheme_value* %171)
  %172 = load i64, i64* %bm, align 8
  %173 = load i32, i32* %hpiece, align 4
  %174 = zext i32 %173 to i64
  %175 = shl i64 1, %174
  %176 = or i64 %172, %175
  %177 = shl i64 %176, 1
  %178 = or i64 %177, 1
  %179 = load %class.KV.7*, %class.KV.7** %node4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EEC2EmPKS_IS0_S1_Lj8EE(%class.KV.6* %agg.result, i64 %178, %class.KV.7* %179)
  br label %180

; <label>:180                                     ; preds = %131, %112, %72, %60
  ret void
}

; Function Attrs: uwtable
define linkonce_odr %class.KV.7* @_ZN2KVI10scheme_key12scheme_valueLj8EE11update_nodeEPKS2_jjRS3_(%class.KV.7* %old, i32 %count, i32 %i, %class.KV.7* dereferenceable(16) %kv) #0 comdat align 2 {
  %1 = alloca %class.KV.7*, align 8
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  %4 = alloca %class.KV.7*, align 8
  %copy = alloca %class.KV.7*, align 8
  store %class.KV.7* %old, %class.KV.7** %1, align 8
  store i32 %count, i32* %2, align 4
  store i32 %i, i32* %3, align 4
  store %class.KV.7* %kv, %class.KV.7** %4, align 8
  %5 = load i32, i32* %2, align 4
  %6 = zext i32 %5 to i64
  %7 = mul i64 %6, 16
  %8 = call noalias i8* @GC_malloc(i64 %7)
  %9 = bitcast i8* %8 to %class.KV.7*
  store %class.KV.7* %9, %class.KV.7** %copy, align 8
  %10 = load %class.KV.7*, %class.KV.7** %copy, align 8
  %11 = bitcast %class.KV.7* %10 to i8*
  %12 = load %class.KV.7*, %class.KV.7** %1, align 8
  %13 = bitcast %class.KV.7* %12 to i8*
  %14 = load i32, i32* %2, align 4
  %15 = zext i32 %14 to i64
  %16 = mul i64 %15, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %13, i64 %16, i32 8, i1 false)
  %17 = load %class.KV.7*, %class.KV.7** %copy, align 8
  %18 = load i32, i32* %3, align 4
  %19 = zext i32 %18 to i64
  %20 = getelementptr inbounds %class.KV.7, %class.KV.7* %17, i64 %19
  %21 = bitcast %class.KV.7* %20 to i8*
  %22 = bitcast i8* %21 to %class.KV.7*
  %23 = load %class.KV.7*, %class.KV.7** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EEC2ERKS2_(%class.KV.7* %22, %class.KV.7* dereferenceable(16) %23)
  %24 = load %class.KV.7*, %class.KV.7** %copy, align 8
  ret %class.KV.7* %24
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj8EE12insert_innerERKS2_mPKS0_PKS1_Pm(%class.KV.7* noalias sret %agg.result, %class.KV.7* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key, %class.scheme_value* %val, i64* %cptr) #0 comdat align 2 {
  %1 = alloca %class.KV.7*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.scheme_key*, align 8
  %4 = alloca %class.scheme_value*, align 8
  %5 = alloca i64*, align 8
  %data = alloca %class.KV.8*, align 8
  %bm = alloca i64, align 8
  %hpiece = alloca i32, align 4
  %count = alloca i32, align 4
  %i = alloca i32, align 4
  %exists = alloca i8, align 1
  %node = alloca %class.KV.8*, align 8
  %6 = alloca %class.KV.8, align 8
  %childkv = alloca %class.KV.8, align 8
  %node1 = alloca %class.KV.8*, align 8
  %childkv2 = alloca %class.KV.8, align 8
  %node3 = alloca %class.KV.8*, align 8
  %node4 = alloca %class.KV.8*, align 8
  store %class.KV.7* %kv, %class.KV.7** %1, align 8
  store i64 %h, i64* %2, align 8
  store %class.scheme_key* %key, %class.scheme_key** %3, align 8
  store %class.scheme_value* %val, %class.scheme_value** %4, align 8
  store i64* %cptr, i64** %5, align 8
  %7 = load %class.KV.7*, %class.KV.7** %1, align 8
  %8 = getelementptr inbounds %class.KV.7, %class.KV.7* %7, i32 0, i32 1
  %9 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Val"* %8 to %class.KV.8**
  %10 = load %class.KV.8*, %class.KV.8** %9, align 8
  store %class.KV.8* %10, %class.KV.8** %data, align 8
  %11 = load %class.KV.7*, %class.KV.7** %1, align 8
  %12 = getelementptr inbounds %class.KV.7, %class.KV.7* %11, i32 0, i32 0
  %13 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Key"* %12 to i64*
  %14 = load i64, i64* %13, align 8
  %15 = lshr i64 %14, 1
  store i64 %15, i64* %bm, align 8
  %16 = load i64, i64* %2, align 8
  %17 = and i64 %16, 63
  %18 = urem i64 %17, 63
  %19 = trunc i64 %18 to i32
  store i32 %19, i32* %hpiece, align 4
  %20 = load i64, i64* %bm, align 8
  %21 = call i64 @llvm.ctpop.i64(i64 %20)
  %22 = trunc i64 %21 to i32
  store i32 %22, i32* %count, align 4
  %23 = load i64, i64* %bm, align 8
  %24 = shl i64 %23, 1
  %25 = load i32, i32* %hpiece, align 4
  %26 = sub i32 63, %25
  %27 = zext i32 %26 to i64
  %28 = shl i64 %24, %27
  %29 = call i64 @llvm.ctpop.i64(i64 %28)
  %30 = trunc i64 %29 to i32
  store i32 %30, i32* %i, align 4
  %31 = load i64, i64* %bm, align 8
  %32 = load i32, i32* %hpiece, align 4
  %33 = zext i32 %32 to i64
  %34 = shl i64 1, %33
  %35 = and i64 %31, %34
  %36 = icmp ne i64 %35, 0
  %37 = zext i1 %36 to i8
  store i8 %37, i8* %exists, align 1
  %38 = load i8, i8* %exists, align 1
  %39 = trunc i8 %38 to i1
  br i1 %39, label %40, label %131

; <label>:40                                      ; preds = %0
  %41 = load i32, i32* %i, align 4
  %42 = zext i32 %41 to i64
  %43 = load %class.KV.8*, %class.KV.8** %data, align 8
  %44 = getelementptr inbounds %class.KV.8, %class.KV.8* %43, i64 %42
  %45 = getelementptr inbounds %class.KV.8, %class.KV.8* %44, i32 0, i32 0
  %46 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Key"* %45 to i64*
  %47 = load i64, i64* %46, align 8
  %48 = and i64 %47, 1
  %49 = icmp eq i64 %48, 0
  br i1 %49, label %50, label %112

; <label>:50                                      ; preds = %40
  %51 = load i32, i32* %i, align 4
  %52 = zext i32 %51 to i64
  %53 = load %class.KV.8*, %class.KV.8** %data, align 8
  %54 = getelementptr inbounds %class.KV.8, %class.KV.8* %53, i64 %52
  %55 = getelementptr inbounds %class.KV.8, %class.KV.8* %54, i32 0, i32 0
  %56 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Key"* %55 to %class.scheme_key**
  %57 = load %class.scheme_key*, %class.scheme_key** %56, align 8
  %58 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %59 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %57, %class.scheme_key* dereferenceable(8) %58)
  br i1 %59, label %60, label %72

; <label>:60                                      ; preds = %50
  %61 = load %class.KV.8*, %class.KV.8** %data, align 8
  %62 = load i32, i32* %count, align 4
  %63 = load i32, i32* %i, align 4
  %64 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %65 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EEC2EPKS0_PKS1_(%class.KV.8* %6, %class.scheme_key* %64, %class.scheme_value* %65)
  %66 = call %class.KV.8* @_ZN2KVI10scheme_key12scheme_valueLj9EE11update_nodeEPKS2_jjRS3_(%class.KV.8* %61, i32 %62, i32 %63, %class.KV.8* dereferenceable(16) %6)
  store %class.KV.8* %66, %class.KV.8** %node, align 8
  %67 = load %class.KV.7*, %class.KV.7** %1, align 8
  %68 = getelementptr inbounds %class.KV.7, %class.KV.7* %67, i32 0, i32 0
  %69 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Key"* %68 to i64*
  %70 = load i64, i64* %69, align 8
  %71 = load %class.KV.8*, %class.KV.8** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EEC2EmPKS_IS0_S1_Lj9EE(%class.KV.7* %agg.result, i64 %70, %class.KV.8* %71)
  br label %180

; <label>:72                                      ; preds = %50
  %73 = load i64*, i64** %5, align 8
  %74 = load i64, i64* %73, align 8
  %75 = add i64 %74, 1
  store i64 %75, i64* %73, align 8
  %76 = load i32, i32* %i, align 4
  %77 = zext i32 %76 to i64
  %78 = load %class.KV.8*, %class.KV.8** %data, align 8
  %79 = getelementptr inbounds %class.KV.8, %class.KV.8* %78, i64 %77
  %80 = getelementptr inbounds %class.KV.8, %class.KV.8* %79, i32 0, i32 0
  %81 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Key"* %80 to %class.scheme_key**
  %82 = load %class.scheme_key*, %class.scheme_key** %81, align 8
  %83 = call i64 @_ZNK10scheme_key4hashEv(%class.scheme_key* %82)
  %84 = lshr i64 %83, 58
  %85 = load i32, i32* %i, align 4
  %86 = zext i32 %85 to i64
  %87 = load %class.KV.8*, %class.KV.8** %data, align 8
  %88 = getelementptr inbounds %class.KV.8, %class.KV.8* %87, i64 %86
  %89 = getelementptr inbounds %class.KV.8, %class.KV.8* %88, i32 0, i32 0
  %90 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Key"* %89 to %class.scheme_key**
  %91 = load %class.scheme_key*, %class.scheme_key** %90, align 8
  %92 = load i32, i32* %i, align 4
  %93 = zext i32 %92 to i64
  %94 = load %class.KV.8*, %class.KV.8** %data, align 8
  %95 = getelementptr inbounds %class.KV.8, %class.KV.8* %94, i64 %93
  %96 = getelementptr inbounds %class.KV.8, %class.KV.8* %95, i32 0, i32 1
  %97 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Val"* %96 to %class.scheme_value**
  %98 = load %class.scheme_value*, %class.scheme_value** %97, align 8
  %99 = load i64, i64* %2, align 8
  %100 = lshr i64 %99, 6
  %101 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %102 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.8* sret %childkv, i64 %84, %class.scheme_key* %91, %class.scheme_value* %98, i64 %100, %class.scheme_key* %101, %class.scheme_value* %102)
  %103 = load %class.KV.8*, %class.KV.8** %data, align 8
  %104 = load i32, i32* %count, align 4
  %105 = load i32, i32* %i, align 4
  %106 = call %class.KV.8* @_ZN2KVI10scheme_key12scheme_valueLj9EE11update_nodeEPKS2_jjRS3_(%class.KV.8* %103, i32 %104, i32 %105, %class.KV.8* dereferenceable(16) %childkv)
  store %class.KV.8* %106, %class.KV.8** %node1, align 8
  %107 = load %class.KV.7*, %class.KV.7** %1, align 8
  %108 = getelementptr inbounds %class.KV.7, %class.KV.7* %107, i32 0, i32 0
  %109 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Key"* %108 to i64*
  %110 = load i64, i64* %109, align 8
  %111 = load %class.KV.8*, %class.KV.8** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EEC2EmPKS_IS0_S1_Lj9EE(%class.KV.7* %agg.result, i64 %110, %class.KV.8* %111)
  br label %180

; <label>:112                                     ; preds = %40
  %113 = load i32, i32* %i, align 4
  %114 = zext i32 %113 to i64
  %115 = load %class.KV.8*, %class.KV.8** %data, align 8
  %116 = getelementptr inbounds %class.KV.8, %class.KV.8* %115, i64 %114
  %117 = load i64, i64* %2, align 8
  %118 = lshr i64 %117, 6
  %119 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %120 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  %121 = load i64*, i64** %5, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EE12insert_innerERKS2_mPKS0_PKS1_Pm(%class.KV.8* sret %childkv2, %class.KV.8* dereferenceable(16) %116, i64 %118, %class.scheme_key* %119, %class.scheme_value* %120, i64* %121)
  %122 = load %class.KV.8*, %class.KV.8** %data, align 8
  %123 = load i32, i32* %count, align 4
  %124 = load i32, i32* %i, align 4
  %125 = call %class.KV.8* @_ZN2KVI10scheme_key12scheme_valueLj9EE11update_nodeEPKS2_jjRS3_(%class.KV.8* %122, i32 %123, i32 %124, %class.KV.8* dereferenceable(16) %childkv2)
  store %class.KV.8* %125, %class.KV.8** %node3, align 8
  %126 = load %class.KV.7*, %class.KV.7** %1, align 8
  %127 = getelementptr inbounds %class.KV.7, %class.KV.7* %126, i32 0, i32 0
  %128 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Key"* %127 to i64*
  %129 = load i64, i64* %128, align 8
  %130 = load %class.KV.8*, %class.KV.8** %node3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EEC2EmPKS_IS0_S1_Lj9EE(%class.KV.7* %agg.result, i64 %129, %class.KV.8* %130)
  br label %180

; <label>:131                                     ; preds = %0
  %132 = load i64*, i64** %5, align 8
  %133 = load i64, i64* %132, align 8
  %134 = add i64 %133, 1
  store i64 %134, i64* %132, align 8
  %135 = load i32, i32* %count, align 4
  %136 = add i32 %135, 1
  %137 = zext i32 %136 to i64
  %138 = mul i64 %137, 16
  %139 = call noalias i8* @GC_malloc(i64 %138)
  %140 = bitcast i8* %139 to %class.KV.8*
  store %class.KV.8* %140, %class.KV.8** %node4, align 8
  %141 = load %class.KV.8*, %class.KV.8** %node4, align 8
  %142 = bitcast %class.KV.8* %141 to i8*
  %143 = load %class.KV.8*, %class.KV.8** %data, align 8
  %144 = bitcast %class.KV.8* %143 to i8*
  %145 = load i32, i32* %i, align 4
  %146 = zext i32 %145 to i64
  %147 = mul i64 %146, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %142, i8* %144, i64 %147, i32 8, i1 false)
  %148 = load i32, i32* %i, align 4
  %149 = add i32 %148, 1
  %150 = zext i32 %149 to i64
  %151 = load %class.KV.8*, %class.KV.8** %node4, align 8
  %152 = getelementptr inbounds %class.KV.8, %class.KV.8* %151, i64 %150
  %153 = bitcast %class.KV.8* %152 to i8*
  %154 = load i32, i32* %i, align 4
  %155 = zext i32 %154 to i64
  %156 = load %class.KV.8*, %class.KV.8** %data, align 8
  %157 = getelementptr inbounds %class.KV.8, %class.KV.8* %156, i64 %155
  %158 = bitcast %class.KV.8* %157 to i8*
  %159 = load i32, i32* %count, align 4
  %160 = load i32, i32* %i, align 4
  %161 = sub i32 %159, %160
  %162 = zext i32 %161 to i64
  %163 = mul i64 %162, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %153, i8* %158, i64 %163, i32 8, i1 false)
  %164 = load %class.KV.8*, %class.KV.8** %node4, align 8
  %165 = load i32, i32* %i, align 4
  %166 = zext i32 %165 to i64
  %167 = getelementptr inbounds %class.KV.8, %class.KV.8* %164, i64 %166
  %168 = bitcast %class.KV.8* %167 to i8*
  %169 = bitcast i8* %168 to %class.KV.8*
  %170 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %171 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EEC2EPKS0_PKS1_(%class.KV.8* %169, %class.scheme_key* %170, %class.scheme_value* %171)
  %172 = load i64, i64* %bm, align 8
  %173 = load i32, i32* %hpiece, align 4
  %174 = zext i32 %173 to i64
  %175 = shl i64 1, %174
  %176 = or i64 %172, %175
  %177 = shl i64 %176, 1
  %178 = or i64 %177, 1
  %179 = load %class.KV.8*, %class.KV.8** %node4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EEC2EmPKS_IS0_S1_Lj9EE(%class.KV.7* %agg.result, i64 %178, %class.KV.8* %179)
  br label %180

; <label>:180                                     ; preds = %131, %112, %72, %60
  ret void
}

; Function Attrs: uwtable
define linkonce_odr %class.KV.8* @_ZN2KVI10scheme_key12scheme_valueLj9EE11update_nodeEPKS2_jjRS3_(%class.KV.8* %old, i32 %count, i32 %i, %class.KV.8* dereferenceable(16) %kv) #0 comdat align 2 {
  %1 = alloca %class.KV.8*, align 8
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  %4 = alloca %class.KV.8*, align 8
  %copy = alloca %class.KV.8*, align 8
  store %class.KV.8* %old, %class.KV.8** %1, align 8
  store i32 %count, i32* %2, align 4
  store i32 %i, i32* %3, align 4
  store %class.KV.8* %kv, %class.KV.8** %4, align 8
  %5 = load i32, i32* %2, align 4
  %6 = zext i32 %5 to i64
  %7 = mul i64 %6, 16
  %8 = call noalias i8* @GC_malloc(i64 %7)
  %9 = bitcast i8* %8 to %class.KV.8*
  store %class.KV.8* %9, %class.KV.8** %copy, align 8
  %10 = load %class.KV.8*, %class.KV.8** %copy, align 8
  %11 = bitcast %class.KV.8* %10 to i8*
  %12 = load %class.KV.8*, %class.KV.8** %1, align 8
  %13 = bitcast %class.KV.8* %12 to i8*
  %14 = load i32, i32* %2, align 4
  %15 = zext i32 %14 to i64
  %16 = mul i64 %15, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %13, i64 %16, i32 8, i1 false)
  %17 = load %class.KV.8*, %class.KV.8** %copy, align 8
  %18 = load i32, i32* %3, align 4
  %19 = zext i32 %18 to i64
  %20 = getelementptr inbounds %class.KV.8, %class.KV.8* %17, i64 %19
  %21 = bitcast %class.KV.8* %20 to i8*
  %22 = bitcast i8* %21 to %class.KV.8*
  %23 = load %class.KV.8*, %class.KV.8** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EEC2ERKS2_(%class.KV.8* %22, %class.KV.8* dereferenceable(16) %23)
  %24 = load %class.KV.8*, %class.KV.8** %copy, align 8
  ret %class.KV.8* %24
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj9EE12insert_innerERKS2_mPKS0_PKS1_Pm(%class.KV.8* noalias sret %agg.result, %class.KV.8* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key, %class.scheme_value* %val, i64* %cptr) #0 comdat align 2 {
  %1 = alloca %class.KV.8*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.scheme_key*, align 8
  %4 = alloca %class.scheme_value*, align 8
  %5 = alloca i64*, align 8
  %data = alloca %class.KV.9*, align 8
  %bm = alloca i64, align 8
  %hpiece = alloca i32, align 4
  %count = alloca i32, align 4
  %i = alloca i32, align 4
  %exists = alloca i8, align 1
  %node = alloca %class.KV.9*, align 8
  %6 = alloca %class.KV.9, align 8
  %childkv = alloca %class.KV.9, align 8
  %node1 = alloca %class.KV.9*, align 8
  %childkv2 = alloca %class.KV.9, align 8
  %node3 = alloca %class.KV.9*, align 8
  %node4 = alloca %class.KV.9*, align 8
  store %class.KV.8* %kv, %class.KV.8** %1, align 8
  store i64 %h, i64* %2, align 8
  store %class.scheme_key* %key, %class.scheme_key** %3, align 8
  store %class.scheme_value* %val, %class.scheme_value** %4, align 8
  store i64* %cptr, i64** %5, align 8
  %7 = load %class.KV.8*, %class.KV.8** %1, align 8
  %8 = getelementptr inbounds %class.KV.8, %class.KV.8* %7, i32 0, i32 1
  %9 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Val"* %8 to %class.KV.9**
  %10 = load %class.KV.9*, %class.KV.9** %9, align 8
  store %class.KV.9* %10, %class.KV.9** %data, align 8
  %11 = load %class.KV.8*, %class.KV.8** %1, align 8
  %12 = getelementptr inbounds %class.KV.8, %class.KV.8* %11, i32 0, i32 0
  %13 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Key"* %12 to i64*
  %14 = load i64, i64* %13, align 8
  %15 = lshr i64 %14, 1
  store i64 %15, i64* %bm, align 8
  %16 = load i64, i64* %2, align 8
  %17 = and i64 %16, 63
  %18 = urem i64 %17, 63
  %19 = trunc i64 %18 to i32
  store i32 %19, i32* %hpiece, align 4
  %20 = load i64, i64* %bm, align 8
  %21 = call i64 @llvm.ctpop.i64(i64 %20)
  %22 = trunc i64 %21 to i32
  store i32 %22, i32* %count, align 4
  %23 = load i64, i64* %bm, align 8
  %24 = shl i64 %23, 1
  %25 = load i32, i32* %hpiece, align 4
  %26 = sub i32 63, %25
  %27 = zext i32 %26 to i64
  %28 = shl i64 %24, %27
  %29 = call i64 @llvm.ctpop.i64(i64 %28)
  %30 = trunc i64 %29 to i32
  store i32 %30, i32* %i, align 4
  %31 = load i64, i64* %bm, align 8
  %32 = load i32, i32* %hpiece, align 4
  %33 = zext i32 %32 to i64
  %34 = shl i64 1, %33
  %35 = and i64 %31, %34
  %36 = icmp ne i64 %35, 0
  %37 = zext i1 %36 to i8
  store i8 %37, i8* %exists, align 1
  %38 = load i8, i8* %exists, align 1
  %39 = trunc i8 %38 to i1
  br i1 %39, label %40, label %131

; <label>:40                                      ; preds = %0
  %41 = load i32, i32* %i, align 4
  %42 = zext i32 %41 to i64
  %43 = load %class.KV.9*, %class.KV.9** %data, align 8
  %44 = getelementptr inbounds %class.KV.9, %class.KV.9* %43, i64 %42
  %45 = getelementptr inbounds %class.KV.9, %class.KV.9* %44, i32 0, i32 0
  %46 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Key"* %45 to i64*
  %47 = load i64, i64* %46, align 8
  %48 = and i64 %47, 1
  %49 = icmp eq i64 %48, 0
  br i1 %49, label %50, label %112

; <label>:50                                      ; preds = %40
  %51 = load i32, i32* %i, align 4
  %52 = zext i32 %51 to i64
  %53 = load %class.KV.9*, %class.KV.9** %data, align 8
  %54 = getelementptr inbounds %class.KV.9, %class.KV.9* %53, i64 %52
  %55 = getelementptr inbounds %class.KV.9, %class.KV.9* %54, i32 0, i32 0
  %56 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Key"* %55 to %class.scheme_key**
  %57 = load %class.scheme_key*, %class.scheme_key** %56, align 8
  %58 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %59 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %57, %class.scheme_key* dereferenceable(8) %58)
  br i1 %59, label %60, label %72

; <label>:60                                      ; preds = %50
  %61 = load %class.KV.9*, %class.KV.9** %data, align 8
  %62 = load i32, i32* %count, align 4
  %63 = load i32, i32* %i, align 4
  %64 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %65 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj10EEC2EPKS0_PKS1_(%class.KV.9* %6, %class.scheme_key* %64, %class.scheme_value* %65)
  %66 = call %class.KV.9* @_ZN2KVI10scheme_key12scheme_valueLj10EE11update_nodeEPKS2_jjRS3_(%class.KV.9* %61, i32 %62, i32 %63, %class.KV.9* dereferenceable(16) %6)
  store %class.KV.9* %66, %class.KV.9** %node, align 8
  %67 = load %class.KV.8*, %class.KV.8** %1, align 8
  %68 = getelementptr inbounds %class.KV.8, %class.KV.8* %67, i32 0, i32 0
  %69 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Key"* %68 to i64*
  %70 = load i64, i64* %69, align 8
  %71 = load %class.KV.9*, %class.KV.9** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EEC2EmPKS_IS0_S1_Lj10EE(%class.KV.8* %agg.result, i64 %70, %class.KV.9* %71)
  br label %180

; <label>:72                                      ; preds = %50
  %73 = load i64*, i64** %5, align 8
  %74 = load i64, i64* %73, align 8
  %75 = add i64 %74, 1
  store i64 %75, i64* %73, align 8
  %76 = load i32, i32* %i, align 4
  %77 = zext i32 %76 to i64
  %78 = load %class.KV.9*, %class.KV.9** %data, align 8
  %79 = getelementptr inbounds %class.KV.9, %class.KV.9* %78, i64 %77
  %80 = getelementptr inbounds %class.KV.9, %class.KV.9* %79, i32 0, i32 0
  %81 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Key"* %80 to %class.scheme_key**
  %82 = load %class.scheme_key*, %class.scheme_key** %81, align 8
  %83 = call i64 @_ZNK10scheme_key4hashEv(%class.scheme_key* %82)
  %84 = lshr i64 %83, 0
  %85 = load i32, i32* %i, align 4
  %86 = zext i32 %85 to i64
  %87 = load %class.KV.9*, %class.KV.9** %data, align 8
  %88 = getelementptr inbounds %class.KV.9, %class.KV.9* %87, i64 %86
  %89 = getelementptr inbounds %class.KV.9, %class.KV.9* %88, i32 0, i32 0
  %90 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Key"* %89 to %class.scheme_key**
  %91 = load %class.scheme_key*, %class.scheme_key** %90, align 8
  %92 = load i32, i32* %i, align 4
  %93 = zext i32 %92 to i64
  %94 = load %class.KV.9*, %class.KV.9** %data, align 8
  %95 = getelementptr inbounds %class.KV.9, %class.KV.9* %94, i64 %93
  %96 = getelementptr inbounds %class.KV.9, %class.KV.9* %95, i32 0, i32 1
  %97 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Val"* %96 to %class.scheme_value**
  %98 = load %class.scheme_value*, %class.scheme_value** %97, align 8
  %99 = load i64, i64* %2, align 8
  %100 = lshr i64 %99, 6
  %101 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %102 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj10EE14new_inner_nodeEmPKS0_PKS1_mS4_S6_(%class.KV.9* sret %childkv, i64 %84, %class.scheme_key* %91, %class.scheme_value* %98, i64 %100, %class.scheme_key* %101, %class.scheme_value* %102)
  %103 = load %class.KV.9*, %class.KV.9** %data, align 8
  %104 = load i32, i32* %count, align 4
  %105 = load i32, i32* %i, align 4
  %106 = call %class.KV.9* @_ZN2KVI10scheme_key12scheme_valueLj10EE11update_nodeEPKS2_jjRS3_(%class.KV.9* %103, i32 %104, i32 %105, %class.KV.9* dereferenceable(16) %childkv)
  store %class.KV.9* %106, %class.KV.9** %node1, align 8
  %107 = load %class.KV.8*, %class.KV.8** %1, align 8
  %108 = getelementptr inbounds %class.KV.8, %class.KV.8* %107, i32 0, i32 0
  %109 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Key"* %108 to i64*
  %110 = load i64, i64* %109, align 8
  %111 = load %class.KV.9*, %class.KV.9** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EEC2EmPKS_IS0_S1_Lj10EE(%class.KV.8* %agg.result, i64 %110, %class.KV.9* %111)
  br label %180

; <label>:112                                     ; preds = %40
  %113 = load i32, i32* %i, align 4
  %114 = zext i32 %113 to i64
  %115 = load %class.KV.9*, %class.KV.9** %data, align 8
  %116 = getelementptr inbounds %class.KV.9, %class.KV.9* %115, i64 %114
  %117 = load i64, i64* %2, align 8
  %118 = lshr i64 %117, 6
  %119 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %120 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  %121 = load i64*, i64** %5, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj10EE12insert_innerERKS2_mPKS0_PKS1_Pm(%class.KV.9* sret %childkv2, %class.KV.9* dereferenceable(16) %116, i64 %118, %class.scheme_key* %119, %class.scheme_value* %120, i64* %121)
  %122 = load %class.KV.9*, %class.KV.9** %data, align 8
  %123 = load i32, i32* %count, align 4
  %124 = load i32, i32* %i, align 4
  %125 = call %class.KV.9* @_ZN2KVI10scheme_key12scheme_valueLj10EE11update_nodeEPKS2_jjRS3_(%class.KV.9* %122, i32 %123, i32 %124, %class.KV.9* dereferenceable(16) %childkv2)
  store %class.KV.9* %125, %class.KV.9** %node3, align 8
  %126 = load %class.KV.8*, %class.KV.8** %1, align 8
  %127 = getelementptr inbounds %class.KV.8, %class.KV.8* %126, i32 0, i32 0
  %128 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Key"* %127 to i64*
  %129 = load i64, i64* %128, align 8
  %130 = load %class.KV.9*, %class.KV.9** %node3, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EEC2EmPKS_IS0_S1_Lj10EE(%class.KV.8* %agg.result, i64 %129, %class.KV.9* %130)
  br label %180

; <label>:131                                     ; preds = %0
  %132 = load i64*, i64** %5, align 8
  %133 = load i64, i64* %132, align 8
  %134 = add i64 %133, 1
  store i64 %134, i64* %132, align 8
  %135 = load i32, i32* %count, align 4
  %136 = add i32 %135, 1
  %137 = zext i32 %136 to i64
  %138 = mul i64 %137, 16
  %139 = call noalias i8* @GC_malloc(i64 %138)
  %140 = bitcast i8* %139 to %class.KV.9*
  store %class.KV.9* %140, %class.KV.9** %node4, align 8
  %141 = load %class.KV.9*, %class.KV.9** %node4, align 8
  %142 = bitcast %class.KV.9* %141 to i8*
  %143 = load %class.KV.9*, %class.KV.9** %data, align 8
  %144 = bitcast %class.KV.9* %143 to i8*
  %145 = load i32, i32* %i, align 4
  %146 = zext i32 %145 to i64
  %147 = mul i64 %146, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %142, i8* %144, i64 %147, i32 8, i1 false)
  %148 = load i32, i32* %i, align 4
  %149 = add i32 %148, 1
  %150 = zext i32 %149 to i64
  %151 = load %class.KV.9*, %class.KV.9** %node4, align 8
  %152 = getelementptr inbounds %class.KV.9, %class.KV.9* %151, i64 %150
  %153 = bitcast %class.KV.9* %152 to i8*
  %154 = load i32, i32* %i, align 4
  %155 = zext i32 %154 to i64
  %156 = load %class.KV.9*, %class.KV.9** %data, align 8
  %157 = getelementptr inbounds %class.KV.9, %class.KV.9* %156, i64 %155
  %158 = bitcast %class.KV.9* %157 to i8*
  %159 = load i32, i32* %count, align 4
  %160 = load i32, i32* %i, align 4
  %161 = sub i32 %159, %160
  %162 = zext i32 %161 to i64
  %163 = mul i64 %162, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %153, i8* %158, i64 %163, i32 8, i1 false)
  %164 = load %class.KV.9*, %class.KV.9** %node4, align 8
  %165 = load i32, i32* %i, align 4
  %166 = zext i32 %165 to i64
  %167 = getelementptr inbounds %class.KV.9, %class.KV.9* %164, i64 %166
  %168 = bitcast %class.KV.9* %167 to i8*
  %169 = bitcast i8* %168 to %class.KV.9*
  %170 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %171 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj10EEC2EPKS0_PKS1_(%class.KV.9* %169, %class.scheme_key* %170, %class.scheme_value* %171)
  %172 = load i64, i64* %bm, align 8
  %173 = load i32, i32* %hpiece, align 4
  %174 = zext i32 %173 to i64
  %175 = shl i64 1, %174
  %176 = or i64 %172, %175
  %177 = shl i64 %176, 1
  %178 = or i64 %177, 1
  %179 = load %class.KV.9*, %class.KV.9** %node4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EEC2EmPKS_IS0_S1_Lj10EE(%class.KV.8* %agg.result, i64 %178, %class.KV.9* %179)
  br label %180

; <label>:180                                     ; preds = %131, %112, %72, %60
  ret void
}

; Function Attrs: uwtable
define linkonce_odr %class.KV.9* @_ZN2KVI10scheme_key12scheme_valueLj10EE11update_nodeEPKS2_jjRS3_(%class.KV.9* %old, i32 %count, i32 %i, %class.KV.9* dereferenceable(16) %kv) #0 comdat align 2 {
  %1 = alloca %class.KV.9*, align 8
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  %4 = alloca %class.KV.9*, align 8
  %copy = alloca %class.KV.9*, align 8
  store %class.KV.9* %old, %class.KV.9** %1, align 8
  store i32 %count, i32* %2, align 4
  store i32 %i, i32* %3, align 4
  store %class.KV.9* %kv, %class.KV.9** %4, align 8
  %5 = load i32, i32* %2, align 4
  %6 = zext i32 %5 to i64
  %7 = mul i64 %6, 16
  %8 = call noalias i8* @GC_malloc(i64 %7)
  %9 = bitcast i8* %8 to %class.KV.9*
  store %class.KV.9* %9, %class.KV.9** %copy, align 8
  %10 = load %class.KV.9*, %class.KV.9** %copy, align 8
  %11 = bitcast %class.KV.9* %10 to i8*
  %12 = load %class.KV.9*, %class.KV.9** %1, align 8
  %13 = bitcast %class.KV.9* %12 to i8*
  %14 = load i32, i32* %2, align 4
  %15 = zext i32 %14 to i64
  %16 = mul i64 %15, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %13, i64 %16, i32 8, i1 false)
  %17 = load %class.KV.9*, %class.KV.9** %copy, align 8
  %18 = load i32, i32* %3, align 4
  %19 = zext i32 %18 to i64
  %20 = getelementptr inbounds %class.KV.9, %class.KV.9* %17, i64 %19
  %21 = bitcast %class.KV.9* %20 to i8*
  %22 = bitcast i8* %21 to %class.KV.9*
  %23 = load %class.KV.9*, %class.KV.9** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj10EEC2ERKS2_(%class.KV.9* %22, %class.KV.9* dereferenceable(16) %23)
  %24 = load %class.KV.9*, %class.KV.9** %copy, align 8
  ret %class.KV.9* %24
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj10EE12insert_innerERKS2_mPKS0_PKS1_Pm(%class.KV.9* noalias sret %agg.result, %class.KV.9* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key, %class.scheme_value* %val, i64* %cptr) #0 comdat align 2 {
  %1 = alloca %class.KV.9*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.scheme_key*, align 8
  %4 = alloca %class.scheme_value*, align 8
  %5 = alloca i64*, align 8
  %ll1 = alloca %class.LL*, align 8
  %ll0 = alloca %class.LL*, align 8
  %ll01 = alloca %class.LL*, align 8
  store %class.KV.9* %kv, %class.KV.9** %1, align 8
  store i64 %h, i64* %2, align 8
  store %class.scheme_key* %key, %class.scheme_key** %3, align 8
  store %class.scheme_value* %val, %class.scheme_value** %4, align 8
  store i64* %cptr, i64** %5, align 8
  %6 = load %class.KV.9*, %class.KV.9** %1, align 8
  %7 = getelementptr inbounds %class.KV.9, %class.KV.9* %6, i32 0, i32 0
  %8 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Key"* %7 to i64*
  %9 = load i64, i64* %8, align 8
  %10 = and i64 %9, 1
  %11 = icmp eq i64 %10, 0
  br i1 %11, label %12, label %49

; <label>:12                                      ; preds = %0
  %13 = load %class.KV.9*, %class.KV.9** %1, align 8
  %14 = getelementptr inbounds %class.KV.9, %class.KV.9* %13, i32 0, i32 0
  %15 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Key"* %14 to %class.scheme_key**
  %16 = load %class.scheme_key*, %class.scheme_key** %15, align 8
  %17 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %18 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %16, %class.scheme_key* dereferenceable(8) %17)
  br i1 %18, label %19, label %25

; <label>:19                                      ; preds = %12
  %20 = load %class.KV.9*, %class.KV.9** %1, align 8
  %21 = getelementptr inbounds %class.KV.9, %class.KV.9* %20, i32 0, i32 0
  %22 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Key"* %21 to %class.scheme_key**
  %23 = load %class.scheme_key*, %class.scheme_key** %22, align 8
  %24 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj10EEC2EPKS0_PKS1_(%class.KV.9* %agg.result, %class.scheme_key* %23, %class.scheme_value* %24)
  br label %75

; <label>:25                                      ; preds = %12
  %26 = load i64*, i64** %5, align 8
  %27 = load i64, i64* %26, align 8
  %28 = add i64 %27, 1
  store i64 %28, i64* %26, align 8
  %29 = call noalias i8* @GC_malloc(i64 24)
  %30 = bitcast i8* %29 to %class.LL*
  %31 = bitcast %class.LL* %30 to i8*
  %32 = bitcast i8* %31 to %class.LL*
  %33 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %34 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2LLI10scheme_key12scheme_valueEC2EPKS0_PKS1_PKS2_(%class.LL* %32, %class.scheme_key* %33, %class.scheme_value* %34, %class.LL* null)
  store %class.LL* %32, %class.LL** %ll1, align 8
  %35 = call noalias i8* @GC_malloc(i64 24)
  %36 = bitcast i8* %35 to %class.LL*
  %37 = bitcast %class.LL* %36 to i8*
  %38 = bitcast i8* %37 to %class.LL*
  %39 = load %class.KV.9*, %class.KV.9** %1, align 8
  %40 = getelementptr inbounds %class.KV.9, %class.KV.9* %39, i32 0, i32 0
  %41 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Key"* %40 to %class.scheme_key**
  %42 = load %class.scheme_key*, %class.scheme_key** %41, align 8
  %43 = load %class.KV.9*, %class.KV.9** %1, align 8
  %44 = getelementptr inbounds %class.KV.9, %class.KV.9* %43, i32 0, i32 1
  %45 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Val"* %44 to %class.scheme_value**
  %46 = load %class.scheme_value*, %class.scheme_value** %45, align 8
  %47 = load %class.LL*, %class.LL** %ll1, align 8
  call void @_ZN2LLI10scheme_key12scheme_valueEC2EPKS0_PKS1_PKS2_(%class.LL* %38, %class.scheme_key* %42, %class.scheme_value* %46, %class.LL* %47)
  store %class.LL* %38, %class.LL** %ll0, align 8
  %48 = load %class.LL*, %class.LL** %ll0, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj10EEC2EmPK2LLIS0_S1_E(%class.KV.9* %agg.result, i64 1, %class.LL* %48)
  br label %75

; <label>:49                                      ; preds = %0
  %50 = load %class.KV.9*, %class.KV.9** %1, align 8
  %51 = getelementptr inbounds %class.KV.9, %class.KV.9* %50, i32 0, i32 1
  %52 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Val"* %51 to %class.LL**
  %53 = load %class.LL*, %class.LL** %52, align 8
  %54 = icmp ne %class.LL* %53, null
  br i1 %54, label %55, label %64

; <label>:55                                      ; preds = %49
  %56 = load %class.KV.9*, %class.KV.9** %1, align 8
  %57 = getelementptr inbounds %class.KV.9, %class.KV.9* %56, i32 0, i32 1
  %58 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Val"* %57 to %class.LL**
  %59 = load %class.LL*, %class.LL** %58, align 8
  %60 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %61 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  %62 = load i64*, i64** %5, align 8
  %63 = call %class.LL* @_ZNK2LLI10scheme_key12scheme_valueE6insertEPKS0_PKS1_Pm(%class.LL* %59, %class.scheme_key* %60, %class.scheme_value* %61, i64* %62)
  call void @_ZN2KVI10scheme_key12scheme_valueLj10EEC2EmPK2LLIS0_S1_E(%class.KV.9* %agg.result, i64 1, %class.LL* %63)
  br label %75

; <label>:64                                      ; preds = %49
  %65 = load i64*, i64** %5, align 8
  %66 = load i64, i64* %65, align 8
  %67 = add i64 %66, 1
  store i64 %67, i64* %65, align 8
  %68 = call noalias i8* @GC_malloc(i64 24)
  %69 = bitcast i8* %68 to %class.LL*
  %70 = bitcast %class.LL* %69 to i8*
  %71 = bitcast i8* %70 to %class.LL*
  %72 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %73 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  call void @_ZN2LLI10scheme_key12scheme_valueEC2EPKS0_PKS1_PKS2_(%class.LL* %71, %class.scheme_key* %72, %class.scheme_value* %73, %class.LL* null)
  store %class.LL* %71, %class.LL** %ll01, align 8
  %74 = load %class.LL*, %class.LL** %ll01, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj10EEC2EmPK2LLIS0_S1_E(%class.KV.9* %agg.result, i64 1, %class.LL* %74)
  br label %75

; <label>:75                                      ; preds = %64, %55, %25, %19
  ret void
}

; Function Attrs: uwtable
define linkonce_odr %class.LL* @_ZNK2LLI10scheme_key12scheme_valueE6insertEPKS0_PKS1_Pm(%class.LL* %this, %class.scheme_key* %k, %class.scheme_value* %v, i64* %cptr) #0 comdat align 2 {
  %1 = alloca %class.LL*, align 8
  %2 = alloca %class.LL*, align 8
  %3 = alloca %class.scheme_key*, align 8
  %4 = alloca %class.scheme_value*, align 8
  %5 = alloca i64*, align 8
  %link1 = alloca %class.LL*, align 8
  %link0 = alloca %class.LL*, align 8
  store %class.LL* %this, %class.LL** %2, align 8
  store %class.scheme_key* %k, %class.scheme_key** %3, align 8
  store %class.scheme_value* %v, %class.scheme_value** %4, align 8
  store i64* %cptr, i64** %5, align 8
  %6 = load %class.LL*, %class.LL** %2, align 8
  %7 = getelementptr inbounds %class.LL, %class.LL* %6, i32 0, i32 0
  %8 = load %class.scheme_key*, %class.scheme_key** %7, align 8
  %9 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %10 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %8, %class.scheme_key* dereferenceable(8) %9)
  br i1 %10, label %11, label %21

; <label>:11                                      ; preds = %0
  %12 = call noalias i8* @GC_malloc(i64 24)
  %13 = bitcast i8* %12 to %class.LL*
  %14 = bitcast %class.LL* %13 to i8*
  %15 = bitcast i8* %14 to %class.LL*
  %16 = getelementptr inbounds %class.LL, %class.LL* %6, i32 0, i32 0
  %17 = load %class.scheme_key*, %class.scheme_key** %16, align 8
  %18 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  %19 = getelementptr inbounds %class.LL, %class.LL* %6, i32 0, i32 2
  %20 = load %class.LL*, %class.LL** %19, align 8
  call void @_ZN2LLI10scheme_key12scheme_valueEC2EPKS0_PKS1_PKS2_(%class.LL* %15, %class.scheme_key* %17, %class.scheme_value* %18, %class.LL* %20)
  store %class.LL* %15, %class.LL** %1, align 8
  br label %60

; <label>:21                                      ; preds = %0
  %22 = getelementptr inbounds %class.LL, %class.LL* %6, i32 0, i32 2
  %23 = load %class.LL*, %class.LL** %22, align 8
  %24 = icmp ne %class.LL* %23, null
  br i1 %24, label %25, label %40

; <label>:25                                      ; preds = %21
  %26 = call noalias i8* @GC_malloc(i64 24)
  %27 = bitcast i8* %26 to %class.LL*
  %28 = bitcast %class.LL* %27 to i8*
  %29 = bitcast i8* %28 to %class.LL*
  %30 = getelementptr inbounds %class.LL, %class.LL* %6, i32 0, i32 0
  %31 = load %class.scheme_key*, %class.scheme_key** %30, align 8
  %32 = getelementptr inbounds %class.LL, %class.LL* %6, i32 0, i32 1
  %33 = load %class.scheme_value*, %class.scheme_value** %32, align 8
  %34 = getelementptr inbounds %class.LL, %class.LL* %6, i32 0, i32 2
  %35 = load %class.LL*, %class.LL** %34, align 8
  %36 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %37 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  %38 = load i64*, i64** %5, align 8
  %39 = call %class.LL* @_ZNK2LLI10scheme_key12scheme_valueE6insertEPKS0_PKS1_Pm(%class.LL* %35, %class.scheme_key* %36, %class.scheme_value* %37, i64* %38)
  call void @_ZN2LLI10scheme_key12scheme_valueEC2EPKS0_PKS1_PKS2_(%class.LL* %29, %class.scheme_key* %31, %class.scheme_value* %33, %class.LL* %39)
  store %class.LL* %29, %class.LL** %1, align 8
  br label %60

; <label>:40                                      ; preds = %21
  %41 = load i64*, i64** %5, align 8
  %42 = load i64, i64* %41, align 8
  %43 = add i64 %42, 1
  store i64 %43, i64* %41, align 8
  %44 = call noalias i8* @GC_malloc(i64 24)
  %45 = bitcast i8* %44 to %class.LL*
  %46 = bitcast %class.LL* %45 to i8*
  %47 = bitcast i8* %46 to %class.LL*
  %48 = getelementptr inbounds %class.LL, %class.LL* %6, i32 0, i32 0
  %49 = load %class.scheme_key*, %class.scheme_key** %48, align 8
  %50 = getelementptr inbounds %class.LL, %class.LL* %6, i32 0, i32 1
  %51 = load %class.scheme_value*, %class.scheme_value** %50, align 8
  call void @_ZN2LLI10scheme_key12scheme_valueEC2EPKS0_PKS1_PKS2_(%class.LL* %47, %class.scheme_key* %49, %class.scheme_value* %51, %class.LL* null)
  store %class.LL* %47, %class.LL** %link1, align 8
  %52 = call noalias i8* @GC_malloc(i64 24)
  %53 = bitcast i8* %52 to %class.LL*
  %54 = bitcast %class.LL* %53 to i8*
  %55 = bitcast i8* %54 to %class.LL*
  %56 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %57 = load %class.scheme_value*, %class.scheme_value** %4, align 8
  %58 = load %class.LL*, %class.LL** %link1, align 8
  call void @_ZN2LLI10scheme_key12scheme_valueEC2EPKS0_PKS1_PKS2_(%class.LL* %55, %class.scheme_key* %56, %class.scheme_value* %57, %class.LL* %58)
  store %class.LL* %55, %class.LL** %link0, align 8
  %59 = load %class.LL*, %class.LL** %link0, align 8
  store %class.LL* %59, %class.LL** %1, align 8
  br label %60

; <label>:60                                      ; preds = %40, %25, %11
  %61 = load %class.LL*, %class.LL** %1, align 8
  ret %class.LL* %61
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj0EE12remove_innerERKS2_mPKS0_Pm(%class.KV* noalias sret %agg.result, %class.KV* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key, i64* %cptr) #0 comdat align 2 {
  %1 = alloca %class.KV*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.scheme_key*, align 8
  %4 = alloca i64*, align 8
  %data = alloca %class.KV.0*, align 8
  %bm = alloca i64, align 8
  %hpiece = alloca i32, align 4
  %count = alloca i32, align 4
  %exists = alloca i8, align 1
  %i = alloca i32, align 4
  %node = alloca %class.KV.0*, align 8
  %newbm = alloca i64, align 8
  %childkv = alloca %class.KV.0, align 8
  %node1 = alloca %class.KV.0*, align 8
  store %class.KV* %kv, %class.KV** %1, align 8
  store i64 %h, i64* %2, align 8
  store %class.scheme_key* %key, %class.scheme_key** %3, align 8
  store i64* %cptr, i64** %4, align 8
  %5 = load %class.KV*, %class.KV** %1, align 8
  %6 = getelementptr inbounds %class.KV, %class.KV* %5, i32 0, i32 1
  %7 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Val"* %6 to %class.KV.0**
  %8 = load %class.KV.0*, %class.KV.0** %7, align 8
  store %class.KV.0* %8, %class.KV.0** %data, align 8
  %9 = load %class.KV*, %class.KV** %1, align 8
  %10 = getelementptr inbounds %class.KV, %class.KV* %9, i32 0, i32 0
  %11 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Key"* %10 to i64*
  %12 = load i64, i64* %11, align 8
  %13 = lshr i64 %12, 1
  store i64 %13, i64* %bm, align 8
  %14 = load i64, i64* %2, align 8
  %15 = and i64 %14, 63
  %16 = urem i64 %15, 63
  %17 = trunc i64 %16 to i32
  store i32 %17, i32* %hpiece, align 4
  %18 = load i64, i64* %bm, align 8
  %19 = call i64 @llvm.ctpop.i64(i64 %18)
  %20 = trunc i64 %19 to i32
  store i32 %20, i32* %count, align 4
  %21 = load i64, i64* %bm, align 8
  %22 = load i32, i32* %hpiece, align 4
  %23 = zext i32 %22 to i64
  %24 = shl i64 1, %23
  %25 = and i64 %21, %24
  %26 = icmp ne i64 %25, 0
  %27 = zext i1 %26 to i8
  store i8 %27, i8* %exists, align 1
  %28 = load i8, i8* %exists, align 1
  %29 = trunc i8 %28 to i1
  br i1 %29, label %30, label %130

; <label>:30                                      ; preds = %0
  %31 = load i64, i64* %bm, align 8
  %32 = shl i64 %31, 1
  %33 = load i32, i32* %hpiece, align 4
  %34 = sub i32 63, %33
  %35 = zext i32 %34 to i64
  %36 = shl i64 %32, %35
  %37 = call i64 @llvm.ctpop.i64(i64 %36)
  %38 = trunc i64 %37 to i32
  store i32 %38, i32* %i, align 4
  %39 = load i32, i32* %i, align 4
  %40 = zext i32 %39 to i64
  %41 = load %class.KV.0*, %class.KV.0** %data, align 8
  %42 = getelementptr inbounds %class.KV.0, %class.KV.0* %41, i64 %40
  %43 = getelementptr inbounds %class.KV.0, %class.KV.0* %42, i32 0, i32 0
  %44 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Key"* %43 to i64*
  %45 = load i64, i64* %44, align 8
  %46 = and i64 %45, 1
  %47 = icmp eq i64 %46, 0
  br i1 %47, label %48, label %104

; <label>:48                                      ; preds = %30
  %49 = load i32, i32* %i, align 4
  %50 = zext i32 %49 to i64
  %51 = load %class.KV.0*, %class.KV.0** %data, align 8
  %52 = getelementptr inbounds %class.KV.0, %class.KV.0* %51, i64 %50
  %53 = getelementptr inbounds %class.KV.0, %class.KV.0* %52, i32 0, i32 0
  %54 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Key"* %53 to %class.scheme_key**
  %55 = load %class.scheme_key*, %class.scheme_key** %54, align 8
  %56 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %57 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %55, %class.scheme_key* dereferenceable(8) %56)
  br i1 %57, label %58, label %102

; <label>:58                                      ; preds = %48
  %59 = load i64*, i64** %4, align 8
  %60 = load i64, i64* %59, align 8
  %61 = add i64 %60, -1
  store i64 %61, i64* %59, align 8
  %62 = load i32, i32* %count, align 4
  %63 = sub i32 %62, 1
  %64 = zext i32 %63 to i64
  %65 = mul i64 %64, 16
  %66 = call noalias i8* @GC_malloc(i64 %65)
  %67 = bitcast i8* %66 to %class.KV.0*
  store %class.KV.0* %67, %class.KV.0** %node, align 8
  %68 = load %class.KV.0*, %class.KV.0** %node, align 8
  %69 = bitcast %class.KV.0* %68 to i8*
  %70 = load %class.KV.0*, %class.KV.0** %data, align 8
  %71 = bitcast %class.KV.0* %70 to i8*
  %72 = load i32, i32* %i, align 4
  %73 = zext i32 %72 to i64
  %74 = mul i64 %73, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %69, i8* %71, i64 %74, i32 8, i1 false)
  %75 = load i32, i32* %i, align 4
  %76 = zext i32 %75 to i64
  %77 = load %class.KV.0*, %class.KV.0** %node, align 8
  %78 = getelementptr inbounds %class.KV.0, %class.KV.0* %77, i64 %76
  %79 = bitcast %class.KV.0* %78 to i8*
  %80 = load i32, i32* %i, align 4
  %81 = add i32 %80, 1
  %82 = zext i32 %81 to i64
  %83 = load %class.KV.0*, %class.KV.0** %data, align 8
  %84 = getelementptr inbounds %class.KV.0, %class.KV.0* %83, i64 %82
  %85 = bitcast %class.KV.0* %84 to i8*
  %86 = load i32, i32* %count, align 4
  %87 = sub i32 %86, 1
  %88 = load i32, i32* %i, align 4
  %89 = sub i32 %87, %88
  %90 = zext i32 %89 to i64
  %91 = mul i64 %90, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %79, i8* %85, i64 %91, i32 8, i1 false)
  %92 = load i64, i64* %bm, align 8
  %93 = load i32, i32* %hpiece, align 4
  %94 = zext i32 %93 to i64
  %95 = shl i64 1, %94
  %96 = xor i64 -1, %95
  %97 = and i64 %92, %96
  %98 = shl i64 %97, 1
  %99 = or i64 %98, 1
  store i64 %99, i64* %newbm, align 8
  %100 = load i64, i64* %newbm, align 8
  %101 = load %class.KV.0*, %class.KV.0** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EEC2EmPKS_IS0_S1_Lj1EE(%class.KV* %agg.result, i64 %100, %class.KV.0* %101)
  br label %132

; <label>:102                                     ; preds = %48
  %103 = load %class.KV*, %class.KV** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EEC2ERKS2_(%class.KV* %agg.result, %class.KV* dereferenceable(16) %103)
  br label %132

; <label>:104                                     ; preds = %30
  %105 = load i32, i32* %i, align 4
  %106 = zext i32 %105 to i64
  %107 = load %class.KV.0*, %class.KV.0** %data, align 8
  %108 = getelementptr inbounds %class.KV.0, %class.KV.0* %107, i64 %106
  %109 = load i64, i64* %2, align 8
  %110 = lshr i64 %109, 6
  %111 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %112 = load i64*, i64** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EE12remove_innerERKS2_mPKS0_Pm(%class.KV.0* sret %childkv, %class.KV.0* dereferenceable(16) %108, i64 %110, %class.scheme_key* %111, i64* %112)
  %113 = load i32, i32* %i, align 4
  %114 = zext i32 %113 to i64
  %115 = load %class.KV.0*, %class.KV.0** %data, align 8
  %116 = getelementptr inbounds %class.KV.0, %class.KV.0* %115, i64 %114
  %117 = call zeroext i1 @_ZNK2KVI10scheme_key12scheme_valueLj1EEeqERKS2_(%class.KV.0* %childkv, %class.KV.0* dereferenceable(16) %116)
  br i1 %117, label %118, label %120

; <label>:118                                     ; preds = %104
  %119 = load %class.KV*, %class.KV** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EEC2ERKS2_(%class.KV* %agg.result, %class.KV* dereferenceable(16) %119)
  br label %132

; <label>:120                                     ; preds = %104
  %121 = load %class.KV.0*, %class.KV.0** %data, align 8
  %122 = load i32, i32* %count, align 4
  %123 = load i32, i32* %i, align 4
  %124 = call %class.KV.0* @_ZN2KVI10scheme_key12scheme_valueLj1EE11update_nodeEPKS2_jjRS3_(%class.KV.0* %121, i32 %122, i32 %123, %class.KV.0* dereferenceable(16) %childkv)
  store %class.KV.0* %124, %class.KV.0** %node1, align 8
  %125 = load %class.KV*, %class.KV** %1, align 8
  %126 = getelementptr inbounds %class.KV, %class.KV* %125, i32 0, i32 0
  %127 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Key"* %126 to i64*
  %128 = load i64, i64* %127, align 8
  %129 = load %class.KV.0*, %class.KV.0** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EEC2EmPKS_IS0_S1_Lj1EE(%class.KV* %agg.result, i64 %128, %class.KV.0* %129)
  br label %132

; <label>:130                                     ; preds = %0
  %131 = load %class.KV*, %class.KV** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj0EEC2ERKS2_(%class.KV* %agg.result, %class.KV* dereferenceable(16) %131)
  br label %132

; <label>:132                                     ; preds = %130, %120, %118, %102, %58
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr zeroext i1 @_ZNK2KVI10scheme_key12scheme_valueLj0EEeqERKS2_(%class.KV* %this, %class.KV* dereferenceable(16) %kv) #5 comdat align 2 {
  %1 = alloca %class.KV*, align 8
  %2 = alloca %class.KV*, align 8
  store %class.KV* %this, %class.KV** %1, align 8
  store %class.KV* %kv, %class.KV** %2, align 8
  %3 = load %class.KV*, %class.KV** %1, align 8
  %4 = getelementptr inbounds %class.KV, %class.KV* %3, i32 0, i32 0
  %5 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Key"* %4 to i64*
  %6 = load i64, i64* %5, align 8
  %7 = load %class.KV*, %class.KV** %2, align 8
  %8 = getelementptr inbounds %class.KV, %class.KV* %7, i32 0, i32 0
  %9 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Key"* %8 to i64*
  %10 = load i64, i64* %9, align 8
  %11 = icmp eq i64 %6, %10
  br i1 %11, label %12, label %21

; <label>:12                                      ; preds = %0
  %13 = getelementptr inbounds %class.KV, %class.KV* %3, i32 0, i32 1
  %14 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Val"* %13 to %class.KV.0**
  %15 = load %class.KV.0*, %class.KV.0** %14, align 8
  %16 = load %class.KV*, %class.KV** %2, align 8
  %17 = getelementptr inbounds %class.KV, %class.KV* %16, i32 0, i32 1
  %18 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Val"* %17 to %class.KV.0**
  %19 = load %class.KV.0*, %class.KV.0** %18, align 8
  %20 = icmp eq %class.KV.0* %15, %19
  br label %21

; <label>:21                                      ; preds = %12, %0
  %22 = phi i1 [ false, %0 ], [ %20, %12 ]
  ret i1 %22
}

; Function Attrs: nounwind uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj0EEC2ERKS2_(%class.KV* %this, %class.KV* dereferenceable(16) %o) unnamed_addr #5 comdat align 2 {
  %1 = alloca %class.KV*, align 8
  %2 = alloca %class.KV*, align 8
  store %class.KV* %this, %class.KV** %1, align 8
  store %class.KV* %o, %class.KV** %2, align 8
  %3 = load %class.KV*, %class.KV** %1, align 8
  %4 = getelementptr inbounds %class.KV, %class.KV* %3, i32 0, i32 0
  %5 = load %class.KV*, %class.KV** %2, align 8
  %6 = getelementptr inbounds %class.KV, %class.KV* %5, i32 0, i32 0
  %7 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Key"* %4 to i8*
  %8 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Key"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 8, i32 8, i1 false)
  %9 = getelementptr inbounds %class.KV, %class.KV* %3, i32 0, i32 1
  %10 = load %class.KV*, %class.KV** %2, align 8
  %11 = getelementptr inbounds %class.KV, %class.KV* %10, i32 0, i32 1
  %12 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Val"* %9 to i8*
  %13 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Val"* %11 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %12, i8* %13, i64 8, i32 8, i1 false)
  ret void
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj1EE12remove_innerERKS2_mPKS0_Pm(%class.KV.0* noalias sret %agg.result, %class.KV.0* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key, i64* %cptr) #0 comdat align 2 {
  %1 = alloca %class.KV.0*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.scheme_key*, align 8
  %4 = alloca i64*, align 8
  %data = alloca %class.KV.1*, align 8
  %bm = alloca i64, align 8
  %hpiece = alloca i32, align 4
  %count = alloca i32, align 4
  %exists = alloca i8, align 1
  %i = alloca i32, align 4
  %node = alloca %class.KV.1*, align 8
  %newbm = alloca i64, align 8
  %childkv = alloca %class.KV.1, align 8
  %node1 = alloca %class.KV.1*, align 8
  store %class.KV.0* %kv, %class.KV.0** %1, align 8
  store i64 %h, i64* %2, align 8
  store %class.scheme_key* %key, %class.scheme_key** %3, align 8
  store i64* %cptr, i64** %4, align 8
  %5 = load %class.KV.0*, %class.KV.0** %1, align 8
  %6 = getelementptr inbounds %class.KV.0, %class.KV.0* %5, i32 0, i32 1
  %7 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Val"* %6 to %class.KV.1**
  %8 = load %class.KV.1*, %class.KV.1** %7, align 8
  store %class.KV.1* %8, %class.KV.1** %data, align 8
  %9 = load %class.KV.0*, %class.KV.0** %1, align 8
  %10 = getelementptr inbounds %class.KV.0, %class.KV.0* %9, i32 0, i32 0
  %11 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Key"* %10 to i64*
  %12 = load i64, i64* %11, align 8
  %13 = lshr i64 %12, 1
  store i64 %13, i64* %bm, align 8
  %14 = load i64, i64* %2, align 8
  %15 = and i64 %14, 63
  %16 = urem i64 %15, 63
  %17 = trunc i64 %16 to i32
  store i32 %17, i32* %hpiece, align 4
  %18 = load i64, i64* %bm, align 8
  %19 = call i64 @llvm.ctpop.i64(i64 %18)
  %20 = trunc i64 %19 to i32
  store i32 %20, i32* %count, align 4
  %21 = load i64, i64* %bm, align 8
  %22 = load i32, i32* %hpiece, align 4
  %23 = zext i32 %22 to i64
  %24 = shl i64 1, %23
  %25 = and i64 %21, %24
  %26 = icmp ne i64 %25, 0
  %27 = zext i1 %26 to i8
  store i8 %27, i8* %exists, align 1
  %28 = load i8, i8* %exists, align 1
  %29 = trunc i8 %28 to i1
  br i1 %29, label %30, label %130

; <label>:30                                      ; preds = %0
  %31 = load i64, i64* %bm, align 8
  %32 = shl i64 %31, 1
  %33 = load i32, i32* %hpiece, align 4
  %34 = sub i32 63, %33
  %35 = zext i32 %34 to i64
  %36 = shl i64 %32, %35
  %37 = call i64 @llvm.ctpop.i64(i64 %36)
  %38 = trunc i64 %37 to i32
  store i32 %38, i32* %i, align 4
  %39 = load i32, i32* %i, align 4
  %40 = zext i32 %39 to i64
  %41 = load %class.KV.1*, %class.KV.1** %data, align 8
  %42 = getelementptr inbounds %class.KV.1, %class.KV.1* %41, i64 %40
  %43 = getelementptr inbounds %class.KV.1, %class.KV.1* %42, i32 0, i32 0
  %44 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Key"* %43 to i64*
  %45 = load i64, i64* %44, align 8
  %46 = and i64 %45, 1
  %47 = icmp eq i64 %46, 0
  br i1 %47, label %48, label %104

; <label>:48                                      ; preds = %30
  %49 = load i32, i32* %i, align 4
  %50 = zext i32 %49 to i64
  %51 = load %class.KV.1*, %class.KV.1** %data, align 8
  %52 = getelementptr inbounds %class.KV.1, %class.KV.1* %51, i64 %50
  %53 = getelementptr inbounds %class.KV.1, %class.KV.1* %52, i32 0, i32 0
  %54 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Key"* %53 to %class.scheme_key**
  %55 = load %class.scheme_key*, %class.scheme_key** %54, align 8
  %56 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %57 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %55, %class.scheme_key* dereferenceable(8) %56)
  br i1 %57, label %58, label %102

; <label>:58                                      ; preds = %48
  %59 = load i64*, i64** %4, align 8
  %60 = load i64, i64* %59, align 8
  %61 = add i64 %60, -1
  store i64 %61, i64* %59, align 8
  %62 = load i32, i32* %count, align 4
  %63 = sub i32 %62, 1
  %64 = zext i32 %63 to i64
  %65 = mul i64 %64, 16
  %66 = call noalias i8* @GC_malloc(i64 %65)
  %67 = bitcast i8* %66 to %class.KV.1*
  store %class.KV.1* %67, %class.KV.1** %node, align 8
  %68 = load %class.KV.1*, %class.KV.1** %node, align 8
  %69 = bitcast %class.KV.1* %68 to i8*
  %70 = load %class.KV.1*, %class.KV.1** %data, align 8
  %71 = bitcast %class.KV.1* %70 to i8*
  %72 = load i32, i32* %i, align 4
  %73 = zext i32 %72 to i64
  %74 = mul i64 %73, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %69, i8* %71, i64 %74, i32 8, i1 false)
  %75 = load i32, i32* %i, align 4
  %76 = zext i32 %75 to i64
  %77 = load %class.KV.1*, %class.KV.1** %node, align 8
  %78 = getelementptr inbounds %class.KV.1, %class.KV.1* %77, i64 %76
  %79 = bitcast %class.KV.1* %78 to i8*
  %80 = load i32, i32* %i, align 4
  %81 = add i32 %80, 1
  %82 = zext i32 %81 to i64
  %83 = load %class.KV.1*, %class.KV.1** %data, align 8
  %84 = getelementptr inbounds %class.KV.1, %class.KV.1* %83, i64 %82
  %85 = bitcast %class.KV.1* %84 to i8*
  %86 = load i32, i32* %count, align 4
  %87 = sub i32 %86, 1
  %88 = load i32, i32* %i, align 4
  %89 = sub i32 %87, %88
  %90 = zext i32 %89 to i64
  %91 = mul i64 %90, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %79, i8* %85, i64 %91, i32 8, i1 false)
  %92 = load i64, i64* %bm, align 8
  %93 = load i32, i32* %hpiece, align 4
  %94 = zext i32 %93 to i64
  %95 = shl i64 1, %94
  %96 = xor i64 -1, %95
  %97 = and i64 %92, %96
  %98 = shl i64 %97, 1
  %99 = or i64 %98, 1
  store i64 %99, i64* %newbm, align 8
  %100 = load i64, i64* %newbm, align 8
  %101 = load %class.KV.1*, %class.KV.1** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EEC2EmPKS_IS0_S1_Lj2EE(%class.KV.0* %agg.result, i64 %100, %class.KV.1* %101)
  br label %132

; <label>:102                                     ; preds = %48
  %103 = load %class.KV.0*, %class.KV.0** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EEC2ERKS2_(%class.KV.0* %agg.result, %class.KV.0* dereferenceable(16) %103)
  br label %132

; <label>:104                                     ; preds = %30
  %105 = load i32, i32* %i, align 4
  %106 = zext i32 %105 to i64
  %107 = load %class.KV.1*, %class.KV.1** %data, align 8
  %108 = getelementptr inbounds %class.KV.1, %class.KV.1* %107, i64 %106
  %109 = load i64, i64* %2, align 8
  %110 = lshr i64 %109, 6
  %111 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %112 = load i64*, i64** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EE12remove_innerERKS2_mPKS0_Pm(%class.KV.1* sret %childkv, %class.KV.1* dereferenceable(16) %108, i64 %110, %class.scheme_key* %111, i64* %112)
  %113 = load i32, i32* %i, align 4
  %114 = zext i32 %113 to i64
  %115 = load %class.KV.1*, %class.KV.1** %data, align 8
  %116 = getelementptr inbounds %class.KV.1, %class.KV.1* %115, i64 %114
  %117 = call zeroext i1 @_ZNK2KVI10scheme_key12scheme_valueLj2EEeqERKS2_(%class.KV.1* %childkv, %class.KV.1* dereferenceable(16) %116)
  br i1 %117, label %118, label %120

; <label>:118                                     ; preds = %104
  %119 = load %class.KV.0*, %class.KV.0** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EEC2ERKS2_(%class.KV.0* %agg.result, %class.KV.0* dereferenceable(16) %119)
  br label %132

; <label>:120                                     ; preds = %104
  %121 = load %class.KV.1*, %class.KV.1** %data, align 8
  %122 = load i32, i32* %count, align 4
  %123 = load i32, i32* %i, align 4
  %124 = call %class.KV.1* @_ZN2KVI10scheme_key12scheme_valueLj2EE11update_nodeEPKS2_jjRS3_(%class.KV.1* %121, i32 %122, i32 %123, %class.KV.1* dereferenceable(16) %childkv)
  store %class.KV.1* %124, %class.KV.1** %node1, align 8
  %125 = load %class.KV.0*, %class.KV.0** %1, align 8
  %126 = getelementptr inbounds %class.KV.0, %class.KV.0* %125, i32 0, i32 0
  %127 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Key"* %126 to i64*
  %128 = load i64, i64* %127, align 8
  %129 = load %class.KV.1*, %class.KV.1** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EEC2EmPKS_IS0_S1_Lj2EE(%class.KV.0* %agg.result, i64 %128, %class.KV.1* %129)
  br label %132

; <label>:130                                     ; preds = %0
  %131 = load %class.KV.0*, %class.KV.0** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj1EEC2ERKS2_(%class.KV.0* %agg.result, %class.KV.0* dereferenceable(16) %131)
  br label %132

; <label>:132                                     ; preds = %130, %120, %118, %102, %58
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr zeroext i1 @_ZNK2KVI10scheme_key12scheme_valueLj1EEeqERKS2_(%class.KV.0* %this, %class.KV.0* dereferenceable(16) %kv) #5 comdat align 2 {
  %1 = alloca %class.KV.0*, align 8
  %2 = alloca %class.KV.0*, align 8
  store %class.KV.0* %this, %class.KV.0** %1, align 8
  store %class.KV.0* %kv, %class.KV.0** %2, align 8
  %3 = load %class.KV.0*, %class.KV.0** %1, align 8
  %4 = getelementptr inbounds %class.KV.0, %class.KV.0* %3, i32 0, i32 0
  %5 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Key"* %4 to i64*
  %6 = load i64, i64* %5, align 8
  %7 = load %class.KV.0*, %class.KV.0** %2, align 8
  %8 = getelementptr inbounds %class.KV.0, %class.KV.0* %7, i32 0, i32 0
  %9 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Key"* %8 to i64*
  %10 = load i64, i64* %9, align 8
  %11 = icmp eq i64 %6, %10
  br i1 %11, label %12, label %21

; <label>:12                                      ; preds = %0
  %13 = getelementptr inbounds %class.KV.0, %class.KV.0* %3, i32 0, i32 1
  %14 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Val"* %13 to %class.KV.1**
  %15 = load %class.KV.1*, %class.KV.1** %14, align 8
  %16 = load %class.KV.0*, %class.KV.0** %2, align 8
  %17 = getelementptr inbounds %class.KV.0, %class.KV.0* %16, i32 0, i32 1
  %18 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Val"* %17 to %class.KV.1**
  %19 = load %class.KV.1*, %class.KV.1** %18, align 8
  %20 = icmp eq %class.KV.1* %15, %19
  br label %21

; <label>:21                                      ; preds = %12, %0
  %22 = phi i1 [ false, %0 ], [ %20, %12 ]
  ret i1 %22
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj2EE12remove_innerERKS2_mPKS0_Pm(%class.KV.1* noalias sret %agg.result, %class.KV.1* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key, i64* %cptr) #0 comdat align 2 {
  %1 = alloca %class.KV.1*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.scheme_key*, align 8
  %4 = alloca i64*, align 8
  %data = alloca %class.KV.2*, align 8
  %bm = alloca i64, align 8
  %hpiece = alloca i32, align 4
  %count = alloca i32, align 4
  %exists = alloca i8, align 1
  %i = alloca i32, align 4
  %node = alloca %class.KV.2*, align 8
  %newbm = alloca i64, align 8
  %childkv = alloca %class.KV.2, align 8
  %node1 = alloca %class.KV.2*, align 8
  store %class.KV.1* %kv, %class.KV.1** %1, align 8
  store i64 %h, i64* %2, align 8
  store %class.scheme_key* %key, %class.scheme_key** %3, align 8
  store i64* %cptr, i64** %4, align 8
  %5 = load %class.KV.1*, %class.KV.1** %1, align 8
  %6 = getelementptr inbounds %class.KV.1, %class.KV.1* %5, i32 0, i32 1
  %7 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Val"* %6 to %class.KV.2**
  %8 = load %class.KV.2*, %class.KV.2** %7, align 8
  store %class.KV.2* %8, %class.KV.2** %data, align 8
  %9 = load %class.KV.1*, %class.KV.1** %1, align 8
  %10 = getelementptr inbounds %class.KV.1, %class.KV.1* %9, i32 0, i32 0
  %11 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Key"* %10 to i64*
  %12 = load i64, i64* %11, align 8
  %13 = lshr i64 %12, 1
  store i64 %13, i64* %bm, align 8
  %14 = load i64, i64* %2, align 8
  %15 = and i64 %14, 63
  %16 = urem i64 %15, 63
  %17 = trunc i64 %16 to i32
  store i32 %17, i32* %hpiece, align 4
  %18 = load i64, i64* %bm, align 8
  %19 = call i64 @llvm.ctpop.i64(i64 %18)
  %20 = trunc i64 %19 to i32
  store i32 %20, i32* %count, align 4
  %21 = load i64, i64* %bm, align 8
  %22 = load i32, i32* %hpiece, align 4
  %23 = zext i32 %22 to i64
  %24 = shl i64 1, %23
  %25 = and i64 %21, %24
  %26 = icmp ne i64 %25, 0
  %27 = zext i1 %26 to i8
  store i8 %27, i8* %exists, align 1
  %28 = load i8, i8* %exists, align 1
  %29 = trunc i8 %28 to i1
  br i1 %29, label %30, label %130

; <label>:30                                      ; preds = %0
  %31 = load i64, i64* %bm, align 8
  %32 = shl i64 %31, 1
  %33 = load i32, i32* %hpiece, align 4
  %34 = sub i32 63, %33
  %35 = zext i32 %34 to i64
  %36 = shl i64 %32, %35
  %37 = call i64 @llvm.ctpop.i64(i64 %36)
  %38 = trunc i64 %37 to i32
  store i32 %38, i32* %i, align 4
  %39 = load i32, i32* %i, align 4
  %40 = zext i32 %39 to i64
  %41 = load %class.KV.2*, %class.KV.2** %data, align 8
  %42 = getelementptr inbounds %class.KV.2, %class.KV.2* %41, i64 %40
  %43 = getelementptr inbounds %class.KV.2, %class.KV.2* %42, i32 0, i32 0
  %44 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Key"* %43 to i64*
  %45 = load i64, i64* %44, align 8
  %46 = and i64 %45, 1
  %47 = icmp eq i64 %46, 0
  br i1 %47, label %48, label %104

; <label>:48                                      ; preds = %30
  %49 = load i32, i32* %i, align 4
  %50 = zext i32 %49 to i64
  %51 = load %class.KV.2*, %class.KV.2** %data, align 8
  %52 = getelementptr inbounds %class.KV.2, %class.KV.2* %51, i64 %50
  %53 = getelementptr inbounds %class.KV.2, %class.KV.2* %52, i32 0, i32 0
  %54 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Key"* %53 to %class.scheme_key**
  %55 = load %class.scheme_key*, %class.scheme_key** %54, align 8
  %56 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %57 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %55, %class.scheme_key* dereferenceable(8) %56)
  br i1 %57, label %58, label %102

; <label>:58                                      ; preds = %48
  %59 = load i64*, i64** %4, align 8
  %60 = load i64, i64* %59, align 8
  %61 = add i64 %60, -1
  store i64 %61, i64* %59, align 8
  %62 = load i32, i32* %count, align 4
  %63 = sub i32 %62, 1
  %64 = zext i32 %63 to i64
  %65 = mul i64 %64, 16
  %66 = call noalias i8* @GC_malloc(i64 %65)
  %67 = bitcast i8* %66 to %class.KV.2*
  store %class.KV.2* %67, %class.KV.2** %node, align 8
  %68 = load %class.KV.2*, %class.KV.2** %node, align 8
  %69 = bitcast %class.KV.2* %68 to i8*
  %70 = load %class.KV.2*, %class.KV.2** %data, align 8
  %71 = bitcast %class.KV.2* %70 to i8*
  %72 = load i32, i32* %i, align 4
  %73 = zext i32 %72 to i64
  %74 = mul i64 %73, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %69, i8* %71, i64 %74, i32 8, i1 false)
  %75 = load i32, i32* %i, align 4
  %76 = zext i32 %75 to i64
  %77 = load %class.KV.2*, %class.KV.2** %node, align 8
  %78 = getelementptr inbounds %class.KV.2, %class.KV.2* %77, i64 %76
  %79 = bitcast %class.KV.2* %78 to i8*
  %80 = load i32, i32* %i, align 4
  %81 = add i32 %80, 1
  %82 = zext i32 %81 to i64
  %83 = load %class.KV.2*, %class.KV.2** %data, align 8
  %84 = getelementptr inbounds %class.KV.2, %class.KV.2* %83, i64 %82
  %85 = bitcast %class.KV.2* %84 to i8*
  %86 = load i32, i32* %count, align 4
  %87 = sub i32 %86, 1
  %88 = load i32, i32* %i, align 4
  %89 = sub i32 %87, %88
  %90 = zext i32 %89 to i64
  %91 = mul i64 %90, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %79, i8* %85, i64 %91, i32 8, i1 false)
  %92 = load i64, i64* %bm, align 8
  %93 = load i32, i32* %hpiece, align 4
  %94 = zext i32 %93 to i64
  %95 = shl i64 1, %94
  %96 = xor i64 -1, %95
  %97 = and i64 %92, %96
  %98 = shl i64 %97, 1
  %99 = or i64 %98, 1
  store i64 %99, i64* %newbm, align 8
  %100 = load i64, i64* %newbm, align 8
  %101 = load %class.KV.2*, %class.KV.2** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EEC2EmPKS_IS0_S1_Lj3EE(%class.KV.1* %agg.result, i64 %100, %class.KV.2* %101)
  br label %132

; <label>:102                                     ; preds = %48
  %103 = load %class.KV.1*, %class.KV.1** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EEC2ERKS2_(%class.KV.1* %agg.result, %class.KV.1* dereferenceable(16) %103)
  br label %132

; <label>:104                                     ; preds = %30
  %105 = load i32, i32* %i, align 4
  %106 = zext i32 %105 to i64
  %107 = load %class.KV.2*, %class.KV.2** %data, align 8
  %108 = getelementptr inbounds %class.KV.2, %class.KV.2* %107, i64 %106
  %109 = load i64, i64* %2, align 8
  %110 = lshr i64 %109, 6
  %111 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %112 = load i64*, i64** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EE12remove_innerERKS2_mPKS0_Pm(%class.KV.2* sret %childkv, %class.KV.2* dereferenceable(16) %108, i64 %110, %class.scheme_key* %111, i64* %112)
  %113 = load i32, i32* %i, align 4
  %114 = zext i32 %113 to i64
  %115 = load %class.KV.2*, %class.KV.2** %data, align 8
  %116 = getelementptr inbounds %class.KV.2, %class.KV.2* %115, i64 %114
  %117 = call zeroext i1 @_ZNK2KVI10scheme_key12scheme_valueLj3EEeqERKS2_(%class.KV.2* %childkv, %class.KV.2* dereferenceable(16) %116)
  br i1 %117, label %118, label %120

; <label>:118                                     ; preds = %104
  %119 = load %class.KV.1*, %class.KV.1** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EEC2ERKS2_(%class.KV.1* %agg.result, %class.KV.1* dereferenceable(16) %119)
  br label %132

; <label>:120                                     ; preds = %104
  %121 = load %class.KV.2*, %class.KV.2** %data, align 8
  %122 = load i32, i32* %count, align 4
  %123 = load i32, i32* %i, align 4
  %124 = call %class.KV.2* @_ZN2KVI10scheme_key12scheme_valueLj3EE11update_nodeEPKS2_jjRS3_(%class.KV.2* %121, i32 %122, i32 %123, %class.KV.2* dereferenceable(16) %childkv)
  store %class.KV.2* %124, %class.KV.2** %node1, align 8
  %125 = load %class.KV.1*, %class.KV.1** %1, align 8
  %126 = getelementptr inbounds %class.KV.1, %class.KV.1* %125, i32 0, i32 0
  %127 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Key"* %126 to i64*
  %128 = load i64, i64* %127, align 8
  %129 = load %class.KV.2*, %class.KV.2** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EEC2EmPKS_IS0_S1_Lj3EE(%class.KV.1* %agg.result, i64 %128, %class.KV.2* %129)
  br label %132

; <label>:130                                     ; preds = %0
  %131 = load %class.KV.1*, %class.KV.1** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj2EEC2ERKS2_(%class.KV.1* %agg.result, %class.KV.1* dereferenceable(16) %131)
  br label %132

; <label>:132                                     ; preds = %130, %120, %118, %102, %58
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr zeroext i1 @_ZNK2KVI10scheme_key12scheme_valueLj2EEeqERKS2_(%class.KV.1* %this, %class.KV.1* dereferenceable(16) %kv) #5 comdat align 2 {
  %1 = alloca %class.KV.1*, align 8
  %2 = alloca %class.KV.1*, align 8
  store %class.KV.1* %this, %class.KV.1** %1, align 8
  store %class.KV.1* %kv, %class.KV.1** %2, align 8
  %3 = load %class.KV.1*, %class.KV.1** %1, align 8
  %4 = getelementptr inbounds %class.KV.1, %class.KV.1* %3, i32 0, i32 0
  %5 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Key"* %4 to i64*
  %6 = load i64, i64* %5, align 8
  %7 = load %class.KV.1*, %class.KV.1** %2, align 8
  %8 = getelementptr inbounds %class.KV.1, %class.KV.1* %7, i32 0, i32 0
  %9 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Key"* %8 to i64*
  %10 = load i64, i64* %9, align 8
  %11 = icmp eq i64 %6, %10
  br i1 %11, label %12, label %21

; <label>:12                                      ; preds = %0
  %13 = getelementptr inbounds %class.KV.1, %class.KV.1* %3, i32 0, i32 1
  %14 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Val"* %13 to %class.KV.2**
  %15 = load %class.KV.2*, %class.KV.2** %14, align 8
  %16 = load %class.KV.1*, %class.KV.1** %2, align 8
  %17 = getelementptr inbounds %class.KV.1, %class.KV.1* %16, i32 0, i32 1
  %18 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Val"* %17 to %class.KV.2**
  %19 = load %class.KV.2*, %class.KV.2** %18, align 8
  %20 = icmp eq %class.KV.2* %15, %19
  br label %21

; <label>:21                                      ; preds = %12, %0
  %22 = phi i1 [ false, %0 ], [ %20, %12 ]
  ret i1 %22
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj3EE12remove_innerERKS2_mPKS0_Pm(%class.KV.2* noalias sret %agg.result, %class.KV.2* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key, i64* %cptr) #0 comdat align 2 {
  %1 = alloca %class.KV.2*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.scheme_key*, align 8
  %4 = alloca i64*, align 8
  %data = alloca %class.KV.3*, align 8
  %bm = alloca i64, align 8
  %hpiece = alloca i32, align 4
  %count = alloca i32, align 4
  %exists = alloca i8, align 1
  %i = alloca i32, align 4
  %node = alloca %class.KV.3*, align 8
  %newbm = alloca i64, align 8
  %childkv = alloca %class.KV.3, align 8
  %node1 = alloca %class.KV.3*, align 8
  store %class.KV.2* %kv, %class.KV.2** %1, align 8
  store i64 %h, i64* %2, align 8
  store %class.scheme_key* %key, %class.scheme_key** %3, align 8
  store i64* %cptr, i64** %4, align 8
  %5 = load %class.KV.2*, %class.KV.2** %1, align 8
  %6 = getelementptr inbounds %class.KV.2, %class.KV.2* %5, i32 0, i32 1
  %7 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Val"* %6 to %class.KV.3**
  %8 = load %class.KV.3*, %class.KV.3** %7, align 8
  store %class.KV.3* %8, %class.KV.3** %data, align 8
  %9 = load %class.KV.2*, %class.KV.2** %1, align 8
  %10 = getelementptr inbounds %class.KV.2, %class.KV.2* %9, i32 0, i32 0
  %11 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Key"* %10 to i64*
  %12 = load i64, i64* %11, align 8
  %13 = lshr i64 %12, 1
  store i64 %13, i64* %bm, align 8
  %14 = load i64, i64* %2, align 8
  %15 = and i64 %14, 63
  %16 = urem i64 %15, 63
  %17 = trunc i64 %16 to i32
  store i32 %17, i32* %hpiece, align 4
  %18 = load i64, i64* %bm, align 8
  %19 = call i64 @llvm.ctpop.i64(i64 %18)
  %20 = trunc i64 %19 to i32
  store i32 %20, i32* %count, align 4
  %21 = load i64, i64* %bm, align 8
  %22 = load i32, i32* %hpiece, align 4
  %23 = zext i32 %22 to i64
  %24 = shl i64 1, %23
  %25 = and i64 %21, %24
  %26 = icmp ne i64 %25, 0
  %27 = zext i1 %26 to i8
  store i8 %27, i8* %exists, align 1
  %28 = load i8, i8* %exists, align 1
  %29 = trunc i8 %28 to i1
  br i1 %29, label %30, label %130

; <label>:30                                      ; preds = %0
  %31 = load i64, i64* %bm, align 8
  %32 = shl i64 %31, 1
  %33 = load i32, i32* %hpiece, align 4
  %34 = sub i32 63, %33
  %35 = zext i32 %34 to i64
  %36 = shl i64 %32, %35
  %37 = call i64 @llvm.ctpop.i64(i64 %36)
  %38 = trunc i64 %37 to i32
  store i32 %38, i32* %i, align 4
  %39 = load i32, i32* %i, align 4
  %40 = zext i32 %39 to i64
  %41 = load %class.KV.3*, %class.KV.3** %data, align 8
  %42 = getelementptr inbounds %class.KV.3, %class.KV.3* %41, i64 %40
  %43 = getelementptr inbounds %class.KV.3, %class.KV.3* %42, i32 0, i32 0
  %44 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Key"* %43 to i64*
  %45 = load i64, i64* %44, align 8
  %46 = and i64 %45, 1
  %47 = icmp eq i64 %46, 0
  br i1 %47, label %48, label %104

; <label>:48                                      ; preds = %30
  %49 = load i32, i32* %i, align 4
  %50 = zext i32 %49 to i64
  %51 = load %class.KV.3*, %class.KV.3** %data, align 8
  %52 = getelementptr inbounds %class.KV.3, %class.KV.3* %51, i64 %50
  %53 = getelementptr inbounds %class.KV.3, %class.KV.3* %52, i32 0, i32 0
  %54 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Key"* %53 to %class.scheme_key**
  %55 = load %class.scheme_key*, %class.scheme_key** %54, align 8
  %56 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %57 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %55, %class.scheme_key* dereferenceable(8) %56)
  br i1 %57, label %58, label %102

; <label>:58                                      ; preds = %48
  %59 = load i64*, i64** %4, align 8
  %60 = load i64, i64* %59, align 8
  %61 = add i64 %60, -1
  store i64 %61, i64* %59, align 8
  %62 = load i32, i32* %count, align 4
  %63 = sub i32 %62, 1
  %64 = zext i32 %63 to i64
  %65 = mul i64 %64, 16
  %66 = call noalias i8* @GC_malloc(i64 %65)
  %67 = bitcast i8* %66 to %class.KV.3*
  store %class.KV.3* %67, %class.KV.3** %node, align 8
  %68 = load %class.KV.3*, %class.KV.3** %node, align 8
  %69 = bitcast %class.KV.3* %68 to i8*
  %70 = load %class.KV.3*, %class.KV.3** %data, align 8
  %71 = bitcast %class.KV.3* %70 to i8*
  %72 = load i32, i32* %i, align 4
  %73 = zext i32 %72 to i64
  %74 = mul i64 %73, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %69, i8* %71, i64 %74, i32 8, i1 false)
  %75 = load i32, i32* %i, align 4
  %76 = zext i32 %75 to i64
  %77 = load %class.KV.3*, %class.KV.3** %node, align 8
  %78 = getelementptr inbounds %class.KV.3, %class.KV.3* %77, i64 %76
  %79 = bitcast %class.KV.3* %78 to i8*
  %80 = load i32, i32* %i, align 4
  %81 = add i32 %80, 1
  %82 = zext i32 %81 to i64
  %83 = load %class.KV.3*, %class.KV.3** %data, align 8
  %84 = getelementptr inbounds %class.KV.3, %class.KV.3* %83, i64 %82
  %85 = bitcast %class.KV.3* %84 to i8*
  %86 = load i32, i32* %count, align 4
  %87 = sub i32 %86, 1
  %88 = load i32, i32* %i, align 4
  %89 = sub i32 %87, %88
  %90 = zext i32 %89 to i64
  %91 = mul i64 %90, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %79, i8* %85, i64 %91, i32 8, i1 false)
  %92 = load i64, i64* %bm, align 8
  %93 = load i32, i32* %hpiece, align 4
  %94 = zext i32 %93 to i64
  %95 = shl i64 1, %94
  %96 = xor i64 -1, %95
  %97 = and i64 %92, %96
  %98 = shl i64 %97, 1
  %99 = or i64 %98, 1
  store i64 %99, i64* %newbm, align 8
  %100 = load i64, i64* %newbm, align 8
  %101 = load %class.KV.3*, %class.KV.3** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EEC2EmPKS_IS0_S1_Lj4EE(%class.KV.2* %agg.result, i64 %100, %class.KV.3* %101)
  br label %132

; <label>:102                                     ; preds = %48
  %103 = load %class.KV.2*, %class.KV.2** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EEC2ERKS2_(%class.KV.2* %agg.result, %class.KV.2* dereferenceable(16) %103)
  br label %132

; <label>:104                                     ; preds = %30
  %105 = load i32, i32* %i, align 4
  %106 = zext i32 %105 to i64
  %107 = load %class.KV.3*, %class.KV.3** %data, align 8
  %108 = getelementptr inbounds %class.KV.3, %class.KV.3* %107, i64 %106
  %109 = load i64, i64* %2, align 8
  %110 = lshr i64 %109, 6
  %111 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %112 = load i64*, i64** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EE12remove_innerERKS2_mPKS0_Pm(%class.KV.3* sret %childkv, %class.KV.3* dereferenceable(16) %108, i64 %110, %class.scheme_key* %111, i64* %112)
  %113 = load i32, i32* %i, align 4
  %114 = zext i32 %113 to i64
  %115 = load %class.KV.3*, %class.KV.3** %data, align 8
  %116 = getelementptr inbounds %class.KV.3, %class.KV.3* %115, i64 %114
  %117 = call zeroext i1 @_ZNK2KVI10scheme_key12scheme_valueLj4EEeqERKS2_(%class.KV.3* %childkv, %class.KV.3* dereferenceable(16) %116)
  br i1 %117, label %118, label %120

; <label>:118                                     ; preds = %104
  %119 = load %class.KV.2*, %class.KV.2** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EEC2ERKS2_(%class.KV.2* %agg.result, %class.KV.2* dereferenceable(16) %119)
  br label %132

; <label>:120                                     ; preds = %104
  %121 = load %class.KV.3*, %class.KV.3** %data, align 8
  %122 = load i32, i32* %count, align 4
  %123 = load i32, i32* %i, align 4
  %124 = call %class.KV.3* @_ZN2KVI10scheme_key12scheme_valueLj4EE11update_nodeEPKS2_jjRS3_(%class.KV.3* %121, i32 %122, i32 %123, %class.KV.3* dereferenceable(16) %childkv)
  store %class.KV.3* %124, %class.KV.3** %node1, align 8
  %125 = load %class.KV.2*, %class.KV.2** %1, align 8
  %126 = getelementptr inbounds %class.KV.2, %class.KV.2* %125, i32 0, i32 0
  %127 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Key"* %126 to i64*
  %128 = load i64, i64* %127, align 8
  %129 = load %class.KV.3*, %class.KV.3** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EEC2EmPKS_IS0_S1_Lj4EE(%class.KV.2* %agg.result, i64 %128, %class.KV.3* %129)
  br label %132

; <label>:130                                     ; preds = %0
  %131 = load %class.KV.2*, %class.KV.2** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj3EEC2ERKS2_(%class.KV.2* %agg.result, %class.KV.2* dereferenceable(16) %131)
  br label %132

; <label>:132                                     ; preds = %130, %120, %118, %102, %58
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr zeroext i1 @_ZNK2KVI10scheme_key12scheme_valueLj3EEeqERKS2_(%class.KV.2* %this, %class.KV.2* dereferenceable(16) %kv) #5 comdat align 2 {
  %1 = alloca %class.KV.2*, align 8
  %2 = alloca %class.KV.2*, align 8
  store %class.KV.2* %this, %class.KV.2** %1, align 8
  store %class.KV.2* %kv, %class.KV.2** %2, align 8
  %3 = load %class.KV.2*, %class.KV.2** %1, align 8
  %4 = getelementptr inbounds %class.KV.2, %class.KV.2* %3, i32 0, i32 0
  %5 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Key"* %4 to i64*
  %6 = load i64, i64* %5, align 8
  %7 = load %class.KV.2*, %class.KV.2** %2, align 8
  %8 = getelementptr inbounds %class.KV.2, %class.KV.2* %7, i32 0, i32 0
  %9 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Key"* %8 to i64*
  %10 = load i64, i64* %9, align 8
  %11 = icmp eq i64 %6, %10
  br i1 %11, label %12, label %21

; <label>:12                                      ; preds = %0
  %13 = getelementptr inbounds %class.KV.2, %class.KV.2* %3, i32 0, i32 1
  %14 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Val"* %13 to %class.KV.3**
  %15 = load %class.KV.3*, %class.KV.3** %14, align 8
  %16 = load %class.KV.2*, %class.KV.2** %2, align 8
  %17 = getelementptr inbounds %class.KV.2, %class.KV.2* %16, i32 0, i32 1
  %18 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Val"* %17 to %class.KV.3**
  %19 = load %class.KV.3*, %class.KV.3** %18, align 8
  %20 = icmp eq %class.KV.3* %15, %19
  br label %21

; <label>:21                                      ; preds = %12, %0
  %22 = phi i1 [ false, %0 ], [ %20, %12 ]
  ret i1 %22
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj4EE12remove_innerERKS2_mPKS0_Pm(%class.KV.3* noalias sret %agg.result, %class.KV.3* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key, i64* %cptr) #0 comdat align 2 {
  %1 = alloca %class.KV.3*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.scheme_key*, align 8
  %4 = alloca i64*, align 8
  %data = alloca %class.KV.4*, align 8
  %bm = alloca i64, align 8
  %hpiece = alloca i32, align 4
  %count = alloca i32, align 4
  %exists = alloca i8, align 1
  %i = alloca i32, align 4
  %node = alloca %class.KV.4*, align 8
  %newbm = alloca i64, align 8
  %childkv = alloca %class.KV.4, align 8
  %node1 = alloca %class.KV.4*, align 8
  store %class.KV.3* %kv, %class.KV.3** %1, align 8
  store i64 %h, i64* %2, align 8
  store %class.scheme_key* %key, %class.scheme_key** %3, align 8
  store i64* %cptr, i64** %4, align 8
  %5 = load %class.KV.3*, %class.KV.3** %1, align 8
  %6 = getelementptr inbounds %class.KV.3, %class.KV.3* %5, i32 0, i32 1
  %7 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Val"* %6 to %class.KV.4**
  %8 = load %class.KV.4*, %class.KV.4** %7, align 8
  store %class.KV.4* %8, %class.KV.4** %data, align 8
  %9 = load %class.KV.3*, %class.KV.3** %1, align 8
  %10 = getelementptr inbounds %class.KV.3, %class.KV.3* %9, i32 0, i32 0
  %11 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Key"* %10 to i64*
  %12 = load i64, i64* %11, align 8
  %13 = lshr i64 %12, 1
  store i64 %13, i64* %bm, align 8
  %14 = load i64, i64* %2, align 8
  %15 = and i64 %14, 63
  %16 = urem i64 %15, 63
  %17 = trunc i64 %16 to i32
  store i32 %17, i32* %hpiece, align 4
  %18 = load i64, i64* %bm, align 8
  %19 = call i64 @llvm.ctpop.i64(i64 %18)
  %20 = trunc i64 %19 to i32
  store i32 %20, i32* %count, align 4
  %21 = load i64, i64* %bm, align 8
  %22 = load i32, i32* %hpiece, align 4
  %23 = zext i32 %22 to i64
  %24 = shl i64 1, %23
  %25 = and i64 %21, %24
  %26 = icmp ne i64 %25, 0
  %27 = zext i1 %26 to i8
  store i8 %27, i8* %exists, align 1
  %28 = load i8, i8* %exists, align 1
  %29 = trunc i8 %28 to i1
  br i1 %29, label %30, label %130

; <label>:30                                      ; preds = %0
  %31 = load i64, i64* %bm, align 8
  %32 = shl i64 %31, 1
  %33 = load i32, i32* %hpiece, align 4
  %34 = sub i32 63, %33
  %35 = zext i32 %34 to i64
  %36 = shl i64 %32, %35
  %37 = call i64 @llvm.ctpop.i64(i64 %36)
  %38 = trunc i64 %37 to i32
  store i32 %38, i32* %i, align 4
  %39 = load i32, i32* %i, align 4
  %40 = zext i32 %39 to i64
  %41 = load %class.KV.4*, %class.KV.4** %data, align 8
  %42 = getelementptr inbounds %class.KV.4, %class.KV.4* %41, i64 %40
  %43 = getelementptr inbounds %class.KV.4, %class.KV.4* %42, i32 0, i32 0
  %44 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Key"* %43 to i64*
  %45 = load i64, i64* %44, align 8
  %46 = and i64 %45, 1
  %47 = icmp eq i64 %46, 0
  br i1 %47, label %48, label %104

; <label>:48                                      ; preds = %30
  %49 = load i32, i32* %i, align 4
  %50 = zext i32 %49 to i64
  %51 = load %class.KV.4*, %class.KV.4** %data, align 8
  %52 = getelementptr inbounds %class.KV.4, %class.KV.4* %51, i64 %50
  %53 = getelementptr inbounds %class.KV.4, %class.KV.4* %52, i32 0, i32 0
  %54 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Key"* %53 to %class.scheme_key**
  %55 = load %class.scheme_key*, %class.scheme_key** %54, align 8
  %56 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %57 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %55, %class.scheme_key* dereferenceable(8) %56)
  br i1 %57, label %58, label %102

; <label>:58                                      ; preds = %48
  %59 = load i64*, i64** %4, align 8
  %60 = load i64, i64* %59, align 8
  %61 = add i64 %60, -1
  store i64 %61, i64* %59, align 8
  %62 = load i32, i32* %count, align 4
  %63 = sub i32 %62, 1
  %64 = zext i32 %63 to i64
  %65 = mul i64 %64, 16
  %66 = call noalias i8* @GC_malloc(i64 %65)
  %67 = bitcast i8* %66 to %class.KV.4*
  store %class.KV.4* %67, %class.KV.4** %node, align 8
  %68 = load %class.KV.4*, %class.KV.4** %node, align 8
  %69 = bitcast %class.KV.4* %68 to i8*
  %70 = load %class.KV.4*, %class.KV.4** %data, align 8
  %71 = bitcast %class.KV.4* %70 to i8*
  %72 = load i32, i32* %i, align 4
  %73 = zext i32 %72 to i64
  %74 = mul i64 %73, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %69, i8* %71, i64 %74, i32 8, i1 false)
  %75 = load i32, i32* %i, align 4
  %76 = zext i32 %75 to i64
  %77 = load %class.KV.4*, %class.KV.4** %node, align 8
  %78 = getelementptr inbounds %class.KV.4, %class.KV.4* %77, i64 %76
  %79 = bitcast %class.KV.4* %78 to i8*
  %80 = load i32, i32* %i, align 4
  %81 = add i32 %80, 1
  %82 = zext i32 %81 to i64
  %83 = load %class.KV.4*, %class.KV.4** %data, align 8
  %84 = getelementptr inbounds %class.KV.4, %class.KV.4* %83, i64 %82
  %85 = bitcast %class.KV.4* %84 to i8*
  %86 = load i32, i32* %count, align 4
  %87 = sub i32 %86, 1
  %88 = load i32, i32* %i, align 4
  %89 = sub i32 %87, %88
  %90 = zext i32 %89 to i64
  %91 = mul i64 %90, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %79, i8* %85, i64 %91, i32 8, i1 false)
  %92 = load i64, i64* %bm, align 8
  %93 = load i32, i32* %hpiece, align 4
  %94 = zext i32 %93 to i64
  %95 = shl i64 1, %94
  %96 = xor i64 -1, %95
  %97 = and i64 %92, %96
  %98 = shl i64 %97, 1
  %99 = or i64 %98, 1
  store i64 %99, i64* %newbm, align 8
  %100 = load i64, i64* %newbm, align 8
  %101 = load %class.KV.4*, %class.KV.4** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EEC2EmPKS_IS0_S1_Lj5EE(%class.KV.3* %agg.result, i64 %100, %class.KV.4* %101)
  br label %132

; <label>:102                                     ; preds = %48
  %103 = load %class.KV.3*, %class.KV.3** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EEC2ERKS2_(%class.KV.3* %agg.result, %class.KV.3* dereferenceable(16) %103)
  br label %132

; <label>:104                                     ; preds = %30
  %105 = load i32, i32* %i, align 4
  %106 = zext i32 %105 to i64
  %107 = load %class.KV.4*, %class.KV.4** %data, align 8
  %108 = getelementptr inbounds %class.KV.4, %class.KV.4* %107, i64 %106
  %109 = load i64, i64* %2, align 8
  %110 = lshr i64 %109, 6
  %111 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %112 = load i64*, i64** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EE12remove_innerERKS2_mPKS0_Pm(%class.KV.4* sret %childkv, %class.KV.4* dereferenceable(16) %108, i64 %110, %class.scheme_key* %111, i64* %112)
  %113 = load i32, i32* %i, align 4
  %114 = zext i32 %113 to i64
  %115 = load %class.KV.4*, %class.KV.4** %data, align 8
  %116 = getelementptr inbounds %class.KV.4, %class.KV.4* %115, i64 %114
  %117 = call zeroext i1 @_ZNK2KVI10scheme_key12scheme_valueLj5EEeqERKS2_(%class.KV.4* %childkv, %class.KV.4* dereferenceable(16) %116)
  br i1 %117, label %118, label %120

; <label>:118                                     ; preds = %104
  %119 = load %class.KV.3*, %class.KV.3** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EEC2ERKS2_(%class.KV.3* %agg.result, %class.KV.3* dereferenceable(16) %119)
  br label %132

; <label>:120                                     ; preds = %104
  %121 = load %class.KV.4*, %class.KV.4** %data, align 8
  %122 = load i32, i32* %count, align 4
  %123 = load i32, i32* %i, align 4
  %124 = call %class.KV.4* @_ZN2KVI10scheme_key12scheme_valueLj5EE11update_nodeEPKS2_jjRS3_(%class.KV.4* %121, i32 %122, i32 %123, %class.KV.4* dereferenceable(16) %childkv)
  store %class.KV.4* %124, %class.KV.4** %node1, align 8
  %125 = load %class.KV.3*, %class.KV.3** %1, align 8
  %126 = getelementptr inbounds %class.KV.3, %class.KV.3* %125, i32 0, i32 0
  %127 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Key"* %126 to i64*
  %128 = load i64, i64* %127, align 8
  %129 = load %class.KV.4*, %class.KV.4** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EEC2EmPKS_IS0_S1_Lj5EE(%class.KV.3* %agg.result, i64 %128, %class.KV.4* %129)
  br label %132

; <label>:130                                     ; preds = %0
  %131 = load %class.KV.3*, %class.KV.3** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj4EEC2ERKS2_(%class.KV.3* %agg.result, %class.KV.3* dereferenceable(16) %131)
  br label %132

; <label>:132                                     ; preds = %130, %120, %118, %102, %58
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr zeroext i1 @_ZNK2KVI10scheme_key12scheme_valueLj4EEeqERKS2_(%class.KV.3* %this, %class.KV.3* dereferenceable(16) %kv) #5 comdat align 2 {
  %1 = alloca %class.KV.3*, align 8
  %2 = alloca %class.KV.3*, align 8
  store %class.KV.3* %this, %class.KV.3** %1, align 8
  store %class.KV.3* %kv, %class.KV.3** %2, align 8
  %3 = load %class.KV.3*, %class.KV.3** %1, align 8
  %4 = getelementptr inbounds %class.KV.3, %class.KV.3* %3, i32 0, i32 0
  %5 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Key"* %4 to i64*
  %6 = load i64, i64* %5, align 8
  %7 = load %class.KV.3*, %class.KV.3** %2, align 8
  %8 = getelementptr inbounds %class.KV.3, %class.KV.3* %7, i32 0, i32 0
  %9 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Key"* %8 to i64*
  %10 = load i64, i64* %9, align 8
  %11 = icmp eq i64 %6, %10
  br i1 %11, label %12, label %21

; <label>:12                                      ; preds = %0
  %13 = getelementptr inbounds %class.KV.3, %class.KV.3* %3, i32 0, i32 1
  %14 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Val"* %13 to %class.KV.4**
  %15 = load %class.KV.4*, %class.KV.4** %14, align 8
  %16 = load %class.KV.3*, %class.KV.3** %2, align 8
  %17 = getelementptr inbounds %class.KV.3, %class.KV.3* %16, i32 0, i32 1
  %18 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Val"* %17 to %class.KV.4**
  %19 = load %class.KV.4*, %class.KV.4** %18, align 8
  %20 = icmp eq %class.KV.4* %15, %19
  br label %21

; <label>:21                                      ; preds = %12, %0
  %22 = phi i1 [ false, %0 ], [ %20, %12 ]
  ret i1 %22
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj5EE12remove_innerERKS2_mPKS0_Pm(%class.KV.4* noalias sret %agg.result, %class.KV.4* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key, i64* %cptr) #0 comdat align 2 {
  %1 = alloca %class.KV.4*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.scheme_key*, align 8
  %4 = alloca i64*, align 8
  %data = alloca %class.KV.5*, align 8
  %bm = alloca i64, align 8
  %hpiece = alloca i32, align 4
  %count = alloca i32, align 4
  %exists = alloca i8, align 1
  %i = alloca i32, align 4
  %node = alloca %class.KV.5*, align 8
  %newbm = alloca i64, align 8
  %childkv = alloca %class.KV.5, align 8
  %node1 = alloca %class.KV.5*, align 8
  store %class.KV.4* %kv, %class.KV.4** %1, align 8
  store i64 %h, i64* %2, align 8
  store %class.scheme_key* %key, %class.scheme_key** %3, align 8
  store i64* %cptr, i64** %4, align 8
  %5 = load %class.KV.4*, %class.KV.4** %1, align 8
  %6 = getelementptr inbounds %class.KV.4, %class.KV.4* %5, i32 0, i32 1
  %7 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Val"* %6 to %class.KV.5**
  %8 = load %class.KV.5*, %class.KV.5** %7, align 8
  store %class.KV.5* %8, %class.KV.5** %data, align 8
  %9 = load %class.KV.4*, %class.KV.4** %1, align 8
  %10 = getelementptr inbounds %class.KV.4, %class.KV.4* %9, i32 0, i32 0
  %11 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Key"* %10 to i64*
  %12 = load i64, i64* %11, align 8
  %13 = lshr i64 %12, 1
  store i64 %13, i64* %bm, align 8
  %14 = load i64, i64* %2, align 8
  %15 = and i64 %14, 63
  %16 = urem i64 %15, 63
  %17 = trunc i64 %16 to i32
  store i32 %17, i32* %hpiece, align 4
  %18 = load i64, i64* %bm, align 8
  %19 = call i64 @llvm.ctpop.i64(i64 %18)
  %20 = trunc i64 %19 to i32
  store i32 %20, i32* %count, align 4
  %21 = load i64, i64* %bm, align 8
  %22 = load i32, i32* %hpiece, align 4
  %23 = zext i32 %22 to i64
  %24 = shl i64 1, %23
  %25 = and i64 %21, %24
  %26 = icmp ne i64 %25, 0
  %27 = zext i1 %26 to i8
  store i8 %27, i8* %exists, align 1
  %28 = load i8, i8* %exists, align 1
  %29 = trunc i8 %28 to i1
  br i1 %29, label %30, label %130

; <label>:30                                      ; preds = %0
  %31 = load i64, i64* %bm, align 8
  %32 = shl i64 %31, 1
  %33 = load i32, i32* %hpiece, align 4
  %34 = sub i32 63, %33
  %35 = zext i32 %34 to i64
  %36 = shl i64 %32, %35
  %37 = call i64 @llvm.ctpop.i64(i64 %36)
  %38 = trunc i64 %37 to i32
  store i32 %38, i32* %i, align 4
  %39 = load i32, i32* %i, align 4
  %40 = zext i32 %39 to i64
  %41 = load %class.KV.5*, %class.KV.5** %data, align 8
  %42 = getelementptr inbounds %class.KV.5, %class.KV.5* %41, i64 %40
  %43 = getelementptr inbounds %class.KV.5, %class.KV.5* %42, i32 0, i32 0
  %44 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Key"* %43 to i64*
  %45 = load i64, i64* %44, align 8
  %46 = and i64 %45, 1
  %47 = icmp eq i64 %46, 0
  br i1 %47, label %48, label %104

; <label>:48                                      ; preds = %30
  %49 = load i32, i32* %i, align 4
  %50 = zext i32 %49 to i64
  %51 = load %class.KV.5*, %class.KV.5** %data, align 8
  %52 = getelementptr inbounds %class.KV.5, %class.KV.5* %51, i64 %50
  %53 = getelementptr inbounds %class.KV.5, %class.KV.5* %52, i32 0, i32 0
  %54 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Key"* %53 to %class.scheme_key**
  %55 = load %class.scheme_key*, %class.scheme_key** %54, align 8
  %56 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %57 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %55, %class.scheme_key* dereferenceable(8) %56)
  br i1 %57, label %58, label %102

; <label>:58                                      ; preds = %48
  %59 = load i64*, i64** %4, align 8
  %60 = load i64, i64* %59, align 8
  %61 = add i64 %60, -1
  store i64 %61, i64* %59, align 8
  %62 = load i32, i32* %count, align 4
  %63 = sub i32 %62, 1
  %64 = zext i32 %63 to i64
  %65 = mul i64 %64, 16
  %66 = call noalias i8* @GC_malloc(i64 %65)
  %67 = bitcast i8* %66 to %class.KV.5*
  store %class.KV.5* %67, %class.KV.5** %node, align 8
  %68 = load %class.KV.5*, %class.KV.5** %node, align 8
  %69 = bitcast %class.KV.5* %68 to i8*
  %70 = load %class.KV.5*, %class.KV.5** %data, align 8
  %71 = bitcast %class.KV.5* %70 to i8*
  %72 = load i32, i32* %i, align 4
  %73 = zext i32 %72 to i64
  %74 = mul i64 %73, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %69, i8* %71, i64 %74, i32 8, i1 false)
  %75 = load i32, i32* %i, align 4
  %76 = zext i32 %75 to i64
  %77 = load %class.KV.5*, %class.KV.5** %node, align 8
  %78 = getelementptr inbounds %class.KV.5, %class.KV.5* %77, i64 %76
  %79 = bitcast %class.KV.5* %78 to i8*
  %80 = load i32, i32* %i, align 4
  %81 = add i32 %80, 1
  %82 = zext i32 %81 to i64
  %83 = load %class.KV.5*, %class.KV.5** %data, align 8
  %84 = getelementptr inbounds %class.KV.5, %class.KV.5* %83, i64 %82
  %85 = bitcast %class.KV.5* %84 to i8*
  %86 = load i32, i32* %count, align 4
  %87 = sub i32 %86, 1
  %88 = load i32, i32* %i, align 4
  %89 = sub i32 %87, %88
  %90 = zext i32 %89 to i64
  %91 = mul i64 %90, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %79, i8* %85, i64 %91, i32 8, i1 false)
  %92 = load i64, i64* %bm, align 8
  %93 = load i32, i32* %hpiece, align 4
  %94 = zext i32 %93 to i64
  %95 = shl i64 1, %94
  %96 = xor i64 -1, %95
  %97 = and i64 %92, %96
  %98 = shl i64 %97, 1
  %99 = or i64 %98, 1
  store i64 %99, i64* %newbm, align 8
  %100 = load i64, i64* %newbm, align 8
  %101 = load %class.KV.5*, %class.KV.5** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EEC2EmPKS_IS0_S1_Lj6EE(%class.KV.4* %agg.result, i64 %100, %class.KV.5* %101)
  br label %132

; <label>:102                                     ; preds = %48
  %103 = load %class.KV.4*, %class.KV.4** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EEC2ERKS2_(%class.KV.4* %agg.result, %class.KV.4* dereferenceable(16) %103)
  br label %132

; <label>:104                                     ; preds = %30
  %105 = load i32, i32* %i, align 4
  %106 = zext i32 %105 to i64
  %107 = load %class.KV.5*, %class.KV.5** %data, align 8
  %108 = getelementptr inbounds %class.KV.5, %class.KV.5* %107, i64 %106
  %109 = load i64, i64* %2, align 8
  %110 = lshr i64 %109, 6
  %111 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %112 = load i64*, i64** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EE12remove_innerERKS2_mPKS0_Pm(%class.KV.5* sret %childkv, %class.KV.5* dereferenceable(16) %108, i64 %110, %class.scheme_key* %111, i64* %112)
  %113 = load i32, i32* %i, align 4
  %114 = zext i32 %113 to i64
  %115 = load %class.KV.5*, %class.KV.5** %data, align 8
  %116 = getelementptr inbounds %class.KV.5, %class.KV.5* %115, i64 %114
  %117 = call zeroext i1 @_ZNK2KVI10scheme_key12scheme_valueLj6EEeqERKS2_(%class.KV.5* %childkv, %class.KV.5* dereferenceable(16) %116)
  br i1 %117, label %118, label %120

; <label>:118                                     ; preds = %104
  %119 = load %class.KV.4*, %class.KV.4** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EEC2ERKS2_(%class.KV.4* %agg.result, %class.KV.4* dereferenceable(16) %119)
  br label %132

; <label>:120                                     ; preds = %104
  %121 = load %class.KV.5*, %class.KV.5** %data, align 8
  %122 = load i32, i32* %count, align 4
  %123 = load i32, i32* %i, align 4
  %124 = call %class.KV.5* @_ZN2KVI10scheme_key12scheme_valueLj6EE11update_nodeEPKS2_jjRS3_(%class.KV.5* %121, i32 %122, i32 %123, %class.KV.5* dereferenceable(16) %childkv)
  store %class.KV.5* %124, %class.KV.5** %node1, align 8
  %125 = load %class.KV.4*, %class.KV.4** %1, align 8
  %126 = getelementptr inbounds %class.KV.4, %class.KV.4* %125, i32 0, i32 0
  %127 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Key"* %126 to i64*
  %128 = load i64, i64* %127, align 8
  %129 = load %class.KV.5*, %class.KV.5** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EEC2EmPKS_IS0_S1_Lj6EE(%class.KV.4* %agg.result, i64 %128, %class.KV.5* %129)
  br label %132

; <label>:130                                     ; preds = %0
  %131 = load %class.KV.4*, %class.KV.4** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj5EEC2ERKS2_(%class.KV.4* %agg.result, %class.KV.4* dereferenceable(16) %131)
  br label %132

; <label>:132                                     ; preds = %130, %120, %118, %102, %58
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr zeroext i1 @_ZNK2KVI10scheme_key12scheme_valueLj5EEeqERKS2_(%class.KV.4* %this, %class.KV.4* dereferenceable(16) %kv) #5 comdat align 2 {
  %1 = alloca %class.KV.4*, align 8
  %2 = alloca %class.KV.4*, align 8
  store %class.KV.4* %this, %class.KV.4** %1, align 8
  store %class.KV.4* %kv, %class.KV.4** %2, align 8
  %3 = load %class.KV.4*, %class.KV.4** %1, align 8
  %4 = getelementptr inbounds %class.KV.4, %class.KV.4* %3, i32 0, i32 0
  %5 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Key"* %4 to i64*
  %6 = load i64, i64* %5, align 8
  %7 = load %class.KV.4*, %class.KV.4** %2, align 8
  %8 = getelementptr inbounds %class.KV.4, %class.KV.4* %7, i32 0, i32 0
  %9 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Key"* %8 to i64*
  %10 = load i64, i64* %9, align 8
  %11 = icmp eq i64 %6, %10
  br i1 %11, label %12, label %21

; <label>:12                                      ; preds = %0
  %13 = getelementptr inbounds %class.KV.4, %class.KV.4* %3, i32 0, i32 1
  %14 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Val"* %13 to %class.KV.5**
  %15 = load %class.KV.5*, %class.KV.5** %14, align 8
  %16 = load %class.KV.4*, %class.KV.4** %2, align 8
  %17 = getelementptr inbounds %class.KV.4, %class.KV.4* %16, i32 0, i32 1
  %18 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Val"* %17 to %class.KV.5**
  %19 = load %class.KV.5*, %class.KV.5** %18, align 8
  %20 = icmp eq %class.KV.5* %15, %19
  br label %21

; <label>:21                                      ; preds = %12, %0
  %22 = phi i1 [ false, %0 ], [ %20, %12 ]
  ret i1 %22
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj6EE12remove_innerERKS2_mPKS0_Pm(%class.KV.5* noalias sret %agg.result, %class.KV.5* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key, i64* %cptr) #0 comdat align 2 {
  %1 = alloca %class.KV.5*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.scheme_key*, align 8
  %4 = alloca i64*, align 8
  %data = alloca %class.KV.6*, align 8
  %bm = alloca i64, align 8
  %hpiece = alloca i32, align 4
  %count = alloca i32, align 4
  %exists = alloca i8, align 1
  %i = alloca i32, align 4
  %node = alloca %class.KV.6*, align 8
  %newbm = alloca i64, align 8
  %childkv = alloca %class.KV.6, align 8
  %node1 = alloca %class.KV.6*, align 8
  store %class.KV.5* %kv, %class.KV.5** %1, align 8
  store i64 %h, i64* %2, align 8
  store %class.scheme_key* %key, %class.scheme_key** %3, align 8
  store i64* %cptr, i64** %4, align 8
  %5 = load %class.KV.5*, %class.KV.5** %1, align 8
  %6 = getelementptr inbounds %class.KV.5, %class.KV.5* %5, i32 0, i32 1
  %7 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Val"* %6 to %class.KV.6**
  %8 = load %class.KV.6*, %class.KV.6** %7, align 8
  store %class.KV.6* %8, %class.KV.6** %data, align 8
  %9 = load %class.KV.5*, %class.KV.5** %1, align 8
  %10 = getelementptr inbounds %class.KV.5, %class.KV.5* %9, i32 0, i32 0
  %11 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Key"* %10 to i64*
  %12 = load i64, i64* %11, align 8
  %13 = lshr i64 %12, 1
  store i64 %13, i64* %bm, align 8
  %14 = load i64, i64* %2, align 8
  %15 = and i64 %14, 63
  %16 = urem i64 %15, 63
  %17 = trunc i64 %16 to i32
  store i32 %17, i32* %hpiece, align 4
  %18 = load i64, i64* %bm, align 8
  %19 = call i64 @llvm.ctpop.i64(i64 %18)
  %20 = trunc i64 %19 to i32
  store i32 %20, i32* %count, align 4
  %21 = load i64, i64* %bm, align 8
  %22 = load i32, i32* %hpiece, align 4
  %23 = zext i32 %22 to i64
  %24 = shl i64 1, %23
  %25 = and i64 %21, %24
  %26 = icmp ne i64 %25, 0
  %27 = zext i1 %26 to i8
  store i8 %27, i8* %exists, align 1
  %28 = load i8, i8* %exists, align 1
  %29 = trunc i8 %28 to i1
  br i1 %29, label %30, label %130

; <label>:30                                      ; preds = %0
  %31 = load i64, i64* %bm, align 8
  %32 = shl i64 %31, 1
  %33 = load i32, i32* %hpiece, align 4
  %34 = sub i32 63, %33
  %35 = zext i32 %34 to i64
  %36 = shl i64 %32, %35
  %37 = call i64 @llvm.ctpop.i64(i64 %36)
  %38 = trunc i64 %37 to i32
  store i32 %38, i32* %i, align 4
  %39 = load i32, i32* %i, align 4
  %40 = zext i32 %39 to i64
  %41 = load %class.KV.6*, %class.KV.6** %data, align 8
  %42 = getelementptr inbounds %class.KV.6, %class.KV.6* %41, i64 %40
  %43 = getelementptr inbounds %class.KV.6, %class.KV.6* %42, i32 0, i32 0
  %44 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Key"* %43 to i64*
  %45 = load i64, i64* %44, align 8
  %46 = and i64 %45, 1
  %47 = icmp eq i64 %46, 0
  br i1 %47, label %48, label %104

; <label>:48                                      ; preds = %30
  %49 = load i32, i32* %i, align 4
  %50 = zext i32 %49 to i64
  %51 = load %class.KV.6*, %class.KV.6** %data, align 8
  %52 = getelementptr inbounds %class.KV.6, %class.KV.6* %51, i64 %50
  %53 = getelementptr inbounds %class.KV.6, %class.KV.6* %52, i32 0, i32 0
  %54 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Key"* %53 to %class.scheme_key**
  %55 = load %class.scheme_key*, %class.scheme_key** %54, align 8
  %56 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %57 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %55, %class.scheme_key* dereferenceable(8) %56)
  br i1 %57, label %58, label %102

; <label>:58                                      ; preds = %48
  %59 = load i64*, i64** %4, align 8
  %60 = load i64, i64* %59, align 8
  %61 = add i64 %60, -1
  store i64 %61, i64* %59, align 8
  %62 = load i32, i32* %count, align 4
  %63 = sub i32 %62, 1
  %64 = zext i32 %63 to i64
  %65 = mul i64 %64, 16
  %66 = call noalias i8* @GC_malloc(i64 %65)
  %67 = bitcast i8* %66 to %class.KV.6*
  store %class.KV.6* %67, %class.KV.6** %node, align 8
  %68 = load %class.KV.6*, %class.KV.6** %node, align 8
  %69 = bitcast %class.KV.6* %68 to i8*
  %70 = load %class.KV.6*, %class.KV.6** %data, align 8
  %71 = bitcast %class.KV.6* %70 to i8*
  %72 = load i32, i32* %i, align 4
  %73 = zext i32 %72 to i64
  %74 = mul i64 %73, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %69, i8* %71, i64 %74, i32 8, i1 false)
  %75 = load i32, i32* %i, align 4
  %76 = zext i32 %75 to i64
  %77 = load %class.KV.6*, %class.KV.6** %node, align 8
  %78 = getelementptr inbounds %class.KV.6, %class.KV.6* %77, i64 %76
  %79 = bitcast %class.KV.6* %78 to i8*
  %80 = load i32, i32* %i, align 4
  %81 = add i32 %80, 1
  %82 = zext i32 %81 to i64
  %83 = load %class.KV.6*, %class.KV.6** %data, align 8
  %84 = getelementptr inbounds %class.KV.6, %class.KV.6* %83, i64 %82
  %85 = bitcast %class.KV.6* %84 to i8*
  %86 = load i32, i32* %count, align 4
  %87 = sub i32 %86, 1
  %88 = load i32, i32* %i, align 4
  %89 = sub i32 %87, %88
  %90 = zext i32 %89 to i64
  %91 = mul i64 %90, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %79, i8* %85, i64 %91, i32 8, i1 false)
  %92 = load i64, i64* %bm, align 8
  %93 = load i32, i32* %hpiece, align 4
  %94 = zext i32 %93 to i64
  %95 = shl i64 1, %94
  %96 = xor i64 -1, %95
  %97 = and i64 %92, %96
  %98 = shl i64 %97, 1
  %99 = or i64 %98, 1
  store i64 %99, i64* %newbm, align 8
  %100 = load i64, i64* %newbm, align 8
  %101 = load %class.KV.6*, %class.KV.6** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EEC2EmPKS_IS0_S1_Lj7EE(%class.KV.5* %agg.result, i64 %100, %class.KV.6* %101)
  br label %132

; <label>:102                                     ; preds = %48
  %103 = load %class.KV.5*, %class.KV.5** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EEC2ERKS2_(%class.KV.5* %agg.result, %class.KV.5* dereferenceable(16) %103)
  br label %132

; <label>:104                                     ; preds = %30
  %105 = load i32, i32* %i, align 4
  %106 = zext i32 %105 to i64
  %107 = load %class.KV.6*, %class.KV.6** %data, align 8
  %108 = getelementptr inbounds %class.KV.6, %class.KV.6* %107, i64 %106
  %109 = load i64, i64* %2, align 8
  %110 = lshr i64 %109, 6
  %111 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %112 = load i64*, i64** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EE12remove_innerERKS2_mPKS0_Pm(%class.KV.6* sret %childkv, %class.KV.6* dereferenceable(16) %108, i64 %110, %class.scheme_key* %111, i64* %112)
  %113 = load i32, i32* %i, align 4
  %114 = zext i32 %113 to i64
  %115 = load %class.KV.6*, %class.KV.6** %data, align 8
  %116 = getelementptr inbounds %class.KV.6, %class.KV.6* %115, i64 %114
  %117 = call zeroext i1 @_ZNK2KVI10scheme_key12scheme_valueLj7EEeqERKS2_(%class.KV.6* %childkv, %class.KV.6* dereferenceable(16) %116)
  br i1 %117, label %118, label %120

; <label>:118                                     ; preds = %104
  %119 = load %class.KV.5*, %class.KV.5** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EEC2ERKS2_(%class.KV.5* %agg.result, %class.KV.5* dereferenceable(16) %119)
  br label %132

; <label>:120                                     ; preds = %104
  %121 = load %class.KV.6*, %class.KV.6** %data, align 8
  %122 = load i32, i32* %count, align 4
  %123 = load i32, i32* %i, align 4
  %124 = call %class.KV.6* @_ZN2KVI10scheme_key12scheme_valueLj7EE11update_nodeEPKS2_jjRS3_(%class.KV.6* %121, i32 %122, i32 %123, %class.KV.6* dereferenceable(16) %childkv)
  store %class.KV.6* %124, %class.KV.6** %node1, align 8
  %125 = load %class.KV.5*, %class.KV.5** %1, align 8
  %126 = getelementptr inbounds %class.KV.5, %class.KV.5* %125, i32 0, i32 0
  %127 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Key"* %126 to i64*
  %128 = load i64, i64* %127, align 8
  %129 = load %class.KV.6*, %class.KV.6** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EEC2EmPKS_IS0_S1_Lj7EE(%class.KV.5* %agg.result, i64 %128, %class.KV.6* %129)
  br label %132

; <label>:130                                     ; preds = %0
  %131 = load %class.KV.5*, %class.KV.5** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj6EEC2ERKS2_(%class.KV.5* %agg.result, %class.KV.5* dereferenceable(16) %131)
  br label %132

; <label>:132                                     ; preds = %130, %120, %118, %102, %58
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr zeroext i1 @_ZNK2KVI10scheme_key12scheme_valueLj6EEeqERKS2_(%class.KV.5* %this, %class.KV.5* dereferenceable(16) %kv) #5 comdat align 2 {
  %1 = alloca %class.KV.5*, align 8
  %2 = alloca %class.KV.5*, align 8
  store %class.KV.5* %this, %class.KV.5** %1, align 8
  store %class.KV.5* %kv, %class.KV.5** %2, align 8
  %3 = load %class.KV.5*, %class.KV.5** %1, align 8
  %4 = getelementptr inbounds %class.KV.5, %class.KV.5* %3, i32 0, i32 0
  %5 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Key"* %4 to i64*
  %6 = load i64, i64* %5, align 8
  %7 = load %class.KV.5*, %class.KV.5** %2, align 8
  %8 = getelementptr inbounds %class.KV.5, %class.KV.5* %7, i32 0, i32 0
  %9 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Key"* %8 to i64*
  %10 = load i64, i64* %9, align 8
  %11 = icmp eq i64 %6, %10
  br i1 %11, label %12, label %21

; <label>:12                                      ; preds = %0
  %13 = getelementptr inbounds %class.KV.5, %class.KV.5* %3, i32 0, i32 1
  %14 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Val"* %13 to %class.KV.6**
  %15 = load %class.KV.6*, %class.KV.6** %14, align 8
  %16 = load %class.KV.5*, %class.KV.5** %2, align 8
  %17 = getelementptr inbounds %class.KV.5, %class.KV.5* %16, i32 0, i32 1
  %18 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Val"* %17 to %class.KV.6**
  %19 = load %class.KV.6*, %class.KV.6** %18, align 8
  %20 = icmp eq %class.KV.6* %15, %19
  br label %21

; <label>:21                                      ; preds = %12, %0
  %22 = phi i1 [ false, %0 ], [ %20, %12 ]
  ret i1 %22
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj7EE12remove_innerERKS2_mPKS0_Pm(%class.KV.6* noalias sret %agg.result, %class.KV.6* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key, i64* %cptr) #0 comdat align 2 {
  %1 = alloca %class.KV.6*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.scheme_key*, align 8
  %4 = alloca i64*, align 8
  %data = alloca %class.KV.7*, align 8
  %bm = alloca i64, align 8
  %hpiece = alloca i32, align 4
  %count = alloca i32, align 4
  %exists = alloca i8, align 1
  %i = alloca i32, align 4
  %node = alloca %class.KV.7*, align 8
  %newbm = alloca i64, align 8
  %childkv = alloca %class.KV.7, align 8
  %node1 = alloca %class.KV.7*, align 8
  store %class.KV.6* %kv, %class.KV.6** %1, align 8
  store i64 %h, i64* %2, align 8
  store %class.scheme_key* %key, %class.scheme_key** %3, align 8
  store i64* %cptr, i64** %4, align 8
  %5 = load %class.KV.6*, %class.KV.6** %1, align 8
  %6 = getelementptr inbounds %class.KV.6, %class.KV.6* %5, i32 0, i32 1
  %7 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Val"* %6 to %class.KV.7**
  %8 = load %class.KV.7*, %class.KV.7** %7, align 8
  store %class.KV.7* %8, %class.KV.7** %data, align 8
  %9 = load %class.KV.6*, %class.KV.6** %1, align 8
  %10 = getelementptr inbounds %class.KV.6, %class.KV.6* %9, i32 0, i32 0
  %11 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Key"* %10 to i64*
  %12 = load i64, i64* %11, align 8
  %13 = lshr i64 %12, 1
  store i64 %13, i64* %bm, align 8
  %14 = load i64, i64* %2, align 8
  %15 = and i64 %14, 63
  %16 = urem i64 %15, 63
  %17 = trunc i64 %16 to i32
  store i32 %17, i32* %hpiece, align 4
  %18 = load i64, i64* %bm, align 8
  %19 = call i64 @llvm.ctpop.i64(i64 %18)
  %20 = trunc i64 %19 to i32
  store i32 %20, i32* %count, align 4
  %21 = load i64, i64* %bm, align 8
  %22 = load i32, i32* %hpiece, align 4
  %23 = zext i32 %22 to i64
  %24 = shl i64 1, %23
  %25 = and i64 %21, %24
  %26 = icmp ne i64 %25, 0
  %27 = zext i1 %26 to i8
  store i8 %27, i8* %exists, align 1
  %28 = load i8, i8* %exists, align 1
  %29 = trunc i8 %28 to i1
  br i1 %29, label %30, label %130

; <label>:30                                      ; preds = %0
  %31 = load i64, i64* %bm, align 8
  %32 = shl i64 %31, 1
  %33 = load i32, i32* %hpiece, align 4
  %34 = sub i32 63, %33
  %35 = zext i32 %34 to i64
  %36 = shl i64 %32, %35
  %37 = call i64 @llvm.ctpop.i64(i64 %36)
  %38 = trunc i64 %37 to i32
  store i32 %38, i32* %i, align 4
  %39 = load i32, i32* %i, align 4
  %40 = zext i32 %39 to i64
  %41 = load %class.KV.7*, %class.KV.7** %data, align 8
  %42 = getelementptr inbounds %class.KV.7, %class.KV.7* %41, i64 %40
  %43 = getelementptr inbounds %class.KV.7, %class.KV.7* %42, i32 0, i32 0
  %44 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Key"* %43 to i64*
  %45 = load i64, i64* %44, align 8
  %46 = and i64 %45, 1
  %47 = icmp eq i64 %46, 0
  br i1 %47, label %48, label %104

; <label>:48                                      ; preds = %30
  %49 = load i32, i32* %i, align 4
  %50 = zext i32 %49 to i64
  %51 = load %class.KV.7*, %class.KV.7** %data, align 8
  %52 = getelementptr inbounds %class.KV.7, %class.KV.7* %51, i64 %50
  %53 = getelementptr inbounds %class.KV.7, %class.KV.7* %52, i32 0, i32 0
  %54 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Key"* %53 to %class.scheme_key**
  %55 = load %class.scheme_key*, %class.scheme_key** %54, align 8
  %56 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %57 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %55, %class.scheme_key* dereferenceable(8) %56)
  br i1 %57, label %58, label %102

; <label>:58                                      ; preds = %48
  %59 = load i64*, i64** %4, align 8
  %60 = load i64, i64* %59, align 8
  %61 = add i64 %60, -1
  store i64 %61, i64* %59, align 8
  %62 = load i32, i32* %count, align 4
  %63 = sub i32 %62, 1
  %64 = zext i32 %63 to i64
  %65 = mul i64 %64, 16
  %66 = call noalias i8* @GC_malloc(i64 %65)
  %67 = bitcast i8* %66 to %class.KV.7*
  store %class.KV.7* %67, %class.KV.7** %node, align 8
  %68 = load %class.KV.7*, %class.KV.7** %node, align 8
  %69 = bitcast %class.KV.7* %68 to i8*
  %70 = load %class.KV.7*, %class.KV.7** %data, align 8
  %71 = bitcast %class.KV.7* %70 to i8*
  %72 = load i32, i32* %i, align 4
  %73 = zext i32 %72 to i64
  %74 = mul i64 %73, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %69, i8* %71, i64 %74, i32 8, i1 false)
  %75 = load i32, i32* %i, align 4
  %76 = zext i32 %75 to i64
  %77 = load %class.KV.7*, %class.KV.7** %node, align 8
  %78 = getelementptr inbounds %class.KV.7, %class.KV.7* %77, i64 %76
  %79 = bitcast %class.KV.7* %78 to i8*
  %80 = load i32, i32* %i, align 4
  %81 = add i32 %80, 1
  %82 = zext i32 %81 to i64
  %83 = load %class.KV.7*, %class.KV.7** %data, align 8
  %84 = getelementptr inbounds %class.KV.7, %class.KV.7* %83, i64 %82
  %85 = bitcast %class.KV.7* %84 to i8*
  %86 = load i32, i32* %count, align 4
  %87 = sub i32 %86, 1
  %88 = load i32, i32* %i, align 4
  %89 = sub i32 %87, %88
  %90 = zext i32 %89 to i64
  %91 = mul i64 %90, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %79, i8* %85, i64 %91, i32 8, i1 false)
  %92 = load i64, i64* %bm, align 8
  %93 = load i32, i32* %hpiece, align 4
  %94 = zext i32 %93 to i64
  %95 = shl i64 1, %94
  %96 = xor i64 -1, %95
  %97 = and i64 %92, %96
  %98 = shl i64 %97, 1
  %99 = or i64 %98, 1
  store i64 %99, i64* %newbm, align 8
  %100 = load i64, i64* %newbm, align 8
  %101 = load %class.KV.7*, %class.KV.7** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EEC2EmPKS_IS0_S1_Lj8EE(%class.KV.6* %agg.result, i64 %100, %class.KV.7* %101)
  br label %132

; <label>:102                                     ; preds = %48
  %103 = load %class.KV.6*, %class.KV.6** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EEC2ERKS2_(%class.KV.6* %agg.result, %class.KV.6* dereferenceable(16) %103)
  br label %132

; <label>:104                                     ; preds = %30
  %105 = load i32, i32* %i, align 4
  %106 = zext i32 %105 to i64
  %107 = load %class.KV.7*, %class.KV.7** %data, align 8
  %108 = getelementptr inbounds %class.KV.7, %class.KV.7* %107, i64 %106
  %109 = load i64, i64* %2, align 8
  %110 = lshr i64 %109, 6
  %111 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %112 = load i64*, i64** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EE12remove_innerERKS2_mPKS0_Pm(%class.KV.7* sret %childkv, %class.KV.7* dereferenceable(16) %108, i64 %110, %class.scheme_key* %111, i64* %112)
  %113 = load i32, i32* %i, align 4
  %114 = zext i32 %113 to i64
  %115 = load %class.KV.7*, %class.KV.7** %data, align 8
  %116 = getelementptr inbounds %class.KV.7, %class.KV.7* %115, i64 %114
  %117 = call zeroext i1 @_ZNK2KVI10scheme_key12scheme_valueLj8EEeqERKS2_(%class.KV.7* %childkv, %class.KV.7* dereferenceable(16) %116)
  br i1 %117, label %118, label %120

; <label>:118                                     ; preds = %104
  %119 = load %class.KV.6*, %class.KV.6** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EEC2ERKS2_(%class.KV.6* %agg.result, %class.KV.6* dereferenceable(16) %119)
  br label %132

; <label>:120                                     ; preds = %104
  %121 = load %class.KV.7*, %class.KV.7** %data, align 8
  %122 = load i32, i32* %count, align 4
  %123 = load i32, i32* %i, align 4
  %124 = call %class.KV.7* @_ZN2KVI10scheme_key12scheme_valueLj8EE11update_nodeEPKS2_jjRS3_(%class.KV.7* %121, i32 %122, i32 %123, %class.KV.7* dereferenceable(16) %childkv)
  store %class.KV.7* %124, %class.KV.7** %node1, align 8
  %125 = load %class.KV.6*, %class.KV.6** %1, align 8
  %126 = getelementptr inbounds %class.KV.6, %class.KV.6* %125, i32 0, i32 0
  %127 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Key"* %126 to i64*
  %128 = load i64, i64* %127, align 8
  %129 = load %class.KV.7*, %class.KV.7** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EEC2EmPKS_IS0_S1_Lj8EE(%class.KV.6* %agg.result, i64 %128, %class.KV.7* %129)
  br label %132

; <label>:130                                     ; preds = %0
  %131 = load %class.KV.6*, %class.KV.6** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj7EEC2ERKS2_(%class.KV.6* %agg.result, %class.KV.6* dereferenceable(16) %131)
  br label %132

; <label>:132                                     ; preds = %130, %120, %118, %102, %58
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr zeroext i1 @_ZNK2KVI10scheme_key12scheme_valueLj7EEeqERKS2_(%class.KV.6* %this, %class.KV.6* dereferenceable(16) %kv) #5 comdat align 2 {
  %1 = alloca %class.KV.6*, align 8
  %2 = alloca %class.KV.6*, align 8
  store %class.KV.6* %this, %class.KV.6** %1, align 8
  store %class.KV.6* %kv, %class.KV.6** %2, align 8
  %3 = load %class.KV.6*, %class.KV.6** %1, align 8
  %4 = getelementptr inbounds %class.KV.6, %class.KV.6* %3, i32 0, i32 0
  %5 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Key"* %4 to i64*
  %6 = load i64, i64* %5, align 8
  %7 = load %class.KV.6*, %class.KV.6** %2, align 8
  %8 = getelementptr inbounds %class.KV.6, %class.KV.6* %7, i32 0, i32 0
  %9 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Key"* %8 to i64*
  %10 = load i64, i64* %9, align 8
  %11 = icmp eq i64 %6, %10
  br i1 %11, label %12, label %21

; <label>:12                                      ; preds = %0
  %13 = getelementptr inbounds %class.KV.6, %class.KV.6* %3, i32 0, i32 1
  %14 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Val"* %13 to %class.KV.7**
  %15 = load %class.KV.7*, %class.KV.7** %14, align 8
  %16 = load %class.KV.6*, %class.KV.6** %2, align 8
  %17 = getelementptr inbounds %class.KV.6, %class.KV.6* %16, i32 0, i32 1
  %18 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Val"* %17 to %class.KV.7**
  %19 = load %class.KV.7*, %class.KV.7** %18, align 8
  %20 = icmp eq %class.KV.7* %15, %19
  br label %21

; <label>:21                                      ; preds = %12, %0
  %22 = phi i1 [ false, %0 ], [ %20, %12 ]
  ret i1 %22
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj8EE12remove_innerERKS2_mPKS0_Pm(%class.KV.7* noalias sret %agg.result, %class.KV.7* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key, i64* %cptr) #0 comdat align 2 {
  %1 = alloca %class.KV.7*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.scheme_key*, align 8
  %4 = alloca i64*, align 8
  %data = alloca %class.KV.8*, align 8
  %bm = alloca i64, align 8
  %hpiece = alloca i32, align 4
  %count = alloca i32, align 4
  %exists = alloca i8, align 1
  %i = alloca i32, align 4
  %node = alloca %class.KV.8*, align 8
  %newbm = alloca i64, align 8
  %childkv = alloca %class.KV.8, align 8
  %node1 = alloca %class.KV.8*, align 8
  store %class.KV.7* %kv, %class.KV.7** %1, align 8
  store i64 %h, i64* %2, align 8
  store %class.scheme_key* %key, %class.scheme_key** %3, align 8
  store i64* %cptr, i64** %4, align 8
  %5 = load %class.KV.7*, %class.KV.7** %1, align 8
  %6 = getelementptr inbounds %class.KV.7, %class.KV.7* %5, i32 0, i32 1
  %7 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Val"* %6 to %class.KV.8**
  %8 = load %class.KV.8*, %class.KV.8** %7, align 8
  store %class.KV.8* %8, %class.KV.8** %data, align 8
  %9 = load %class.KV.7*, %class.KV.7** %1, align 8
  %10 = getelementptr inbounds %class.KV.7, %class.KV.7* %9, i32 0, i32 0
  %11 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Key"* %10 to i64*
  %12 = load i64, i64* %11, align 8
  %13 = lshr i64 %12, 1
  store i64 %13, i64* %bm, align 8
  %14 = load i64, i64* %2, align 8
  %15 = and i64 %14, 63
  %16 = urem i64 %15, 63
  %17 = trunc i64 %16 to i32
  store i32 %17, i32* %hpiece, align 4
  %18 = load i64, i64* %bm, align 8
  %19 = call i64 @llvm.ctpop.i64(i64 %18)
  %20 = trunc i64 %19 to i32
  store i32 %20, i32* %count, align 4
  %21 = load i64, i64* %bm, align 8
  %22 = load i32, i32* %hpiece, align 4
  %23 = zext i32 %22 to i64
  %24 = shl i64 1, %23
  %25 = and i64 %21, %24
  %26 = icmp ne i64 %25, 0
  %27 = zext i1 %26 to i8
  store i8 %27, i8* %exists, align 1
  %28 = load i8, i8* %exists, align 1
  %29 = trunc i8 %28 to i1
  br i1 %29, label %30, label %130

; <label>:30                                      ; preds = %0
  %31 = load i64, i64* %bm, align 8
  %32 = shl i64 %31, 1
  %33 = load i32, i32* %hpiece, align 4
  %34 = sub i32 63, %33
  %35 = zext i32 %34 to i64
  %36 = shl i64 %32, %35
  %37 = call i64 @llvm.ctpop.i64(i64 %36)
  %38 = trunc i64 %37 to i32
  store i32 %38, i32* %i, align 4
  %39 = load i32, i32* %i, align 4
  %40 = zext i32 %39 to i64
  %41 = load %class.KV.8*, %class.KV.8** %data, align 8
  %42 = getelementptr inbounds %class.KV.8, %class.KV.8* %41, i64 %40
  %43 = getelementptr inbounds %class.KV.8, %class.KV.8* %42, i32 0, i32 0
  %44 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Key"* %43 to i64*
  %45 = load i64, i64* %44, align 8
  %46 = and i64 %45, 1
  %47 = icmp eq i64 %46, 0
  br i1 %47, label %48, label %104

; <label>:48                                      ; preds = %30
  %49 = load i32, i32* %i, align 4
  %50 = zext i32 %49 to i64
  %51 = load %class.KV.8*, %class.KV.8** %data, align 8
  %52 = getelementptr inbounds %class.KV.8, %class.KV.8* %51, i64 %50
  %53 = getelementptr inbounds %class.KV.8, %class.KV.8* %52, i32 0, i32 0
  %54 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Key"* %53 to %class.scheme_key**
  %55 = load %class.scheme_key*, %class.scheme_key** %54, align 8
  %56 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %57 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %55, %class.scheme_key* dereferenceable(8) %56)
  br i1 %57, label %58, label %102

; <label>:58                                      ; preds = %48
  %59 = load i64*, i64** %4, align 8
  %60 = load i64, i64* %59, align 8
  %61 = add i64 %60, -1
  store i64 %61, i64* %59, align 8
  %62 = load i32, i32* %count, align 4
  %63 = sub i32 %62, 1
  %64 = zext i32 %63 to i64
  %65 = mul i64 %64, 16
  %66 = call noalias i8* @GC_malloc(i64 %65)
  %67 = bitcast i8* %66 to %class.KV.8*
  store %class.KV.8* %67, %class.KV.8** %node, align 8
  %68 = load %class.KV.8*, %class.KV.8** %node, align 8
  %69 = bitcast %class.KV.8* %68 to i8*
  %70 = load %class.KV.8*, %class.KV.8** %data, align 8
  %71 = bitcast %class.KV.8* %70 to i8*
  %72 = load i32, i32* %i, align 4
  %73 = zext i32 %72 to i64
  %74 = mul i64 %73, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %69, i8* %71, i64 %74, i32 8, i1 false)
  %75 = load i32, i32* %i, align 4
  %76 = zext i32 %75 to i64
  %77 = load %class.KV.8*, %class.KV.8** %node, align 8
  %78 = getelementptr inbounds %class.KV.8, %class.KV.8* %77, i64 %76
  %79 = bitcast %class.KV.8* %78 to i8*
  %80 = load i32, i32* %i, align 4
  %81 = add i32 %80, 1
  %82 = zext i32 %81 to i64
  %83 = load %class.KV.8*, %class.KV.8** %data, align 8
  %84 = getelementptr inbounds %class.KV.8, %class.KV.8* %83, i64 %82
  %85 = bitcast %class.KV.8* %84 to i8*
  %86 = load i32, i32* %count, align 4
  %87 = sub i32 %86, 1
  %88 = load i32, i32* %i, align 4
  %89 = sub i32 %87, %88
  %90 = zext i32 %89 to i64
  %91 = mul i64 %90, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %79, i8* %85, i64 %91, i32 8, i1 false)
  %92 = load i64, i64* %bm, align 8
  %93 = load i32, i32* %hpiece, align 4
  %94 = zext i32 %93 to i64
  %95 = shl i64 1, %94
  %96 = xor i64 -1, %95
  %97 = and i64 %92, %96
  %98 = shl i64 %97, 1
  %99 = or i64 %98, 1
  store i64 %99, i64* %newbm, align 8
  %100 = load i64, i64* %newbm, align 8
  %101 = load %class.KV.8*, %class.KV.8** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EEC2EmPKS_IS0_S1_Lj9EE(%class.KV.7* %agg.result, i64 %100, %class.KV.8* %101)
  br label %132

; <label>:102                                     ; preds = %48
  %103 = load %class.KV.7*, %class.KV.7** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EEC2ERKS2_(%class.KV.7* %agg.result, %class.KV.7* dereferenceable(16) %103)
  br label %132

; <label>:104                                     ; preds = %30
  %105 = load i32, i32* %i, align 4
  %106 = zext i32 %105 to i64
  %107 = load %class.KV.8*, %class.KV.8** %data, align 8
  %108 = getelementptr inbounds %class.KV.8, %class.KV.8* %107, i64 %106
  %109 = load i64, i64* %2, align 8
  %110 = lshr i64 %109, 6
  %111 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %112 = load i64*, i64** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EE12remove_innerERKS2_mPKS0_Pm(%class.KV.8* sret %childkv, %class.KV.8* dereferenceable(16) %108, i64 %110, %class.scheme_key* %111, i64* %112)
  %113 = load i32, i32* %i, align 4
  %114 = zext i32 %113 to i64
  %115 = load %class.KV.8*, %class.KV.8** %data, align 8
  %116 = getelementptr inbounds %class.KV.8, %class.KV.8* %115, i64 %114
  %117 = call zeroext i1 @_ZNK2KVI10scheme_key12scheme_valueLj9EEeqERKS2_(%class.KV.8* %childkv, %class.KV.8* dereferenceable(16) %116)
  br i1 %117, label %118, label %120

; <label>:118                                     ; preds = %104
  %119 = load %class.KV.7*, %class.KV.7** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EEC2ERKS2_(%class.KV.7* %agg.result, %class.KV.7* dereferenceable(16) %119)
  br label %132

; <label>:120                                     ; preds = %104
  %121 = load %class.KV.8*, %class.KV.8** %data, align 8
  %122 = load i32, i32* %count, align 4
  %123 = load i32, i32* %i, align 4
  %124 = call %class.KV.8* @_ZN2KVI10scheme_key12scheme_valueLj9EE11update_nodeEPKS2_jjRS3_(%class.KV.8* %121, i32 %122, i32 %123, %class.KV.8* dereferenceable(16) %childkv)
  store %class.KV.8* %124, %class.KV.8** %node1, align 8
  %125 = load %class.KV.7*, %class.KV.7** %1, align 8
  %126 = getelementptr inbounds %class.KV.7, %class.KV.7* %125, i32 0, i32 0
  %127 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Key"* %126 to i64*
  %128 = load i64, i64* %127, align 8
  %129 = load %class.KV.8*, %class.KV.8** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EEC2EmPKS_IS0_S1_Lj9EE(%class.KV.7* %agg.result, i64 %128, %class.KV.8* %129)
  br label %132

; <label>:130                                     ; preds = %0
  %131 = load %class.KV.7*, %class.KV.7** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj8EEC2ERKS2_(%class.KV.7* %agg.result, %class.KV.7* dereferenceable(16) %131)
  br label %132

; <label>:132                                     ; preds = %130, %120, %118, %102, %58
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr zeroext i1 @_ZNK2KVI10scheme_key12scheme_valueLj8EEeqERKS2_(%class.KV.7* %this, %class.KV.7* dereferenceable(16) %kv) #5 comdat align 2 {
  %1 = alloca %class.KV.7*, align 8
  %2 = alloca %class.KV.7*, align 8
  store %class.KV.7* %this, %class.KV.7** %1, align 8
  store %class.KV.7* %kv, %class.KV.7** %2, align 8
  %3 = load %class.KV.7*, %class.KV.7** %1, align 8
  %4 = getelementptr inbounds %class.KV.7, %class.KV.7* %3, i32 0, i32 0
  %5 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Key"* %4 to i64*
  %6 = load i64, i64* %5, align 8
  %7 = load %class.KV.7*, %class.KV.7** %2, align 8
  %8 = getelementptr inbounds %class.KV.7, %class.KV.7* %7, i32 0, i32 0
  %9 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Key"* %8 to i64*
  %10 = load i64, i64* %9, align 8
  %11 = icmp eq i64 %6, %10
  br i1 %11, label %12, label %21

; <label>:12                                      ; preds = %0
  %13 = getelementptr inbounds %class.KV.7, %class.KV.7* %3, i32 0, i32 1
  %14 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Val"* %13 to %class.KV.8**
  %15 = load %class.KV.8*, %class.KV.8** %14, align 8
  %16 = load %class.KV.7*, %class.KV.7** %2, align 8
  %17 = getelementptr inbounds %class.KV.7, %class.KV.7* %16, i32 0, i32 1
  %18 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Val"* %17 to %class.KV.8**
  %19 = load %class.KV.8*, %class.KV.8** %18, align 8
  %20 = icmp eq %class.KV.8* %15, %19
  br label %21

; <label>:21                                      ; preds = %12, %0
  %22 = phi i1 [ false, %0 ], [ %20, %12 ]
  ret i1 %22
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj9EE12remove_innerERKS2_mPKS0_Pm(%class.KV.8* noalias sret %agg.result, %class.KV.8* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key, i64* %cptr) #0 comdat align 2 {
  %1 = alloca %class.KV.8*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.scheme_key*, align 8
  %4 = alloca i64*, align 8
  %data = alloca %class.KV.9*, align 8
  %bm = alloca i64, align 8
  %hpiece = alloca i32, align 4
  %count = alloca i32, align 4
  %exists = alloca i8, align 1
  %i = alloca i32, align 4
  %node = alloca %class.KV.9*, align 8
  %newbm = alloca i64, align 8
  %childkv = alloca %class.KV.9, align 8
  %node1 = alloca %class.KV.9*, align 8
  store %class.KV.8* %kv, %class.KV.8** %1, align 8
  store i64 %h, i64* %2, align 8
  store %class.scheme_key* %key, %class.scheme_key** %3, align 8
  store i64* %cptr, i64** %4, align 8
  %5 = load %class.KV.8*, %class.KV.8** %1, align 8
  %6 = getelementptr inbounds %class.KV.8, %class.KV.8* %5, i32 0, i32 1
  %7 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Val"* %6 to %class.KV.9**
  %8 = load %class.KV.9*, %class.KV.9** %7, align 8
  store %class.KV.9* %8, %class.KV.9** %data, align 8
  %9 = load %class.KV.8*, %class.KV.8** %1, align 8
  %10 = getelementptr inbounds %class.KV.8, %class.KV.8* %9, i32 0, i32 0
  %11 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Key"* %10 to i64*
  %12 = load i64, i64* %11, align 8
  %13 = lshr i64 %12, 1
  store i64 %13, i64* %bm, align 8
  %14 = load i64, i64* %2, align 8
  %15 = and i64 %14, 63
  %16 = urem i64 %15, 63
  %17 = trunc i64 %16 to i32
  store i32 %17, i32* %hpiece, align 4
  %18 = load i64, i64* %bm, align 8
  %19 = call i64 @llvm.ctpop.i64(i64 %18)
  %20 = trunc i64 %19 to i32
  store i32 %20, i32* %count, align 4
  %21 = load i64, i64* %bm, align 8
  %22 = load i32, i32* %hpiece, align 4
  %23 = zext i32 %22 to i64
  %24 = shl i64 1, %23
  %25 = and i64 %21, %24
  %26 = icmp ne i64 %25, 0
  %27 = zext i1 %26 to i8
  store i8 %27, i8* %exists, align 1
  %28 = load i8, i8* %exists, align 1
  %29 = trunc i8 %28 to i1
  br i1 %29, label %30, label %130

; <label>:30                                      ; preds = %0
  %31 = load i64, i64* %bm, align 8
  %32 = shl i64 %31, 1
  %33 = load i32, i32* %hpiece, align 4
  %34 = sub i32 63, %33
  %35 = zext i32 %34 to i64
  %36 = shl i64 %32, %35
  %37 = call i64 @llvm.ctpop.i64(i64 %36)
  %38 = trunc i64 %37 to i32
  store i32 %38, i32* %i, align 4
  %39 = load i32, i32* %i, align 4
  %40 = zext i32 %39 to i64
  %41 = load %class.KV.9*, %class.KV.9** %data, align 8
  %42 = getelementptr inbounds %class.KV.9, %class.KV.9* %41, i64 %40
  %43 = getelementptr inbounds %class.KV.9, %class.KV.9* %42, i32 0, i32 0
  %44 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Key"* %43 to i64*
  %45 = load i64, i64* %44, align 8
  %46 = and i64 %45, 1
  %47 = icmp eq i64 %46, 0
  br i1 %47, label %48, label %104

; <label>:48                                      ; preds = %30
  %49 = load i32, i32* %i, align 4
  %50 = zext i32 %49 to i64
  %51 = load %class.KV.9*, %class.KV.9** %data, align 8
  %52 = getelementptr inbounds %class.KV.9, %class.KV.9* %51, i64 %50
  %53 = getelementptr inbounds %class.KV.9, %class.KV.9* %52, i32 0, i32 0
  %54 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Key"* %53 to %class.scheme_key**
  %55 = load %class.scheme_key*, %class.scheme_key** %54, align 8
  %56 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %57 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %55, %class.scheme_key* dereferenceable(8) %56)
  br i1 %57, label %58, label %102

; <label>:58                                      ; preds = %48
  %59 = load i64*, i64** %4, align 8
  %60 = load i64, i64* %59, align 8
  %61 = add i64 %60, -1
  store i64 %61, i64* %59, align 8
  %62 = load i32, i32* %count, align 4
  %63 = sub i32 %62, 1
  %64 = zext i32 %63 to i64
  %65 = mul i64 %64, 16
  %66 = call noalias i8* @GC_malloc(i64 %65)
  %67 = bitcast i8* %66 to %class.KV.9*
  store %class.KV.9* %67, %class.KV.9** %node, align 8
  %68 = load %class.KV.9*, %class.KV.9** %node, align 8
  %69 = bitcast %class.KV.9* %68 to i8*
  %70 = load %class.KV.9*, %class.KV.9** %data, align 8
  %71 = bitcast %class.KV.9* %70 to i8*
  %72 = load i32, i32* %i, align 4
  %73 = zext i32 %72 to i64
  %74 = mul i64 %73, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %69, i8* %71, i64 %74, i32 8, i1 false)
  %75 = load i32, i32* %i, align 4
  %76 = zext i32 %75 to i64
  %77 = load %class.KV.9*, %class.KV.9** %node, align 8
  %78 = getelementptr inbounds %class.KV.9, %class.KV.9* %77, i64 %76
  %79 = bitcast %class.KV.9* %78 to i8*
  %80 = load i32, i32* %i, align 4
  %81 = add i32 %80, 1
  %82 = zext i32 %81 to i64
  %83 = load %class.KV.9*, %class.KV.9** %data, align 8
  %84 = getelementptr inbounds %class.KV.9, %class.KV.9* %83, i64 %82
  %85 = bitcast %class.KV.9* %84 to i8*
  %86 = load i32, i32* %count, align 4
  %87 = sub i32 %86, 1
  %88 = load i32, i32* %i, align 4
  %89 = sub i32 %87, %88
  %90 = zext i32 %89 to i64
  %91 = mul i64 %90, 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %79, i8* %85, i64 %91, i32 8, i1 false)
  %92 = load i64, i64* %bm, align 8
  %93 = load i32, i32* %hpiece, align 4
  %94 = zext i32 %93 to i64
  %95 = shl i64 1, %94
  %96 = xor i64 -1, %95
  %97 = and i64 %92, %96
  %98 = shl i64 %97, 1
  %99 = or i64 %98, 1
  store i64 %99, i64* %newbm, align 8
  %100 = load i64, i64* %newbm, align 8
  %101 = load %class.KV.9*, %class.KV.9** %node, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EEC2EmPKS_IS0_S1_Lj10EE(%class.KV.8* %agg.result, i64 %100, %class.KV.9* %101)
  br label %132

; <label>:102                                     ; preds = %48
  %103 = load %class.KV.8*, %class.KV.8** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EEC2ERKS2_(%class.KV.8* %agg.result, %class.KV.8* dereferenceable(16) %103)
  br label %132

; <label>:104                                     ; preds = %30
  %105 = load i32, i32* %i, align 4
  %106 = zext i32 %105 to i64
  %107 = load %class.KV.9*, %class.KV.9** %data, align 8
  %108 = getelementptr inbounds %class.KV.9, %class.KV.9* %107, i64 %106
  %109 = load i64, i64* %2, align 8
  %110 = lshr i64 %109, 6
  %111 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %112 = load i64*, i64** %4, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj10EE12remove_innerERKS2_mPKS0_Pm(%class.KV.9* sret %childkv, %class.KV.9* dereferenceable(16) %108, i64 %110, %class.scheme_key* %111, i64* %112)
  %113 = load i32, i32* %i, align 4
  %114 = zext i32 %113 to i64
  %115 = load %class.KV.9*, %class.KV.9** %data, align 8
  %116 = getelementptr inbounds %class.KV.9, %class.KV.9* %115, i64 %114
  %117 = call zeroext i1 @_ZNK2KVI10scheme_key12scheme_valueLj10EEeqERKS2_(%class.KV.9* %childkv, %class.KV.9* dereferenceable(16) %116)
  br i1 %117, label %118, label %120

; <label>:118                                     ; preds = %104
  %119 = load %class.KV.8*, %class.KV.8** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EEC2ERKS2_(%class.KV.8* %agg.result, %class.KV.8* dereferenceable(16) %119)
  br label %132

; <label>:120                                     ; preds = %104
  %121 = load %class.KV.9*, %class.KV.9** %data, align 8
  %122 = load i32, i32* %count, align 4
  %123 = load i32, i32* %i, align 4
  %124 = call %class.KV.9* @_ZN2KVI10scheme_key12scheme_valueLj10EE11update_nodeEPKS2_jjRS3_(%class.KV.9* %121, i32 %122, i32 %123, %class.KV.9* dereferenceable(16) %childkv)
  store %class.KV.9* %124, %class.KV.9** %node1, align 8
  %125 = load %class.KV.8*, %class.KV.8** %1, align 8
  %126 = getelementptr inbounds %class.KV.8, %class.KV.8* %125, i32 0, i32 0
  %127 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Key"* %126 to i64*
  %128 = load i64, i64* %127, align 8
  %129 = load %class.KV.9*, %class.KV.9** %node1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EEC2EmPKS_IS0_S1_Lj10EE(%class.KV.8* %agg.result, i64 %128, %class.KV.9* %129)
  br label %132

; <label>:130                                     ; preds = %0
  %131 = load %class.KV.8*, %class.KV.8** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj9EEC2ERKS2_(%class.KV.8* %agg.result, %class.KV.8* dereferenceable(16) %131)
  br label %132

; <label>:132                                     ; preds = %130, %120, %118, %102, %58
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr zeroext i1 @_ZNK2KVI10scheme_key12scheme_valueLj9EEeqERKS2_(%class.KV.8* %this, %class.KV.8* dereferenceable(16) %kv) #5 comdat align 2 {
  %1 = alloca %class.KV.8*, align 8
  %2 = alloca %class.KV.8*, align 8
  store %class.KV.8* %this, %class.KV.8** %1, align 8
  store %class.KV.8* %kv, %class.KV.8** %2, align 8
  %3 = load %class.KV.8*, %class.KV.8** %1, align 8
  %4 = getelementptr inbounds %class.KV.8, %class.KV.8* %3, i32 0, i32 0
  %5 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Key"* %4 to i64*
  %6 = load i64, i64* %5, align 8
  %7 = load %class.KV.8*, %class.KV.8** %2, align 8
  %8 = getelementptr inbounds %class.KV.8, %class.KV.8* %7, i32 0, i32 0
  %9 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Key"* %8 to i64*
  %10 = load i64, i64* %9, align 8
  %11 = icmp eq i64 %6, %10
  br i1 %11, label %12, label %21

; <label>:12                                      ; preds = %0
  %13 = getelementptr inbounds %class.KV.8, %class.KV.8* %3, i32 0, i32 1
  %14 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Val"* %13 to %class.KV.9**
  %15 = load %class.KV.9*, %class.KV.9** %14, align 8
  %16 = load %class.KV.8*, %class.KV.8** %2, align 8
  %17 = getelementptr inbounds %class.KV.8, %class.KV.8* %16, i32 0, i32 1
  %18 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Val"* %17 to %class.KV.9**
  %19 = load %class.KV.9*, %class.KV.9** %18, align 8
  %20 = icmp eq %class.KV.9* %15, %19
  br label %21

; <label>:21                                      ; preds = %12, %0
  %22 = phi i1 [ false, %0 ], [ %20, %12 ]
  ret i1 %22
}

; Function Attrs: uwtable
define linkonce_odr void @_ZN2KVI10scheme_key12scheme_valueLj10EE12remove_innerERKS2_mPKS0_Pm(%class.KV.9* noalias sret %agg.result, %class.KV.9* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key, i64* %cptr) #0 comdat align 2 {
  %1 = alloca %class.KV.9*, align 8
  %2 = alloca i64, align 8
  %3 = alloca %class.scheme_key*, align 8
  %4 = alloca i64*, align 8
  %ll = alloca %class.LL*, align 8
  store %class.KV.9* %kv, %class.KV.9** %1, align 8
  store i64 %h, i64* %2, align 8
  store %class.scheme_key* %key, %class.scheme_key** %3, align 8
  store i64* %cptr, i64** %4, align 8
  %5 = load %class.KV.9*, %class.KV.9** %1, align 8
  %6 = getelementptr inbounds %class.KV.9, %class.KV.9* %5, i32 0, i32 1
  %7 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Val"* %6 to %class.LL**
  %8 = load %class.LL*, %class.LL** %7, align 8
  %9 = icmp ne %class.LL* %8, null
  br i1 %9, label %10, label %28

; <label>:10                                      ; preds = %0
  %11 = load %class.KV.9*, %class.KV.9** %1, align 8
  %12 = getelementptr inbounds %class.KV.9, %class.KV.9* %11, i32 0, i32 1
  %13 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Val"* %12 to %class.LL**
  %14 = load %class.LL*, %class.LL** %13, align 8
  %15 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %16 = load i64*, i64** %4, align 8
  %17 = call %class.LL* @_ZNK2LLI10scheme_key12scheme_valueE6removeEPKS0_Pm(%class.LL* %14, %class.scheme_key* %15, i64* %16)
  store %class.LL* %17, %class.LL** %ll, align 8
  %18 = load %class.LL*, %class.LL** %ll, align 8
  %19 = load %class.KV.9*, %class.KV.9** %1, align 8
  %20 = getelementptr inbounds %class.KV.9, %class.KV.9* %19, i32 0, i32 1
  %21 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Val"* %20 to %class.LL**
  %22 = load %class.LL*, %class.LL** %21, align 8
  %23 = icmp eq %class.LL* %18, %22
  br i1 %23, label %24, label %26

; <label>:24                                      ; preds = %10
  %25 = load %class.KV.9*, %class.KV.9** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj10EEC2ERKS2_(%class.KV.9* %agg.result, %class.KV.9* dereferenceable(16) %25)
  br label %30

; <label>:26                                      ; preds = %10
  %27 = load %class.LL*, %class.LL** %ll, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj10EEC2EmPK2LLIS0_S1_E(%class.KV.9* %agg.result, i64 1, %class.LL* %27)
  br label %30

; <label>:28                                      ; preds = %0
  %29 = load %class.KV.9*, %class.KV.9** %1, align 8
  call void @_ZN2KVI10scheme_key12scheme_valueLj10EEC2ERKS2_(%class.KV.9* %agg.result, %class.KV.9* dereferenceable(16) %29)
  br label %30

; <label>:30                                      ; preds = %28, %26, %24
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce_odr zeroext i1 @_ZNK2KVI10scheme_key12scheme_valueLj10EEeqERKS2_(%class.KV.9* %this, %class.KV.9* dereferenceable(16) %kv) #5 comdat align 2 {
  %1 = alloca %class.KV.9*, align 8
  %2 = alloca %class.KV.9*, align 8
  store %class.KV.9* %this, %class.KV.9** %1, align 8
  store %class.KV.9* %kv, %class.KV.9** %2, align 8
  %3 = load %class.KV.9*, %class.KV.9** %1, align 8
  %4 = getelementptr inbounds %class.KV.9, %class.KV.9* %3, i32 0, i32 0
  %5 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Key"* %4 to i64*
  %6 = load i64, i64* %5, align 8
  %7 = load %class.KV.9*, %class.KV.9** %2, align 8
  %8 = getelementptr inbounds %class.KV.9, %class.KV.9* %7, i32 0, i32 0
  %9 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Key"* %8 to i64*
  %10 = load i64, i64* %9, align 8
  %11 = icmp eq i64 %6, %10
  br i1 %11, label %12, label %21

; <label>:12                                      ; preds = %0
  %13 = getelementptr inbounds %class.KV.9, %class.KV.9* %3, i32 0, i32 1
  %14 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Val"* %13 to %class.scheme_value**
  %15 = load %class.scheme_value*, %class.scheme_value** %14, align 8
  %16 = load %class.KV.9*, %class.KV.9** %2, align 8
  %17 = getelementptr inbounds %class.KV.9, %class.KV.9* %16, i32 0, i32 1
  %18 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Val"* %17 to %class.scheme_value**
  %19 = load %class.scheme_value*, %class.scheme_value** %18, align 8
  %20 = icmp eq %class.scheme_value* %15, %19
  br label %21

; <label>:21                                      ; preds = %12, %0
  %22 = phi i1 [ false, %0 ], [ %20, %12 ]
  ret i1 %22
}

; Function Attrs: uwtable
define linkonce_odr %class.LL* @_ZNK2LLI10scheme_key12scheme_valueE6removeEPKS0_Pm(%class.LL* %this, %class.scheme_key* %k, i64* %cptr) #0 comdat align 2 {
  %1 = alloca %class.LL*, align 8
  %2 = alloca %class.LL*, align 8
  %3 = alloca %class.scheme_key*, align 8
  %4 = alloca i64*, align 8
  %next = alloca %class.LL*, align 8
  store %class.LL* %this, %class.LL** %2, align 8
  store %class.scheme_key* %k, %class.scheme_key** %3, align 8
  store i64* %cptr, i64** %4, align 8
  %5 = load %class.LL*, %class.LL** %2, align 8
  %6 = getelementptr inbounds %class.LL, %class.LL* %5, i32 0, i32 0
  %7 = load %class.scheme_key*, %class.scheme_key** %6, align 8
  %8 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %9 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %7, %class.scheme_key* dereferenceable(8) %8)
  br i1 %9, label %10, label %16

; <label>:10                                      ; preds = %0
  %11 = load i64*, i64** %4, align 8
  %12 = load i64, i64* %11, align 8
  %13 = add i64 %12, -1
  store i64 %13, i64* %11, align 8
  %14 = getelementptr inbounds %class.LL, %class.LL* %5, i32 0, i32 2
  %15 = load %class.LL*, %class.LL** %14, align 8
  store %class.LL* %15, %class.LL** %1, align 8
  br label %42

; <label>:16                                      ; preds = %0
  %17 = getelementptr inbounds %class.LL, %class.LL* %5, i32 0, i32 2
  %18 = load %class.LL*, %class.LL** %17, align 8
  %19 = icmp ne %class.LL* %18, null
  br i1 %19, label %20, label %41

; <label>:20                                      ; preds = %16
  %21 = getelementptr inbounds %class.LL, %class.LL* %5, i32 0, i32 2
  %22 = load %class.LL*, %class.LL** %21, align 8
  %23 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %24 = load i64*, i64** %4, align 8
  %25 = call %class.LL* @_ZNK2LLI10scheme_key12scheme_valueE6removeEPKS0_Pm(%class.LL* %22, %class.scheme_key* %23, i64* %24)
  store %class.LL* %25, %class.LL** %next, align 8
  %26 = getelementptr inbounds %class.LL, %class.LL* %5, i32 0, i32 2
  %27 = load %class.LL*, %class.LL** %26, align 8
  %28 = load %class.LL*, %class.LL** %next, align 8
  %29 = icmp eq %class.LL* %27, %28
  br i1 %29, label %30, label %31

; <label>:30                                      ; preds = %20
  store %class.LL* %5, %class.LL** %1, align 8
  br label %42

; <label>:31                                      ; preds = %20
  %32 = call noalias i8* @GC_malloc(i64 24)
  %33 = bitcast i8* %32 to %class.LL*
  %34 = bitcast %class.LL* %33 to i8*
  %35 = bitcast i8* %34 to %class.LL*
  %36 = getelementptr inbounds %class.LL, %class.LL* %5, i32 0, i32 0
  %37 = load %class.scheme_key*, %class.scheme_key** %36, align 8
  %38 = getelementptr inbounds %class.LL, %class.LL* %5, i32 0, i32 1
  %39 = load %class.scheme_value*, %class.scheme_value** %38, align 8
  %40 = load %class.LL*, %class.LL** %next, align 8
  call void @_ZN2LLI10scheme_key12scheme_valueEC2EPKS0_PKS1_PKS2_(%class.LL* %35, %class.scheme_key* %37, %class.scheme_value* %39, %class.LL* %40)
  store %class.LL* %35, %class.LL** %1, align 8
  br label %42

; <label>:41                                      ; preds = %16
  store %class.LL* %5, %class.LL** %1, align 8
  br label %42

; <label>:42                                      ; preds = %41, %31, %30, %10
  %43 = load %class.LL*, %class.LL** %1, align 8
  ret %class.LL* %43
}

; Function Attrs: uwtable
define linkonce_odr %class.scheme_value* @_ZN2KVI10scheme_key12scheme_valueLj0EE10inner_findERKS2_mPKS0_(%class.KV* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key) #0 comdat align 2 {
  %1 = alloca %class.scheme_value*, align 8
  %2 = alloca %class.KV*, align 8
  %3 = alloca i64, align 8
  %4 = alloca %class.scheme_key*, align 8
  %hpiece = alloca i64, align 8
  %data = alloca %class.KV.0*, align 8
  %bm = alloca i64, align 8
  %exists = alloca i8, align 1
  %i = alloca i32, align 4
  store %class.KV* %kv, %class.KV** %2, align 8
  store i64 %h, i64* %3, align 8
  store %class.scheme_key* %key, %class.scheme_key** %4, align 8
  %5 = load i64, i64* %3, align 8
  %6 = and i64 %5, 63
  %7 = urem i64 %6, 63
  store i64 %7, i64* %hpiece, align 8
  %8 = load %class.KV*, %class.KV** %2, align 8
  %9 = getelementptr inbounds %class.KV, %class.KV* %8, i32 0, i32 1
  %10 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Val"* %9 to %class.KV.0**
  %11 = load %class.KV.0*, %class.KV.0** %10, align 8
  store %class.KV.0* %11, %class.KV.0** %data, align 8
  %12 = load %class.KV*, %class.KV** %2, align 8
  %13 = getelementptr inbounds %class.KV, %class.KV* %12, i32 0, i32 0
  %14 = bitcast %"union.KV<scheme_key, scheme_value, 0>::Key"* %13 to i64*
  %15 = load i64, i64* %14, align 8
  %16 = lshr i64 %15, 1
  store i64 %16, i64* %bm, align 8
  %17 = load i64, i64* %bm, align 8
  %18 = load i64, i64* %hpiece, align 8
  %19 = shl i64 1, %18
  %20 = and i64 %17, %19
  %21 = icmp ne i64 %20, 0
  %22 = zext i1 %21 to i8
  store i8 %22, i8* %exists, align 1
  %23 = load i8, i8* %exists, align 1
  %24 = trunc i8 %23 to i1
  br i1 %24, label %25, label %70

; <label>:25                                      ; preds = %0
  %26 = load i64, i64* %bm, align 8
  %27 = shl i64 %26, 1
  %28 = load i64, i64* %hpiece, align 8
  %29 = sub i64 63, %28
  %30 = shl i64 %27, %29
  %31 = call i64 @llvm.ctpop.i64(i64 %30)
  %32 = trunc i64 %31 to i32
  store i32 %32, i32* %i, align 4
  %33 = load i32, i32* %i, align 4
  %34 = zext i32 %33 to i64
  %35 = load %class.KV.0*, %class.KV.0** %data, align 8
  %36 = getelementptr inbounds %class.KV.0, %class.KV.0* %35, i64 %34
  %37 = getelementptr inbounds %class.KV.0, %class.KV.0* %36, i32 0, i32 0
  %38 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Key"* %37 to i64*
  %39 = load i64, i64* %38, align 8
  %40 = and i64 %39, 1
  %41 = icmp eq i64 %40, 0
  br i1 %41, label %42, label %61

; <label>:42                                      ; preds = %25
  %43 = load i32, i32* %i, align 4
  %44 = zext i32 %43 to i64
  %45 = load %class.KV.0*, %class.KV.0** %data, align 8
  %46 = getelementptr inbounds %class.KV.0, %class.KV.0* %45, i64 %44
  %47 = getelementptr inbounds %class.KV.0, %class.KV.0* %46, i32 0, i32 0
  %48 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Key"* %47 to %class.scheme_key**
  %49 = load %class.scheme_key*, %class.scheme_key** %48, align 8
  %50 = load %class.scheme_key*, %class.scheme_key** %4, align 8
  %51 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %49, %class.scheme_key* dereferenceable(8) %50)
  br i1 %51, label %52, label %60

; <label>:52                                      ; preds = %42
  %53 = load i32, i32* %i, align 4
  %54 = zext i32 %53 to i64
  %55 = load %class.KV.0*, %class.KV.0** %data, align 8
  %56 = getelementptr inbounds %class.KV.0, %class.KV.0* %55, i64 %54
  %57 = getelementptr inbounds %class.KV.0, %class.KV.0* %56, i32 0, i32 1
  %58 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Val"* %57 to %class.scheme_value**
  %59 = load %class.scheme_value*, %class.scheme_value** %58, align 8
  store %class.scheme_value* %59, %class.scheme_value** %1, align 8
  br label %71

; <label>:60                                      ; preds = %42
  store %class.scheme_value* null, %class.scheme_value** %1, align 8
  br label %71

; <label>:61                                      ; preds = %25
  %62 = load i32, i32* %i, align 4
  %63 = zext i32 %62 to i64
  %64 = load %class.KV.0*, %class.KV.0** %data, align 8
  %65 = getelementptr inbounds %class.KV.0, %class.KV.0* %64, i64 %63
  %66 = load i64, i64* %3, align 8
  %67 = lshr i64 %66, 6
  %68 = load %class.scheme_key*, %class.scheme_key** %4, align 8
  %69 = call %class.scheme_value* @_ZN2KVI10scheme_key12scheme_valueLj1EE10inner_findERKS2_mPKS0_(%class.KV.0* dereferenceable(16) %65, i64 %67, %class.scheme_key* %68)
  store %class.scheme_value* %69, %class.scheme_value** %1, align 8
  br label %71

; <label>:70                                      ; preds = %0
  store %class.scheme_value* null, %class.scheme_value** %1, align 8
  br label %71

; <label>:71                                      ; preds = %70, %61, %60, %52
  %72 = load %class.scheme_value*, %class.scheme_value** %1, align 8
  ret %class.scheme_value* %72
}

; Function Attrs: uwtable
define linkonce_odr %class.scheme_value* @_ZN2KVI10scheme_key12scheme_valueLj1EE10inner_findERKS2_mPKS0_(%class.KV.0* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key) #0 comdat align 2 {
  %1 = alloca %class.scheme_value*, align 8
  %2 = alloca %class.KV.0*, align 8
  %3 = alloca i64, align 8
  %4 = alloca %class.scheme_key*, align 8
  %hpiece = alloca i64, align 8
  %data = alloca %class.KV.1*, align 8
  %bm = alloca i64, align 8
  %exists = alloca i8, align 1
  %i = alloca i32, align 4
  store %class.KV.0* %kv, %class.KV.0** %2, align 8
  store i64 %h, i64* %3, align 8
  store %class.scheme_key* %key, %class.scheme_key** %4, align 8
  %5 = load i64, i64* %3, align 8
  %6 = and i64 %5, 63
  %7 = urem i64 %6, 63
  store i64 %7, i64* %hpiece, align 8
  %8 = load %class.KV.0*, %class.KV.0** %2, align 8
  %9 = getelementptr inbounds %class.KV.0, %class.KV.0* %8, i32 0, i32 1
  %10 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Val"* %9 to %class.KV.1**
  %11 = load %class.KV.1*, %class.KV.1** %10, align 8
  store %class.KV.1* %11, %class.KV.1** %data, align 8
  %12 = load %class.KV.0*, %class.KV.0** %2, align 8
  %13 = getelementptr inbounds %class.KV.0, %class.KV.0* %12, i32 0, i32 0
  %14 = bitcast %"union.KV<scheme_key, scheme_value, 1>::Key"* %13 to i64*
  %15 = load i64, i64* %14, align 8
  %16 = lshr i64 %15, 1
  store i64 %16, i64* %bm, align 8
  %17 = load i64, i64* %bm, align 8
  %18 = load i64, i64* %hpiece, align 8
  %19 = shl i64 1, %18
  %20 = and i64 %17, %19
  %21 = icmp ne i64 %20, 0
  %22 = zext i1 %21 to i8
  store i8 %22, i8* %exists, align 1
  %23 = load i8, i8* %exists, align 1
  %24 = trunc i8 %23 to i1
  br i1 %24, label %25, label %70

; <label>:25                                      ; preds = %0
  %26 = load i64, i64* %bm, align 8
  %27 = shl i64 %26, 1
  %28 = load i64, i64* %hpiece, align 8
  %29 = sub i64 63, %28
  %30 = shl i64 %27, %29
  %31 = call i64 @llvm.ctpop.i64(i64 %30)
  %32 = trunc i64 %31 to i32
  store i32 %32, i32* %i, align 4
  %33 = load i32, i32* %i, align 4
  %34 = zext i32 %33 to i64
  %35 = load %class.KV.1*, %class.KV.1** %data, align 8
  %36 = getelementptr inbounds %class.KV.1, %class.KV.1* %35, i64 %34
  %37 = getelementptr inbounds %class.KV.1, %class.KV.1* %36, i32 0, i32 0
  %38 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Key"* %37 to i64*
  %39 = load i64, i64* %38, align 8
  %40 = and i64 %39, 1
  %41 = icmp eq i64 %40, 0
  br i1 %41, label %42, label %61

; <label>:42                                      ; preds = %25
  %43 = load i32, i32* %i, align 4
  %44 = zext i32 %43 to i64
  %45 = load %class.KV.1*, %class.KV.1** %data, align 8
  %46 = getelementptr inbounds %class.KV.1, %class.KV.1* %45, i64 %44
  %47 = getelementptr inbounds %class.KV.1, %class.KV.1* %46, i32 0, i32 0
  %48 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Key"* %47 to %class.scheme_key**
  %49 = load %class.scheme_key*, %class.scheme_key** %48, align 8
  %50 = load %class.scheme_key*, %class.scheme_key** %4, align 8
  %51 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %49, %class.scheme_key* dereferenceable(8) %50)
  br i1 %51, label %52, label %60

; <label>:52                                      ; preds = %42
  %53 = load i32, i32* %i, align 4
  %54 = zext i32 %53 to i64
  %55 = load %class.KV.1*, %class.KV.1** %data, align 8
  %56 = getelementptr inbounds %class.KV.1, %class.KV.1* %55, i64 %54
  %57 = getelementptr inbounds %class.KV.1, %class.KV.1* %56, i32 0, i32 1
  %58 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Val"* %57 to %class.scheme_value**
  %59 = load %class.scheme_value*, %class.scheme_value** %58, align 8
  store %class.scheme_value* %59, %class.scheme_value** %1, align 8
  br label %71

; <label>:60                                      ; preds = %42
  store %class.scheme_value* null, %class.scheme_value** %1, align 8
  br label %71

; <label>:61                                      ; preds = %25
  %62 = load i32, i32* %i, align 4
  %63 = zext i32 %62 to i64
  %64 = load %class.KV.1*, %class.KV.1** %data, align 8
  %65 = getelementptr inbounds %class.KV.1, %class.KV.1* %64, i64 %63
  %66 = load i64, i64* %3, align 8
  %67 = lshr i64 %66, 6
  %68 = load %class.scheme_key*, %class.scheme_key** %4, align 8
  %69 = call %class.scheme_value* @_ZN2KVI10scheme_key12scheme_valueLj2EE10inner_findERKS2_mPKS0_(%class.KV.1* dereferenceable(16) %65, i64 %67, %class.scheme_key* %68)
  store %class.scheme_value* %69, %class.scheme_value** %1, align 8
  br label %71

; <label>:70                                      ; preds = %0
  store %class.scheme_value* null, %class.scheme_value** %1, align 8
  br label %71

; <label>:71                                      ; preds = %70, %61, %60, %52
  %72 = load %class.scheme_value*, %class.scheme_value** %1, align 8
  ret %class.scheme_value* %72
}

; Function Attrs: uwtable
define linkonce_odr %class.scheme_value* @_ZN2KVI10scheme_key12scheme_valueLj2EE10inner_findERKS2_mPKS0_(%class.KV.1* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key) #0 comdat align 2 {
  %1 = alloca %class.scheme_value*, align 8
  %2 = alloca %class.KV.1*, align 8
  %3 = alloca i64, align 8
  %4 = alloca %class.scheme_key*, align 8
  %hpiece = alloca i64, align 8
  %data = alloca %class.KV.2*, align 8
  %bm = alloca i64, align 8
  %exists = alloca i8, align 1
  %i = alloca i32, align 4
  store %class.KV.1* %kv, %class.KV.1** %2, align 8
  store i64 %h, i64* %3, align 8
  store %class.scheme_key* %key, %class.scheme_key** %4, align 8
  %5 = load i64, i64* %3, align 8
  %6 = and i64 %5, 63
  %7 = urem i64 %6, 63
  store i64 %7, i64* %hpiece, align 8
  %8 = load %class.KV.1*, %class.KV.1** %2, align 8
  %9 = getelementptr inbounds %class.KV.1, %class.KV.1* %8, i32 0, i32 1
  %10 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Val"* %9 to %class.KV.2**
  %11 = load %class.KV.2*, %class.KV.2** %10, align 8
  store %class.KV.2* %11, %class.KV.2** %data, align 8
  %12 = load %class.KV.1*, %class.KV.1** %2, align 8
  %13 = getelementptr inbounds %class.KV.1, %class.KV.1* %12, i32 0, i32 0
  %14 = bitcast %"union.KV<scheme_key, scheme_value, 2>::Key"* %13 to i64*
  %15 = load i64, i64* %14, align 8
  %16 = lshr i64 %15, 1
  store i64 %16, i64* %bm, align 8
  %17 = load i64, i64* %bm, align 8
  %18 = load i64, i64* %hpiece, align 8
  %19 = shl i64 1, %18
  %20 = and i64 %17, %19
  %21 = icmp ne i64 %20, 0
  %22 = zext i1 %21 to i8
  store i8 %22, i8* %exists, align 1
  %23 = load i8, i8* %exists, align 1
  %24 = trunc i8 %23 to i1
  br i1 %24, label %25, label %70

; <label>:25                                      ; preds = %0
  %26 = load i64, i64* %bm, align 8
  %27 = shl i64 %26, 1
  %28 = load i64, i64* %hpiece, align 8
  %29 = sub i64 63, %28
  %30 = shl i64 %27, %29
  %31 = call i64 @llvm.ctpop.i64(i64 %30)
  %32 = trunc i64 %31 to i32
  store i32 %32, i32* %i, align 4
  %33 = load i32, i32* %i, align 4
  %34 = zext i32 %33 to i64
  %35 = load %class.KV.2*, %class.KV.2** %data, align 8
  %36 = getelementptr inbounds %class.KV.2, %class.KV.2* %35, i64 %34
  %37 = getelementptr inbounds %class.KV.2, %class.KV.2* %36, i32 0, i32 0
  %38 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Key"* %37 to i64*
  %39 = load i64, i64* %38, align 8
  %40 = and i64 %39, 1
  %41 = icmp eq i64 %40, 0
  br i1 %41, label %42, label %61

; <label>:42                                      ; preds = %25
  %43 = load i32, i32* %i, align 4
  %44 = zext i32 %43 to i64
  %45 = load %class.KV.2*, %class.KV.2** %data, align 8
  %46 = getelementptr inbounds %class.KV.2, %class.KV.2* %45, i64 %44
  %47 = getelementptr inbounds %class.KV.2, %class.KV.2* %46, i32 0, i32 0
  %48 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Key"* %47 to %class.scheme_key**
  %49 = load %class.scheme_key*, %class.scheme_key** %48, align 8
  %50 = load %class.scheme_key*, %class.scheme_key** %4, align 8
  %51 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %49, %class.scheme_key* dereferenceable(8) %50)
  br i1 %51, label %52, label %60

; <label>:52                                      ; preds = %42
  %53 = load i32, i32* %i, align 4
  %54 = zext i32 %53 to i64
  %55 = load %class.KV.2*, %class.KV.2** %data, align 8
  %56 = getelementptr inbounds %class.KV.2, %class.KV.2* %55, i64 %54
  %57 = getelementptr inbounds %class.KV.2, %class.KV.2* %56, i32 0, i32 1
  %58 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Val"* %57 to %class.scheme_value**
  %59 = load %class.scheme_value*, %class.scheme_value** %58, align 8
  store %class.scheme_value* %59, %class.scheme_value** %1, align 8
  br label %71

; <label>:60                                      ; preds = %42
  store %class.scheme_value* null, %class.scheme_value** %1, align 8
  br label %71

; <label>:61                                      ; preds = %25
  %62 = load i32, i32* %i, align 4
  %63 = zext i32 %62 to i64
  %64 = load %class.KV.2*, %class.KV.2** %data, align 8
  %65 = getelementptr inbounds %class.KV.2, %class.KV.2* %64, i64 %63
  %66 = load i64, i64* %3, align 8
  %67 = lshr i64 %66, 6
  %68 = load %class.scheme_key*, %class.scheme_key** %4, align 8
  %69 = call %class.scheme_value* @_ZN2KVI10scheme_key12scheme_valueLj3EE10inner_findERKS2_mPKS0_(%class.KV.2* dereferenceable(16) %65, i64 %67, %class.scheme_key* %68)
  store %class.scheme_value* %69, %class.scheme_value** %1, align 8
  br label %71

; <label>:70                                      ; preds = %0
  store %class.scheme_value* null, %class.scheme_value** %1, align 8
  br label %71

; <label>:71                                      ; preds = %70, %61, %60, %52
  %72 = load %class.scheme_value*, %class.scheme_value** %1, align 8
  ret %class.scheme_value* %72
}

; Function Attrs: uwtable
define linkonce_odr %class.scheme_value* @_ZN2KVI10scheme_key12scheme_valueLj3EE10inner_findERKS2_mPKS0_(%class.KV.2* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key) #0 comdat align 2 {
  %1 = alloca %class.scheme_value*, align 8
  %2 = alloca %class.KV.2*, align 8
  %3 = alloca i64, align 8
  %4 = alloca %class.scheme_key*, align 8
  %hpiece = alloca i64, align 8
  %data = alloca %class.KV.3*, align 8
  %bm = alloca i64, align 8
  %exists = alloca i8, align 1
  %i = alloca i32, align 4
  store %class.KV.2* %kv, %class.KV.2** %2, align 8
  store i64 %h, i64* %3, align 8
  store %class.scheme_key* %key, %class.scheme_key** %4, align 8
  %5 = load i64, i64* %3, align 8
  %6 = and i64 %5, 63
  %7 = urem i64 %6, 63
  store i64 %7, i64* %hpiece, align 8
  %8 = load %class.KV.2*, %class.KV.2** %2, align 8
  %9 = getelementptr inbounds %class.KV.2, %class.KV.2* %8, i32 0, i32 1
  %10 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Val"* %9 to %class.KV.3**
  %11 = load %class.KV.3*, %class.KV.3** %10, align 8
  store %class.KV.3* %11, %class.KV.3** %data, align 8
  %12 = load %class.KV.2*, %class.KV.2** %2, align 8
  %13 = getelementptr inbounds %class.KV.2, %class.KV.2* %12, i32 0, i32 0
  %14 = bitcast %"union.KV<scheme_key, scheme_value, 3>::Key"* %13 to i64*
  %15 = load i64, i64* %14, align 8
  %16 = lshr i64 %15, 1
  store i64 %16, i64* %bm, align 8
  %17 = load i64, i64* %bm, align 8
  %18 = load i64, i64* %hpiece, align 8
  %19 = shl i64 1, %18
  %20 = and i64 %17, %19
  %21 = icmp ne i64 %20, 0
  %22 = zext i1 %21 to i8
  store i8 %22, i8* %exists, align 1
  %23 = load i8, i8* %exists, align 1
  %24 = trunc i8 %23 to i1
  br i1 %24, label %25, label %70

; <label>:25                                      ; preds = %0
  %26 = load i64, i64* %bm, align 8
  %27 = shl i64 %26, 1
  %28 = load i64, i64* %hpiece, align 8
  %29 = sub i64 63, %28
  %30 = shl i64 %27, %29
  %31 = call i64 @llvm.ctpop.i64(i64 %30)
  %32 = trunc i64 %31 to i32
  store i32 %32, i32* %i, align 4
  %33 = load i32, i32* %i, align 4
  %34 = zext i32 %33 to i64
  %35 = load %class.KV.3*, %class.KV.3** %data, align 8
  %36 = getelementptr inbounds %class.KV.3, %class.KV.3* %35, i64 %34
  %37 = getelementptr inbounds %class.KV.3, %class.KV.3* %36, i32 0, i32 0
  %38 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Key"* %37 to i64*
  %39 = load i64, i64* %38, align 8
  %40 = and i64 %39, 1
  %41 = icmp eq i64 %40, 0
  br i1 %41, label %42, label %61

; <label>:42                                      ; preds = %25
  %43 = load i32, i32* %i, align 4
  %44 = zext i32 %43 to i64
  %45 = load %class.KV.3*, %class.KV.3** %data, align 8
  %46 = getelementptr inbounds %class.KV.3, %class.KV.3* %45, i64 %44
  %47 = getelementptr inbounds %class.KV.3, %class.KV.3* %46, i32 0, i32 0
  %48 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Key"* %47 to %class.scheme_key**
  %49 = load %class.scheme_key*, %class.scheme_key** %48, align 8
  %50 = load %class.scheme_key*, %class.scheme_key** %4, align 8
  %51 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %49, %class.scheme_key* dereferenceable(8) %50)
  br i1 %51, label %52, label %60

; <label>:52                                      ; preds = %42
  %53 = load i32, i32* %i, align 4
  %54 = zext i32 %53 to i64
  %55 = load %class.KV.3*, %class.KV.3** %data, align 8
  %56 = getelementptr inbounds %class.KV.3, %class.KV.3* %55, i64 %54
  %57 = getelementptr inbounds %class.KV.3, %class.KV.3* %56, i32 0, i32 1
  %58 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Val"* %57 to %class.scheme_value**
  %59 = load %class.scheme_value*, %class.scheme_value** %58, align 8
  store %class.scheme_value* %59, %class.scheme_value** %1, align 8
  br label %71

; <label>:60                                      ; preds = %42
  store %class.scheme_value* null, %class.scheme_value** %1, align 8
  br label %71

; <label>:61                                      ; preds = %25
  %62 = load i32, i32* %i, align 4
  %63 = zext i32 %62 to i64
  %64 = load %class.KV.3*, %class.KV.3** %data, align 8
  %65 = getelementptr inbounds %class.KV.3, %class.KV.3* %64, i64 %63
  %66 = load i64, i64* %3, align 8
  %67 = lshr i64 %66, 6
  %68 = load %class.scheme_key*, %class.scheme_key** %4, align 8
  %69 = call %class.scheme_value* @_ZN2KVI10scheme_key12scheme_valueLj4EE10inner_findERKS2_mPKS0_(%class.KV.3* dereferenceable(16) %65, i64 %67, %class.scheme_key* %68)
  store %class.scheme_value* %69, %class.scheme_value** %1, align 8
  br label %71

; <label>:70                                      ; preds = %0
  store %class.scheme_value* null, %class.scheme_value** %1, align 8
  br label %71

; <label>:71                                      ; preds = %70, %61, %60, %52
  %72 = load %class.scheme_value*, %class.scheme_value** %1, align 8
  ret %class.scheme_value* %72
}

; Function Attrs: uwtable
define linkonce_odr %class.scheme_value* @_ZN2KVI10scheme_key12scheme_valueLj4EE10inner_findERKS2_mPKS0_(%class.KV.3* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key) #0 comdat align 2 {
  %1 = alloca %class.scheme_value*, align 8
  %2 = alloca %class.KV.3*, align 8
  %3 = alloca i64, align 8
  %4 = alloca %class.scheme_key*, align 8
  %hpiece = alloca i64, align 8
  %data = alloca %class.KV.4*, align 8
  %bm = alloca i64, align 8
  %exists = alloca i8, align 1
  %i = alloca i32, align 4
  store %class.KV.3* %kv, %class.KV.3** %2, align 8
  store i64 %h, i64* %3, align 8
  store %class.scheme_key* %key, %class.scheme_key** %4, align 8
  %5 = load i64, i64* %3, align 8
  %6 = and i64 %5, 63
  %7 = urem i64 %6, 63
  store i64 %7, i64* %hpiece, align 8
  %8 = load %class.KV.3*, %class.KV.3** %2, align 8
  %9 = getelementptr inbounds %class.KV.3, %class.KV.3* %8, i32 0, i32 1
  %10 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Val"* %9 to %class.KV.4**
  %11 = load %class.KV.4*, %class.KV.4** %10, align 8
  store %class.KV.4* %11, %class.KV.4** %data, align 8
  %12 = load %class.KV.3*, %class.KV.3** %2, align 8
  %13 = getelementptr inbounds %class.KV.3, %class.KV.3* %12, i32 0, i32 0
  %14 = bitcast %"union.KV<scheme_key, scheme_value, 4>::Key"* %13 to i64*
  %15 = load i64, i64* %14, align 8
  %16 = lshr i64 %15, 1
  store i64 %16, i64* %bm, align 8
  %17 = load i64, i64* %bm, align 8
  %18 = load i64, i64* %hpiece, align 8
  %19 = shl i64 1, %18
  %20 = and i64 %17, %19
  %21 = icmp ne i64 %20, 0
  %22 = zext i1 %21 to i8
  store i8 %22, i8* %exists, align 1
  %23 = load i8, i8* %exists, align 1
  %24 = trunc i8 %23 to i1
  br i1 %24, label %25, label %70

; <label>:25                                      ; preds = %0
  %26 = load i64, i64* %bm, align 8
  %27 = shl i64 %26, 1
  %28 = load i64, i64* %hpiece, align 8
  %29 = sub i64 63, %28
  %30 = shl i64 %27, %29
  %31 = call i64 @llvm.ctpop.i64(i64 %30)
  %32 = trunc i64 %31 to i32
  store i32 %32, i32* %i, align 4
  %33 = load i32, i32* %i, align 4
  %34 = zext i32 %33 to i64
  %35 = load %class.KV.4*, %class.KV.4** %data, align 8
  %36 = getelementptr inbounds %class.KV.4, %class.KV.4* %35, i64 %34
  %37 = getelementptr inbounds %class.KV.4, %class.KV.4* %36, i32 0, i32 0
  %38 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Key"* %37 to i64*
  %39 = load i64, i64* %38, align 8
  %40 = and i64 %39, 1
  %41 = icmp eq i64 %40, 0
  br i1 %41, label %42, label %61

; <label>:42                                      ; preds = %25
  %43 = load i32, i32* %i, align 4
  %44 = zext i32 %43 to i64
  %45 = load %class.KV.4*, %class.KV.4** %data, align 8
  %46 = getelementptr inbounds %class.KV.4, %class.KV.4* %45, i64 %44
  %47 = getelementptr inbounds %class.KV.4, %class.KV.4* %46, i32 0, i32 0
  %48 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Key"* %47 to %class.scheme_key**
  %49 = load %class.scheme_key*, %class.scheme_key** %48, align 8
  %50 = load %class.scheme_key*, %class.scheme_key** %4, align 8
  %51 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %49, %class.scheme_key* dereferenceable(8) %50)
  br i1 %51, label %52, label %60

; <label>:52                                      ; preds = %42
  %53 = load i32, i32* %i, align 4
  %54 = zext i32 %53 to i64
  %55 = load %class.KV.4*, %class.KV.4** %data, align 8
  %56 = getelementptr inbounds %class.KV.4, %class.KV.4* %55, i64 %54
  %57 = getelementptr inbounds %class.KV.4, %class.KV.4* %56, i32 0, i32 1
  %58 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Val"* %57 to %class.scheme_value**
  %59 = load %class.scheme_value*, %class.scheme_value** %58, align 8
  store %class.scheme_value* %59, %class.scheme_value** %1, align 8
  br label %71

; <label>:60                                      ; preds = %42
  store %class.scheme_value* null, %class.scheme_value** %1, align 8
  br label %71

; <label>:61                                      ; preds = %25
  %62 = load i32, i32* %i, align 4
  %63 = zext i32 %62 to i64
  %64 = load %class.KV.4*, %class.KV.4** %data, align 8
  %65 = getelementptr inbounds %class.KV.4, %class.KV.4* %64, i64 %63
  %66 = load i64, i64* %3, align 8
  %67 = lshr i64 %66, 6
  %68 = load %class.scheme_key*, %class.scheme_key** %4, align 8
  %69 = call %class.scheme_value* @_ZN2KVI10scheme_key12scheme_valueLj5EE10inner_findERKS2_mPKS0_(%class.KV.4* dereferenceable(16) %65, i64 %67, %class.scheme_key* %68)
  store %class.scheme_value* %69, %class.scheme_value** %1, align 8
  br label %71

; <label>:70                                      ; preds = %0
  store %class.scheme_value* null, %class.scheme_value** %1, align 8
  br label %71

; <label>:71                                      ; preds = %70, %61, %60, %52
  %72 = load %class.scheme_value*, %class.scheme_value** %1, align 8
  ret %class.scheme_value* %72
}

; Function Attrs: uwtable
define linkonce_odr %class.scheme_value* @_ZN2KVI10scheme_key12scheme_valueLj5EE10inner_findERKS2_mPKS0_(%class.KV.4* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key) #0 comdat align 2 {
  %1 = alloca %class.scheme_value*, align 8
  %2 = alloca %class.KV.4*, align 8
  %3 = alloca i64, align 8
  %4 = alloca %class.scheme_key*, align 8
  %hpiece = alloca i64, align 8
  %data = alloca %class.KV.5*, align 8
  %bm = alloca i64, align 8
  %exists = alloca i8, align 1
  %i = alloca i32, align 4
  store %class.KV.4* %kv, %class.KV.4** %2, align 8
  store i64 %h, i64* %3, align 8
  store %class.scheme_key* %key, %class.scheme_key** %4, align 8
  %5 = load i64, i64* %3, align 8
  %6 = and i64 %5, 63
  %7 = urem i64 %6, 63
  store i64 %7, i64* %hpiece, align 8
  %8 = load %class.KV.4*, %class.KV.4** %2, align 8
  %9 = getelementptr inbounds %class.KV.4, %class.KV.4* %8, i32 0, i32 1
  %10 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Val"* %9 to %class.KV.5**
  %11 = load %class.KV.5*, %class.KV.5** %10, align 8
  store %class.KV.5* %11, %class.KV.5** %data, align 8
  %12 = load %class.KV.4*, %class.KV.4** %2, align 8
  %13 = getelementptr inbounds %class.KV.4, %class.KV.4* %12, i32 0, i32 0
  %14 = bitcast %"union.KV<scheme_key, scheme_value, 5>::Key"* %13 to i64*
  %15 = load i64, i64* %14, align 8
  %16 = lshr i64 %15, 1
  store i64 %16, i64* %bm, align 8
  %17 = load i64, i64* %bm, align 8
  %18 = load i64, i64* %hpiece, align 8
  %19 = shl i64 1, %18
  %20 = and i64 %17, %19
  %21 = icmp ne i64 %20, 0
  %22 = zext i1 %21 to i8
  store i8 %22, i8* %exists, align 1
  %23 = load i8, i8* %exists, align 1
  %24 = trunc i8 %23 to i1
  br i1 %24, label %25, label %70

; <label>:25                                      ; preds = %0
  %26 = load i64, i64* %bm, align 8
  %27 = shl i64 %26, 1
  %28 = load i64, i64* %hpiece, align 8
  %29 = sub i64 63, %28
  %30 = shl i64 %27, %29
  %31 = call i64 @llvm.ctpop.i64(i64 %30)
  %32 = trunc i64 %31 to i32
  store i32 %32, i32* %i, align 4
  %33 = load i32, i32* %i, align 4
  %34 = zext i32 %33 to i64
  %35 = load %class.KV.5*, %class.KV.5** %data, align 8
  %36 = getelementptr inbounds %class.KV.5, %class.KV.5* %35, i64 %34
  %37 = getelementptr inbounds %class.KV.5, %class.KV.5* %36, i32 0, i32 0
  %38 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Key"* %37 to i64*
  %39 = load i64, i64* %38, align 8
  %40 = and i64 %39, 1
  %41 = icmp eq i64 %40, 0
  br i1 %41, label %42, label %61

; <label>:42                                      ; preds = %25
  %43 = load i32, i32* %i, align 4
  %44 = zext i32 %43 to i64
  %45 = load %class.KV.5*, %class.KV.5** %data, align 8
  %46 = getelementptr inbounds %class.KV.5, %class.KV.5* %45, i64 %44
  %47 = getelementptr inbounds %class.KV.5, %class.KV.5* %46, i32 0, i32 0
  %48 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Key"* %47 to %class.scheme_key**
  %49 = load %class.scheme_key*, %class.scheme_key** %48, align 8
  %50 = load %class.scheme_key*, %class.scheme_key** %4, align 8
  %51 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %49, %class.scheme_key* dereferenceable(8) %50)
  br i1 %51, label %52, label %60

; <label>:52                                      ; preds = %42
  %53 = load i32, i32* %i, align 4
  %54 = zext i32 %53 to i64
  %55 = load %class.KV.5*, %class.KV.5** %data, align 8
  %56 = getelementptr inbounds %class.KV.5, %class.KV.5* %55, i64 %54
  %57 = getelementptr inbounds %class.KV.5, %class.KV.5* %56, i32 0, i32 1
  %58 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Val"* %57 to %class.scheme_value**
  %59 = load %class.scheme_value*, %class.scheme_value** %58, align 8
  store %class.scheme_value* %59, %class.scheme_value** %1, align 8
  br label %71

; <label>:60                                      ; preds = %42
  store %class.scheme_value* null, %class.scheme_value** %1, align 8
  br label %71

; <label>:61                                      ; preds = %25
  %62 = load i32, i32* %i, align 4
  %63 = zext i32 %62 to i64
  %64 = load %class.KV.5*, %class.KV.5** %data, align 8
  %65 = getelementptr inbounds %class.KV.5, %class.KV.5* %64, i64 %63
  %66 = load i64, i64* %3, align 8
  %67 = lshr i64 %66, 6
  %68 = load %class.scheme_key*, %class.scheme_key** %4, align 8
  %69 = call %class.scheme_value* @_ZN2KVI10scheme_key12scheme_valueLj6EE10inner_findERKS2_mPKS0_(%class.KV.5* dereferenceable(16) %65, i64 %67, %class.scheme_key* %68)
  store %class.scheme_value* %69, %class.scheme_value** %1, align 8
  br label %71

; <label>:70                                      ; preds = %0
  store %class.scheme_value* null, %class.scheme_value** %1, align 8
  br label %71

; <label>:71                                      ; preds = %70, %61, %60, %52
  %72 = load %class.scheme_value*, %class.scheme_value** %1, align 8
  ret %class.scheme_value* %72
}

; Function Attrs: uwtable
define linkonce_odr %class.scheme_value* @_ZN2KVI10scheme_key12scheme_valueLj6EE10inner_findERKS2_mPKS0_(%class.KV.5* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key) #0 comdat align 2 {
  %1 = alloca %class.scheme_value*, align 8
  %2 = alloca %class.KV.5*, align 8
  %3 = alloca i64, align 8
  %4 = alloca %class.scheme_key*, align 8
  %hpiece = alloca i64, align 8
  %data = alloca %class.KV.6*, align 8
  %bm = alloca i64, align 8
  %exists = alloca i8, align 1
  %i = alloca i32, align 4
  store %class.KV.5* %kv, %class.KV.5** %2, align 8
  store i64 %h, i64* %3, align 8
  store %class.scheme_key* %key, %class.scheme_key** %4, align 8
  %5 = load i64, i64* %3, align 8
  %6 = and i64 %5, 63
  %7 = urem i64 %6, 63
  store i64 %7, i64* %hpiece, align 8
  %8 = load %class.KV.5*, %class.KV.5** %2, align 8
  %9 = getelementptr inbounds %class.KV.5, %class.KV.5* %8, i32 0, i32 1
  %10 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Val"* %9 to %class.KV.6**
  %11 = load %class.KV.6*, %class.KV.6** %10, align 8
  store %class.KV.6* %11, %class.KV.6** %data, align 8
  %12 = load %class.KV.5*, %class.KV.5** %2, align 8
  %13 = getelementptr inbounds %class.KV.5, %class.KV.5* %12, i32 0, i32 0
  %14 = bitcast %"union.KV<scheme_key, scheme_value, 6>::Key"* %13 to i64*
  %15 = load i64, i64* %14, align 8
  %16 = lshr i64 %15, 1
  store i64 %16, i64* %bm, align 8
  %17 = load i64, i64* %bm, align 8
  %18 = load i64, i64* %hpiece, align 8
  %19 = shl i64 1, %18
  %20 = and i64 %17, %19
  %21 = icmp ne i64 %20, 0
  %22 = zext i1 %21 to i8
  store i8 %22, i8* %exists, align 1
  %23 = load i8, i8* %exists, align 1
  %24 = trunc i8 %23 to i1
  br i1 %24, label %25, label %70

; <label>:25                                      ; preds = %0
  %26 = load i64, i64* %bm, align 8
  %27 = shl i64 %26, 1
  %28 = load i64, i64* %hpiece, align 8
  %29 = sub i64 63, %28
  %30 = shl i64 %27, %29
  %31 = call i64 @llvm.ctpop.i64(i64 %30)
  %32 = trunc i64 %31 to i32
  store i32 %32, i32* %i, align 4
  %33 = load i32, i32* %i, align 4
  %34 = zext i32 %33 to i64
  %35 = load %class.KV.6*, %class.KV.6** %data, align 8
  %36 = getelementptr inbounds %class.KV.6, %class.KV.6* %35, i64 %34
  %37 = getelementptr inbounds %class.KV.6, %class.KV.6* %36, i32 0, i32 0
  %38 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Key"* %37 to i64*
  %39 = load i64, i64* %38, align 8
  %40 = and i64 %39, 1
  %41 = icmp eq i64 %40, 0
  br i1 %41, label %42, label %61

; <label>:42                                      ; preds = %25
  %43 = load i32, i32* %i, align 4
  %44 = zext i32 %43 to i64
  %45 = load %class.KV.6*, %class.KV.6** %data, align 8
  %46 = getelementptr inbounds %class.KV.6, %class.KV.6* %45, i64 %44
  %47 = getelementptr inbounds %class.KV.6, %class.KV.6* %46, i32 0, i32 0
  %48 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Key"* %47 to %class.scheme_key**
  %49 = load %class.scheme_key*, %class.scheme_key** %48, align 8
  %50 = load %class.scheme_key*, %class.scheme_key** %4, align 8
  %51 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %49, %class.scheme_key* dereferenceable(8) %50)
  br i1 %51, label %52, label %60

; <label>:52                                      ; preds = %42
  %53 = load i32, i32* %i, align 4
  %54 = zext i32 %53 to i64
  %55 = load %class.KV.6*, %class.KV.6** %data, align 8
  %56 = getelementptr inbounds %class.KV.6, %class.KV.6* %55, i64 %54
  %57 = getelementptr inbounds %class.KV.6, %class.KV.6* %56, i32 0, i32 1
  %58 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Val"* %57 to %class.scheme_value**
  %59 = load %class.scheme_value*, %class.scheme_value** %58, align 8
  store %class.scheme_value* %59, %class.scheme_value** %1, align 8
  br label %71

; <label>:60                                      ; preds = %42
  store %class.scheme_value* null, %class.scheme_value** %1, align 8
  br label %71

; <label>:61                                      ; preds = %25
  %62 = load i32, i32* %i, align 4
  %63 = zext i32 %62 to i64
  %64 = load %class.KV.6*, %class.KV.6** %data, align 8
  %65 = getelementptr inbounds %class.KV.6, %class.KV.6* %64, i64 %63
  %66 = load i64, i64* %3, align 8
  %67 = lshr i64 %66, 6
  %68 = load %class.scheme_key*, %class.scheme_key** %4, align 8
  %69 = call %class.scheme_value* @_ZN2KVI10scheme_key12scheme_valueLj7EE10inner_findERKS2_mPKS0_(%class.KV.6* dereferenceable(16) %65, i64 %67, %class.scheme_key* %68)
  store %class.scheme_value* %69, %class.scheme_value** %1, align 8
  br label %71

; <label>:70                                      ; preds = %0
  store %class.scheme_value* null, %class.scheme_value** %1, align 8
  br label %71

; <label>:71                                      ; preds = %70, %61, %60, %52
  %72 = load %class.scheme_value*, %class.scheme_value** %1, align 8
  ret %class.scheme_value* %72
}

; Function Attrs: uwtable
define linkonce_odr %class.scheme_value* @_ZN2KVI10scheme_key12scheme_valueLj7EE10inner_findERKS2_mPKS0_(%class.KV.6* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key) #0 comdat align 2 {
  %1 = alloca %class.scheme_value*, align 8
  %2 = alloca %class.KV.6*, align 8
  %3 = alloca i64, align 8
  %4 = alloca %class.scheme_key*, align 8
  %hpiece = alloca i64, align 8
  %data = alloca %class.KV.7*, align 8
  %bm = alloca i64, align 8
  %exists = alloca i8, align 1
  %i = alloca i32, align 4
  store %class.KV.6* %kv, %class.KV.6** %2, align 8
  store i64 %h, i64* %3, align 8
  store %class.scheme_key* %key, %class.scheme_key** %4, align 8
  %5 = load i64, i64* %3, align 8
  %6 = and i64 %5, 63
  %7 = urem i64 %6, 63
  store i64 %7, i64* %hpiece, align 8
  %8 = load %class.KV.6*, %class.KV.6** %2, align 8
  %9 = getelementptr inbounds %class.KV.6, %class.KV.6* %8, i32 0, i32 1
  %10 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Val"* %9 to %class.KV.7**
  %11 = load %class.KV.7*, %class.KV.7** %10, align 8
  store %class.KV.7* %11, %class.KV.7** %data, align 8
  %12 = load %class.KV.6*, %class.KV.6** %2, align 8
  %13 = getelementptr inbounds %class.KV.6, %class.KV.6* %12, i32 0, i32 0
  %14 = bitcast %"union.KV<scheme_key, scheme_value, 7>::Key"* %13 to i64*
  %15 = load i64, i64* %14, align 8
  %16 = lshr i64 %15, 1
  store i64 %16, i64* %bm, align 8
  %17 = load i64, i64* %bm, align 8
  %18 = load i64, i64* %hpiece, align 8
  %19 = shl i64 1, %18
  %20 = and i64 %17, %19
  %21 = icmp ne i64 %20, 0
  %22 = zext i1 %21 to i8
  store i8 %22, i8* %exists, align 1
  %23 = load i8, i8* %exists, align 1
  %24 = trunc i8 %23 to i1
  br i1 %24, label %25, label %70

; <label>:25                                      ; preds = %0
  %26 = load i64, i64* %bm, align 8
  %27 = shl i64 %26, 1
  %28 = load i64, i64* %hpiece, align 8
  %29 = sub i64 63, %28
  %30 = shl i64 %27, %29
  %31 = call i64 @llvm.ctpop.i64(i64 %30)
  %32 = trunc i64 %31 to i32
  store i32 %32, i32* %i, align 4
  %33 = load i32, i32* %i, align 4
  %34 = zext i32 %33 to i64
  %35 = load %class.KV.7*, %class.KV.7** %data, align 8
  %36 = getelementptr inbounds %class.KV.7, %class.KV.7* %35, i64 %34
  %37 = getelementptr inbounds %class.KV.7, %class.KV.7* %36, i32 0, i32 0
  %38 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Key"* %37 to i64*
  %39 = load i64, i64* %38, align 8
  %40 = and i64 %39, 1
  %41 = icmp eq i64 %40, 0
  br i1 %41, label %42, label %61

; <label>:42                                      ; preds = %25
  %43 = load i32, i32* %i, align 4
  %44 = zext i32 %43 to i64
  %45 = load %class.KV.7*, %class.KV.7** %data, align 8
  %46 = getelementptr inbounds %class.KV.7, %class.KV.7* %45, i64 %44
  %47 = getelementptr inbounds %class.KV.7, %class.KV.7* %46, i32 0, i32 0
  %48 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Key"* %47 to %class.scheme_key**
  %49 = load %class.scheme_key*, %class.scheme_key** %48, align 8
  %50 = load %class.scheme_key*, %class.scheme_key** %4, align 8
  %51 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %49, %class.scheme_key* dereferenceable(8) %50)
  br i1 %51, label %52, label %60

; <label>:52                                      ; preds = %42
  %53 = load i32, i32* %i, align 4
  %54 = zext i32 %53 to i64
  %55 = load %class.KV.7*, %class.KV.7** %data, align 8
  %56 = getelementptr inbounds %class.KV.7, %class.KV.7* %55, i64 %54
  %57 = getelementptr inbounds %class.KV.7, %class.KV.7* %56, i32 0, i32 1
  %58 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Val"* %57 to %class.scheme_value**
  %59 = load %class.scheme_value*, %class.scheme_value** %58, align 8
  store %class.scheme_value* %59, %class.scheme_value** %1, align 8
  br label %71

; <label>:60                                      ; preds = %42
  store %class.scheme_value* null, %class.scheme_value** %1, align 8
  br label %71

; <label>:61                                      ; preds = %25
  %62 = load i32, i32* %i, align 4
  %63 = zext i32 %62 to i64
  %64 = load %class.KV.7*, %class.KV.7** %data, align 8
  %65 = getelementptr inbounds %class.KV.7, %class.KV.7* %64, i64 %63
  %66 = load i64, i64* %3, align 8
  %67 = lshr i64 %66, 6
  %68 = load %class.scheme_key*, %class.scheme_key** %4, align 8
  %69 = call %class.scheme_value* @_ZN2KVI10scheme_key12scheme_valueLj8EE10inner_findERKS2_mPKS0_(%class.KV.7* dereferenceable(16) %65, i64 %67, %class.scheme_key* %68)
  store %class.scheme_value* %69, %class.scheme_value** %1, align 8
  br label %71

; <label>:70                                      ; preds = %0
  store %class.scheme_value* null, %class.scheme_value** %1, align 8
  br label %71

; <label>:71                                      ; preds = %70, %61, %60, %52
  %72 = load %class.scheme_value*, %class.scheme_value** %1, align 8
  ret %class.scheme_value* %72
}

; Function Attrs: uwtable
define linkonce_odr %class.scheme_value* @_ZN2KVI10scheme_key12scheme_valueLj8EE10inner_findERKS2_mPKS0_(%class.KV.7* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key) #0 comdat align 2 {
  %1 = alloca %class.scheme_value*, align 8
  %2 = alloca %class.KV.7*, align 8
  %3 = alloca i64, align 8
  %4 = alloca %class.scheme_key*, align 8
  %hpiece = alloca i64, align 8
  %data = alloca %class.KV.8*, align 8
  %bm = alloca i64, align 8
  %exists = alloca i8, align 1
  %i = alloca i32, align 4
  store %class.KV.7* %kv, %class.KV.7** %2, align 8
  store i64 %h, i64* %3, align 8
  store %class.scheme_key* %key, %class.scheme_key** %4, align 8
  %5 = load i64, i64* %3, align 8
  %6 = and i64 %5, 63
  %7 = urem i64 %6, 63
  store i64 %7, i64* %hpiece, align 8
  %8 = load %class.KV.7*, %class.KV.7** %2, align 8
  %9 = getelementptr inbounds %class.KV.7, %class.KV.7* %8, i32 0, i32 1
  %10 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Val"* %9 to %class.KV.8**
  %11 = load %class.KV.8*, %class.KV.8** %10, align 8
  store %class.KV.8* %11, %class.KV.8** %data, align 8
  %12 = load %class.KV.7*, %class.KV.7** %2, align 8
  %13 = getelementptr inbounds %class.KV.7, %class.KV.7* %12, i32 0, i32 0
  %14 = bitcast %"union.KV<scheme_key, scheme_value, 8>::Key"* %13 to i64*
  %15 = load i64, i64* %14, align 8
  %16 = lshr i64 %15, 1
  store i64 %16, i64* %bm, align 8
  %17 = load i64, i64* %bm, align 8
  %18 = load i64, i64* %hpiece, align 8
  %19 = shl i64 1, %18
  %20 = and i64 %17, %19
  %21 = icmp ne i64 %20, 0
  %22 = zext i1 %21 to i8
  store i8 %22, i8* %exists, align 1
  %23 = load i8, i8* %exists, align 1
  %24 = trunc i8 %23 to i1
  br i1 %24, label %25, label %70

; <label>:25                                      ; preds = %0
  %26 = load i64, i64* %bm, align 8
  %27 = shl i64 %26, 1
  %28 = load i64, i64* %hpiece, align 8
  %29 = sub i64 63, %28
  %30 = shl i64 %27, %29
  %31 = call i64 @llvm.ctpop.i64(i64 %30)
  %32 = trunc i64 %31 to i32
  store i32 %32, i32* %i, align 4
  %33 = load i32, i32* %i, align 4
  %34 = zext i32 %33 to i64
  %35 = load %class.KV.8*, %class.KV.8** %data, align 8
  %36 = getelementptr inbounds %class.KV.8, %class.KV.8* %35, i64 %34
  %37 = getelementptr inbounds %class.KV.8, %class.KV.8* %36, i32 0, i32 0
  %38 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Key"* %37 to i64*
  %39 = load i64, i64* %38, align 8
  %40 = and i64 %39, 1
  %41 = icmp eq i64 %40, 0
  br i1 %41, label %42, label %61

; <label>:42                                      ; preds = %25
  %43 = load i32, i32* %i, align 4
  %44 = zext i32 %43 to i64
  %45 = load %class.KV.8*, %class.KV.8** %data, align 8
  %46 = getelementptr inbounds %class.KV.8, %class.KV.8* %45, i64 %44
  %47 = getelementptr inbounds %class.KV.8, %class.KV.8* %46, i32 0, i32 0
  %48 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Key"* %47 to %class.scheme_key**
  %49 = load %class.scheme_key*, %class.scheme_key** %48, align 8
  %50 = load %class.scheme_key*, %class.scheme_key** %4, align 8
  %51 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %49, %class.scheme_key* dereferenceable(8) %50)
  br i1 %51, label %52, label %60

; <label>:52                                      ; preds = %42
  %53 = load i32, i32* %i, align 4
  %54 = zext i32 %53 to i64
  %55 = load %class.KV.8*, %class.KV.8** %data, align 8
  %56 = getelementptr inbounds %class.KV.8, %class.KV.8* %55, i64 %54
  %57 = getelementptr inbounds %class.KV.8, %class.KV.8* %56, i32 0, i32 1
  %58 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Val"* %57 to %class.scheme_value**
  %59 = load %class.scheme_value*, %class.scheme_value** %58, align 8
  store %class.scheme_value* %59, %class.scheme_value** %1, align 8
  br label %71

; <label>:60                                      ; preds = %42
  store %class.scheme_value* null, %class.scheme_value** %1, align 8
  br label %71

; <label>:61                                      ; preds = %25
  %62 = load i32, i32* %i, align 4
  %63 = zext i32 %62 to i64
  %64 = load %class.KV.8*, %class.KV.8** %data, align 8
  %65 = getelementptr inbounds %class.KV.8, %class.KV.8* %64, i64 %63
  %66 = load i64, i64* %3, align 8
  %67 = lshr i64 %66, 6
  %68 = load %class.scheme_key*, %class.scheme_key** %4, align 8
  %69 = call %class.scheme_value* @_ZN2KVI10scheme_key12scheme_valueLj9EE10inner_findERKS2_mPKS0_(%class.KV.8* dereferenceable(16) %65, i64 %67, %class.scheme_key* %68)
  store %class.scheme_value* %69, %class.scheme_value** %1, align 8
  br label %71

; <label>:70                                      ; preds = %0
  store %class.scheme_value* null, %class.scheme_value** %1, align 8
  br label %71

; <label>:71                                      ; preds = %70, %61, %60, %52
  %72 = load %class.scheme_value*, %class.scheme_value** %1, align 8
  ret %class.scheme_value* %72
}

; Function Attrs: uwtable
define linkonce_odr %class.scheme_value* @_ZN2KVI10scheme_key12scheme_valueLj9EE10inner_findERKS2_mPKS0_(%class.KV.8* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key) #0 comdat align 2 {
  %1 = alloca %class.scheme_value*, align 8
  %2 = alloca %class.KV.8*, align 8
  %3 = alloca i64, align 8
  %4 = alloca %class.scheme_key*, align 8
  %hpiece = alloca i64, align 8
  %data = alloca %class.KV.9*, align 8
  %bm = alloca i64, align 8
  %exists = alloca i8, align 1
  %i = alloca i32, align 4
  store %class.KV.8* %kv, %class.KV.8** %2, align 8
  store i64 %h, i64* %3, align 8
  store %class.scheme_key* %key, %class.scheme_key** %4, align 8
  %5 = load i64, i64* %3, align 8
  %6 = and i64 %5, 63
  %7 = urem i64 %6, 63
  store i64 %7, i64* %hpiece, align 8
  %8 = load %class.KV.8*, %class.KV.8** %2, align 8
  %9 = getelementptr inbounds %class.KV.8, %class.KV.8* %8, i32 0, i32 1
  %10 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Val"* %9 to %class.KV.9**
  %11 = load %class.KV.9*, %class.KV.9** %10, align 8
  store %class.KV.9* %11, %class.KV.9** %data, align 8
  %12 = load %class.KV.8*, %class.KV.8** %2, align 8
  %13 = getelementptr inbounds %class.KV.8, %class.KV.8* %12, i32 0, i32 0
  %14 = bitcast %"union.KV<scheme_key, scheme_value, 9>::Key"* %13 to i64*
  %15 = load i64, i64* %14, align 8
  %16 = lshr i64 %15, 1
  store i64 %16, i64* %bm, align 8
  %17 = load i64, i64* %bm, align 8
  %18 = load i64, i64* %hpiece, align 8
  %19 = shl i64 1, %18
  %20 = and i64 %17, %19
  %21 = icmp ne i64 %20, 0
  %22 = zext i1 %21 to i8
  store i8 %22, i8* %exists, align 1
  %23 = load i8, i8* %exists, align 1
  %24 = trunc i8 %23 to i1
  br i1 %24, label %25, label %70

; <label>:25                                      ; preds = %0
  %26 = load i64, i64* %bm, align 8
  %27 = shl i64 %26, 1
  %28 = load i64, i64* %hpiece, align 8
  %29 = sub i64 63, %28
  %30 = shl i64 %27, %29
  %31 = call i64 @llvm.ctpop.i64(i64 %30)
  %32 = trunc i64 %31 to i32
  store i32 %32, i32* %i, align 4
  %33 = load i32, i32* %i, align 4
  %34 = zext i32 %33 to i64
  %35 = load %class.KV.9*, %class.KV.9** %data, align 8
  %36 = getelementptr inbounds %class.KV.9, %class.KV.9* %35, i64 %34
  %37 = getelementptr inbounds %class.KV.9, %class.KV.9* %36, i32 0, i32 0
  %38 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Key"* %37 to i64*
  %39 = load i64, i64* %38, align 8
  %40 = and i64 %39, 1
  %41 = icmp eq i64 %40, 0
  br i1 %41, label %42, label %61

; <label>:42                                      ; preds = %25
  %43 = load i32, i32* %i, align 4
  %44 = zext i32 %43 to i64
  %45 = load %class.KV.9*, %class.KV.9** %data, align 8
  %46 = getelementptr inbounds %class.KV.9, %class.KV.9* %45, i64 %44
  %47 = getelementptr inbounds %class.KV.9, %class.KV.9* %46, i32 0, i32 0
  %48 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Key"* %47 to %class.scheme_key**
  %49 = load %class.scheme_key*, %class.scheme_key** %48, align 8
  %50 = load %class.scheme_key*, %class.scheme_key** %4, align 8
  %51 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %49, %class.scheme_key* dereferenceable(8) %50)
  br i1 %51, label %52, label %60

; <label>:52                                      ; preds = %42
  %53 = load i32, i32* %i, align 4
  %54 = zext i32 %53 to i64
  %55 = load %class.KV.9*, %class.KV.9** %data, align 8
  %56 = getelementptr inbounds %class.KV.9, %class.KV.9* %55, i64 %54
  %57 = getelementptr inbounds %class.KV.9, %class.KV.9* %56, i32 0, i32 1
  %58 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Val"* %57 to %class.scheme_value**
  %59 = load %class.scheme_value*, %class.scheme_value** %58, align 8
  store %class.scheme_value* %59, %class.scheme_value** %1, align 8
  br label %71

; <label>:60                                      ; preds = %42
  store %class.scheme_value* null, %class.scheme_value** %1, align 8
  br label %71

; <label>:61                                      ; preds = %25
  %62 = load i32, i32* %i, align 4
  %63 = zext i32 %62 to i64
  %64 = load %class.KV.9*, %class.KV.9** %data, align 8
  %65 = getelementptr inbounds %class.KV.9, %class.KV.9* %64, i64 %63
  %66 = load i64, i64* %3, align 8
  %67 = lshr i64 %66, 6
  %68 = load %class.scheme_key*, %class.scheme_key** %4, align 8
  %69 = call %class.scheme_value* @_ZN2KVI10scheme_key12scheme_valueLj10EE10inner_findERKS2_mPKS0_(%class.KV.9* dereferenceable(16) %65, i64 %67, %class.scheme_key* %68)
  store %class.scheme_value* %69, %class.scheme_value** %1, align 8
  br label %71

; <label>:70                                      ; preds = %0
  store %class.scheme_value* null, %class.scheme_value** %1, align 8
  br label %71

; <label>:71                                      ; preds = %70, %61, %60, %52
  %72 = load %class.scheme_value*, %class.scheme_value** %1, align 8
  ret %class.scheme_value* %72
}

; Function Attrs: uwtable
define linkonce_odr %class.scheme_value* @_ZN2KVI10scheme_key12scheme_valueLj10EE10inner_findERKS2_mPKS0_(%class.KV.9* dereferenceable(16) %kv, i64 %h, %class.scheme_key* %key) #0 comdat align 2 {
  %1 = alloca %class.scheme_value*, align 8
  %2 = alloca %class.KV.9*, align 8
  %3 = alloca i64, align 8
  %4 = alloca %class.scheme_key*, align 8
  store %class.KV.9* %kv, %class.KV.9** %2, align 8
  store i64 %h, i64* %3, align 8
  store %class.scheme_key* %key, %class.scheme_key** %4, align 8
  %5 = load %class.KV.9*, %class.KV.9** %2, align 8
  %6 = getelementptr inbounds %class.KV.9, %class.KV.9* %5, i32 0, i32 1
  %7 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Val"* %6 to %class.LL**
  %8 = load %class.LL*, %class.LL** %7, align 8
  %9 = icmp ne %class.LL* %8, null
  br i1 %9, label %10, label %17

; <label>:10                                      ; preds = %0
  %11 = load %class.KV.9*, %class.KV.9** %2, align 8
  %12 = getelementptr inbounds %class.KV.9, %class.KV.9* %11, i32 0, i32 1
  %13 = bitcast %"union.KV<scheme_key, scheme_value, 10>::Val"* %12 to %class.LL**
  %14 = load %class.LL*, %class.LL** %13, align 8
  %15 = load %class.scheme_key*, %class.scheme_key** %4, align 8
  %16 = call %class.scheme_value* @_ZNK2LLI10scheme_key12scheme_valueE4findEPKS0_(%class.LL* %14, %class.scheme_key* %15)
  store %class.scheme_value* %16, %class.scheme_value** %1, align 8
  br label %18

; <label>:17                                      ; preds = %0
  store %class.scheme_value* null, %class.scheme_value** %1, align 8
  br label %18

; <label>:18                                      ; preds = %17, %10
  %19 = load %class.scheme_value*, %class.scheme_value** %1, align 8
  ret %class.scheme_value* %19
}

; Function Attrs: uwtable
define linkonce_odr %class.scheme_value* @_ZNK2LLI10scheme_key12scheme_valueE4findEPKS0_(%class.LL* %this, %class.scheme_key* %k) #0 comdat align 2 {
  %1 = alloca %class.scheme_value*, align 8
  %2 = alloca %class.LL*, align 8
  %3 = alloca %class.scheme_key*, align 8
  store %class.LL* %this, %class.LL** %2, align 8
  store %class.scheme_key* %k, %class.scheme_key** %3, align 8
  %4 = load %class.LL*, %class.LL** %2, align 8
  %5 = getelementptr inbounds %class.LL, %class.LL* %4, i32 0, i32 0
  %6 = load %class.scheme_key*, %class.scheme_key** %5, align 8
  %7 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %8 = call zeroext i1 @_ZNK10scheme_keyeqERKS_(%class.scheme_key* %6, %class.scheme_key* dereferenceable(8) %7)
  br i1 %8, label %9, label %12

; <label>:9                                       ; preds = %0
  %10 = getelementptr inbounds %class.LL, %class.LL* %4, i32 0, i32 1
  %11 = load %class.scheme_value*, %class.scheme_value** %10, align 8
  store %class.scheme_value* %11, %class.scheme_value** %1, align 8
  br label %22

; <label>:12                                      ; preds = %0
  %13 = getelementptr inbounds %class.LL, %class.LL* %4, i32 0, i32 2
  %14 = load %class.LL*, %class.LL** %13, align 8
  %15 = icmp ne %class.LL* %14, null
  br i1 %15, label %16, label %21

; <label>:16                                      ; preds = %12
  %17 = getelementptr inbounds %class.LL, %class.LL* %4, i32 0, i32 2
  %18 = load %class.LL*, %class.LL** %17, align 8
  %19 = load %class.scheme_key*, %class.scheme_key** %3, align 8
  %20 = call %class.scheme_value* @_ZNK2LLI10scheme_key12scheme_valueE4findEPKS0_(%class.LL* %18, %class.scheme_key* %19)
  store %class.scheme_value* %20, %class.scheme_value** %1, align 8
  br label %22

; <label>:21                                      ; preds = %12
  store %class.scheme_value* null, %class.scheme_value** %1, align 8
  br label %22

; <label>:22                                      ; preds = %21, %16, %9
  %23 = load %class.scheme_value*, %class.scheme_value** %1, align 8
  ret %class.scheme_value* %23
}

; Function Attrs: uwtable
define internal void @_GLOBAL__sub_I_header.cpp() #0 section ".text.startup" {
  call void @__cxx_global_var_init()
  ret void
}

attributes #0 = { uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind }
attributes #4 = { noreturn nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { nobuiltin nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { argmemonly nounwind }
attributes #8 = { nounwind readnone }
attributes #9 = { noreturn nounwind }
attributes #10 = { builtin nounwind }

!llvm.ident = !{!0}

!0 = !{!"clang version 3.8.0-2ubuntu4 (tags/RELEASE_380/final)"}


;;;;;;

define void @proc_main() {
 %vptr12446 = alloca i64, align 8 
  %emsg08636 = call i64 @const_init_string(i8* getelementptr inbounds ([51 x i8], [51 x i8]* @str12445, i32 0, i32 0)) 
  store volatile i64 %emsg08636, i64* %vptr12446, align 8 ; quoted string
 %vptr12448 = alloca i64, align 8 
  %emsg18637 = call i64 @const_init_string(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @str12447, i32 0, i32 0)) 
  store volatile i64 %emsg18637, i64* %vptr12448, align 8 ; quoted string
  %vptr12454 = alloca i64*, align 8 
  %cloptr12449 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr12449, i64** %vptr12454, align 8 ; malloc
  %vptr12455 = alloca i64*, align 8 
  %eptr12451 = getelementptr inbounds i64, i64* %cloptr12449, i64 2 
  store volatile i64* %eptr12451, i64** %vptr12455, align 8 ; &eptr12451[1]
  %vptr12456 = alloca i64*, align 8 
  %eptr12452 = getelementptr inbounds i64, i64* %cloptr12449, i64 3 
  store volatile i64* %eptr12452, i64** %vptr12456, align 8 ; &eptr12452[2]
  store i64 %emsg18637, i64* %eptr12451                                              ; *eptr12451 = %emsg18637
  store i64 %emsg08636, i64* %eptr12452                                              ; *eptr12452 = %emsg08636
  %vptr12457 = alloca i64*, align 8 
  %eptr12450 = getelementptr inbounds i64, i64* %cloptr12449, i64 1 
  store volatile i64* %eptr12450, i64** %vptr12457, align 8 ; &cloptr12449[1]
 %vptr12458 = alloca i64, align 8 
  %f12453 = ptrtoint void(i64,i64)* @lam12441 to i64 
  store volatile i64 %f12453, i64* %vptr12458, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f12453, i64* %eptr12450                                                 ; store fptr
 %vptr12459 = alloca i64, align 8 
  %arg7369 = ptrtoint i64* %cloptr12449 to i64 
  store volatile i64 %arg7369, i64* %vptr12459, align 8 ; closure cast; i64* -> i64
  %vptr12465 = alloca i64*, align 8 
  %cloptr12460 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr12460, i64** %vptr12465, align 8 ; malloc
  %vptr12466 = alloca i64*, align 8 
  %eptr12462 = getelementptr inbounds i64, i64* %cloptr12460, i64 2 
  store volatile i64* %eptr12462, i64** %vptr12466, align 8 ; &eptr12462[1]
  %vptr12467 = alloca i64*, align 8 
  %eptr12463 = getelementptr inbounds i64, i64* %cloptr12460, i64 3 
  store volatile i64* %eptr12463, i64** %vptr12467, align 8 ; &eptr12463[2]
  store i64 %emsg18637, i64* %eptr12462                                              ; *eptr12462 = %emsg18637
  store i64 %emsg08636, i64* %eptr12463                                              ; *eptr12463 = %emsg08636
  %vptr12468 = alloca i64*, align 8 
  %eptr12461 = getelementptr inbounds i64, i64* %cloptr12460, i64 1 
  store volatile i64* %eptr12461, i64** %vptr12468, align 8 ; &cloptr12460[1]
 %vptr12469 = alloca i64, align 8 
  %f12464 = ptrtoint void(i64,i64)* @lam12438 to i64 
  store volatile i64 %f12464, i64* %vptr12469, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f12464, i64* %eptr12461                                                 ; store fptr
 %vptr12470 = alloca i64, align 8 
  %arg7368 = ptrtoint i64* %cloptr12460 to i64 
  store volatile i64 %arg7368, i64* %vptr12470, align 8 ; closure cast; i64* -> i64
  %vptr12476 = alloca i64*, align 8 
  %cloptr12471 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr12471, i64** %vptr12476, align 8 ; malloc
  %vptr12477 = alloca i64*, align 8 
  %eptr12473 = getelementptr inbounds i64, i64* %cloptr12471, i64 2 
  store volatile i64* %eptr12473, i64** %vptr12477, align 8 ; &eptr12473[1]
  %vptr12478 = alloca i64*, align 8 
  %eptr12474 = getelementptr inbounds i64, i64* %cloptr12471, i64 3 
  store volatile i64* %eptr12474, i64** %vptr12478, align 8 ; &eptr12474[2]
  store i64 %emsg18637, i64* %eptr12473                                              ; *eptr12473 = %emsg18637
  store i64 %emsg08636, i64* %eptr12474                                              ; *eptr12474 = %emsg08636
  %vptr12479 = alloca i64*, align 8 
  %eptr12472 = getelementptr inbounds i64, i64* %cloptr12471, i64 1 
  store volatile i64* %eptr12472, i64** %vptr12479, align 8 ; &cloptr12471[1]
 %vptr12480 = alloca i64, align 8 
  %f12475 = ptrtoint void(i64,i64)* @lam11503 to i64 
  store volatile i64 %f12475, i64* %vptr12480, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f12475, i64* %eptr12472                                                 ; store fptr
 %vptr12481 = alloca i64, align 8 
  %arg7367 = ptrtoint i64* %cloptr12471 to i64 
  store volatile i64 %arg7367, i64* %vptr12481, align 8 ; closure cast; i64* -> i64
 %vptr12482 = alloca i64, align 8 
  %rva11488 = add i64 0, 0 
  store volatile i64 %rva11488, i64* %vptr12482, align 8 ; quoted ()
 %vptr12483 = alloca i64, align 8 
  %rva11487 = call i64 @prim_cons(i64 %arg7367, i64 %rva11488) 
  store volatile i64 %rva11487, i64* %vptr12483, align 8 ; call prim_cons
 %vptr12484 = alloca i64, align 8 
  %rva11486 = call i64 @prim_cons(i64 %arg7368, i64 %rva11487) 
  store volatile i64 %rva11486, i64* %vptr12484, align 8 ; call prim_cons
  %vptr12490 = alloca i64*, align 8 
  %cloptr12485 = inttoptr i64 %arg7369 to i64* 
  store volatile i64* %cloptr12485, i64** %vptr12490, align 8 ; closure/env cast; i64 -> i64*
  %vptr12491 = alloca i64*, align 8 
  %i0ptr12486 = getelementptr inbounds i64, i64* %cloptr12485, i64 1 
  store volatile i64* %i0ptr12486, i64** %vptr12491, align 8 ; &cloptr12485[1]
 %vptr12492 = alloca i64, align 8 
  %f12488 = load i64, i64* %i0ptr12486, align 8 
  store volatile i64 %f12488, i64* %vptr12492, align 8 ; load; *i0ptr12486
  %fptr12487 = inttoptr i64 %f12488 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr12487(i64 %arg7369, i64 %rva11486)                  ; tail call
  ret void
}


define i32 @main() {
  call fastcc void @proc_main()
  ret i32 0
}



define void @lam12441(i64 %env12442, i64 %rvp8647) {
 %vptr12495 = alloca i64, align 8 
  %envptr12493 = inttoptr i64 %env12442 to i64* 
  store volatile i64 %emsg08636, i64* %vptr12495, align 8 ; closure/env cast; i64 -> i64*
  %vptr12496 = alloca i64*, align 8 
  %envptr12494 = getelementptr inbounds i64, i64* %envptr12493, i64 3 
  store volatile i64* %envptr12494, i64** %vptr12496, align 8 ; &envptr12493[2]
 %vptr12497 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr12494, align 8 
  store volatile i64 %emsg08636, i64* %vptr12497, align 8 ; load; *envptr12494
 %vptr12500 = alloca i64, align 8 
  %envptr12498 = inttoptr i64 %env12442 to i64* 
  store volatile i64 %emsg18637, i64* %vptr12500, align 8 ; closure/env cast; i64 -> i64*
  %vptr12501 = alloca i64*, align 8 
  %envptr12499 = getelementptr inbounds i64, i64* %envptr12498, i64 2 
  store volatile i64* %envptr12499, i64** %vptr12501, align 8 ; &envptr12498[1]
 %vptr12502 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr12499, align 8 
  store volatile i64 %emsg18637, i64* %vptr12502, align 8 ; load; *envptr12499
 %vptr12503 = alloca i64, align 8 
  %cont7359 = call i64 @prim_car(i64 %rvp8647) 
  store volatile i64 %cont7359, i64* %vptr12503, align 8 ; call prim_car
 %vptr12504 = alloca i64, align 8 
  %rvp8643 = call i64 @prim_cdr(i64 %rvp8647) 
  store volatile i64 %rvp8643, i64* %vptr12504, align 8 ; call prim_cdr
 %vptr12505 = alloca i64, align 8 
  %n_638648 = call i64 @prim_null_63(i64 %rvp8643) 
  store volatile i64 %n_638648, i64* %vptr12505, align 8 ; call prim_null_63
  %cmpptr12509 = alloca i1, align 8  %cmp12506 = icmp eq i64 %n_638648, 15 store volatile i1 %cmp12506, i1* %cmpptr12509, align 8; false?
  br i1 %cmp12506, label %else12508, label %then12507                                ; if

then12507:
 %vptr12510 = alloca i64, align 8 
  %h8649 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8649, i64* %vptr12510, align 8 ; call prim_halt
  %vptr12516 = alloca i64*, align 8 
  %cloptr12511 = inttoptr i64 %h8649 to i64* 
  store volatile i64* %cloptr12511, i64** %vptr12516, align 8 ; closure/env cast; i64 -> i64*
  %vptr12517 = alloca i64*, align 8 
  %i0ptr12512 = getelementptr inbounds i64, i64* %cloptr12511, i64 1 
  store volatile i64* %i0ptr12512, i64** %vptr12517, align 8 ; &cloptr12511[1]
 %vptr12518 = alloca i64, align 8 
  %f12514 = load i64, i64* %i0ptr12512, align 8 
  store volatile i64 %f12514, i64* %vptr12518, align 8 ; load; *i0ptr12512
  %fptr12513 = inttoptr i64 %f12514 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr12513(i64 %h8649, i64 %h8649)                       ; tail call
  ret void

else12508:
 %vptr12519 = alloca i64, align 8 
  %dG8$yu = call i64 @prim_car(i64 %rvp8643) 
  store volatile i64 %dG8$yu, i64* %vptr12519, align 8 ; call prim_car
 %vptr12520 = alloca i64, align 8 
  %na8639 = call i64 @prim_cdr(i64 %rvp8643) 
  store volatile i64 %na8639, i64* %vptr12520, align 8 ; call prim_cdr
 %vptr12521 = alloca i64, align 8 
  %n_638644 = call i64 @prim_null_63(i64 %na8639) 
  store volatile i64 %n_638644, i64* %vptr12521, align 8 ; call prim_null_63
  %cmpptr12525 = alloca i1, align 8  %cmp12522 = icmp eq i64 %n_638644, 15 store volatile i1 %cmp12522, i1* %cmpptr12525, align 8; false?
  br i1 %cmp12522, label %else12524, label %then12523                                ; if

then12523:
 %vptr12526 = alloca i64, align 8 
  %rva8642 = add i64 0, 0 
  store volatile i64 %rva8642, i64* %vptr12526, align 8 ; quoted ()
 %vptr12527 = alloca i64, align 8 
  %rva8641 = call i64 @prim_cons(i64 %dG8$yu, i64 %rva8642) 
  store volatile i64 %rva8641, i64* %vptr12527, align 8 ; call prim_cons
 %vptr12528 = alloca i64, align 8 
  %rva8640 = call i64 @prim_cons(i64 %cont7359, i64 %rva8641) 
  store volatile i64 %rva8640, i64* %vptr12528, align 8 ; call prim_cons
  %vptr12534 = alloca i64*, align 8 
  %cloptr12529 = inttoptr i64 %dG8$yu to i64* 
  store volatile i64* %cloptr12529, i64** %vptr12534, align 8 ; closure/env cast; i64 -> i64*
  %vptr12535 = alloca i64*, align 8 
  %i0ptr12530 = getelementptr inbounds i64, i64* %cloptr12529, i64 1 
  store volatile i64* %i0ptr12530, i64** %vptr12535, align 8 ; &cloptr12529[1]
 %vptr12536 = alloca i64, align 8 
  %f12532 = load i64, i64* %i0ptr12530, align 8 
  store volatile i64 %f12532, i64* %vptr12536, align 8 ; load; *i0ptr12530
  %fptr12531 = inttoptr i64 %f12532 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr12531(i64 %dG8$yu, i64 %rva8640)                    ; tail call
  ret void

else12524:
 %vptr12537 = alloca i64, align 8 
  %h8645 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h8645, i64* %vptr12537, align 8 ; call prim_halt
  %vptr12543 = alloca i64*, align 8 
  %cloptr12538 = inttoptr i64 %h8645 to i64* 
  store volatile i64* %cloptr12538, i64** %vptr12543, align 8 ; closure/env cast; i64 -> i64*
  %vptr12544 = alloca i64*, align 8 
  %i0ptr12539 = getelementptr inbounds i64, i64* %cloptr12538, i64 1 
  store volatile i64* %i0ptr12539, i64** %vptr12544, align 8 ; &cloptr12538[1]
 %vptr12545 = alloca i64, align 8 
  %f12541 = load i64, i64* %i0ptr12539, align 8 
  store volatile i64 %f12541, i64* %vptr12545, align 8 ; load; *i0ptr12539
  %fptr12540 = inttoptr i64 %f12541 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr12540(i64 %h8645, i64 %h8645)                       ; tail call
  ret void
}


define void @lam12438(i64 %env12439, i64 %rvp11430) {
 %vptr12548 = alloca i64, align 8 
  %envptr12546 = inttoptr i64 %env12439 to i64* 
  store volatile i64 %emsg08636, i64* %vptr12548, align 8 ; closure/env cast; i64 -> i64*
  %vptr12549 = alloca i64*, align 8 
  %envptr12547 = getelementptr inbounds i64, i64* %envptr12546, i64 3 
  store volatile i64* %envptr12547, i64** %vptr12549, align 8 ; &envptr12546[2]
 %vptr12550 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr12547, align 8 
  store volatile i64 %emsg08636, i64* %vptr12550, align 8 ; load; *envptr12547
 %vptr12553 = alloca i64, align 8 
  %envptr12551 = inttoptr i64 %env12439 to i64* 
  store volatile i64 %emsg18637, i64* %vptr12553, align 8 ; closure/env cast; i64 -> i64*
  %vptr12554 = alloca i64*, align 8 
  %envptr12552 = getelementptr inbounds i64, i64* %envptr12551, i64 2 
  store volatile i64* %envptr12552, i64** %vptr12554, align 8 ; &envptr12551[1]
 %vptr12555 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr12552, align 8 
  store volatile i64 %emsg18637, i64* %vptr12555, align 8 ; load; *envptr12552
 %vptr12556 = alloca i64, align 8 
  %_957088 = call i64 @prim_car(i64 %rvp11430) 
  store volatile i64 %_957088, i64* %vptr12556, align 8 ; call prim_car
 %vptr12557 = alloca i64, align 8 
  %rvp11426 = call i64 @prim_cdr(i64 %rvp11430) 
  store volatile i64 %rvp11426, i64* %vptr12557, align 8 ; call prim_cdr
 %vptr12558 = alloca i64, align 8 
  %n_6311431 = call i64 @prim_null_63(i64 %rvp11426) 
  store volatile i64 %n_6311431, i64* %vptr12558, align 8 ; call prim_null_63
  %cmpptr12562 = alloca i1, align 8  %cmp12559 = icmp eq i64 %n_6311431, 15 store volatile i1 %cmp12559, i1* %cmpptr12562, align 8; false?
  br i1 %cmp12559, label %else12561, label %then12560                                ; if

then12560:
 %vptr12563 = alloca i64, align 8 
  %h11432 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11432, i64* %vptr12563, align 8 ; call prim_halt
  %vptr12569 = alloca i64*, align 8 
  %cloptr12564 = inttoptr i64 %h11432 to i64* 
  store volatile i64* %cloptr12564, i64** %vptr12569, align 8 ; closure/env cast; i64 -> i64*
  %vptr12570 = alloca i64*, align 8 
  %i0ptr12565 = getelementptr inbounds i64, i64* %cloptr12564, i64 1 
  store volatile i64* %i0ptr12565, i64** %vptr12570, align 8 ; &cloptr12564[1]
 %vptr12571 = alloca i64, align 8 
  %f12567 = load i64, i64* %i0ptr12565, align 8 
  store volatile i64 %f12567, i64* %vptr12571, align 8 ; load; *i0ptr12565
  %fptr12566 = inttoptr i64 %f12567 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr12566(i64 %h11432, i64 %h11432)                     ; tail call
  ret void

else12561:
 %vptr12572 = alloca i64, align 8 
  %NOz$Ycmb = call i64 @prim_car(i64 %rvp11426) 
  store volatile i64 %NOz$Ycmb, i64* %vptr12572, align 8 ; call prim_car
 %vptr12573 = alloca i64, align 8 
  %na8652 = call i64 @prim_cdr(i64 %rvp11426) 
  store volatile i64 %na8652, i64* %vptr12573, align 8 ; call prim_cdr
 %vptr12574 = alloca i64, align 8 
  %n_6311427 = call i64 @prim_null_63(i64 %na8652) 
  store volatile i64 %n_6311427, i64* %vptr12574, align 8 ; call prim_null_63
  %cmpptr12578 = alloca i1, align 8  %cmp12575 = icmp eq i64 %n_6311427, 15 store volatile i1 %cmp12575, i1* %cmpptr12578, align 8; false?
  br i1 %cmp12575, label %else12577, label %then12576                                ; if

then12576:
  %vptr12585 = alloca i64*, align 8 
  %cloptr12579 = call i64* @make_closure(i64 32) 
  store volatile i64* %cloptr12579, i64** %vptr12585, align 8 ; malloc
  %vptr12586 = alloca i64*, align 8 
  %eptr12581 = getelementptr inbounds i64, i64* %cloptr12579, i64 2 
  store volatile i64* %eptr12581, i64** %vptr12586, align 8 ; &eptr12581[1]
  %vptr12587 = alloca i64*, align 8 
  %eptr12582 = getelementptr inbounds i64, i64* %cloptr12579, i64 3 
  store volatile i64* %eptr12582, i64** %vptr12587, align 8 ; &eptr12582[2]
  %vptr12588 = alloca i64*, align 8 
  %eptr12583 = getelementptr inbounds i64, i64* %cloptr12579, i64 4 
  store volatile i64* %eptr12583, i64** %vptr12588, align 8 ; &eptr12583[3]
  store i64 %emsg18637, i64* %eptr12581                                              ; *eptr12581 = %emsg18637
  store i64 %NOz$Ycmb, i64* %eptr12582                                               ; *eptr12582 = %NOz$Ycmb
  store i64 %emsg08636, i64* %eptr12583                                              ; *eptr12583 = %emsg08636
  %vptr12589 = alloca i64*, align 8 
  %eptr12580 = getelementptr inbounds i64, i64* %cloptr12579, i64 1 
  store volatile i64* %eptr12580, i64** %vptr12589, align 8 ; &cloptr12579[1]
 %vptr12590 = alloca i64, align 8 
  %f12584 = ptrtoint void(i64,i64)* @lam12436 to i64 
  store volatile i64 %f12584, i64* %vptr12590, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f12584, i64* %eptr12580                                                 ; store fptr
 %vptr12591 = alloca i64, align 8 
  %arg7374 = ptrtoint i64* %cloptr12579 to i64 
  store volatile i64 %arg7374, i64* %vptr12591, align 8 ; closure cast; i64* -> i64
  %vptr12597 = alloca i64*, align 8 
  %cloptr12592 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr12592, i64** %vptr12597, align 8 ; malloc
  %vptr12598 = alloca i64*, align 8 
  %eptr12594 = getelementptr inbounds i64, i64* %cloptr12592, i64 2 
  store volatile i64* %eptr12594, i64** %vptr12598, align 8 ; &eptr12594[1]
  %vptr12599 = alloca i64*, align 8 
  %eptr12595 = getelementptr inbounds i64, i64* %cloptr12592, i64 3 
  store volatile i64* %eptr12595, i64** %vptr12599, align 8 ; &eptr12595[2]
  store i64 %emsg18637, i64* %eptr12594                                              ; *eptr12594 = %emsg18637
  store i64 %emsg08636, i64* %eptr12595                                              ; *eptr12595 = %emsg08636
  %vptr12600 = alloca i64*, align 8 
  %eptr12593 = getelementptr inbounds i64, i64* %cloptr12592, i64 1 
  store volatile i64* %eptr12593, i64** %vptr12600, align 8 ; &cloptr12592[1]
 %vptr12601 = alloca i64, align 8 
  %f12596 = ptrtoint void(i64,i64)* @lam11516 to i64 
  store volatile i64 %f12596, i64* %vptr12601, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f12596, i64* %eptr12593                                                 ; store fptr
 %vptr12602 = alloca i64, align 8 
  %arg7373 = ptrtoint i64* %cloptr12592 to i64 
  store volatile i64 %arg7373, i64* %vptr12602, align 8 ; closure cast; i64* -> i64
 %vptr12603 = alloca i64, align 8 
  %rva11425 = add i64 0, 0 
  store volatile i64 %rva11425, i64* %vptr12603, align 8 ; quoted ()
 %vptr12604 = alloca i64, align 8 
  %rva11424 = call i64 @prim_cons(i64 %arg7373, i64 %rva11425) 
  store volatile i64 %rva11424, i64* %vptr12604, align 8 ; call prim_cons
 %vptr12605 = alloca i64, align 8 
  %rva11423 = call i64 @prim_cons(i64 %arg7374, i64 %rva11424) 
  store volatile i64 %rva11423, i64* %vptr12605, align 8 ; call prim_cons
  %vptr12611 = alloca i64*, align 8 
  %cloptr12606 = inttoptr i64 %NOz$Ycmb to i64* 
  store volatile i64* %cloptr12606, i64** %vptr12611, align 8 ; closure/env cast; i64 -> i64*
  %vptr12612 = alloca i64*, align 8 
  %i0ptr12607 = getelementptr inbounds i64, i64* %cloptr12606, i64 1 
  store volatile i64* %i0ptr12607, i64** %vptr12612, align 8 ; &cloptr12606[1]
 %vptr12613 = alloca i64, align 8 
  %f12609 = load i64, i64* %i0ptr12607, align 8 
  store volatile i64 %f12609, i64* %vptr12613, align 8 ; load; *i0ptr12607
  %fptr12608 = inttoptr i64 %f12609 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr12608(i64 %NOz$Ycmb, i64 %rva11423)                 ; tail call
  ret void

else12577:
 %vptr12614 = alloca i64, align 8 
  %h11428 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11428, i64* %vptr12614, align 8 ; call prim_halt
  %vptr12620 = alloca i64*, align 8 
  %cloptr12615 = inttoptr i64 %h11428 to i64* 
  store volatile i64* %cloptr12615, i64** %vptr12620, align 8 ; closure/env cast; i64 -> i64*
  %vptr12621 = alloca i64*, align 8 
  %i0ptr12616 = getelementptr inbounds i64, i64* %cloptr12615, i64 1 
  store volatile i64* %i0ptr12616, i64** %vptr12621, align 8 ; &cloptr12615[1]
 %vptr12622 = alloca i64, align 8 
  %f12618 = load i64, i64* %i0ptr12616, align 8 
  store volatile i64 %f12618, i64* %vptr12622, align 8 ; load; *i0ptr12616
  %fptr12617 = inttoptr i64 %f12618 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr12617(i64 %h11428, i64 %h11428)                     ; tail call
  ret void
}


define void @lam12436(i64 %env12437, i64 %rvp11366) {
 %vptr12625 = alloca i64, align 8 
  %envptr12623 = inttoptr i64 %env12437 to i64* 
  store volatile i64 %emsg08636, i64* %vptr12625, align 8 ; closure/env cast; i64 -> i64*
  %vptr12626 = alloca i64*, align 8 
  %envptr12624 = getelementptr inbounds i64, i64* %envptr12623, i64 4 
  store volatile i64* %envptr12624, i64** %vptr12626, align 8 ; &envptr12623[3]
 %vptr12627 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr12624, align 8 
  store volatile i64 %emsg08636, i64* %vptr12627, align 8 ; load; *envptr12624
 %vptr12630 = alloca i64, align 8 
  %envptr12628 = inttoptr i64 %env12437 to i64* 
  store volatile i64 %NOz$Ycmb, i64* %vptr12630, align 8 ; closure/env cast; i64 -> i64*
  %vptr12631 = alloca i64*, align 8 
  %envptr12629 = getelementptr inbounds i64, i64* %envptr12628, i64 3 
  store volatile i64* %envptr12629, i64** %vptr12631, align 8 ; &envptr12628[2]
 %vptr12632 = alloca i64, align 8 
  %NOz$Ycmb = load i64, i64* %envptr12629, align 8 
  store volatile i64 %NOz$Ycmb, i64* %vptr12632, align 8 ; load; *envptr12629
 %vptr12635 = alloca i64, align 8 
  %envptr12633 = inttoptr i64 %env12437 to i64* 
  store volatile i64 %emsg18637, i64* %vptr12635, align 8 ; closure/env cast; i64 -> i64*
  %vptr12636 = alloca i64*, align 8 
  %envptr12634 = getelementptr inbounds i64, i64* %envptr12633, i64 2 
  store volatile i64* %envptr12634, i64** %vptr12636, align 8 ; &envptr12633[1]
 %vptr12637 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr12634, align 8 
  store volatile i64 %emsg18637, i64* %vptr12637, align 8 ; load; *envptr12634
 %vptr12638 = alloca i64, align 8 
  %_957089 = call i64 @prim_car(i64 %rvp11366) 
  store volatile i64 %_957089, i64* %vptr12638, align 8 ; call prim_car
 %vptr12639 = alloca i64, align 8 
  %rvp11362 = call i64 @prim_cdr(i64 %rvp11366) 
  store volatile i64 %rvp11362, i64* %vptr12639, align 8 ; call prim_cdr
 %vptr12640 = alloca i64, align 8 
  %n_6311367 = call i64 @prim_null_63(i64 %rvp11362) 
  store volatile i64 %n_6311367, i64* %vptr12640, align 8 ; call prim_null_63
  %cmpptr12644 = alloca i1, align 8  %cmp12641 = icmp eq i64 %n_6311367, 15 store volatile i1 %cmp12641, i1* %cmpptr12644, align 8; false?
  br i1 %cmp12641, label %else12643, label %then12642                                ; if

then12642:
 %vptr12645 = alloca i64, align 8 
  %h11368 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11368, i64* %vptr12645, align 8 ; call prim_halt
  %vptr12651 = alloca i64*, align 8 
  %cloptr12646 = inttoptr i64 %h11368 to i64* 
  store volatile i64* %cloptr12646, i64** %vptr12651, align 8 ; closure/env cast; i64 -> i64*
  %vptr12652 = alloca i64*, align 8 
  %i0ptr12647 = getelementptr inbounds i64, i64* %cloptr12646, i64 1 
  store volatile i64* %i0ptr12647, i64** %vptr12652, align 8 ; &cloptr12646[1]
 %vptr12653 = alloca i64, align 8 
  %f12649 = load i64, i64* %i0ptr12647, align 8 
  store volatile i64 %f12649, i64* %vptr12653, align 8 ; load; *i0ptr12647
  %fptr12648 = inttoptr i64 %f12649 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr12648(i64 %h11368, i64 %h11368)                     ; tail call
  ret void

else12643:
 %vptr12654 = alloca i64, align 8 
  %Mcq$_37foldr1 = call i64 @prim_car(i64 %rvp11362) 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr12654, align 8 ; call prim_car
 %vptr12655 = alloca i64, align 8 
  %na8654 = call i64 @prim_cdr(i64 %rvp11362) 
  store volatile i64 %na8654, i64* %vptr12655, align 8 ; call prim_cdr
 %vptr12656 = alloca i64, align 8 
  %n_6311363 = call i64 @prim_null_63(i64 %na8654) 
  store volatile i64 %n_6311363, i64* %vptr12656, align 8 ; call prim_null_63
  %cmpptr12660 = alloca i1, align 8  %cmp12657 = icmp eq i64 %n_6311363, 15 store volatile i1 %cmp12657, i1* %cmpptr12660, align 8; false?
  br i1 %cmp12657, label %else12659, label %then12658                                ; if

then12658:
  %vptr12668 = alloca i64*, align 8 
  %cloptr12661 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr12661, i64** %vptr12668, align 8 ; malloc
  %vptr12669 = alloca i64*, align 8 
  %eptr12663 = getelementptr inbounds i64, i64* %cloptr12661, i64 2 
  store volatile i64* %eptr12663, i64** %vptr12669, align 8 ; &eptr12663[1]
  %vptr12670 = alloca i64*, align 8 
  %eptr12664 = getelementptr inbounds i64, i64* %cloptr12661, i64 3 
  store volatile i64* %eptr12664, i64** %vptr12670, align 8 ; &eptr12664[2]
  %vptr12671 = alloca i64*, align 8 
  %eptr12665 = getelementptr inbounds i64, i64* %cloptr12661, i64 4 
  store volatile i64* %eptr12665, i64** %vptr12671, align 8 ; &eptr12665[3]
  %vptr12672 = alloca i64*, align 8 
  %eptr12666 = getelementptr inbounds i64, i64* %cloptr12661, i64 5 
  store volatile i64* %eptr12666, i64** %vptr12672, align 8 ; &eptr12666[4]
  store i64 %Mcq$_37foldr1, i64* %eptr12663                                          ; *eptr12663 = %Mcq$_37foldr1
  store i64 %emsg18637, i64* %eptr12664                                              ; *eptr12664 = %emsg18637
  store i64 %NOz$Ycmb, i64* %eptr12665                                               ; *eptr12665 = %NOz$Ycmb
  store i64 %emsg08636, i64* %eptr12666                                              ; *eptr12666 = %emsg08636
  %vptr12673 = alloca i64*, align 8 
  %eptr12662 = getelementptr inbounds i64, i64* %cloptr12661, i64 1 
  store volatile i64* %eptr12662, i64** %vptr12673, align 8 ; &cloptr12661[1]
 %vptr12674 = alloca i64, align 8 
  %f12667 = ptrtoint void(i64,i64)* @lam12434 to i64 
  store volatile i64 %f12667, i64* %vptr12674, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f12667, i64* %eptr12662                                                 ; store fptr
 %vptr12675 = alloca i64, align 8 
  %arg7377 = ptrtoint i64* %cloptr12661 to i64 
  store volatile i64 %arg7377, i64* %vptr12675, align 8 ; closure cast; i64* -> i64
  %vptr12681 = alloca i64*, align 8 
  %cloptr12676 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr12676, i64** %vptr12681, align 8 ; malloc
  %vptr12682 = alloca i64*, align 8 
  %eptr12678 = getelementptr inbounds i64, i64* %cloptr12676, i64 2 
  store volatile i64* %eptr12678, i64** %vptr12682, align 8 ; &eptr12678[1]
  %vptr12683 = alloca i64*, align 8 
  %eptr12679 = getelementptr inbounds i64, i64* %cloptr12676, i64 3 
  store volatile i64* %eptr12679, i64** %vptr12683, align 8 ; &eptr12679[2]
  store i64 %emsg18637, i64* %eptr12678                                              ; *eptr12678 = %emsg18637
  store i64 %emsg08636, i64* %eptr12679                                              ; *eptr12679 = %emsg08636
  %vptr12684 = alloca i64*, align 8 
  %eptr12677 = getelementptr inbounds i64, i64* %cloptr12676, i64 1 
  store volatile i64* %eptr12677, i64** %vptr12684, align 8 ; &cloptr12676[1]
 %vptr12685 = alloca i64, align 8 
  %f12680 = ptrtoint void(i64,i64)* @lam11534 to i64 
  store volatile i64 %f12680, i64* %vptr12685, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f12680, i64* %eptr12677                                                 ; store fptr
 %vptr12686 = alloca i64, align 8 
  %arg7376 = ptrtoint i64* %cloptr12676 to i64 
  store volatile i64 %arg7376, i64* %vptr12686, align 8 ; closure cast; i64* -> i64
 %vptr12687 = alloca i64, align 8 
  %rva11361 = add i64 0, 0 
  store volatile i64 %rva11361, i64* %vptr12687, align 8 ; quoted ()
 %vptr12688 = alloca i64, align 8 
  %rva11360 = call i64 @prim_cons(i64 %arg7376, i64 %rva11361) 
  store volatile i64 %rva11360, i64* %vptr12688, align 8 ; call prim_cons
 %vptr12689 = alloca i64, align 8 
  %rva11359 = call i64 @prim_cons(i64 %arg7377, i64 %rva11360) 
  store volatile i64 %rva11359, i64* %vptr12689, align 8 ; call prim_cons
  %vptr12695 = alloca i64*, align 8 
  %cloptr12690 = inttoptr i64 %NOz$Ycmb to i64* 
  store volatile i64* %cloptr12690, i64** %vptr12695, align 8 ; closure/env cast; i64 -> i64*
  %vptr12696 = alloca i64*, align 8 
  %i0ptr12691 = getelementptr inbounds i64, i64* %cloptr12690, i64 1 
  store volatile i64* %i0ptr12691, i64** %vptr12696, align 8 ; &cloptr12690[1]
 %vptr12697 = alloca i64, align 8 
  %f12693 = load i64, i64* %i0ptr12691, align 8 
  store volatile i64 %f12693, i64* %vptr12697, align 8 ; load; *i0ptr12691
  %fptr12692 = inttoptr i64 %f12693 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr12692(i64 %NOz$Ycmb, i64 %rva11359)                 ; tail call
  ret void

else12659:
 %vptr12698 = alloca i64, align 8 
  %h11364 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11364, i64* %vptr12698, align 8 ; call prim_halt
  %vptr12704 = alloca i64*, align 8 
  %cloptr12699 = inttoptr i64 %h11364 to i64* 
  store volatile i64* %cloptr12699, i64** %vptr12704, align 8 ; closure/env cast; i64 -> i64*
  %vptr12705 = alloca i64*, align 8 
  %i0ptr12700 = getelementptr inbounds i64, i64* %cloptr12699, i64 1 
  store volatile i64* %i0ptr12700, i64** %vptr12705, align 8 ; &cloptr12699[1]
 %vptr12706 = alloca i64, align 8 
  %f12702 = load i64, i64* %i0ptr12700, align 8 
  store volatile i64 %f12702, i64* %vptr12706, align 8 ; load; *i0ptr12700
  %fptr12701 = inttoptr i64 %f12702 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr12701(i64 %h11364, i64 %h11364)                     ; tail call
  ret void
}


define void @lam12434(i64 %env12435, i64 %rvp11295) {
 %vptr12709 = alloca i64, align 8 
  %envptr12707 = inttoptr i64 %env12435 to i64* 
  store volatile i64 %emsg08636, i64* %vptr12709, align 8 ; closure/env cast; i64 -> i64*
  %vptr12710 = alloca i64*, align 8 
  %envptr12708 = getelementptr inbounds i64, i64* %envptr12707, i64 5 
  store volatile i64* %envptr12708, i64** %vptr12710, align 8 ; &envptr12707[4]
 %vptr12711 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr12708, align 8 
  store volatile i64 %emsg08636, i64* %vptr12711, align 8 ; load; *envptr12708
 %vptr12714 = alloca i64, align 8 
  %envptr12712 = inttoptr i64 %env12435 to i64* 
  store volatile i64 %NOz$Ycmb, i64* %vptr12714, align 8 ; closure/env cast; i64 -> i64*
  %vptr12715 = alloca i64*, align 8 
  %envptr12713 = getelementptr inbounds i64, i64* %envptr12712, i64 4 
  store volatile i64* %envptr12713, i64** %vptr12715, align 8 ; &envptr12712[3]
 %vptr12716 = alloca i64, align 8 
  %NOz$Ycmb = load i64, i64* %envptr12713, align 8 
  store volatile i64 %NOz$Ycmb, i64* %vptr12716, align 8 ; load; *envptr12713
 %vptr12719 = alloca i64, align 8 
  %envptr12717 = inttoptr i64 %env12435 to i64* 
  store volatile i64 %emsg18637, i64* %vptr12719, align 8 ; closure/env cast; i64 -> i64*
  %vptr12720 = alloca i64*, align 8 
  %envptr12718 = getelementptr inbounds i64, i64* %envptr12717, i64 3 
  store volatile i64* %envptr12718, i64** %vptr12720, align 8 ; &envptr12717[2]
 %vptr12721 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr12718, align 8 
  store volatile i64 %emsg18637, i64* %vptr12721, align 8 ; load; *envptr12718
 %vptr12724 = alloca i64, align 8 
  %envptr12722 = inttoptr i64 %env12435 to i64* 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr12724, align 8 ; closure/env cast; i64 -> i64*
  %vptr12725 = alloca i64*, align 8 
  %envptr12723 = getelementptr inbounds i64, i64* %envptr12722, i64 2 
  store volatile i64* %envptr12723, i64** %vptr12725, align 8 ; &envptr12722[1]
 %vptr12726 = alloca i64, align 8 
  %Mcq$_37foldr1 = load i64, i64* %envptr12723, align 8 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr12726, align 8 ; load; *envptr12723
 %vptr12727 = alloca i64, align 8 
  %_957090 = call i64 @prim_car(i64 %rvp11295) 
  store volatile i64 %_957090, i64* %vptr12727, align 8 ; call prim_car
 %vptr12728 = alloca i64, align 8 
  %rvp11291 = call i64 @prim_cdr(i64 %rvp11295) 
  store volatile i64 %rvp11291, i64* %vptr12728, align 8 ; call prim_cdr
 %vptr12729 = alloca i64, align 8 
  %n_6311296 = call i64 @prim_null_63(i64 %rvp11291) 
  store volatile i64 %n_6311296, i64* %vptr12729, align 8 ; call prim_null_63
  %cmpptr12733 = alloca i1, align 8  %cmp12730 = icmp eq i64 %n_6311296, 15 store volatile i1 %cmp12730, i1* %cmpptr12733, align 8; false?
  br i1 %cmp12730, label %else12732, label %then12731                                ; if

then12731:
 %vptr12734 = alloca i64, align 8 
  %h11297 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11297, i64* %vptr12734, align 8 ; call prim_halt
  %vptr12740 = alloca i64*, align 8 
  %cloptr12735 = inttoptr i64 %h11297 to i64* 
  store volatile i64* %cloptr12735, i64** %vptr12740, align 8 ; closure/env cast; i64 -> i64*
  %vptr12741 = alloca i64*, align 8 
  %i0ptr12736 = getelementptr inbounds i64, i64* %cloptr12735, i64 1 
  store volatile i64* %i0ptr12736, i64** %vptr12741, align 8 ; &cloptr12735[1]
 %vptr12742 = alloca i64, align 8 
  %f12738 = load i64, i64* %i0ptr12736, align 8 
  store volatile i64 %f12738, i64* %vptr12742, align 8 ; load; *i0ptr12736
  %fptr12737 = inttoptr i64 %f12738 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr12737(i64 %h11297, i64 %h11297)                     ; tail call
  ret void

else12732:
 %vptr12743 = alloca i64, align 8 
  %Gcn$_37map1 = call i64 @prim_car(i64 %rvp11291) 
  store volatile i64 %Gcn$_37map1, i64* %vptr12743, align 8 ; call prim_car
 %vptr12744 = alloca i64, align 8 
  %na8656 = call i64 @prim_cdr(i64 %rvp11291) 
  store volatile i64 %na8656, i64* %vptr12744, align 8 ; call prim_cdr
 %vptr12745 = alloca i64, align 8 
  %n_6311292 = call i64 @prim_null_63(i64 %na8656) 
  store volatile i64 %n_6311292, i64* %vptr12745, align 8 ; call prim_null_63
  %cmpptr12749 = alloca i1, align 8  %cmp12746 = icmp eq i64 %n_6311292, 15 store volatile i1 %cmp12746, i1* %cmpptr12749, align 8; false?
  br i1 %cmp12746, label %else12748, label %then12747                                ; if

then12747:
  %vptr12758 = alloca i64*, align 8 
  %cloptr12750 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr12750, i64** %vptr12758, align 8 ; malloc
  %vptr12759 = alloca i64*, align 8 
  %eptr12752 = getelementptr inbounds i64, i64* %cloptr12750, i64 2 
  store volatile i64* %eptr12752, i64** %vptr12759, align 8 ; &eptr12752[1]
  %vptr12760 = alloca i64*, align 8 
  %eptr12753 = getelementptr inbounds i64, i64* %cloptr12750, i64 3 
  store volatile i64* %eptr12753, i64** %vptr12760, align 8 ; &eptr12753[2]
  %vptr12761 = alloca i64*, align 8 
  %eptr12754 = getelementptr inbounds i64, i64* %cloptr12750, i64 4 
  store volatile i64* %eptr12754, i64** %vptr12761, align 8 ; &eptr12754[3]
  %vptr12762 = alloca i64*, align 8 
  %eptr12755 = getelementptr inbounds i64, i64* %cloptr12750, i64 5 
  store volatile i64* %eptr12755, i64** %vptr12762, align 8 ; &eptr12755[4]
  %vptr12763 = alloca i64*, align 8 
  %eptr12756 = getelementptr inbounds i64, i64* %cloptr12750, i64 6 
  store volatile i64* %eptr12756, i64** %vptr12763, align 8 ; &eptr12756[5]
  store i64 %Mcq$_37foldr1, i64* %eptr12752                                          ; *eptr12752 = %Mcq$_37foldr1
  store i64 %emsg18637, i64* %eptr12753                                              ; *eptr12753 = %emsg18637
  store i64 %NOz$Ycmb, i64* %eptr12754                                               ; *eptr12754 = %NOz$Ycmb
  store i64 %emsg08636, i64* %eptr12755                                              ; *eptr12755 = %emsg08636
  store i64 %Gcn$_37map1, i64* %eptr12756                                            ; *eptr12756 = %Gcn$_37map1
  %vptr12764 = alloca i64*, align 8 
  %eptr12751 = getelementptr inbounds i64, i64* %cloptr12750, i64 1 
  store volatile i64* %eptr12751, i64** %vptr12764, align 8 ; &cloptr12750[1]
 %vptr12765 = alloca i64, align 8 
  %f12757 = ptrtoint void(i64,i64)* @lam12432 to i64 
  store volatile i64 %f12757, i64* %vptr12765, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f12757, i64* %eptr12751                                                 ; store fptr
 %vptr12766 = alloca i64, align 8 
  %arg7380 = ptrtoint i64* %cloptr12750 to i64 
  store volatile i64 %arg7380, i64* %vptr12766, align 8 ; closure cast; i64* -> i64
  %vptr12772 = alloca i64*, align 8 
  %cloptr12767 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr12767, i64** %vptr12772, align 8 ; malloc
  %vptr12773 = alloca i64*, align 8 
  %eptr12769 = getelementptr inbounds i64, i64* %cloptr12767, i64 2 
  store volatile i64* %eptr12769, i64** %vptr12773, align 8 ; &eptr12769[1]
  %vptr12774 = alloca i64*, align 8 
  %eptr12770 = getelementptr inbounds i64, i64* %cloptr12767, i64 3 
  store volatile i64* %eptr12770, i64** %vptr12774, align 8 ; &eptr12770[2]
  store i64 %emsg18637, i64* %eptr12769                                              ; *eptr12769 = %emsg18637
  store i64 %emsg08636, i64* %eptr12770                                              ; *eptr12770 = %emsg08636
  %vptr12775 = alloca i64*, align 8 
  %eptr12768 = getelementptr inbounds i64, i64* %cloptr12767, i64 1 
  store volatile i64* %eptr12768, i64** %vptr12775, align 8 ; &cloptr12767[1]
 %vptr12776 = alloca i64, align 8 
  %f12771 = ptrtoint void(i64,i64)* @lam11554 to i64 
  store volatile i64 %f12771, i64* %vptr12776, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f12771, i64* %eptr12768                                                 ; store fptr
 %vptr12777 = alloca i64, align 8 
  %arg7379 = ptrtoint i64* %cloptr12767 to i64 
  store volatile i64 %arg7379, i64* %vptr12777, align 8 ; closure cast; i64* -> i64
 %vptr12778 = alloca i64, align 8 
  %rva11290 = add i64 0, 0 
  store volatile i64 %rva11290, i64* %vptr12778, align 8 ; quoted ()
 %vptr12779 = alloca i64, align 8 
  %rva11289 = call i64 @prim_cons(i64 %arg7379, i64 %rva11290) 
  store volatile i64 %rva11289, i64* %vptr12779, align 8 ; call prim_cons
 %vptr12780 = alloca i64, align 8 
  %rva11288 = call i64 @prim_cons(i64 %arg7380, i64 %rva11289) 
  store volatile i64 %rva11288, i64* %vptr12780, align 8 ; call prim_cons
  %vptr12786 = alloca i64*, align 8 
  %cloptr12781 = inttoptr i64 %NOz$Ycmb to i64* 
  store volatile i64* %cloptr12781, i64** %vptr12786, align 8 ; closure/env cast; i64 -> i64*
  %vptr12787 = alloca i64*, align 8 
  %i0ptr12782 = getelementptr inbounds i64, i64* %cloptr12781, i64 1 
  store volatile i64* %i0ptr12782, i64** %vptr12787, align 8 ; &cloptr12781[1]
 %vptr12788 = alloca i64, align 8 
  %f12784 = load i64, i64* %i0ptr12782, align 8 
  store volatile i64 %f12784, i64* %vptr12788, align 8 ; load; *i0ptr12782
  %fptr12783 = inttoptr i64 %f12784 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr12783(i64 %NOz$Ycmb, i64 %rva11288)                 ; tail call
  ret void

else12748:
 %vptr12789 = alloca i64, align 8 
  %h11293 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11293, i64* %vptr12789, align 8 ; call prim_halt
  %vptr12795 = alloca i64*, align 8 
  %cloptr12790 = inttoptr i64 %h11293 to i64* 
  store volatile i64* %cloptr12790, i64** %vptr12795, align 8 ; closure/env cast; i64 -> i64*
  %vptr12796 = alloca i64*, align 8 
  %i0ptr12791 = getelementptr inbounds i64, i64* %cloptr12790, i64 1 
  store volatile i64* %i0ptr12791, i64** %vptr12796, align 8 ; &cloptr12790[1]
 %vptr12797 = alloca i64, align 8 
  %f12793 = load i64, i64* %i0ptr12791, align 8 
  store volatile i64 %f12793, i64* %vptr12797, align 8 ; load; *i0ptr12791
  %fptr12792 = inttoptr i64 %f12793 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr12792(i64 %h11293, i64 %h11293)                     ; tail call
  ret void
}


define void @lam12432(i64 %env12433, i64 %rvp11234) {
 %vptr12800 = alloca i64, align 8 
  %envptr12798 = inttoptr i64 %env12433 to i64* 
  store volatile i64 %Gcn$_37map1, i64* %vptr12800, align 8 ; closure/env cast; i64 -> i64*
  %vptr12801 = alloca i64*, align 8 
  %envptr12799 = getelementptr inbounds i64, i64* %envptr12798, i64 6 
  store volatile i64* %envptr12799, i64** %vptr12801, align 8 ; &envptr12798[5]
 %vptr12802 = alloca i64, align 8 
  %Gcn$_37map1 = load i64, i64* %envptr12799, align 8 
  store volatile i64 %Gcn$_37map1, i64* %vptr12802, align 8 ; load; *envptr12799
 %vptr12805 = alloca i64, align 8 
  %envptr12803 = inttoptr i64 %env12433 to i64* 
  store volatile i64 %emsg08636, i64* %vptr12805, align 8 ; closure/env cast; i64 -> i64*
  %vptr12806 = alloca i64*, align 8 
  %envptr12804 = getelementptr inbounds i64, i64* %envptr12803, i64 5 
  store volatile i64* %envptr12804, i64** %vptr12806, align 8 ; &envptr12803[4]
 %vptr12807 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr12804, align 8 
  store volatile i64 %emsg08636, i64* %vptr12807, align 8 ; load; *envptr12804
 %vptr12810 = alloca i64, align 8 
  %envptr12808 = inttoptr i64 %env12433 to i64* 
  store volatile i64 %NOz$Ycmb, i64* %vptr12810, align 8 ; closure/env cast; i64 -> i64*
  %vptr12811 = alloca i64*, align 8 
  %envptr12809 = getelementptr inbounds i64, i64* %envptr12808, i64 4 
  store volatile i64* %envptr12809, i64** %vptr12811, align 8 ; &envptr12808[3]
 %vptr12812 = alloca i64, align 8 
  %NOz$Ycmb = load i64, i64* %envptr12809, align 8 
  store volatile i64 %NOz$Ycmb, i64* %vptr12812, align 8 ; load; *envptr12809
 %vptr12815 = alloca i64, align 8 
  %envptr12813 = inttoptr i64 %env12433 to i64* 
  store volatile i64 %emsg18637, i64* %vptr12815, align 8 ; closure/env cast; i64 -> i64*
  %vptr12816 = alloca i64*, align 8 
  %envptr12814 = getelementptr inbounds i64, i64* %envptr12813, i64 3 
  store volatile i64* %envptr12814, i64** %vptr12816, align 8 ; &envptr12813[2]
 %vptr12817 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr12814, align 8 
  store volatile i64 %emsg18637, i64* %vptr12817, align 8 ; load; *envptr12814
 %vptr12820 = alloca i64, align 8 
  %envptr12818 = inttoptr i64 %env12433 to i64* 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr12820, align 8 ; closure/env cast; i64 -> i64*
  %vptr12821 = alloca i64*, align 8 
  %envptr12819 = getelementptr inbounds i64, i64* %envptr12818, i64 2 
  store volatile i64* %envptr12819, i64** %vptr12821, align 8 ; &envptr12818[1]
 %vptr12822 = alloca i64, align 8 
  %Mcq$_37foldr1 = load i64, i64* %envptr12819, align 8 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr12822, align 8 ; load; *envptr12819
 %vptr12823 = alloca i64, align 8 
  %_957091 = call i64 @prim_car(i64 %rvp11234) 
  store volatile i64 %_957091, i64* %vptr12823, align 8 ; call prim_car
 %vptr12824 = alloca i64, align 8 
  %rvp11230 = call i64 @prim_cdr(i64 %rvp11234) 
  store volatile i64 %rvp11230, i64* %vptr12824, align 8 ; call prim_cdr
 %vptr12825 = alloca i64, align 8 
  %n_6311235 = call i64 @prim_null_63(i64 %rvp11230) 
  store volatile i64 %n_6311235, i64* %vptr12825, align 8 ; call prim_null_63
  %cmpptr12829 = alloca i1, align 8  %cmp12826 = icmp eq i64 %n_6311235, 15 store volatile i1 %cmp12826, i1* %cmpptr12829, align 8; false?
  br i1 %cmp12826, label %else12828, label %then12827                                ; if

then12827:
 %vptr12830 = alloca i64, align 8 
  %h11236 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11236, i64* %vptr12830, align 8 ; call prim_halt
  %vptr12836 = alloca i64*, align 8 
  %cloptr12831 = inttoptr i64 %h11236 to i64* 
  store volatile i64* %cloptr12831, i64** %vptr12836, align 8 ; closure/env cast; i64 -> i64*
  %vptr12837 = alloca i64*, align 8 
  %i0ptr12832 = getelementptr inbounds i64, i64* %cloptr12831, i64 1 
  store volatile i64* %i0ptr12832, i64** %vptr12837, align 8 ; &cloptr12831[1]
 %vptr12838 = alloca i64, align 8 
  %f12834 = load i64, i64* %i0ptr12832, align 8 
  store volatile i64 %f12834, i64* %vptr12838, align 8 ; load; *i0ptr12832
  %fptr12833 = inttoptr i64 %f12834 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr12833(i64 %h11236, i64 %h11236)                     ; tail call
  ret void

else12828:
 %vptr12839 = alloca i64, align 8 
  %LF0$_37take = call i64 @prim_car(i64 %rvp11230) 
  store volatile i64 %LF0$_37take, i64* %vptr12839, align 8 ; call prim_car
 %vptr12840 = alloca i64, align 8 
  %na8658 = call i64 @prim_cdr(i64 %rvp11230) 
  store volatile i64 %na8658, i64* %vptr12840, align 8 ; call prim_cdr
 %vptr12841 = alloca i64, align 8 
  %n_6311231 = call i64 @prim_null_63(i64 %na8658) 
  store volatile i64 %n_6311231, i64* %vptr12841, align 8 ; call prim_null_63
  %cmpptr12845 = alloca i1, align 8  %cmp12842 = icmp eq i64 %n_6311231, 15 store volatile i1 %cmp12842, i1* %cmpptr12845, align 8; false?
  br i1 %cmp12842, label %else12844, label %then12843                                ; if

then12843:
  %vptr12855 = alloca i64*, align 8 
  %cloptr12846 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr12846, i64** %vptr12855, align 8 ; malloc
  %vptr12856 = alloca i64*, align 8 
  %eptr12848 = getelementptr inbounds i64, i64* %cloptr12846, i64 2 
  store volatile i64* %eptr12848, i64** %vptr12856, align 8 ; &eptr12848[1]
  %vptr12857 = alloca i64*, align 8 
  %eptr12849 = getelementptr inbounds i64, i64* %cloptr12846, i64 3 
  store volatile i64* %eptr12849, i64** %vptr12857, align 8 ; &eptr12849[2]
  %vptr12858 = alloca i64*, align 8 
  %eptr12850 = getelementptr inbounds i64, i64* %cloptr12846, i64 4 
  store volatile i64* %eptr12850, i64** %vptr12858, align 8 ; &eptr12850[3]
  %vptr12859 = alloca i64*, align 8 
  %eptr12851 = getelementptr inbounds i64, i64* %cloptr12846, i64 5 
  store volatile i64* %eptr12851, i64** %vptr12859, align 8 ; &eptr12851[4]
  %vptr12860 = alloca i64*, align 8 
  %eptr12852 = getelementptr inbounds i64, i64* %cloptr12846, i64 6 
  store volatile i64* %eptr12852, i64** %vptr12860, align 8 ; &eptr12852[5]
  %vptr12861 = alloca i64*, align 8 
  %eptr12853 = getelementptr inbounds i64, i64* %cloptr12846, i64 7 
  store volatile i64* %eptr12853, i64** %vptr12861, align 8 ; &eptr12853[6]
  store i64 %Mcq$_37foldr1, i64* %eptr12848                                          ; *eptr12848 = %Mcq$_37foldr1
  store i64 %emsg18637, i64* %eptr12849                                              ; *eptr12849 = %emsg18637
  store i64 %NOz$Ycmb, i64* %eptr12850                                               ; *eptr12850 = %NOz$Ycmb
  store i64 %emsg08636, i64* %eptr12851                                              ; *eptr12851 = %emsg08636
  store i64 %Gcn$_37map1, i64* %eptr12852                                            ; *eptr12852 = %Gcn$_37map1
  store i64 %LF0$_37take, i64* %eptr12853                                            ; *eptr12853 = %LF0$_37take
  %vptr12862 = alloca i64*, align 8 
  %eptr12847 = getelementptr inbounds i64, i64* %cloptr12846, i64 1 
  store volatile i64* %eptr12847, i64** %vptr12862, align 8 ; &cloptr12846[1]
 %vptr12863 = alloca i64, align 8 
  %f12854 = ptrtoint void(i64,i64)* @lam12430 to i64 
  store volatile i64 %f12854, i64* %vptr12863, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f12854, i64* %eptr12847                                                 ; store fptr
 %vptr12864 = alloca i64, align 8 
  %arg7383 = ptrtoint i64* %cloptr12846 to i64 
  store volatile i64 %arg7383, i64* %vptr12864, align 8 ; closure cast; i64* -> i64
  %vptr12870 = alloca i64*, align 8 
  %cloptr12865 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr12865, i64** %vptr12870, align 8 ; malloc
  %vptr12871 = alloca i64*, align 8 
  %eptr12867 = getelementptr inbounds i64, i64* %cloptr12865, i64 2 
  store volatile i64* %eptr12867, i64** %vptr12871, align 8 ; &eptr12867[1]
  %vptr12872 = alloca i64*, align 8 
  %eptr12868 = getelementptr inbounds i64, i64* %cloptr12865, i64 3 
  store volatile i64* %eptr12868, i64** %vptr12872, align 8 ; &eptr12868[2]
  store i64 %emsg18637, i64* %eptr12867                                              ; *eptr12867 = %emsg18637
  store i64 %emsg08636, i64* %eptr12868                                              ; *eptr12868 = %emsg08636
  %vptr12873 = alloca i64*, align 8 
  %eptr12866 = getelementptr inbounds i64, i64* %cloptr12865, i64 1 
  store volatile i64* %eptr12866, i64** %vptr12873, align 8 ; &cloptr12865[1]
 %vptr12874 = alloca i64, align 8 
  %f12869 = ptrtoint void(i64,i64)* @lam11570 to i64 
  store volatile i64 %f12869, i64* %vptr12874, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f12869, i64* %eptr12866                                                 ; store fptr
 %vptr12875 = alloca i64, align 8 
  %arg7382 = ptrtoint i64* %cloptr12865 to i64 
  store volatile i64 %arg7382, i64* %vptr12875, align 8 ; closure cast; i64* -> i64
 %vptr12876 = alloca i64, align 8 
  %rva11229 = add i64 0, 0 
  store volatile i64 %rva11229, i64* %vptr12876, align 8 ; quoted ()
 %vptr12877 = alloca i64, align 8 
  %rva11228 = call i64 @prim_cons(i64 %arg7382, i64 %rva11229) 
  store volatile i64 %rva11228, i64* %vptr12877, align 8 ; call prim_cons
 %vptr12878 = alloca i64, align 8 
  %rva11227 = call i64 @prim_cons(i64 %arg7383, i64 %rva11228) 
  store volatile i64 %rva11227, i64* %vptr12878, align 8 ; call prim_cons
  %vptr12884 = alloca i64*, align 8 
  %cloptr12879 = inttoptr i64 %NOz$Ycmb to i64* 
  store volatile i64* %cloptr12879, i64** %vptr12884, align 8 ; closure/env cast; i64 -> i64*
  %vptr12885 = alloca i64*, align 8 
  %i0ptr12880 = getelementptr inbounds i64, i64* %cloptr12879, i64 1 
  store volatile i64* %i0ptr12880, i64** %vptr12885, align 8 ; &cloptr12879[1]
 %vptr12886 = alloca i64, align 8 
  %f12882 = load i64, i64* %i0ptr12880, align 8 
  store volatile i64 %f12882, i64* %vptr12886, align 8 ; load; *i0ptr12880
  %fptr12881 = inttoptr i64 %f12882 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr12881(i64 %NOz$Ycmb, i64 %rva11227)                 ; tail call
  ret void

else12844:
 %vptr12887 = alloca i64, align 8 
  %h11232 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11232, i64* %vptr12887, align 8 ; call prim_halt
  %vptr12893 = alloca i64*, align 8 
  %cloptr12888 = inttoptr i64 %h11232 to i64* 
  store volatile i64* %cloptr12888, i64** %vptr12893, align 8 ; closure/env cast; i64 -> i64*
  %vptr12894 = alloca i64*, align 8 
  %i0ptr12889 = getelementptr inbounds i64, i64* %cloptr12888, i64 1 
  store volatile i64* %i0ptr12889, i64** %vptr12894, align 8 ; &cloptr12888[1]
 %vptr12895 = alloca i64, align 8 
  %f12891 = load i64, i64* %i0ptr12889, align 8 
  store volatile i64 %f12891, i64* %vptr12895, align 8 ; load; *i0ptr12889
  %fptr12890 = inttoptr i64 %f12891 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr12890(i64 %h11232, i64 %h11232)                     ; tail call
  ret void
}


define void @lam12430(i64 %env12431, i64 %rvp11181) {
 %vptr12898 = alloca i64, align 8 
  %envptr12896 = inttoptr i64 %env12431 to i64* 
  store volatile i64 %LF0$_37take, i64* %vptr12898, align 8 ; closure/env cast; i64 -> i64*
  %vptr12899 = alloca i64*, align 8 
  %envptr12897 = getelementptr inbounds i64, i64* %envptr12896, i64 7 
  store volatile i64* %envptr12897, i64** %vptr12899, align 8 ; &envptr12896[6]
 %vptr12900 = alloca i64, align 8 
  %LF0$_37take = load i64, i64* %envptr12897, align 8 
  store volatile i64 %LF0$_37take, i64* %vptr12900, align 8 ; load; *envptr12897
 %vptr12903 = alloca i64, align 8 
  %envptr12901 = inttoptr i64 %env12431 to i64* 
  store volatile i64 %Gcn$_37map1, i64* %vptr12903, align 8 ; closure/env cast; i64 -> i64*
  %vptr12904 = alloca i64*, align 8 
  %envptr12902 = getelementptr inbounds i64, i64* %envptr12901, i64 6 
  store volatile i64* %envptr12902, i64** %vptr12904, align 8 ; &envptr12901[5]
 %vptr12905 = alloca i64, align 8 
  %Gcn$_37map1 = load i64, i64* %envptr12902, align 8 
  store volatile i64 %Gcn$_37map1, i64* %vptr12905, align 8 ; load; *envptr12902
 %vptr12908 = alloca i64, align 8 
  %envptr12906 = inttoptr i64 %env12431 to i64* 
  store volatile i64 %emsg08636, i64* %vptr12908, align 8 ; closure/env cast; i64 -> i64*
  %vptr12909 = alloca i64*, align 8 
  %envptr12907 = getelementptr inbounds i64, i64* %envptr12906, i64 5 
  store volatile i64* %envptr12907, i64** %vptr12909, align 8 ; &envptr12906[4]
 %vptr12910 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr12907, align 8 
  store volatile i64 %emsg08636, i64* %vptr12910, align 8 ; load; *envptr12907
 %vptr12913 = alloca i64, align 8 
  %envptr12911 = inttoptr i64 %env12431 to i64* 
  store volatile i64 %NOz$Ycmb, i64* %vptr12913, align 8 ; closure/env cast; i64 -> i64*
  %vptr12914 = alloca i64*, align 8 
  %envptr12912 = getelementptr inbounds i64, i64* %envptr12911, i64 4 
  store volatile i64* %envptr12912, i64** %vptr12914, align 8 ; &envptr12911[3]
 %vptr12915 = alloca i64, align 8 
  %NOz$Ycmb = load i64, i64* %envptr12912, align 8 
  store volatile i64 %NOz$Ycmb, i64* %vptr12915, align 8 ; load; *envptr12912
 %vptr12918 = alloca i64, align 8 
  %envptr12916 = inttoptr i64 %env12431 to i64* 
  store volatile i64 %emsg18637, i64* %vptr12918, align 8 ; closure/env cast; i64 -> i64*
  %vptr12919 = alloca i64*, align 8 
  %envptr12917 = getelementptr inbounds i64, i64* %envptr12916, i64 3 
  store volatile i64* %envptr12917, i64** %vptr12919, align 8 ; &envptr12916[2]
 %vptr12920 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr12917, align 8 
  store volatile i64 %emsg18637, i64* %vptr12920, align 8 ; load; *envptr12917
 %vptr12923 = alloca i64, align 8 
  %envptr12921 = inttoptr i64 %env12431 to i64* 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr12923, align 8 ; closure/env cast; i64 -> i64*
  %vptr12924 = alloca i64*, align 8 
  %envptr12922 = getelementptr inbounds i64, i64* %envptr12921, i64 2 
  store volatile i64* %envptr12922, i64** %vptr12924, align 8 ; &envptr12921[1]
 %vptr12925 = alloca i64, align 8 
  %Mcq$_37foldr1 = load i64, i64* %envptr12922, align 8 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr12925, align 8 ; load; *envptr12922
 %vptr12926 = alloca i64, align 8 
  %_957092 = call i64 @prim_car(i64 %rvp11181) 
  store volatile i64 %_957092, i64* %vptr12926, align 8 ; call prim_car
 %vptr12927 = alloca i64, align 8 
  %rvp11177 = call i64 @prim_cdr(i64 %rvp11181) 
  store volatile i64 %rvp11177, i64* %vptr12927, align 8 ; call prim_cdr
 %vptr12928 = alloca i64, align 8 
  %n_6311182 = call i64 @prim_null_63(i64 %rvp11177) 
  store volatile i64 %n_6311182, i64* %vptr12928, align 8 ; call prim_null_63
  %cmpptr12932 = alloca i1, align 8  %cmp12929 = icmp eq i64 %n_6311182, 15 store volatile i1 %cmp12929, i1* %cmpptr12932, align 8; false?
  br i1 %cmp12929, label %else12931, label %then12930                                ; if

then12930:
 %vptr12933 = alloca i64, align 8 
  %h11183 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11183, i64* %vptr12933, align 8 ; call prim_halt
  %vptr12939 = alloca i64*, align 8 
  %cloptr12934 = inttoptr i64 %h11183 to i64* 
  store volatile i64* %cloptr12934, i64** %vptr12939, align 8 ; closure/env cast; i64 -> i64*
  %vptr12940 = alloca i64*, align 8 
  %i0ptr12935 = getelementptr inbounds i64, i64* %cloptr12934, i64 1 
  store volatile i64* %i0ptr12935, i64** %vptr12940, align 8 ; &cloptr12934[1]
 %vptr12941 = alloca i64, align 8 
  %f12937 = load i64, i64* %i0ptr12935, align 8 
  store volatile i64 %f12937, i64* %vptr12941, align 8 ; load; *i0ptr12935
  %fptr12936 = inttoptr i64 %f12937 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr12936(i64 %h11183, i64 %h11183)                     ; tail call
  ret void

else12931:
 %vptr12942 = alloca i64, align 8 
  %Jup$_37length = call i64 @prim_car(i64 %rvp11177) 
  store volatile i64 %Jup$_37length, i64* %vptr12942, align 8 ; call prim_car
 %vptr12943 = alloca i64, align 8 
  %na8660 = call i64 @prim_cdr(i64 %rvp11177) 
  store volatile i64 %na8660, i64* %vptr12943, align 8 ; call prim_cdr
 %vptr12944 = alloca i64, align 8 
  %n_6311178 = call i64 @prim_null_63(i64 %na8660) 
  store volatile i64 %n_6311178, i64* %vptr12944, align 8 ; call prim_null_63
  %cmpptr12948 = alloca i1, align 8  %cmp12945 = icmp eq i64 %n_6311178, 15 store volatile i1 %cmp12945, i1* %cmpptr12948, align 8; false?
  br i1 %cmp12945, label %else12947, label %then12946                                ; if

then12946:
  %vptr12959 = alloca i64*, align 8 
  %cloptr12949 = call i64* @make_closure(i64 64) 
  store volatile i64* %cloptr12949, i64** %vptr12959, align 8 ; malloc
  %vptr12960 = alloca i64*, align 8 
  %eptr12951 = getelementptr inbounds i64, i64* %cloptr12949, i64 2 
  store volatile i64* %eptr12951, i64** %vptr12960, align 8 ; &eptr12951[1]
  %vptr12961 = alloca i64*, align 8 
  %eptr12952 = getelementptr inbounds i64, i64* %cloptr12949, i64 3 
  store volatile i64* %eptr12952, i64** %vptr12961, align 8 ; &eptr12952[2]
  %vptr12962 = alloca i64*, align 8 
  %eptr12953 = getelementptr inbounds i64, i64* %cloptr12949, i64 4 
  store volatile i64* %eptr12953, i64** %vptr12962, align 8 ; &eptr12953[3]
  %vptr12963 = alloca i64*, align 8 
  %eptr12954 = getelementptr inbounds i64, i64* %cloptr12949, i64 5 
  store volatile i64* %eptr12954, i64** %vptr12963, align 8 ; &eptr12954[4]
  %vptr12964 = alloca i64*, align 8 
  %eptr12955 = getelementptr inbounds i64, i64* %cloptr12949, i64 6 
  store volatile i64* %eptr12955, i64** %vptr12964, align 8 ; &eptr12955[5]
  %vptr12965 = alloca i64*, align 8 
  %eptr12956 = getelementptr inbounds i64, i64* %cloptr12949, i64 7 
  store volatile i64* %eptr12956, i64** %vptr12965, align 8 ; &eptr12956[6]
  %vptr12966 = alloca i64*, align 8 
  %eptr12957 = getelementptr inbounds i64, i64* %cloptr12949, i64 8 
  store volatile i64* %eptr12957, i64** %vptr12966, align 8 ; &eptr12957[7]
  store i64 %Mcq$_37foldr1, i64* %eptr12951                                          ; *eptr12951 = %Mcq$_37foldr1
  store i64 %emsg18637, i64* %eptr12952                                              ; *eptr12952 = %emsg18637
  store i64 %Jup$_37length, i64* %eptr12953                                          ; *eptr12953 = %Jup$_37length
  store i64 %NOz$Ycmb, i64* %eptr12954                                               ; *eptr12954 = %NOz$Ycmb
  store i64 %emsg08636, i64* %eptr12955                                              ; *eptr12955 = %emsg08636
  store i64 %Gcn$_37map1, i64* %eptr12956                                            ; *eptr12956 = %Gcn$_37map1
  store i64 %LF0$_37take, i64* %eptr12957                                            ; *eptr12957 = %LF0$_37take
  %vptr12967 = alloca i64*, align 8 
  %eptr12950 = getelementptr inbounds i64, i64* %cloptr12949, i64 1 
  store volatile i64* %eptr12950, i64** %vptr12967, align 8 ; &cloptr12949[1]
 %vptr12968 = alloca i64, align 8 
  %f12958 = ptrtoint void(i64,i64)* @lam12428 to i64 
  store volatile i64 %f12958, i64* %vptr12968, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f12958, i64* %eptr12950                                                 ; store fptr
 %vptr12969 = alloca i64, align 8 
  %arg7386 = ptrtoint i64* %cloptr12949 to i64 
  store volatile i64 %arg7386, i64* %vptr12969, align 8 ; closure cast; i64* -> i64
  %vptr12975 = alloca i64*, align 8 
  %cloptr12970 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr12970, i64** %vptr12975, align 8 ; malloc
  %vptr12976 = alloca i64*, align 8 
  %eptr12972 = getelementptr inbounds i64, i64* %cloptr12970, i64 2 
  store volatile i64* %eptr12972, i64** %vptr12976, align 8 ; &eptr12972[1]
  %vptr12977 = alloca i64*, align 8 
  %eptr12973 = getelementptr inbounds i64, i64* %cloptr12970, i64 3 
  store volatile i64* %eptr12973, i64** %vptr12977, align 8 ; &eptr12973[2]
  store i64 %emsg18637, i64* %eptr12972                                              ; *eptr12972 = %emsg18637
  store i64 %emsg08636, i64* %eptr12973                                              ; *eptr12973 = %emsg08636
  %vptr12978 = alloca i64*, align 8 
  %eptr12971 = getelementptr inbounds i64, i64* %cloptr12970, i64 1 
  store volatile i64* %eptr12971, i64** %vptr12978, align 8 ; &cloptr12970[1]
 %vptr12979 = alloca i64, align 8 
  %f12974 = ptrtoint void(i64,i64)* @lam11583 to i64 
  store volatile i64 %f12974, i64* %vptr12979, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f12974, i64* %eptr12971                                                 ; store fptr
 %vptr12980 = alloca i64, align 8 
  %arg7385 = ptrtoint i64* %cloptr12970 to i64 
  store volatile i64 %arg7385, i64* %vptr12980, align 8 ; closure cast; i64* -> i64
 %vptr12981 = alloca i64, align 8 
  %rva11176 = add i64 0, 0 
  store volatile i64 %rva11176, i64* %vptr12981, align 8 ; quoted ()
 %vptr12982 = alloca i64, align 8 
  %rva11175 = call i64 @prim_cons(i64 %arg7385, i64 %rva11176) 
  store volatile i64 %rva11175, i64* %vptr12982, align 8 ; call prim_cons
 %vptr12983 = alloca i64, align 8 
  %rva11174 = call i64 @prim_cons(i64 %arg7386, i64 %rva11175) 
  store volatile i64 %rva11174, i64* %vptr12983, align 8 ; call prim_cons
  %vptr12989 = alloca i64*, align 8 
  %cloptr12984 = inttoptr i64 %NOz$Ycmb to i64* 
  store volatile i64* %cloptr12984, i64** %vptr12989, align 8 ; closure/env cast; i64 -> i64*
  %vptr12990 = alloca i64*, align 8 
  %i0ptr12985 = getelementptr inbounds i64, i64* %cloptr12984, i64 1 
  store volatile i64* %i0ptr12985, i64** %vptr12990, align 8 ; &cloptr12984[1]
 %vptr12991 = alloca i64, align 8 
  %f12987 = load i64, i64* %i0ptr12985, align 8 
  store volatile i64 %f12987, i64* %vptr12991, align 8 ; load; *i0ptr12985
  %fptr12986 = inttoptr i64 %f12987 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr12986(i64 %NOz$Ycmb, i64 %rva11174)                 ; tail call
  ret void

else12947:
 %vptr12992 = alloca i64, align 8 
  %h11179 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11179, i64* %vptr12992, align 8 ; call prim_halt
  %vptr12998 = alloca i64*, align 8 
  %cloptr12993 = inttoptr i64 %h11179 to i64* 
  store volatile i64* %cloptr12993, i64** %vptr12998, align 8 ; closure/env cast; i64 -> i64*
  %vptr12999 = alloca i64*, align 8 
  %i0ptr12994 = getelementptr inbounds i64, i64* %cloptr12993, i64 1 
  store volatile i64* %i0ptr12994, i64** %vptr12999, align 8 ; &cloptr12993[1]
 %vptr13000 = alloca i64, align 8 
  %f12996 = load i64, i64* %i0ptr12994, align 8 
  store volatile i64 %f12996, i64* %vptr13000, align 8 ; load; *i0ptr12994
  %fptr12995 = inttoptr i64 %f12996 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr12995(i64 %h11179, i64 %h11179)                     ; tail call
  ret void
}


define void @lam12428(i64 %env12429, i64 %rvp11117) {
 %vptr13003 = alloca i64, align 8 
  %envptr13001 = inttoptr i64 %env12429 to i64* 
  store volatile i64 %LF0$_37take, i64* %vptr13003, align 8 ; closure/env cast; i64 -> i64*
  %vptr13004 = alloca i64*, align 8 
  %envptr13002 = getelementptr inbounds i64, i64* %envptr13001, i64 8 
  store volatile i64* %envptr13002, i64** %vptr13004, align 8 ; &envptr13001[7]
 %vptr13005 = alloca i64, align 8 
  %LF0$_37take = load i64, i64* %envptr13002, align 8 
  store volatile i64 %LF0$_37take, i64* %vptr13005, align 8 ; load; *envptr13002
 %vptr13008 = alloca i64, align 8 
  %envptr13006 = inttoptr i64 %env12429 to i64* 
  store volatile i64 %Gcn$_37map1, i64* %vptr13008, align 8 ; closure/env cast; i64 -> i64*
  %vptr13009 = alloca i64*, align 8 
  %envptr13007 = getelementptr inbounds i64, i64* %envptr13006, i64 7 
  store volatile i64* %envptr13007, i64** %vptr13009, align 8 ; &envptr13006[6]
 %vptr13010 = alloca i64, align 8 
  %Gcn$_37map1 = load i64, i64* %envptr13007, align 8 
  store volatile i64 %Gcn$_37map1, i64* %vptr13010, align 8 ; load; *envptr13007
 %vptr13013 = alloca i64, align 8 
  %envptr13011 = inttoptr i64 %env12429 to i64* 
  store volatile i64 %emsg08636, i64* %vptr13013, align 8 ; closure/env cast; i64 -> i64*
  %vptr13014 = alloca i64*, align 8 
  %envptr13012 = getelementptr inbounds i64, i64* %envptr13011, i64 6 
  store volatile i64* %envptr13012, i64** %vptr13014, align 8 ; &envptr13011[5]
 %vptr13015 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr13012, align 8 
  store volatile i64 %emsg08636, i64* %vptr13015, align 8 ; load; *envptr13012
 %vptr13018 = alloca i64, align 8 
  %envptr13016 = inttoptr i64 %env12429 to i64* 
  store volatile i64 %NOz$Ycmb, i64* %vptr13018, align 8 ; closure/env cast; i64 -> i64*
  %vptr13019 = alloca i64*, align 8 
  %envptr13017 = getelementptr inbounds i64, i64* %envptr13016, i64 5 
  store volatile i64* %envptr13017, i64** %vptr13019, align 8 ; &envptr13016[4]
 %vptr13020 = alloca i64, align 8 
  %NOz$Ycmb = load i64, i64* %envptr13017, align 8 
  store volatile i64 %NOz$Ycmb, i64* %vptr13020, align 8 ; load; *envptr13017
 %vptr13023 = alloca i64, align 8 
  %envptr13021 = inttoptr i64 %env12429 to i64* 
  store volatile i64 %Jup$_37length, i64* %vptr13023, align 8 ; closure/env cast; i64 -> i64*
  %vptr13024 = alloca i64*, align 8 
  %envptr13022 = getelementptr inbounds i64, i64* %envptr13021, i64 4 
  store volatile i64* %envptr13022, i64** %vptr13024, align 8 ; &envptr13021[3]
 %vptr13025 = alloca i64, align 8 
  %Jup$_37length = load i64, i64* %envptr13022, align 8 
  store volatile i64 %Jup$_37length, i64* %vptr13025, align 8 ; load; *envptr13022
 %vptr13028 = alloca i64, align 8 
  %envptr13026 = inttoptr i64 %env12429 to i64* 
  store volatile i64 %emsg18637, i64* %vptr13028, align 8 ; closure/env cast; i64 -> i64*
  %vptr13029 = alloca i64*, align 8 
  %envptr13027 = getelementptr inbounds i64, i64* %envptr13026, i64 3 
  store volatile i64* %envptr13027, i64** %vptr13029, align 8 ; &envptr13026[2]
 %vptr13030 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr13027, align 8 
  store volatile i64 %emsg18637, i64* %vptr13030, align 8 ; load; *envptr13027
 %vptr13033 = alloca i64, align 8 
  %envptr13031 = inttoptr i64 %env12429 to i64* 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr13033, align 8 ; closure/env cast; i64 -> i64*
  %vptr13034 = alloca i64*, align 8 
  %envptr13032 = getelementptr inbounds i64, i64* %envptr13031, i64 2 
  store volatile i64* %envptr13032, i64** %vptr13034, align 8 ; &envptr13031[1]
 %vptr13035 = alloca i64, align 8 
  %Mcq$_37foldr1 = load i64, i64* %envptr13032, align 8 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr13035, align 8 ; load; *envptr13032
 %vptr13036 = alloca i64, align 8 
  %_957093 = call i64 @prim_car(i64 %rvp11117) 
  store volatile i64 %_957093, i64* %vptr13036, align 8 ; call prim_car
 %vptr13037 = alloca i64, align 8 
  %rvp11113 = call i64 @prim_cdr(i64 %rvp11117) 
  store volatile i64 %rvp11113, i64* %vptr13037, align 8 ; call prim_cdr
 %vptr13038 = alloca i64, align 8 
  %n_6311118 = call i64 @prim_null_63(i64 %rvp11113) 
  store volatile i64 %n_6311118, i64* %vptr13038, align 8 ; call prim_null_63
  %cmpptr13042 = alloca i1, align 8  %cmp13039 = icmp eq i64 %n_6311118, 15 store volatile i1 %cmp13039, i1* %cmpptr13042, align 8; false?
  br i1 %cmp13039, label %else13041, label %then13040                                ; if

then13040:
 %vptr13043 = alloca i64, align 8 
  %h11119 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11119, i64* %vptr13043, align 8 ; call prim_halt
  %vptr13049 = alloca i64*, align 8 
  %cloptr13044 = inttoptr i64 %h11119 to i64* 
  store volatile i64* %cloptr13044, i64** %vptr13049, align 8 ; closure/env cast; i64 -> i64*
  %vptr13050 = alloca i64*, align 8 
  %i0ptr13045 = getelementptr inbounds i64, i64* %cloptr13044, i64 1 
  store volatile i64* %i0ptr13045, i64** %vptr13050, align 8 ; &cloptr13044[1]
 %vptr13051 = alloca i64, align 8 
  %f13047 = load i64, i64* %i0ptr13045, align 8 
  store volatile i64 %f13047, i64* %vptr13051, align 8 ; load; *i0ptr13045
  %fptr13046 = inttoptr i64 %f13047 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13046(i64 %h11119, i64 %h11119)                     ; tail call
  ret void

else13041:
 %vptr13052 = alloca i64, align 8 
  %F5P$_37foldl1 = call i64 @prim_car(i64 %rvp11113) 
  store volatile i64 %F5P$_37foldl1, i64* %vptr13052, align 8 ; call prim_car
 %vptr13053 = alloca i64, align 8 
  %na8662 = call i64 @prim_cdr(i64 %rvp11113) 
  store volatile i64 %na8662, i64* %vptr13053, align 8 ; call prim_cdr
 %vptr13054 = alloca i64, align 8 
  %n_6311114 = call i64 @prim_null_63(i64 %na8662) 
  store volatile i64 %n_6311114, i64* %vptr13054, align 8 ; call prim_null_63
  %cmpptr13058 = alloca i1, align 8  %cmp13055 = icmp eq i64 %n_6311114, 15 store volatile i1 %cmp13055, i1* %cmpptr13058, align 8; false?
  br i1 %cmp13055, label %else13057, label %then13056                                ; if

then13056:
  %vptr13065 = alloca i64*, align 8 
  %cloptr13059 = call i64* @make_closure(i64 32) 
  store volatile i64* %cloptr13059, i64** %vptr13065, align 8 ; malloc
  %vptr13066 = alloca i64*, align 8 
  %eptr13061 = getelementptr inbounds i64, i64* %cloptr13059, i64 2 
  store volatile i64* %eptr13061, i64** %vptr13066, align 8 ; &eptr13061[1]
  %vptr13067 = alloca i64*, align 8 
  %eptr13062 = getelementptr inbounds i64, i64* %cloptr13059, i64 3 
  store volatile i64* %eptr13062, i64** %vptr13067, align 8 ; &eptr13062[2]
  %vptr13068 = alloca i64*, align 8 
  %eptr13063 = getelementptr inbounds i64, i64* %cloptr13059, i64 4 
  store volatile i64* %eptr13063, i64** %vptr13068, align 8 ; &eptr13063[3]
  store i64 %emsg18637, i64* %eptr13061                                              ; *eptr13061 = %emsg18637
  store i64 %emsg08636, i64* %eptr13062                                              ; *eptr13062 = %emsg08636
  store i64 %F5P$_37foldl1, i64* %eptr13063                                          ; *eptr13063 = %F5P$_37foldl1
  %vptr13069 = alloca i64*, align 8 
  %eptr13060 = getelementptr inbounds i64, i64* %cloptr13059, i64 1 
  store volatile i64* %eptr13060, i64** %vptr13069, align 8 ; &cloptr13059[1]
 %vptr13070 = alloca i64, align 8 
  %f13064 = ptrtoint void(i64,i64)* @lam12426 to i64 
  store volatile i64 %f13064, i64* %vptr13070, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f13064, i64* %eptr13060                                                 ; store fptr
 %vptr13071 = alloca i64, align 8 
  %L15$_37last = ptrtoint i64* %cloptr13059 to i64 
  store volatile i64 %L15$_37last, i64* %vptr13071, align 8 ; closure cast; i64* -> i64
  %vptr13079 = alloca i64*, align 8 
  %cloptr13072 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr13072, i64** %vptr13079, align 8 ; malloc
  %vptr13080 = alloca i64*, align 8 
  %eptr13074 = getelementptr inbounds i64, i64* %cloptr13072, i64 2 
  store volatile i64* %eptr13074, i64** %vptr13080, align 8 ; &eptr13074[1]
  %vptr13081 = alloca i64*, align 8 
  %eptr13075 = getelementptr inbounds i64, i64* %cloptr13072, i64 3 
  store volatile i64* %eptr13075, i64** %vptr13081, align 8 ; &eptr13075[2]
  %vptr13082 = alloca i64*, align 8 
  %eptr13076 = getelementptr inbounds i64, i64* %cloptr13072, i64 4 
  store volatile i64* %eptr13076, i64** %vptr13082, align 8 ; &eptr13076[3]
  %vptr13083 = alloca i64*, align 8 
  %eptr13077 = getelementptr inbounds i64, i64* %cloptr13072, i64 5 
  store volatile i64* %eptr13077, i64** %vptr13083, align 8 ; &eptr13077[4]
  store i64 %emsg18637, i64* %eptr13074                                              ; *eptr13074 = %emsg18637
  store i64 %Jup$_37length, i64* %eptr13075                                          ; *eptr13075 = %Jup$_37length
  store i64 %emsg08636, i64* %eptr13076                                              ; *eptr13076 = %emsg08636
  store i64 %LF0$_37take, i64* %eptr13077                                            ; *eptr13077 = %LF0$_37take
  %vptr13084 = alloca i64*, align 8 
  %eptr13073 = getelementptr inbounds i64, i64* %cloptr13072, i64 1 
  store volatile i64* %eptr13073, i64** %vptr13084, align 8 ; &cloptr13072[1]
 %vptr13085 = alloca i64, align 8 
  %f13078 = ptrtoint void(i64,i64)* @lam12418 to i64 
  store volatile i64 %f13078, i64* %vptr13085, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f13078, i64* %eptr13073                                                 ; store fptr
 %vptr13086 = alloca i64, align 8 
  %JuU$_37drop_45right = ptrtoint i64* %cloptr13072 to i64 
  store volatile i64 %JuU$_37drop_45right, i64* %vptr13086, align 8 ; closure cast; i64* -> i64
  %vptr13098 = alloca i64*, align 8 
  %cloptr13087 = call i64* @make_closure(i64 72) 
  store volatile i64* %cloptr13087, i64** %vptr13098, align 8 ; malloc
  %vptr13099 = alloca i64*, align 8 
  %eptr13089 = getelementptr inbounds i64, i64* %cloptr13087, i64 2 
  store volatile i64* %eptr13089, i64** %vptr13099, align 8 ; &eptr13089[1]
  %vptr13100 = alloca i64*, align 8 
  %eptr13090 = getelementptr inbounds i64, i64* %cloptr13087, i64 3 
  store volatile i64* %eptr13090, i64** %vptr13100, align 8 ; &eptr13090[2]
  %vptr13101 = alloca i64*, align 8 
  %eptr13091 = getelementptr inbounds i64, i64* %cloptr13087, i64 4 
  store volatile i64* %eptr13091, i64** %vptr13101, align 8 ; &eptr13091[3]
  %vptr13102 = alloca i64*, align 8 
  %eptr13092 = getelementptr inbounds i64, i64* %cloptr13087, i64 5 
  store volatile i64* %eptr13092, i64** %vptr13102, align 8 ; &eptr13092[4]
  %vptr13103 = alloca i64*, align 8 
  %eptr13093 = getelementptr inbounds i64, i64* %cloptr13087, i64 6 
  store volatile i64* %eptr13093, i64** %vptr13103, align 8 ; &eptr13093[5]
  %vptr13104 = alloca i64*, align 8 
  %eptr13094 = getelementptr inbounds i64, i64* %cloptr13087, i64 7 
  store volatile i64* %eptr13094, i64** %vptr13104, align 8 ; &eptr13094[6]
  %vptr13105 = alloca i64*, align 8 
  %eptr13095 = getelementptr inbounds i64, i64* %cloptr13087, i64 8 
  store volatile i64* %eptr13095, i64** %vptr13105, align 8 ; &eptr13095[7]
  %vptr13106 = alloca i64*, align 8 
  %eptr13096 = getelementptr inbounds i64, i64* %cloptr13087, i64 9 
  store volatile i64* %eptr13096, i64** %vptr13106, align 8 ; &eptr13096[8]
  store i64 %Mcq$_37foldr1, i64* %eptr13089                                          ; *eptr13089 = %Mcq$_37foldr1
  store i64 %emsg18637, i64* %eptr13090                                              ; *eptr13090 = %emsg18637
  store i64 %Jup$_37length, i64* %eptr13091                                          ; *eptr13091 = %Jup$_37length
  store i64 %L15$_37last, i64* %eptr13092                                            ; *eptr13092 = %L15$_37last
  store i64 %JuU$_37drop_45right, i64* %eptr13093                                    ; *eptr13093 = %JuU$_37drop_45right
  store i64 %NOz$Ycmb, i64* %eptr13094                                               ; *eptr13094 = %NOz$Ycmb
  store i64 %emsg08636, i64* %eptr13095                                              ; *eptr13095 = %emsg08636
  store i64 %F5P$_37foldl1, i64* %eptr13096                                          ; *eptr13096 = %F5P$_37foldl1
  %vptr13107 = alloca i64*, align 8 
  %eptr13088 = getelementptr inbounds i64, i64* %cloptr13087, i64 1 
  store volatile i64* %eptr13088, i64** %vptr13107, align 8 ; &cloptr13087[1]
 %vptr13108 = alloca i64, align 8 
  %f13097 = ptrtoint void(i64,i64)* @lam12412 to i64 
  store volatile i64 %f13097, i64* %vptr13108, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f13097, i64* %eptr13088                                                 ; store fptr
 %vptr13109 = alloca i64, align 8 
  %arg7406 = ptrtoint i64* %cloptr13087 to i64 
  store volatile i64 %arg7406, i64* %vptr13109, align 8 ; closure cast; i64* -> i64
  %vptr13117 = alloca i64*, align 8 
  %cloptr13110 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr13110, i64** %vptr13117, align 8 ; malloc
  %vptr13118 = alloca i64*, align 8 
  %eptr13112 = getelementptr inbounds i64, i64* %cloptr13110, i64 2 
  store volatile i64* %eptr13112, i64** %vptr13118, align 8 ; &eptr13112[1]
  %vptr13119 = alloca i64*, align 8 
  %eptr13113 = getelementptr inbounds i64, i64* %cloptr13110, i64 3 
  store volatile i64* %eptr13113, i64** %vptr13119, align 8 ; &eptr13113[2]
  %vptr13120 = alloca i64*, align 8 
  %eptr13114 = getelementptr inbounds i64, i64* %cloptr13110, i64 4 
  store volatile i64* %eptr13114, i64** %vptr13120, align 8 ; &eptr13114[3]
  %vptr13121 = alloca i64*, align 8 
  %eptr13115 = getelementptr inbounds i64, i64* %cloptr13110, i64 5 
  store volatile i64* %eptr13115, i64** %vptr13121, align 8 ; &eptr13115[4]
  store i64 %Mcq$_37foldr1, i64* %eptr13112                                          ; *eptr13112 = %Mcq$_37foldr1
  store i64 %emsg18637, i64* %eptr13113                                              ; *eptr13113 = %emsg18637
  store i64 %emsg08636, i64* %eptr13114                                              ; *eptr13114 = %emsg08636
  store i64 %Gcn$_37map1, i64* %eptr13115                                            ; *eptr13115 = %Gcn$_37map1
  %vptr13122 = alloca i64*, align 8 
  %eptr13111 = getelementptr inbounds i64, i64* %cloptr13110, i64 1 
  store volatile i64* %eptr13111, i64** %vptr13122, align 8 ; &cloptr13110[1]
 %vptr13123 = alloca i64, align 8 
  %f13116 = ptrtoint void(i64,i64)* @lam11634 to i64 
  store volatile i64 %f13116, i64* %vptr13123, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f13116, i64* %eptr13111                                                 ; store fptr
 %vptr13124 = alloca i64, align 8 
  %arg7405 = ptrtoint i64* %cloptr13110 to i64 
  store volatile i64 %arg7405, i64* %vptr13124, align 8 ; closure cast; i64* -> i64
 %vptr13125 = alloca i64, align 8 
  %rva11112 = add i64 0, 0 
  store volatile i64 %rva11112, i64* %vptr13125, align 8 ; quoted ()
 %vptr13126 = alloca i64, align 8 
  %rva11111 = call i64 @prim_cons(i64 %arg7405, i64 %rva11112) 
  store volatile i64 %rva11111, i64* %vptr13126, align 8 ; call prim_cons
 %vptr13127 = alloca i64, align 8 
  %rva11110 = call i64 @prim_cons(i64 %arg7406, i64 %rva11111) 
  store volatile i64 %rva11110, i64* %vptr13127, align 8 ; call prim_cons
  %vptr13133 = alloca i64*, align 8 
  %cloptr13128 = inttoptr i64 %NOz$Ycmb to i64* 
  store volatile i64* %cloptr13128, i64** %vptr13133, align 8 ; closure/env cast; i64 -> i64*
  %vptr13134 = alloca i64*, align 8 
  %i0ptr13129 = getelementptr inbounds i64, i64* %cloptr13128, i64 1 
  store volatile i64* %i0ptr13129, i64** %vptr13134, align 8 ; &cloptr13128[1]
 %vptr13135 = alloca i64, align 8 
  %f13131 = load i64, i64* %i0ptr13129, align 8 
  store volatile i64 %f13131, i64* %vptr13135, align 8 ; load; *i0ptr13129
  %fptr13130 = inttoptr i64 %f13131 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13130(i64 %NOz$Ycmb, i64 %rva11110)                 ; tail call
  ret void

else13057:
 %vptr13136 = alloca i64, align 8 
  %h11115 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11115, i64* %vptr13136, align 8 ; call prim_halt
  %vptr13142 = alloca i64*, align 8 
  %cloptr13137 = inttoptr i64 %h11115 to i64* 
  store volatile i64* %cloptr13137, i64** %vptr13142, align 8 ; closure/env cast; i64 -> i64*
  %vptr13143 = alloca i64*, align 8 
  %i0ptr13138 = getelementptr inbounds i64, i64* %cloptr13137, i64 1 
  store volatile i64* %i0ptr13138, i64** %vptr13143, align 8 ; &cloptr13137[1]
 %vptr13144 = alloca i64, align 8 
  %f13140 = load i64, i64* %i0ptr13138, align 8 
  store volatile i64 %f13140, i64* %vptr13144, align 8 ; load; *i0ptr13138
  %fptr13139 = inttoptr i64 %f13140 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13139(i64 %h11115, i64 %h11115)                     ; tail call
  ret void
}


define void @lam12426(i64 %env12427, i64 %rvp8691) {
 %vptr13147 = alloca i64, align 8 
  %envptr13145 = inttoptr i64 %env12427 to i64* 
  store volatile i64 %F5P$_37foldl1, i64* %vptr13147, align 8 ; closure/env cast; i64 -> i64*
  %vptr13148 = alloca i64*, align 8 
  %envptr13146 = getelementptr inbounds i64, i64* %envptr13145, i64 4 
  store volatile i64* %envptr13146, i64** %vptr13148, align 8 ; &envptr13145[3]
 %vptr13149 = alloca i64, align 8 
  %F5P$_37foldl1 = load i64, i64* %envptr13146, align 8 
  store volatile i64 %F5P$_37foldl1, i64* %vptr13149, align 8 ; load; *envptr13146
 %vptr13152 = alloca i64, align 8 
  %envptr13150 = inttoptr i64 %env12427 to i64* 
  store volatile i64 %emsg08636, i64* %vptr13152, align 8 ; closure/env cast; i64 -> i64*
  %vptr13153 = alloca i64*, align 8 
  %envptr13151 = getelementptr inbounds i64, i64* %envptr13150, i64 3 
  store volatile i64* %envptr13151, i64** %vptr13153, align 8 ; &envptr13150[2]
 %vptr13154 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr13151, align 8 
  store volatile i64 %emsg08636, i64* %vptr13154, align 8 ; load; *envptr13151
 %vptr13157 = alloca i64, align 8 
  %envptr13155 = inttoptr i64 %env12427 to i64* 
  store volatile i64 %emsg18637, i64* %vptr13157, align 8 ; closure/env cast; i64 -> i64*
  %vptr13158 = alloca i64*, align 8 
  %envptr13156 = getelementptr inbounds i64, i64* %envptr13155, i64 2 
  store volatile i64* %envptr13156, i64** %vptr13158, align 8 ; &envptr13155[1]
 %vptr13159 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr13156, align 8 
  store volatile i64 %emsg18637, i64* %vptr13159, align 8 ; load; *envptr13156
 %vptr13160 = alloca i64, align 8 
  %cont7094 = call i64 @prim_car(i64 %rvp8691) 
  store volatile i64 %cont7094, i64* %vptr13160, align 8 ; call prim_car
 %vptr13161 = alloca i64, align 8 
  %rvp8687 = call i64 @prim_cdr(i64 %rvp8691) 
  store volatile i64 %rvp8687, i64* %vptr13161, align 8 ; call prim_cdr
 %vptr13162 = alloca i64, align 8 
  %n_638692 = call i64 @prim_null_63(i64 %rvp8687) 
  store volatile i64 %n_638692, i64* %vptr13162, align 8 ; call prim_null_63
  %cmpptr13166 = alloca i1, align 8  %cmp13163 = icmp eq i64 %n_638692, 15 store volatile i1 %cmp13163, i1* %cmpptr13166, align 8; false?
  br i1 %cmp13163, label %else13165, label %then13164                                ; if

then13164:
 %vptr13167 = alloca i64, align 8 
  %h8693 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8693, i64* %vptr13167, align 8 ; call prim_halt
  %vptr13173 = alloca i64*, align 8 
  %cloptr13168 = inttoptr i64 %h8693 to i64* 
  store volatile i64* %cloptr13168, i64** %vptr13173, align 8 ; closure/env cast; i64 -> i64*
  %vptr13174 = alloca i64*, align 8 
  %i0ptr13169 = getelementptr inbounds i64, i64* %cloptr13168, i64 1 
  store volatile i64* %i0ptr13169, i64** %vptr13174, align 8 ; &cloptr13168[1]
 %vptr13175 = alloca i64, align 8 
  %f13171 = load i64, i64* %i0ptr13169, align 8 
  store volatile i64 %f13171, i64* %vptr13175, align 8 ; load; *i0ptr13169
  %fptr13170 = inttoptr i64 %f13171 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13170(i64 %h8693, i64 %h8693)                       ; tail call
  ret void

else13165:
 %vptr13176 = alloca i64, align 8 
  %RDN$lst = call i64 @prim_car(i64 %rvp8687) 
  store volatile i64 %RDN$lst, i64* %vptr13176, align 8 ; call prim_car
 %vptr13177 = alloca i64, align 8 
  %na8664 = call i64 @prim_cdr(i64 %rvp8687) 
  store volatile i64 %na8664, i64* %vptr13177, align 8 ; call prim_cdr
 %vptr13178 = alloca i64, align 8 
  %n_638688 = call i64 @prim_null_63(i64 %na8664) 
  store volatile i64 %n_638688, i64* %vptr13178, align 8 ; call prim_null_63
  %cmpptr13182 = alloca i1, align 8  %cmp13179 = icmp eq i64 %n_638688, 15 store volatile i1 %cmp13179, i1* %cmpptr13182, align 8; false?
  br i1 %cmp13179, label %else13181, label %then13180                                ; if

then13180:
  %vptr13188 = alloca i64*, align 8 
  %cloptr13183 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr13183, i64** %vptr13188, align 8 ; malloc
  %vptr13189 = alloca i64*, align 8 
  %eptr13185 = getelementptr inbounds i64, i64* %cloptr13183, i64 2 
  store volatile i64* %eptr13185, i64** %vptr13189, align 8 ; &eptr13185[1]
  %vptr13190 = alloca i64*, align 8 
  %eptr13186 = getelementptr inbounds i64, i64* %cloptr13183, i64 3 
  store volatile i64* %eptr13186, i64** %vptr13190, align 8 ; &eptr13186[2]
  store i64 %emsg18637, i64* %eptr13185                                              ; *eptr13185 = %emsg18637
  store i64 %emsg08636, i64* %eptr13186                                              ; *eptr13186 = %emsg08636
  %vptr13191 = alloca i64*, align 8 
  %eptr13184 = getelementptr inbounds i64, i64* %cloptr13183, i64 1 
  store volatile i64* %eptr13184, i64** %vptr13191, align 8 ; &cloptr13183[1]
 %vptr13192 = alloca i64, align 8 
  %f13187 = ptrtoint void(i64,i64)* @lam12424 to i64 
  store volatile i64 %f13187, i64* %vptr13192, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f13187, i64* %eptr13184                                                 ; store fptr
 %vptr13193 = alloca i64, align 8 
  %arg7390 = ptrtoint i64* %cloptr13183 to i64 
  store volatile i64 %arg7390, i64* %vptr13193, align 8 ; closure cast; i64* -> i64
 %vptr13194 = alloca i64, align 8 
  %arg7389 = add i64 0, 0 
  store volatile i64 %arg7389, i64* %vptr13194, align 8 ; quoted ()
 %vptr13195 = alloca i64, align 8 
  %rva8686 = add i64 0, 0 
  store volatile i64 %rva8686, i64* %vptr13195, align 8 ; quoted ()
 %vptr13196 = alloca i64, align 8 
  %rva8685 = call i64 @prim_cons(i64 %RDN$lst, i64 %rva8686) 
  store volatile i64 %rva8685, i64* %vptr13196, align 8 ; call prim_cons
 %vptr13197 = alloca i64, align 8 
  %rva8684 = call i64 @prim_cons(i64 %arg7389, i64 %rva8685) 
  store volatile i64 %rva8684, i64* %vptr13197, align 8 ; call prim_cons
 %vptr13198 = alloca i64, align 8 
  %rva8683 = call i64 @prim_cons(i64 %arg7390, i64 %rva8684) 
  store volatile i64 %rva8683, i64* %vptr13198, align 8 ; call prim_cons
 %vptr13199 = alloca i64, align 8 
  %rva8682 = call i64 @prim_cons(i64 %cont7094, i64 %rva8683) 
  store volatile i64 %rva8682, i64* %vptr13199, align 8 ; call prim_cons
  %vptr13205 = alloca i64*, align 8 
  %cloptr13200 = inttoptr i64 %F5P$_37foldl1 to i64* 
  store volatile i64* %cloptr13200, i64** %vptr13205, align 8 ; closure/env cast; i64 -> i64*
  %vptr13206 = alloca i64*, align 8 
  %i0ptr13201 = getelementptr inbounds i64, i64* %cloptr13200, i64 1 
  store volatile i64* %i0ptr13201, i64** %vptr13206, align 8 ; &cloptr13200[1]
 %vptr13207 = alloca i64, align 8 
  %f13203 = load i64, i64* %i0ptr13201, align 8 
  store volatile i64 %f13203, i64* %vptr13207, align 8 ; load; *i0ptr13201
  %fptr13202 = inttoptr i64 %f13203 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13202(i64 %F5P$_37foldl1, i64 %rva8682)             ; tail call
  ret void

else13181:
 %vptr13208 = alloca i64, align 8 
  %h8689 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h8689, i64* %vptr13208, align 8 ; call prim_halt
  %vptr13214 = alloca i64*, align 8 
  %cloptr13209 = inttoptr i64 %h8689 to i64* 
  store volatile i64* %cloptr13209, i64** %vptr13214, align 8 ; closure/env cast; i64 -> i64*
  %vptr13215 = alloca i64*, align 8 
  %i0ptr13210 = getelementptr inbounds i64, i64* %cloptr13209, i64 1 
  store volatile i64* %i0ptr13210, i64** %vptr13215, align 8 ; &cloptr13209[1]
 %vptr13216 = alloca i64, align 8 
  %f13212 = load i64, i64* %i0ptr13210, align 8 
  store volatile i64 %f13212, i64* %vptr13216, align 8 ; load; *i0ptr13210
  %fptr13211 = inttoptr i64 %f13212 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13211(i64 %h8689, i64 %h8689)                       ; tail call
  ret void
}


define void @lam12424(i64 %env12425, i64 %rvp8678) {
 %vptr13219 = alloca i64, align 8 
  %envptr13217 = inttoptr i64 %env12425 to i64* 
  store volatile i64 %emsg08636, i64* %vptr13219, align 8 ; closure/env cast; i64 -> i64*
  %vptr13220 = alloca i64*, align 8 
  %envptr13218 = getelementptr inbounds i64, i64* %envptr13217, i64 3 
  store volatile i64* %envptr13218, i64** %vptr13220, align 8 ; &envptr13217[2]
 %vptr13221 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr13218, align 8 
  store volatile i64 %emsg08636, i64* %vptr13221, align 8 ; load; *envptr13218
 %vptr13224 = alloca i64, align 8 
  %envptr13222 = inttoptr i64 %env12425 to i64* 
  store volatile i64 %emsg18637, i64* %vptr13224, align 8 ; closure/env cast; i64 -> i64*
  %vptr13225 = alloca i64*, align 8 
  %envptr13223 = getelementptr inbounds i64, i64* %envptr13222, i64 2 
  store volatile i64* %envptr13223, i64** %vptr13225, align 8 ; &envptr13222[1]
 %vptr13226 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr13223, align 8 
  store volatile i64 %emsg18637, i64* %vptr13226, align 8 ; load; *envptr13223
 %vptr13227 = alloca i64, align 8 
  %cont7095 = call i64 @prim_car(i64 %rvp8678) 
  store volatile i64 %cont7095, i64* %vptr13227, align 8 ; call prim_car
 %vptr13228 = alloca i64, align 8 
  %rvp8674 = call i64 @prim_cdr(i64 %rvp8678) 
  store volatile i64 %rvp8674, i64* %vptr13228, align 8 ; call prim_cdr
 %vptr13229 = alloca i64, align 8 
  %n_638679 = call i64 @prim_null_63(i64 %rvp8674) 
  store volatile i64 %n_638679, i64* %vptr13229, align 8 ; call prim_null_63
  %cmpptr13233 = alloca i1, align 8  %cmp13230 = icmp eq i64 %n_638679, 15 store volatile i1 %cmp13230, i1* %cmpptr13233, align 8; false?
  br i1 %cmp13230, label %else13232, label %then13231                                ; if

then13231:
 %vptr13234 = alloca i64, align 8 
  %h8680 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8680, i64* %vptr13234, align 8 ; call prim_halt
  %vptr13240 = alloca i64*, align 8 
  %cloptr13235 = inttoptr i64 %h8680 to i64* 
  store volatile i64* %cloptr13235, i64** %vptr13240, align 8 ; closure/env cast; i64 -> i64*
  %vptr13241 = alloca i64*, align 8 
  %i0ptr13236 = getelementptr inbounds i64, i64* %cloptr13235, i64 1 
  store volatile i64* %i0ptr13236, i64** %vptr13241, align 8 ; &cloptr13235[1]
 %vptr13242 = alloca i64, align 8 
  %f13238 = load i64, i64* %i0ptr13236, align 8 
  store volatile i64 %f13238, i64* %vptr13242, align 8 ; load; *i0ptr13236
  %fptr13237 = inttoptr i64 %f13238 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13237(i64 %h8680, i64 %h8680)                       ; tail call
  ret void

else13232:
 %vptr13243 = alloca i64, align 8 
  %Hr5$x = call i64 @prim_car(i64 %rvp8674) 
  store volatile i64 %Hr5$x, i64* %vptr13243, align 8 ; call prim_car
 %vptr13244 = alloca i64, align 8 
  %rvp8670 = call i64 @prim_cdr(i64 %rvp8674) 
  store volatile i64 %rvp8670, i64* %vptr13244, align 8 ; call prim_cdr
 %vptr13245 = alloca i64, align 8 
  %n_638675 = call i64 @prim_null_63(i64 %rvp8670) 
  store volatile i64 %n_638675, i64* %vptr13245, align 8 ; call prim_null_63
  %cmpptr13249 = alloca i1, align 8  %cmp13246 = icmp eq i64 %n_638675, 15 store volatile i1 %cmp13246, i1* %cmpptr13249, align 8; false?
  br i1 %cmp13246, label %else13248, label %then13247                                ; if

then13247:
 %vptr13250 = alloca i64, align 8 
  %h8676 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8676, i64* %vptr13250, align 8 ; call prim_halt
  %vptr13256 = alloca i64*, align 8 
  %cloptr13251 = inttoptr i64 %h8676 to i64* 
  store volatile i64* %cloptr13251, i64** %vptr13256, align 8 ; closure/env cast; i64 -> i64*
  %vptr13257 = alloca i64*, align 8 
  %i0ptr13252 = getelementptr inbounds i64, i64* %cloptr13251, i64 1 
  store volatile i64* %i0ptr13252, i64** %vptr13257, align 8 ; &cloptr13251[1]
 %vptr13258 = alloca i64, align 8 
  %f13254 = load i64, i64* %i0ptr13252, align 8 
  store volatile i64 %f13254, i64* %vptr13258, align 8 ; load; *i0ptr13252
  %fptr13253 = inttoptr i64 %f13254 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13253(i64 %h8676, i64 %h8676)                       ; tail call
  ret void

else13248:
 %vptr13259 = alloca i64, align 8 
  %UCN$y = call i64 @prim_car(i64 %rvp8670) 
  store volatile i64 %UCN$y, i64* %vptr13259, align 8 ; call prim_car
 %vptr13260 = alloca i64, align 8 
  %na8666 = call i64 @prim_cdr(i64 %rvp8670) 
  store volatile i64 %na8666, i64* %vptr13260, align 8 ; call prim_cdr
 %vptr13261 = alloca i64, align 8 
  %n_638671 = call i64 @prim_null_63(i64 %na8666) 
  store volatile i64 %n_638671, i64* %vptr13261, align 8 ; call prim_null_63
  %cmpptr13265 = alloca i1, align 8  %cmp13262 = icmp eq i64 %n_638671, 15 store volatile i1 %cmp13262, i1* %cmpptr13265, align 8; false?
  br i1 %cmp13262, label %else13264, label %then13263                                ; if

then13263:
 %vptr13266 = alloca i64, align 8 
  %arg7394 = add i64 0, 0 
  store volatile i64 %arg7394, i64* %vptr13266, align 8 ; quoted ()
 %vptr13267 = alloca i64, align 8 
  %rva8669 = add i64 0, 0 
  store volatile i64 %rva8669, i64* %vptr13267, align 8 ; quoted ()
 %vptr13268 = alloca i64, align 8 
  %rva8668 = call i64 @prim_cons(i64 %Hr5$x, i64 %rva8669) 
  store volatile i64 %rva8668, i64* %vptr13268, align 8 ; call prim_cons
 %vptr13269 = alloca i64, align 8 
  %rva8667 = call i64 @prim_cons(i64 %arg7394, i64 %rva8668) 
  store volatile i64 %rva8667, i64* %vptr13269, align 8 ; call prim_cons
  %vptr13275 = alloca i64*, align 8 
  %cloptr13270 = inttoptr i64 %cont7095 to i64* 
  store volatile i64* %cloptr13270, i64** %vptr13275, align 8 ; closure/env cast; i64 -> i64*
  %vptr13276 = alloca i64*, align 8 
  %i0ptr13271 = getelementptr inbounds i64, i64* %cloptr13270, i64 1 
  store volatile i64* %i0ptr13271, i64** %vptr13276, align 8 ; &cloptr13270[1]
 %vptr13277 = alloca i64, align 8 
  %f13273 = load i64, i64* %i0ptr13271, align 8 
  store volatile i64 %f13273, i64* %vptr13277, align 8 ; load; *i0ptr13271
  %fptr13272 = inttoptr i64 %f13273 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13272(i64 %cont7095, i64 %rva8667)                  ; tail call
  ret void

else13264:
 %vptr13278 = alloca i64, align 8 
  %h8672 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h8672, i64* %vptr13278, align 8 ; call prim_halt
  %vptr13284 = alloca i64*, align 8 
  %cloptr13279 = inttoptr i64 %h8672 to i64* 
  store volatile i64* %cloptr13279, i64** %vptr13284, align 8 ; closure/env cast; i64 -> i64*
  %vptr13285 = alloca i64*, align 8 
  %i0ptr13280 = getelementptr inbounds i64, i64* %cloptr13279, i64 1 
  store volatile i64* %i0ptr13280, i64** %vptr13285, align 8 ; &cloptr13279[1]
 %vptr13286 = alloca i64, align 8 
  %f13282 = load i64, i64* %i0ptr13280, align 8 
  store volatile i64 %f13282, i64* %vptr13286, align 8 ; load; *i0ptr13280
  %fptr13281 = inttoptr i64 %f13282 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13281(i64 %h8672, i64 %h8672)                       ; tail call
  ret void
}


define void @lam12418(i64 %env12419, i64 %rvp8722) {
 %vptr13289 = alloca i64, align 8 
  %envptr13287 = inttoptr i64 %env12419 to i64* 
  store volatile i64 %LF0$_37take, i64* %vptr13289, align 8 ; closure/env cast; i64 -> i64*
  %vptr13290 = alloca i64*, align 8 
  %envptr13288 = getelementptr inbounds i64, i64* %envptr13287, i64 5 
  store volatile i64* %envptr13288, i64** %vptr13290, align 8 ; &envptr13287[4]
 %vptr13291 = alloca i64, align 8 
  %LF0$_37take = load i64, i64* %envptr13288, align 8 
  store volatile i64 %LF0$_37take, i64* %vptr13291, align 8 ; load; *envptr13288
 %vptr13294 = alloca i64, align 8 
  %envptr13292 = inttoptr i64 %env12419 to i64* 
  store volatile i64 %emsg08636, i64* %vptr13294, align 8 ; closure/env cast; i64 -> i64*
  %vptr13295 = alloca i64*, align 8 
  %envptr13293 = getelementptr inbounds i64, i64* %envptr13292, i64 4 
  store volatile i64* %envptr13293, i64** %vptr13295, align 8 ; &envptr13292[3]
 %vptr13296 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr13293, align 8 
  store volatile i64 %emsg08636, i64* %vptr13296, align 8 ; load; *envptr13293
 %vptr13299 = alloca i64, align 8 
  %envptr13297 = inttoptr i64 %env12419 to i64* 
  store volatile i64 %Jup$_37length, i64* %vptr13299, align 8 ; closure/env cast; i64 -> i64*
  %vptr13300 = alloca i64*, align 8 
  %envptr13298 = getelementptr inbounds i64, i64* %envptr13297, i64 3 
  store volatile i64* %envptr13298, i64** %vptr13300, align 8 ; &envptr13297[2]
 %vptr13301 = alloca i64, align 8 
  %Jup$_37length = load i64, i64* %envptr13298, align 8 
  store volatile i64 %Jup$_37length, i64* %vptr13301, align 8 ; load; *envptr13298
 %vptr13304 = alloca i64, align 8 
  %envptr13302 = inttoptr i64 %env12419 to i64* 
  store volatile i64 %emsg18637, i64* %vptr13304, align 8 ; closure/env cast; i64 -> i64*
  %vptr13305 = alloca i64*, align 8 
  %envptr13303 = getelementptr inbounds i64, i64* %envptr13302, i64 2 
  store volatile i64* %envptr13303, i64** %vptr13305, align 8 ; &envptr13302[1]
 %vptr13306 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr13303, align 8 
  store volatile i64 %emsg18637, i64* %vptr13306, align 8 ; load; *envptr13303
 %vptr13307 = alloca i64, align 8 
  %cont7096 = call i64 @prim_car(i64 %rvp8722) 
  store volatile i64 %cont7096, i64* %vptr13307, align 8 ; call prim_car
 %vptr13308 = alloca i64, align 8 
  %rvp8718 = call i64 @prim_cdr(i64 %rvp8722) 
  store volatile i64 %rvp8718, i64* %vptr13308, align 8 ; call prim_cdr
 %vptr13309 = alloca i64, align 8 
  %n_638723 = call i64 @prim_null_63(i64 %rvp8718) 
  store volatile i64 %n_638723, i64* %vptr13309, align 8 ; call prim_null_63
  %cmpptr13313 = alloca i1, align 8  %cmp13310 = icmp eq i64 %n_638723, 15 store volatile i1 %cmp13310, i1* %cmpptr13313, align 8; false?
  br i1 %cmp13310, label %else13312, label %then13311                                ; if

then13311:
 %vptr13314 = alloca i64, align 8 
  %h8724 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8724, i64* %vptr13314, align 8 ; call prim_halt
  %vptr13320 = alloca i64*, align 8 
  %cloptr13315 = inttoptr i64 %h8724 to i64* 
  store volatile i64* %cloptr13315, i64** %vptr13320, align 8 ; closure/env cast; i64 -> i64*
  %vptr13321 = alloca i64*, align 8 
  %i0ptr13316 = getelementptr inbounds i64, i64* %cloptr13315, i64 1 
  store volatile i64* %i0ptr13316, i64** %vptr13321, align 8 ; &cloptr13315[1]
 %vptr13322 = alloca i64, align 8 
  %f13318 = load i64, i64* %i0ptr13316, align 8 
  store volatile i64 %f13318, i64* %vptr13322, align 8 ; load; *i0ptr13316
  %fptr13317 = inttoptr i64 %f13318 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13317(i64 %h8724, i64 %h8724)                       ; tail call
  ret void

else13312:
 %vptr13323 = alloca i64, align 8 
  %NCW$lst = call i64 @prim_car(i64 %rvp8718) 
  store volatile i64 %NCW$lst, i64* %vptr13323, align 8 ; call prim_car
 %vptr13324 = alloca i64, align 8 
  %rvp8714 = call i64 @prim_cdr(i64 %rvp8718) 
  store volatile i64 %rvp8714, i64* %vptr13324, align 8 ; call prim_cdr
 %vptr13325 = alloca i64, align 8 
  %n_638719 = call i64 @prim_null_63(i64 %rvp8714) 
  store volatile i64 %n_638719, i64* %vptr13325, align 8 ; call prim_null_63
  %cmpptr13329 = alloca i1, align 8  %cmp13326 = icmp eq i64 %n_638719, 15 store volatile i1 %cmp13326, i1* %cmpptr13329, align 8; false?
  br i1 %cmp13326, label %else13328, label %then13327                                ; if

then13327:
 %vptr13330 = alloca i64, align 8 
  %h8720 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8720, i64* %vptr13330, align 8 ; call prim_halt
  %vptr13336 = alloca i64*, align 8 
  %cloptr13331 = inttoptr i64 %h8720 to i64* 
  store volatile i64* %cloptr13331, i64** %vptr13336, align 8 ; closure/env cast; i64 -> i64*
  %vptr13337 = alloca i64*, align 8 
  %i0ptr13332 = getelementptr inbounds i64, i64* %cloptr13331, i64 1 
  store volatile i64* %i0ptr13332, i64** %vptr13337, align 8 ; &cloptr13331[1]
 %vptr13338 = alloca i64, align 8 
  %f13334 = load i64, i64* %i0ptr13332, align 8 
  store volatile i64 %f13334, i64* %vptr13338, align 8 ; load; *i0ptr13332
  %fptr13333 = inttoptr i64 %f13334 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13333(i64 %h8720, i64 %h8720)                       ; tail call
  ret void

else13328:
 %vptr13339 = alloca i64, align 8 
  %qwS$n = call i64 @prim_car(i64 %rvp8714) 
  store volatile i64 %qwS$n, i64* %vptr13339, align 8 ; call prim_car
 %vptr13340 = alloca i64, align 8 
  %na8696 = call i64 @prim_cdr(i64 %rvp8714) 
  store volatile i64 %na8696, i64* %vptr13340, align 8 ; call prim_cdr
 %vptr13341 = alloca i64, align 8 
  %n_638715 = call i64 @prim_null_63(i64 %na8696) 
  store volatile i64 %n_638715, i64* %vptr13341, align 8 ; call prim_null_63
  %cmpptr13345 = alloca i1, align 8  %cmp13342 = icmp eq i64 %n_638715, 15 store volatile i1 %cmp13342, i1* %cmpptr13345, align 8; false?
  br i1 %cmp13342, label %else13344, label %then13343                                ; if

then13343:
  %vptr13355 = alloca i64*, align 8 
  %cloptr13346 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr13346, i64** %vptr13355, align 8 ; malloc
  %vptr13356 = alloca i64*, align 8 
  %eptr13348 = getelementptr inbounds i64, i64* %cloptr13346, i64 2 
  store volatile i64* %eptr13348, i64** %vptr13356, align 8 ; &eptr13348[1]
  %vptr13357 = alloca i64*, align 8 
  %eptr13349 = getelementptr inbounds i64, i64* %cloptr13346, i64 3 
  store volatile i64* %eptr13349, i64** %vptr13357, align 8 ; &eptr13349[2]
  %vptr13358 = alloca i64*, align 8 
  %eptr13350 = getelementptr inbounds i64, i64* %cloptr13346, i64 4 
  store volatile i64* %eptr13350, i64** %vptr13358, align 8 ; &eptr13350[3]
  %vptr13359 = alloca i64*, align 8 
  %eptr13351 = getelementptr inbounds i64, i64* %cloptr13346, i64 5 
  store volatile i64* %eptr13351, i64** %vptr13359, align 8 ; &eptr13351[4]
  %vptr13360 = alloca i64*, align 8 
  %eptr13352 = getelementptr inbounds i64, i64* %cloptr13346, i64 6 
  store volatile i64* %eptr13352, i64** %vptr13360, align 8 ; &eptr13352[5]
  %vptr13361 = alloca i64*, align 8 
  %eptr13353 = getelementptr inbounds i64, i64* %cloptr13346, i64 7 
  store volatile i64* %eptr13353, i64** %vptr13361, align 8 ; &eptr13353[6]
  store i64 %emsg18637, i64* %eptr13348                                              ; *eptr13348 = %emsg18637
  store i64 %cont7096, i64* %eptr13349                                               ; *eptr13349 = %cont7096
  store i64 %NCW$lst, i64* %eptr13350                                                ; *eptr13350 = %NCW$lst
  store i64 %qwS$n, i64* %eptr13351                                                  ; *eptr13351 = %qwS$n
  store i64 %emsg08636, i64* %eptr13352                                              ; *eptr13352 = %emsg08636
  store i64 %LF0$_37take, i64* %eptr13353                                            ; *eptr13353 = %LF0$_37take
  %vptr13362 = alloca i64*, align 8 
  %eptr13347 = getelementptr inbounds i64, i64* %cloptr13346, i64 1 
  store volatile i64* %eptr13347, i64** %vptr13362, align 8 ; &cloptr13346[1]
 %vptr13363 = alloca i64, align 8 
  %f13354 = ptrtoint void(i64,i64)* @lam12416 to i64 
  store volatile i64 %f13354, i64* %vptr13363, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f13354, i64* %eptr13347                                                 ; store fptr
 %vptr13364 = alloca i64, align 8 
  %arg7397 = ptrtoint i64* %cloptr13346 to i64 
  store volatile i64 %arg7397, i64* %vptr13364, align 8 ; closure cast; i64* -> i64
 %vptr13365 = alloca i64, align 8 
  %rva8713 = add i64 0, 0 
  store volatile i64 %rva8713, i64* %vptr13365, align 8 ; quoted ()
 %vptr13366 = alloca i64, align 8 
  %rva8712 = call i64 @prim_cons(i64 %NCW$lst, i64 %rva8713) 
  store volatile i64 %rva8712, i64* %vptr13366, align 8 ; call prim_cons
 %vptr13367 = alloca i64, align 8 
  %rva8711 = call i64 @prim_cons(i64 %arg7397, i64 %rva8712) 
  store volatile i64 %rva8711, i64* %vptr13367, align 8 ; call prim_cons
  %vptr13373 = alloca i64*, align 8 
  %cloptr13368 = inttoptr i64 %Jup$_37length to i64* 
  store volatile i64* %cloptr13368, i64** %vptr13373, align 8 ; closure/env cast; i64 -> i64*
  %vptr13374 = alloca i64*, align 8 
  %i0ptr13369 = getelementptr inbounds i64, i64* %cloptr13368, i64 1 
  store volatile i64* %i0ptr13369, i64** %vptr13374, align 8 ; &cloptr13368[1]
 %vptr13375 = alloca i64, align 8 
  %f13371 = load i64, i64* %i0ptr13369, align 8 
  store volatile i64 %f13371, i64* %vptr13375, align 8 ; load; *i0ptr13369
  %fptr13370 = inttoptr i64 %f13371 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13370(i64 %Jup$_37length, i64 %rva8711)             ; tail call
  ret void

else13344:
 %vptr13376 = alloca i64, align 8 
  %h8716 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h8716, i64* %vptr13376, align 8 ; call prim_halt
  %vptr13382 = alloca i64*, align 8 
  %cloptr13377 = inttoptr i64 %h8716 to i64* 
  store volatile i64* %cloptr13377, i64** %vptr13382, align 8 ; closure/env cast; i64 -> i64*
  %vptr13383 = alloca i64*, align 8 
  %i0ptr13378 = getelementptr inbounds i64, i64* %cloptr13377, i64 1 
  store volatile i64* %i0ptr13378, i64** %vptr13383, align 8 ; &cloptr13377[1]
 %vptr13384 = alloca i64, align 8 
  %f13380 = load i64, i64* %i0ptr13378, align 8 
  store volatile i64 %f13380, i64* %vptr13384, align 8 ; load; *i0ptr13378
  %fptr13379 = inttoptr i64 %f13380 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13379(i64 %h8716, i64 %h8716)                       ; tail call
  ret void
}


define void @lam12416(i64 %env12417, i64 %rvp8707) {
 %vptr13387 = alloca i64, align 8 
  %envptr13385 = inttoptr i64 %env12417 to i64* 
  store volatile i64 %LF0$_37take, i64* %vptr13387, align 8 ; closure/env cast; i64 -> i64*
  %vptr13388 = alloca i64*, align 8 
  %envptr13386 = getelementptr inbounds i64, i64* %envptr13385, i64 7 
  store volatile i64* %envptr13386, i64** %vptr13388, align 8 ; &envptr13385[6]
 %vptr13389 = alloca i64, align 8 
  %LF0$_37take = load i64, i64* %envptr13386, align 8 
  store volatile i64 %LF0$_37take, i64* %vptr13389, align 8 ; load; *envptr13386
 %vptr13392 = alloca i64, align 8 
  %envptr13390 = inttoptr i64 %env12417 to i64* 
  store volatile i64 %emsg08636, i64* %vptr13392, align 8 ; closure/env cast; i64 -> i64*
  %vptr13393 = alloca i64*, align 8 
  %envptr13391 = getelementptr inbounds i64, i64* %envptr13390, i64 6 
  store volatile i64* %envptr13391, i64** %vptr13393, align 8 ; &envptr13390[5]
 %vptr13394 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr13391, align 8 
  store volatile i64 %emsg08636, i64* %vptr13394, align 8 ; load; *envptr13391
 %vptr13397 = alloca i64, align 8 
  %envptr13395 = inttoptr i64 %env12417 to i64* 
  store volatile i64 %qwS$n, i64* %vptr13397, align 8 ; closure/env cast; i64 -> i64*
  %vptr13398 = alloca i64*, align 8 
  %envptr13396 = getelementptr inbounds i64, i64* %envptr13395, i64 5 
  store volatile i64* %envptr13396, i64** %vptr13398, align 8 ; &envptr13395[4]
 %vptr13399 = alloca i64, align 8 
  %qwS$n = load i64, i64* %envptr13396, align 8 
  store volatile i64 %qwS$n, i64* %vptr13399, align 8 ; load; *envptr13396
 %vptr13402 = alloca i64, align 8 
  %envptr13400 = inttoptr i64 %env12417 to i64* 
  store volatile i64 %NCW$lst, i64* %vptr13402, align 8 ; closure/env cast; i64 -> i64*
  %vptr13403 = alloca i64*, align 8 
  %envptr13401 = getelementptr inbounds i64, i64* %envptr13400, i64 4 
  store volatile i64* %envptr13401, i64** %vptr13403, align 8 ; &envptr13400[3]
 %vptr13404 = alloca i64, align 8 
  %NCW$lst = load i64, i64* %envptr13401, align 8 
  store volatile i64 %NCW$lst, i64* %vptr13404, align 8 ; load; *envptr13401
 %vptr13407 = alloca i64, align 8 
  %envptr13405 = inttoptr i64 %env12417 to i64* 
  store volatile i64 %cont7096, i64* %vptr13407, align 8 ; closure/env cast; i64 -> i64*
  %vptr13408 = alloca i64*, align 8 
  %envptr13406 = getelementptr inbounds i64, i64* %envptr13405, i64 3 
  store volatile i64* %envptr13406, i64** %vptr13408, align 8 ; &envptr13405[2]
 %vptr13409 = alloca i64, align 8 
  %cont7096 = load i64, i64* %envptr13406, align 8 
  store volatile i64 %cont7096, i64* %vptr13409, align 8 ; load; *envptr13406
 %vptr13412 = alloca i64, align 8 
  %envptr13410 = inttoptr i64 %env12417 to i64* 
  store volatile i64 %emsg18637, i64* %vptr13412, align 8 ; closure/env cast; i64 -> i64*
  %vptr13413 = alloca i64*, align 8 
  %envptr13411 = getelementptr inbounds i64, i64* %envptr13410, i64 2 
  store volatile i64* %envptr13411, i64** %vptr13413, align 8 ; &envptr13410[1]
 %vptr13414 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr13411, align 8 
  store volatile i64 %emsg18637, i64* %vptr13414, align 8 ; load; *envptr13411
 %vptr13415 = alloca i64, align 8 
  %_957097 = call i64 @prim_car(i64 %rvp8707) 
  store volatile i64 %_957097, i64* %vptr13415, align 8 ; call prim_car
 %vptr13416 = alloca i64, align 8 
  %rvp8703 = call i64 @prim_cdr(i64 %rvp8707) 
  store volatile i64 %rvp8703, i64* %vptr13416, align 8 ; call prim_cdr
 %vptr13417 = alloca i64, align 8 
  %n_638708 = call i64 @prim_null_63(i64 %rvp8703) 
  store volatile i64 %n_638708, i64* %vptr13417, align 8 ; call prim_null_63
  %cmpptr13421 = alloca i1, align 8  %cmp13418 = icmp eq i64 %n_638708, 15 store volatile i1 %cmp13418, i1* %cmpptr13421, align 8; false?
  br i1 %cmp13418, label %else13420, label %then13419                                ; if

then13419:
 %vptr13422 = alloca i64, align 8 
  %h8709 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8709, i64* %vptr13422, align 8 ; call prim_halt
  %vptr13428 = alloca i64*, align 8 
  %cloptr13423 = inttoptr i64 %h8709 to i64* 
  store volatile i64* %cloptr13423, i64** %vptr13428, align 8 ; closure/env cast; i64 -> i64*
  %vptr13429 = alloca i64*, align 8 
  %i0ptr13424 = getelementptr inbounds i64, i64* %cloptr13423, i64 1 
  store volatile i64* %i0ptr13424, i64** %vptr13429, align 8 ; &cloptr13423[1]
 %vptr13430 = alloca i64, align 8 
  %f13426 = load i64, i64* %i0ptr13424, align 8 
  store volatile i64 %f13426, i64* %vptr13430, align 8 ; load; *i0ptr13424
  %fptr13425 = inttoptr i64 %f13426 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13425(i64 %h8709, i64 %h8709)                       ; tail call
  ret void

else13420:
 %vptr13431 = alloca i64, align 8 
  %a6931 = call i64 @prim_car(i64 %rvp8703) 
  store volatile i64 %a6931, i64* %vptr13431, align 8 ; call prim_car
 %vptr13432 = alloca i64, align 8 
  %na8698 = call i64 @prim_cdr(i64 %rvp8703) 
  store volatile i64 %na8698, i64* %vptr13432, align 8 ; call prim_cdr
 %vptr13433 = alloca i64, align 8 
  %n_638704 = call i64 @prim_null_63(i64 %na8698) 
  store volatile i64 %n_638704, i64* %vptr13433, align 8 ; call prim_null_63
  %cmpptr13437 = alloca i1, align 8  %cmp13434 = icmp eq i64 %n_638704, 15 store volatile i1 %cmp13434, i1* %cmpptr13437, align 8; false?
  br i1 %cmp13434, label %else13436, label %then13435                                ; if

then13435:
 %vptr13438 = alloca i64, align 8 
  %a6932 = call i64 @prim__45(i64 %a6931, i64 %qwS$n) 
  store volatile i64 %a6932, i64* %vptr13438, align 8 ; call prim__45
 %vptr13439 = alloca i64, align 8 
  %rva8702 = add i64 0, 0 
  store volatile i64 %rva8702, i64* %vptr13439, align 8 ; quoted ()
 %vptr13440 = alloca i64, align 8 
  %rva8701 = call i64 @prim_cons(i64 %a6932, i64 %rva8702) 
  store volatile i64 %rva8701, i64* %vptr13440, align 8 ; call prim_cons
 %vptr13441 = alloca i64, align 8 
  %rva8700 = call i64 @prim_cons(i64 %NCW$lst, i64 %rva8701) 
  store volatile i64 %rva8700, i64* %vptr13441, align 8 ; call prim_cons
 %vptr13442 = alloca i64, align 8 
  %rva8699 = call i64 @prim_cons(i64 %cont7096, i64 %rva8700) 
  store volatile i64 %rva8699, i64* %vptr13442, align 8 ; call prim_cons
  %vptr13448 = alloca i64*, align 8 
  %cloptr13443 = inttoptr i64 %LF0$_37take to i64* 
  store volatile i64* %cloptr13443, i64** %vptr13448, align 8 ; closure/env cast; i64 -> i64*
  %vptr13449 = alloca i64*, align 8 
  %i0ptr13444 = getelementptr inbounds i64, i64* %cloptr13443, i64 1 
  store volatile i64* %i0ptr13444, i64** %vptr13449, align 8 ; &cloptr13443[1]
 %vptr13450 = alloca i64, align 8 
  %f13446 = load i64, i64* %i0ptr13444, align 8 
  store volatile i64 %f13446, i64* %vptr13450, align 8 ; load; *i0ptr13444
  %fptr13445 = inttoptr i64 %f13446 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13445(i64 %LF0$_37take, i64 %rva8699)               ; tail call
  ret void

else13436:
 %vptr13451 = alloca i64, align 8 
  %h8705 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h8705, i64* %vptr13451, align 8 ; call prim_halt
  %vptr13457 = alloca i64*, align 8 
  %cloptr13452 = inttoptr i64 %h8705 to i64* 
  store volatile i64* %cloptr13452, i64** %vptr13457, align 8 ; closure/env cast; i64 -> i64*
  %vptr13458 = alloca i64*, align 8 
  %i0ptr13453 = getelementptr inbounds i64, i64* %cloptr13452, i64 1 
  store volatile i64* %i0ptr13453, i64** %vptr13458, align 8 ; &cloptr13452[1]
 %vptr13459 = alloca i64, align 8 
  %f13455 = load i64, i64* %i0ptr13453, align 8 
  store volatile i64 %f13455, i64* %vptr13459, align 8 ; load; *i0ptr13453
  %fptr13454 = inttoptr i64 %f13455 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13454(i64 %h8705, i64 %h8705)                       ; tail call
  ret void
}


define void @lam12412(i64 %env12413, i64 %rvp10933) {
 %vptr13462 = alloca i64, align 8 
  %envptr13460 = inttoptr i64 %env12413 to i64* 
  store volatile i64 %F5P$_37foldl1, i64* %vptr13462, align 8 ; closure/env cast; i64 -> i64*
  %vptr13463 = alloca i64*, align 8 
  %envptr13461 = getelementptr inbounds i64, i64* %envptr13460, i64 9 
  store volatile i64* %envptr13461, i64** %vptr13463, align 8 ; &envptr13460[8]
 %vptr13464 = alloca i64, align 8 
  %F5P$_37foldl1 = load i64, i64* %envptr13461, align 8 
  store volatile i64 %F5P$_37foldl1, i64* %vptr13464, align 8 ; load; *envptr13461
 %vptr13467 = alloca i64, align 8 
  %envptr13465 = inttoptr i64 %env12413 to i64* 
  store volatile i64 %emsg08636, i64* %vptr13467, align 8 ; closure/env cast; i64 -> i64*
  %vptr13468 = alloca i64*, align 8 
  %envptr13466 = getelementptr inbounds i64, i64* %envptr13465, i64 8 
  store volatile i64* %envptr13466, i64** %vptr13468, align 8 ; &envptr13465[7]
 %vptr13469 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr13466, align 8 
  store volatile i64 %emsg08636, i64* %vptr13469, align 8 ; load; *envptr13466
 %vptr13472 = alloca i64, align 8 
  %envptr13470 = inttoptr i64 %env12413 to i64* 
  store volatile i64 %NOz$Ycmb, i64* %vptr13472, align 8 ; closure/env cast; i64 -> i64*
  %vptr13473 = alloca i64*, align 8 
  %envptr13471 = getelementptr inbounds i64, i64* %envptr13470, i64 7 
  store volatile i64* %envptr13471, i64** %vptr13473, align 8 ; &envptr13470[6]
 %vptr13474 = alloca i64, align 8 
  %NOz$Ycmb = load i64, i64* %envptr13471, align 8 
  store volatile i64 %NOz$Ycmb, i64* %vptr13474, align 8 ; load; *envptr13471
 %vptr13477 = alloca i64, align 8 
  %envptr13475 = inttoptr i64 %env12413 to i64* 
  store volatile i64 %JuU$_37drop_45right, i64* %vptr13477, align 8 ; closure/env cast; i64 -> i64*
  %vptr13478 = alloca i64*, align 8 
  %envptr13476 = getelementptr inbounds i64, i64* %envptr13475, i64 6 
  store volatile i64* %envptr13476, i64** %vptr13478, align 8 ; &envptr13475[5]
 %vptr13479 = alloca i64, align 8 
  %JuU$_37drop_45right = load i64, i64* %envptr13476, align 8 
  store volatile i64 %JuU$_37drop_45right, i64* %vptr13479, align 8 ; load; *envptr13476
 %vptr13482 = alloca i64, align 8 
  %envptr13480 = inttoptr i64 %env12413 to i64* 
  store volatile i64 %L15$_37last, i64* %vptr13482, align 8 ; closure/env cast; i64 -> i64*
  %vptr13483 = alloca i64*, align 8 
  %envptr13481 = getelementptr inbounds i64, i64* %envptr13480, i64 5 
  store volatile i64* %envptr13481, i64** %vptr13483, align 8 ; &envptr13480[4]
 %vptr13484 = alloca i64, align 8 
  %L15$_37last = load i64, i64* %envptr13481, align 8 
  store volatile i64 %L15$_37last, i64* %vptr13484, align 8 ; load; *envptr13481
 %vptr13487 = alloca i64, align 8 
  %envptr13485 = inttoptr i64 %env12413 to i64* 
  store volatile i64 %Jup$_37length, i64* %vptr13487, align 8 ; closure/env cast; i64 -> i64*
  %vptr13488 = alloca i64*, align 8 
  %envptr13486 = getelementptr inbounds i64, i64* %envptr13485, i64 4 
  store volatile i64* %envptr13486, i64** %vptr13488, align 8 ; &envptr13485[3]
 %vptr13489 = alloca i64, align 8 
  %Jup$_37length = load i64, i64* %envptr13486, align 8 
  store volatile i64 %Jup$_37length, i64* %vptr13489, align 8 ; load; *envptr13486
 %vptr13492 = alloca i64, align 8 
  %envptr13490 = inttoptr i64 %env12413 to i64* 
  store volatile i64 %emsg18637, i64* %vptr13492, align 8 ; closure/env cast; i64 -> i64*
  %vptr13493 = alloca i64*, align 8 
  %envptr13491 = getelementptr inbounds i64, i64* %envptr13490, i64 3 
  store volatile i64* %envptr13491, i64** %vptr13493, align 8 ; &envptr13490[2]
 %vptr13494 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr13491, align 8 
  store volatile i64 %emsg18637, i64* %vptr13494, align 8 ; load; *envptr13491
 %vptr13497 = alloca i64, align 8 
  %envptr13495 = inttoptr i64 %env12413 to i64* 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr13497, align 8 ; closure/env cast; i64 -> i64*
  %vptr13498 = alloca i64*, align 8 
  %envptr13496 = getelementptr inbounds i64, i64* %envptr13495, i64 2 
  store volatile i64* %envptr13496, i64** %vptr13498, align 8 ; &envptr13495[1]
 %vptr13499 = alloca i64, align 8 
  %Mcq$_37foldr1 = load i64, i64* %envptr13496, align 8 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr13499, align 8 ; load; *envptr13496
 %vptr13500 = alloca i64, align 8 
  %_957098 = call i64 @prim_car(i64 %rvp10933) 
  store volatile i64 %_957098, i64* %vptr13500, align 8 ; call prim_car
 %vptr13501 = alloca i64, align 8 
  %rvp10929 = call i64 @prim_cdr(i64 %rvp10933) 
  store volatile i64 %rvp10929, i64* %vptr13501, align 8 ; call prim_cdr
 %vptr13502 = alloca i64, align 8 
  %n_6310934 = call i64 @prim_null_63(i64 %rvp10929) 
  store volatile i64 %n_6310934, i64* %vptr13502, align 8 ; call prim_null_63
  %cmpptr13506 = alloca i1, align 8  %cmp13503 = icmp eq i64 %n_6310934, 15 store volatile i1 %cmp13503, i1* %cmpptr13506, align 8; false?
  br i1 %cmp13503, label %else13505, label %then13504                                ; if

then13504:
 %vptr13507 = alloca i64, align 8 
  %h10935 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10935, i64* %vptr13507, align 8 ; call prim_halt
  %vptr13513 = alloca i64*, align 8 
  %cloptr13508 = inttoptr i64 %h10935 to i64* 
  store volatile i64* %cloptr13508, i64** %vptr13513, align 8 ; closure/env cast; i64 -> i64*
  %vptr13514 = alloca i64*, align 8 
  %i0ptr13509 = getelementptr inbounds i64, i64* %cloptr13508, i64 1 
  store volatile i64* %i0ptr13509, i64** %vptr13514, align 8 ; &cloptr13508[1]
 %vptr13515 = alloca i64, align 8 
  %f13511 = load i64, i64* %i0ptr13509, align 8 
  store volatile i64 %f13511, i64* %vptr13515, align 8 ; load; *i0ptr13509
  %fptr13510 = inttoptr i64 %f13511 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13510(i64 %h10935, i64 %h10935)                     ; tail call
  ret void

else13505:
 %vptr13516 = alloca i64, align 8 
  %rC6$_37foldr = call i64 @prim_car(i64 %rvp10929) 
  store volatile i64 %rC6$_37foldr, i64* %vptr13516, align 8 ; call prim_car
 %vptr13517 = alloca i64, align 8 
  %na8727 = call i64 @prim_cdr(i64 %rvp10929) 
  store volatile i64 %na8727, i64* %vptr13517, align 8 ; call prim_cdr
 %vptr13518 = alloca i64, align 8 
  %n_6310930 = call i64 @prim_null_63(i64 %na8727) 
  store volatile i64 %n_6310930, i64* %vptr13518, align 8 ; call prim_null_63
  %cmpptr13522 = alloca i1, align 8  %cmp13519 = icmp eq i64 %n_6310930, 15 store volatile i1 %cmp13519, i1* %cmpptr13522, align 8; false?
  br i1 %cmp13519, label %else13521, label %then13520                                ; if

then13520:
  %vptr13529 = alloca i64*, align 8 
  %cloptr13523 = call i64* @make_closure(i64 32) 
  store volatile i64* %cloptr13523, i64** %vptr13529, align 8 ; malloc
  %vptr13530 = alloca i64*, align 8 
  %eptr13525 = getelementptr inbounds i64, i64* %cloptr13523, i64 2 
  store volatile i64* %eptr13525, i64** %vptr13530, align 8 ; &eptr13525[1]
  %vptr13531 = alloca i64*, align 8 
  %eptr13526 = getelementptr inbounds i64, i64* %cloptr13523, i64 3 
  store volatile i64* %eptr13526, i64** %vptr13531, align 8 ; &eptr13526[2]
  %vptr13532 = alloca i64*, align 8 
  %eptr13527 = getelementptr inbounds i64, i64* %cloptr13523, i64 4 
  store volatile i64* %eptr13527, i64** %vptr13532, align 8 ; &eptr13527[3]
  store i64 %Mcq$_37foldr1, i64* %eptr13525                                          ; *eptr13525 = %Mcq$_37foldr1
  store i64 %emsg18637, i64* %eptr13526                                              ; *eptr13526 = %emsg18637
  store i64 %emsg08636, i64* %eptr13527                                              ; *eptr13527 = %emsg08636
  %vptr13533 = alloca i64*, align 8 
  %eptr13524 = getelementptr inbounds i64, i64* %cloptr13523, i64 1 
  store volatile i64* %eptr13524, i64** %vptr13533, align 8 ; &cloptr13523[1]
 %vptr13534 = alloca i64, align 8 
  %f13528 = ptrtoint void(i64,i64)* @lam12410 to i64 
  store volatile i64 %f13528, i64* %vptr13534, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f13528, i64* %eptr13524                                                 ; store fptr
 %vptr13535 = alloca i64, align 8 
  %awI$_37map1 = ptrtoint i64* %cloptr13523 to i64 
  store volatile i64 %awI$_37map1, i64* %vptr13535, align 8 ; closure cast; i64* -> i64
  %vptr13544 = alloca i64*, align 8 
  %cloptr13536 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr13536, i64** %vptr13544, align 8 ; malloc
  %vptr13545 = alloca i64*, align 8 
  %eptr13538 = getelementptr inbounds i64, i64* %cloptr13536, i64 2 
  store volatile i64* %eptr13538, i64** %vptr13545, align 8 ; &eptr13538[1]
  %vptr13546 = alloca i64*, align 8 
  %eptr13539 = getelementptr inbounds i64, i64* %cloptr13536, i64 3 
  store volatile i64* %eptr13539, i64** %vptr13546, align 8 ; &eptr13539[2]
  %vptr13547 = alloca i64*, align 8 
  %eptr13540 = getelementptr inbounds i64, i64* %cloptr13536, i64 4 
  store volatile i64* %eptr13540, i64** %vptr13547, align 8 ; &eptr13540[3]
  %vptr13548 = alloca i64*, align 8 
  %eptr13541 = getelementptr inbounds i64, i64* %cloptr13536, i64 5 
  store volatile i64* %eptr13541, i64** %vptr13548, align 8 ; &eptr13541[4]
  %vptr13549 = alloca i64*, align 8 
  %eptr13542 = getelementptr inbounds i64, i64* %cloptr13536, i64 6 
  store volatile i64* %eptr13542, i64** %vptr13549, align 8 ; &eptr13542[5]
  store i64 %rC6$_37foldr, i64* %eptr13538                                           ; *eptr13538 = %rC6$_37foldr
  store i64 %emsg18637, i64* %eptr13539                                              ; *eptr13539 = %emsg18637
  store i64 %L15$_37last, i64* %eptr13540                                            ; *eptr13540 = %L15$_37last
  store i64 %JuU$_37drop_45right, i64* %eptr13541                                    ; *eptr13541 = %JuU$_37drop_45right
  store i64 %emsg08636, i64* %eptr13542                                              ; *eptr13542 = %emsg08636
  %vptr13550 = alloca i64*, align 8 
  %eptr13537 = getelementptr inbounds i64, i64* %cloptr13536, i64 1 
  store volatile i64* %eptr13537, i64** %vptr13550, align 8 ; &cloptr13536[1]
 %vptr13551 = alloca i64, align 8 
  %f13543 = ptrtoint void(i64,i64)* @lam12399 to i64 
  store volatile i64 %f13543, i64* %vptr13551, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f13543, i64* %eptr13537                                                 ; store fptr
 %vptr13552 = alloca i64, align 8 
  %V19$_37map = ptrtoint i64* %cloptr13536 to i64 
  store volatile i64 %V19$_37map, i64* %vptr13552, align 8 ; closure cast; i64* -> i64
  %vptr13560 = alloca i64*, align 8 
  %cloptr13553 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr13553, i64** %vptr13560, align 8 ; malloc
  %vptr13561 = alloca i64*, align 8 
  %eptr13555 = getelementptr inbounds i64, i64* %cloptr13553, i64 2 
  store volatile i64* %eptr13555, i64** %vptr13561, align 8 ; &eptr13555[1]
  %vptr13562 = alloca i64*, align 8 
  %eptr13556 = getelementptr inbounds i64, i64* %cloptr13553, i64 3 
  store volatile i64* %eptr13556, i64** %vptr13562, align 8 ; &eptr13556[2]
  %vptr13563 = alloca i64*, align 8 
  %eptr13557 = getelementptr inbounds i64, i64* %cloptr13553, i64 4 
  store volatile i64* %eptr13557, i64** %vptr13563, align 8 ; &eptr13557[3]
  %vptr13564 = alloca i64*, align 8 
  %eptr13558 = getelementptr inbounds i64, i64* %cloptr13553, i64 5 
  store volatile i64* %eptr13558, i64** %vptr13564, align 8 ; &eptr13558[4]
  store i64 %emsg18637, i64* %eptr13555                                              ; *eptr13555 = %emsg18637
  store i64 %Jup$_37length, i64* %eptr13556                                          ; *eptr13556 = %Jup$_37length
  store i64 %emsg08636, i64* %eptr13557                                              ; *eptr13557 = %emsg08636
  store i64 %F5P$_37foldl1, i64* %eptr13558                                          ; *eptr13558 = %F5P$_37foldl1
  %vptr13565 = alloca i64*, align 8 
  %eptr13554 = getelementptr inbounds i64, i64* %cloptr13553, i64 1 
  store volatile i64* %eptr13554, i64** %vptr13565, align 8 ; &cloptr13553[1]
 %vptr13566 = alloca i64, align 8 
  %f13559 = ptrtoint void(i64,i64)* @lam12383 to i64 
  store volatile i64 %f13559, i64* %vptr13566, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f13559, i64* %eptr13554                                                 ; store fptr
 %vptr13567 = alloca i64, align 8 
  %arg7448 = ptrtoint i64* %cloptr13553 to i64 
  store volatile i64 %arg7448, i64* %vptr13567, align 8 ; closure cast; i64* -> i64
  %vptr13576 = alloca i64*, align 8 
  %cloptr13568 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr13568, i64** %vptr13576, align 8 ; malloc
  %vptr13577 = alloca i64*, align 8 
  %eptr13570 = getelementptr inbounds i64, i64* %cloptr13568, i64 2 
  store volatile i64* %eptr13570, i64** %vptr13577, align 8 ; &eptr13570[1]
  %vptr13578 = alloca i64*, align 8 
  %eptr13571 = getelementptr inbounds i64, i64* %cloptr13568, i64 3 
  store volatile i64* %eptr13571, i64** %vptr13578, align 8 ; &eptr13571[2]
  %vptr13579 = alloca i64*, align 8 
  %eptr13572 = getelementptr inbounds i64, i64* %cloptr13568, i64 4 
  store volatile i64* %eptr13572, i64** %vptr13579, align 8 ; &eptr13572[3]
  %vptr13580 = alloca i64*, align 8 
  %eptr13573 = getelementptr inbounds i64, i64* %cloptr13568, i64 5 
  store volatile i64* %eptr13573, i64** %vptr13580, align 8 ; &eptr13573[4]
  %vptr13581 = alloca i64*, align 8 
  %eptr13574 = getelementptr inbounds i64, i64* %cloptr13568, i64 6 
  store volatile i64* %eptr13574, i64** %vptr13581, align 8 ; &eptr13574[5]
  store i64 %Mcq$_37foldr1, i64* %eptr13570                                          ; *eptr13570 = %Mcq$_37foldr1
  store i64 %rC6$_37foldr, i64* %eptr13571                                           ; *eptr13571 = %rC6$_37foldr
  store i64 %emsg18637, i64* %eptr13572                                              ; *eptr13572 = %emsg18637
  store i64 %emsg08636, i64* %eptr13573                                              ; *eptr13573 = %emsg08636
  store i64 %awI$_37map1, i64* %eptr13574                                            ; *eptr13574 = %awI$_37map1
  %vptr13582 = alloca i64*, align 8 
  %eptr13569 = getelementptr inbounds i64, i64* %cloptr13568, i64 1 
  store volatile i64* %eptr13569, i64** %vptr13582, align 8 ; &cloptr13568[1]
 %vptr13583 = alloca i64, align 8 
  %f13575 = ptrtoint void(i64,i64)* @lam11685 to i64 
  store volatile i64 %f13575, i64* %vptr13583, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f13575, i64* %eptr13569                                                 ; store fptr
 %vptr13584 = alloca i64, align 8 
  %arg7447 = ptrtoint i64* %cloptr13568 to i64 
  store volatile i64 %arg7447, i64* %vptr13584, align 8 ; closure cast; i64* -> i64
 %vptr13585 = alloca i64, align 8 
  %rva10928 = add i64 0, 0 
  store volatile i64 %rva10928, i64* %vptr13585, align 8 ; quoted ()
 %vptr13586 = alloca i64, align 8 
  %rva10927 = call i64 @prim_cons(i64 %arg7447, i64 %rva10928) 
  store volatile i64 %rva10927, i64* %vptr13586, align 8 ; call prim_cons
 %vptr13587 = alloca i64, align 8 
  %rva10926 = call i64 @prim_cons(i64 %arg7448, i64 %rva10927) 
  store volatile i64 %rva10926, i64* %vptr13587, align 8 ; call prim_cons
  %vptr13593 = alloca i64*, align 8 
  %cloptr13588 = inttoptr i64 %NOz$Ycmb to i64* 
  store volatile i64* %cloptr13588, i64** %vptr13593, align 8 ; closure/env cast; i64 -> i64*
  %vptr13594 = alloca i64*, align 8 
  %i0ptr13589 = getelementptr inbounds i64, i64* %cloptr13588, i64 1 
  store volatile i64* %i0ptr13589, i64** %vptr13594, align 8 ; &cloptr13588[1]
 %vptr13595 = alloca i64, align 8 
  %f13591 = load i64, i64* %i0ptr13589, align 8 
  store volatile i64 %f13591, i64* %vptr13595, align 8 ; load; *i0ptr13589
  %fptr13590 = inttoptr i64 %f13591 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13590(i64 %NOz$Ycmb, i64 %rva10926)                 ; tail call
  ret void

else13521:
 %vptr13596 = alloca i64, align 8 
  %h10931 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10931, i64* %vptr13596, align 8 ; call prim_halt
  %vptr13602 = alloca i64*, align 8 
  %cloptr13597 = inttoptr i64 %h10931 to i64* 
  store volatile i64* %cloptr13597, i64** %vptr13602, align 8 ; closure/env cast; i64 -> i64*
  %vptr13603 = alloca i64*, align 8 
  %i0ptr13598 = getelementptr inbounds i64, i64* %cloptr13597, i64 1 
  store volatile i64* %i0ptr13598, i64** %vptr13603, align 8 ; &cloptr13597[1]
 %vptr13604 = alloca i64, align 8 
  %f13600 = load i64, i64* %i0ptr13598, align 8 
  store volatile i64 %f13600, i64* %vptr13604, align 8 ; load; *i0ptr13598
  %fptr13599 = inttoptr i64 %f13600 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13599(i64 %h10931, i64 %h10931)                     ; tail call
  ret void
}


define void @lam12410(i64 %env12411, i64 %rvp8773) {
 %vptr13607 = alloca i64, align 8 
  %envptr13605 = inttoptr i64 %env12411 to i64* 
  store volatile i64 %emsg08636, i64* %vptr13607, align 8 ; closure/env cast; i64 -> i64*
  %vptr13608 = alloca i64*, align 8 
  %envptr13606 = getelementptr inbounds i64, i64* %envptr13605, i64 4 
  store volatile i64* %envptr13606, i64** %vptr13608, align 8 ; &envptr13605[3]
 %vptr13609 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr13606, align 8 
  store volatile i64 %emsg08636, i64* %vptr13609, align 8 ; load; *envptr13606
 %vptr13612 = alloca i64, align 8 
  %envptr13610 = inttoptr i64 %env12411 to i64* 
  store volatile i64 %emsg18637, i64* %vptr13612, align 8 ; closure/env cast; i64 -> i64*
  %vptr13613 = alloca i64*, align 8 
  %envptr13611 = getelementptr inbounds i64, i64* %envptr13610, i64 3 
  store volatile i64* %envptr13611, i64** %vptr13613, align 8 ; &envptr13610[2]
 %vptr13614 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr13611, align 8 
  store volatile i64 %emsg18637, i64* %vptr13614, align 8 ; load; *envptr13611
 %vptr13617 = alloca i64, align 8 
  %envptr13615 = inttoptr i64 %env12411 to i64* 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr13617, align 8 ; closure/env cast; i64 -> i64*
  %vptr13618 = alloca i64*, align 8 
  %envptr13616 = getelementptr inbounds i64, i64* %envptr13615, i64 2 
  store volatile i64* %envptr13616, i64** %vptr13618, align 8 ; &envptr13615[1]
 %vptr13619 = alloca i64, align 8 
  %Mcq$_37foldr1 = load i64, i64* %envptr13616, align 8 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr13619, align 8 ; load; *envptr13616
 %vptr13620 = alloca i64, align 8 
  %cont7099 = call i64 @prim_car(i64 %rvp8773) 
  store volatile i64 %cont7099, i64* %vptr13620, align 8 ; call prim_car
 %vptr13621 = alloca i64, align 8 
  %rvp8769 = call i64 @prim_cdr(i64 %rvp8773) 
  store volatile i64 %rvp8769, i64* %vptr13621, align 8 ; call prim_cdr
 %vptr13622 = alloca i64, align 8 
  %n_638774 = call i64 @prim_null_63(i64 %rvp8769) 
  store volatile i64 %n_638774, i64* %vptr13622, align 8 ; call prim_null_63
  %cmpptr13626 = alloca i1, align 8  %cmp13623 = icmp eq i64 %n_638774, 15 store volatile i1 %cmp13623, i1* %cmpptr13626, align 8; false?
  br i1 %cmp13623, label %else13625, label %then13624                                ; if

then13624:
 %vptr13627 = alloca i64, align 8 
  %h8775 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8775, i64* %vptr13627, align 8 ; call prim_halt
  %vptr13633 = alloca i64*, align 8 
  %cloptr13628 = inttoptr i64 %h8775 to i64* 
  store volatile i64* %cloptr13628, i64** %vptr13633, align 8 ; closure/env cast; i64 -> i64*
  %vptr13634 = alloca i64*, align 8 
  %i0ptr13629 = getelementptr inbounds i64, i64* %cloptr13628, i64 1 
  store volatile i64* %i0ptr13629, i64** %vptr13634, align 8 ; &cloptr13628[1]
 %vptr13635 = alloca i64, align 8 
  %f13631 = load i64, i64* %i0ptr13629, align 8 
  store volatile i64 %f13631, i64* %vptr13635, align 8 ; load; *i0ptr13629
  %fptr13630 = inttoptr i64 %f13631 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13630(i64 %h8775, i64 %h8775)                       ; tail call
  ret void

else13625:
 %vptr13636 = alloca i64, align 8 
  %TJP$f = call i64 @prim_car(i64 %rvp8769) 
  store volatile i64 %TJP$f, i64* %vptr13636, align 8 ; call prim_car
 %vptr13637 = alloca i64, align 8 
  %rvp8765 = call i64 @prim_cdr(i64 %rvp8769) 
  store volatile i64 %rvp8765, i64* %vptr13637, align 8 ; call prim_cdr
 %vptr13638 = alloca i64, align 8 
  %n_638770 = call i64 @prim_null_63(i64 %rvp8765) 
  store volatile i64 %n_638770, i64* %vptr13638, align 8 ; call prim_null_63
  %cmpptr13642 = alloca i1, align 8  %cmp13639 = icmp eq i64 %n_638770, 15 store volatile i1 %cmp13639, i1* %cmpptr13642, align 8; false?
  br i1 %cmp13639, label %else13641, label %then13640                                ; if

then13640:
 %vptr13643 = alloca i64, align 8 
  %h8771 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8771, i64* %vptr13643, align 8 ; call prim_halt
  %vptr13649 = alloca i64*, align 8 
  %cloptr13644 = inttoptr i64 %h8771 to i64* 
  store volatile i64* %cloptr13644, i64** %vptr13649, align 8 ; closure/env cast; i64 -> i64*
  %vptr13650 = alloca i64*, align 8 
  %i0ptr13645 = getelementptr inbounds i64, i64* %cloptr13644, i64 1 
  store volatile i64* %i0ptr13645, i64** %vptr13650, align 8 ; &cloptr13644[1]
 %vptr13651 = alloca i64, align 8 
  %f13647 = load i64, i64* %i0ptr13645, align 8 
  store volatile i64 %f13647, i64* %vptr13651, align 8 ; load; *i0ptr13645
  %fptr13646 = inttoptr i64 %f13647 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13646(i64 %h8771, i64 %h8771)                       ; tail call
  ret void

else13641:
 %vptr13652 = alloca i64, align 8 
  %hhO$lst = call i64 @prim_car(i64 %rvp8765) 
  store volatile i64 %hhO$lst, i64* %vptr13652, align 8 ; call prim_car
 %vptr13653 = alloca i64, align 8 
  %na8729 = call i64 @prim_cdr(i64 %rvp8765) 
  store volatile i64 %na8729, i64* %vptr13653, align 8 ; call prim_cdr
 %vptr13654 = alloca i64, align 8 
  %n_638766 = call i64 @prim_null_63(i64 %na8729) 
  store volatile i64 %n_638766, i64* %vptr13654, align 8 ; call prim_null_63
  %cmpptr13658 = alloca i1, align 8  %cmp13655 = icmp eq i64 %n_638766, 15 store volatile i1 %cmp13655, i1* %cmpptr13658, align 8; false?
  br i1 %cmp13655, label %else13657, label %then13656                                ; if

then13656:
  %vptr13665 = alloca i64*, align 8 
  %cloptr13659 = call i64* @make_closure(i64 32) 
  store volatile i64* %cloptr13659, i64** %vptr13665, align 8 ; malloc
  %vptr13666 = alloca i64*, align 8 
  %eptr13661 = getelementptr inbounds i64, i64* %cloptr13659, i64 2 
  store volatile i64* %eptr13661, i64** %vptr13666, align 8 ; &eptr13661[1]
  %vptr13667 = alloca i64*, align 8 
  %eptr13662 = getelementptr inbounds i64, i64* %cloptr13659, i64 3 
  store volatile i64* %eptr13662, i64** %vptr13667, align 8 ; &eptr13662[2]
  %vptr13668 = alloca i64*, align 8 
  %eptr13663 = getelementptr inbounds i64, i64* %cloptr13659, i64 4 
  store volatile i64* %eptr13663, i64** %vptr13668, align 8 ; &eptr13663[3]
  store i64 %emsg18637, i64* %eptr13661                                              ; *eptr13661 = %emsg18637
  store i64 %TJP$f, i64* %eptr13662                                                  ; *eptr13662 = %TJP$f
  store i64 %emsg08636, i64* %eptr13663                                              ; *eptr13663 = %emsg08636
  %vptr13669 = alloca i64*, align 8 
  %eptr13660 = getelementptr inbounds i64, i64* %cloptr13659, i64 1 
  store volatile i64* %eptr13660, i64** %vptr13669, align 8 ; &cloptr13659[1]
 %vptr13670 = alloca i64, align 8 
  %f13664 = ptrtoint void(i64,i64)* @lam12408 to i64 
  store volatile i64 %f13664, i64* %vptr13670, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f13664, i64* %eptr13660                                                 ; store fptr
 %vptr13671 = alloca i64, align 8 
  %arg7410 = ptrtoint i64* %cloptr13659 to i64 
  store volatile i64 %arg7410, i64* %vptr13671, align 8 ; closure cast; i64* -> i64
 %vptr13672 = alloca i64, align 8 
  %arg7409 = add i64 0, 0 
  store volatile i64 %arg7409, i64* %vptr13672, align 8 ; quoted ()
 %vptr13673 = alloca i64, align 8 
  %rva8764 = add i64 0, 0 
  store volatile i64 %rva8764, i64* %vptr13673, align 8 ; quoted ()
 %vptr13674 = alloca i64, align 8 
  %rva8763 = call i64 @prim_cons(i64 %hhO$lst, i64 %rva8764) 
  store volatile i64 %rva8763, i64* %vptr13674, align 8 ; call prim_cons
 %vptr13675 = alloca i64, align 8 
  %rva8762 = call i64 @prim_cons(i64 %arg7409, i64 %rva8763) 
  store volatile i64 %rva8762, i64* %vptr13675, align 8 ; call prim_cons
 %vptr13676 = alloca i64, align 8 
  %rva8761 = call i64 @prim_cons(i64 %arg7410, i64 %rva8762) 
  store volatile i64 %rva8761, i64* %vptr13676, align 8 ; call prim_cons
 %vptr13677 = alloca i64, align 8 
  %rva8760 = call i64 @prim_cons(i64 %cont7099, i64 %rva8761) 
  store volatile i64 %rva8760, i64* %vptr13677, align 8 ; call prim_cons
  %vptr13683 = alloca i64*, align 8 
  %cloptr13678 = inttoptr i64 %Mcq$_37foldr1 to i64* 
  store volatile i64* %cloptr13678, i64** %vptr13683, align 8 ; closure/env cast; i64 -> i64*
  %vptr13684 = alloca i64*, align 8 
  %i0ptr13679 = getelementptr inbounds i64, i64* %cloptr13678, i64 1 
  store volatile i64* %i0ptr13679, i64** %vptr13684, align 8 ; &cloptr13678[1]
 %vptr13685 = alloca i64, align 8 
  %f13681 = load i64, i64* %i0ptr13679, align 8 
  store volatile i64 %f13681, i64* %vptr13685, align 8 ; load; *i0ptr13679
  %fptr13680 = inttoptr i64 %f13681 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13680(i64 %Mcq$_37foldr1, i64 %rva8760)             ; tail call
  ret void

else13657:
 %vptr13686 = alloca i64, align 8 
  %h8767 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h8767, i64* %vptr13686, align 8 ; call prim_halt
  %vptr13692 = alloca i64*, align 8 
  %cloptr13687 = inttoptr i64 %h8767 to i64* 
  store volatile i64* %cloptr13687, i64** %vptr13692, align 8 ; closure/env cast; i64 -> i64*
  %vptr13693 = alloca i64*, align 8 
  %i0ptr13688 = getelementptr inbounds i64, i64* %cloptr13687, i64 1 
  store volatile i64* %i0ptr13688, i64** %vptr13693, align 8 ; &cloptr13687[1]
 %vptr13694 = alloca i64, align 8 
  %f13690 = load i64, i64* %i0ptr13688, align 8 
  store volatile i64 %f13690, i64* %vptr13694, align 8 ; load; *i0ptr13688
  %fptr13689 = inttoptr i64 %f13690 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13689(i64 %h8767, i64 %h8767)                       ; tail call
  ret void
}


define void @lam12408(i64 %env12409, i64 %rvp8756) {
 %vptr13697 = alloca i64, align 8 
  %envptr13695 = inttoptr i64 %env12409 to i64* 
  store volatile i64 %emsg08636, i64* %vptr13697, align 8 ; closure/env cast; i64 -> i64*
  %vptr13698 = alloca i64*, align 8 
  %envptr13696 = getelementptr inbounds i64, i64* %envptr13695, i64 4 
  store volatile i64* %envptr13696, i64** %vptr13698, align 8 ; &envptr13695[3]
 %vptr13699 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr13696, align 8 
  store volatile i64 %emsg08636, i64* %vptr13699, align 8 ; load; *envptr13696
 %vptr13702 = alloca i64, align 8 
  %envptr13700 = inttoptr i64 %env12409 to i64* 
  store volatile i64 %TJP$f, i64* %vptr13702, align 8 ; closure/env cast; i64 -> i64*
  %vptr13703 = alloca i64*, align 8 
  %envptr13701 = getelementptr inbounds i64, i64* %envptr13700, i64 3 
  store volatile i64* %envptr13701, i64** %vptr13703, align 8 ; &envptr13700[2]
 %vptr13704 = alloca i64, align 8 
  %TJP$f = load i64, i64* %envptr13701, align 8 
  store volatile i64 %TJP$f, i64* %vptr13704, align 8 ; load; *envptr13701
 %vptr13707 = alloca i64, align 8 
  %envptr13705 = inttoptr i64 %env12409 to i64* 
  store volatile i64 %emsg18637, i64* %vptr13707, align 8 ; closure/env cast; i64 -> i64*
  %vptr13708 = alloca i64*, align 8 
  %envptr13706 = getelementptr inbounds i64, i64* %envptr13705, i64 2 
  store volatile i64* %envptr13706, i64** %vptr13708, align 8 ; &envptr13705[1]
 %vptr13709 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr13706, align 8 
  store volatile i64 %emsg18637, i64* %vptr13709, align 8 ; load; *envptr13706
 %vptr13710 = alloca i64, align 8 
  %cont7100 = call i64 @prim_car(i64 %rvp8756) 
  store volatile i64 %cont7100, i64* %vptr13710, align 8 ; call prim_car
 %vptr13711 = alloca i64, align 8 
  %rvp8752 = call i64 @prim_cdr(i64 %rvp8756) 
  store volatile i64 %rvp8752, i64* %vptr13711, align 8 ; call prim_cdr
 %vptr13712 = alloca i64, align 8 
  %n_638757 = call i64 @prim_null_63(i64 %rvp8752) 
  store volatile i64 %n_638757, i64* %vptr13712, align 8 ; call prim_null_63
  %cmpptr13716 = alloca i1, align 8  %cmp13713 = icmp eq i64 %n_638757, 15 store volatile i1 %cmp13713, i1* %cmpptr13716, align 8; false?
  br i1 %cmp13713, label %else13715, label %then13714                                ; if

then13714:
 %vptr13717 = alloca i64, align 8 
  %h8758 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8758, i64* %vptr13717, align 8 ; call prim_halt
  %vptr13723 = alloca i64*, align 8 
  %cloptr13718 = inttoptr i64 %h8758 to i64* 
  store volatile i64* %cloptr13718, i64** %vptr13723, align 8 ; closure/env cast; i64 -> i64*
  %vptr13724 = alloca i64*, align 8 
  %i0ptr13719 = getelementptr inbounds i64, i64* %cloptr13718, i64 1 
  store volatile i64* %i0ptr13719, i64** %vptr13724, align 8 ; &cloptr13718[1]
 %vptr13725 = alloca i64, align 8 
  %f13721 = load i64, i64* %i0ptr13719, align 8 
  store volatile i64 %f13721, i64* %vptr13725, align 8 ; load; *i0ptr13719
  %fptr13720 = inttoptr i64 %f13721 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13720(i64 %h8758, i64 %h8758)                       ; tail call
  ret void

else13715:
 %vptr13726 = alloca i64, align 8 
  %qEB$v = call i64 @prim_car(i64 %rvp8752) 
  store volatile i64 %qEB$v, i64* %vptr13726, align 8 ; call prim_car
 %vptr13727 = alloca i64, align 8 
  %rvp8748 = call i64 @prim_cdr(i64 %rvp8752) 
  store volatile i64 %rvp8748, i64* %vptr13727, align 8 ; call prim_cdr
 %vptr13728 = alloca i64, align 8 
  %n_638753 = call i64 @prim_null_63(i64 %rvp8748) 
  store volatile i64 %n_638753, i64* %vptr13728, align 8 ; call prim_null_63
  %cmpptr13732 = alloca i1, align 8  %cmp13729 = icmp eq i64 %n_638753, 15 store volatile i1 %cmp13729, i1* %cmpptr13732, align 8; false?
  br i1 %cmp13729, label %else13731, label %then13730                                ; if

then13730:
 %vptr13733 = alloca i64, align 8 
  %h8754 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8754, i64* %vptr13733, align 8 ; call prim_halt
  %vptr13739 = alloca i64*, align 8 
  %cloptr13734 = inttoptr i64 %h8754 to i64* 
  store volatile i64* %cloptr13734, i64** %vptr13739, align 8 ; closure/env cast; i64 -> i64*
  %vptr13740 = alloca i64*, align 8 
  %i0ptr13735 = getelementptr inbounds i64, i64* %cloptr13734, i64 1 
  store volatile i64* %i0ptr13735, i64** %vptr13740, align 8 ; &cloptr13734[1]
 %vptr13741 = alloca i64, align 8 
  %f13737 = load i64, i64* %i0ptr13735, align 8 
  store volatile i64 %f13737, i64* %vptr13741, align 8 ; load; *i0ptr13735
  %fptr13736 = inttoptr i64 %f13737 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13736(i64 %h8754, i64 %h8754)                       ; tail call
  ret void

else13731:
 %vptr13742 = alloca i64, align 8 
  %HYT$r = call i64 @prim_car(i64 %rvp8748) 
  store volatile i64 %HYT$r, i64* %vptr13742, align 8 ; call prim_car
 %vptr13743 = alloca i64, align 8 
  %na8731 = call i64 @prim_cdr(i64 %rvp8748) 
  store volatile i64 %na8731, i64* %vptr13743, align 8 ; call prim_cdr
 %vptr13744 = alloca i64, align 8 
  %n_638749 = call i64 @prim_null_63(i64 %na8731) 
  store volatile i64 %n_638749, i64* %vptr13744, align 8 ; call prim_null_63
  %cmpptr13748 = alloca i1, align 8  %cmp13745 = icmp eq i64 %n_638749, 15 store volatile i1 %cmp13745, i1* %cmpptr13748, align 8; false?
  br i1 %cmp13745, label %else13747, label %then13746                                ; if

then13746:
  %vptr13756 = alloca i64*, align 8 
  %cloptr13749 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr13749, i64** %vptr13756, align 8 ; malloc
  %vptr13757 = alloca i64*, align 8 
  %eptr13751 = getelementptr inbounds i64, i64* %cloptr13749, i64 2 
  store volatile i64* %eptr13751, i64** %vptr13757, align 8 ; &eptr13751[1]
  %vptr13758 = alloca i64*, align 8 
  %eptr13752 = getelementptr inbounds i64, i64* %cloptr13749, i64 3 
  store volatile i64* %eptr13752, i64** %vptr13758, align 8 ; &eptr13752[2]
  %vptr13759 = alloca i64*, align 8 
  %eptr13753 = getelementptr inbounds i64, i64* %cloptr13749, i64 4 
  store volatile i64* %eptr13753, i64** %vptr13759, align 8 ; &eptr13753[3]
  %vptr13760 = alloca i64*, align 8 
  %eptr13754 = getelementptr inbounds i64, i64* %cloptr13749, i64 5 
  store volatile i64* %eptr13754, i64** %vptr13760, align 8 ; &eptr13754[4]
  store i64 %emsg18637, i64* %eptr13751                                              ; *eptr13751 = %emsg18637
  store i64 %emsg08636, i64* %eptr13752                                              ; *eptr13752 = %emsg08636
  store i64 %cont7100, i64* %eptr13753                                               ; *eptr13753 = %cont7100
  store i64 %HYT$r, i64* %eptr13754                                                  ; *eptr13754 = %HYT$r
  %vptr13761 = alloca i64*, align 8 
  %eptr13750 = getelementptr inbounds i64, i64* %cloptr13749, i64 1 
  store volatile i64* %eptr13750, i64** %vptr13761, align 8 ; &cloptr13749[1]
 %vptr13762 = alloca i64, align 8 
  %f13755 = ptrtoint void(i64,i64)* @lam12406 to i64 
  store volatile i64 %f13755, i64* %vptr13762, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f13755, i64* %eptr13750                                                 ; store fptr
 %vptr13763 = alloca i64, align 8 
  %arg7414 = ptrtoint i64* %cloptr13749 to i64 
  store volatile i64 %arg7414, i64* %vptr13763, align 8 ; closure cast; i64* -> i64
 %vptr13764 = alloca i64, align 8 
  %rva8747 = add i64 0, 0 
  store volatile i64 %rva8747, i64* %vptr13764, align 8 ; quoted ()
 %vptr13765 = alloca i64, align 8 
  %rva8746 = call i64 @prim_cons(i64 %qEB$v, i64 %rva8747) 
  store volatile i64 %rva8746, i64* %vptr13765, align 8 ; call prim_cons
 %vptr13766 = alloca i64, align 8 
  %rva8745 = call i64 @prim_cons(i64 %arg7414, i64 %rva8746) 
  store volatile i64 %rva8745, i64* %vptr13766, align 8 ; call prim_cons
  %vptr13772 = alloca i64*, align 8 
  %cloptr13767 = inttoptr i64 %TJP$f to i64* 
  store volatile i64* %cloptr13767, i64** %vptr13772, align 8 ; closure/env cast; i64 -> i64*
  %vptr13773 = alloca i64*, align 8 
  %i0ptr13768 = getelementptr inbounds i64, i64* %cloptr13767, i64 1 
  store volatile i64* %i0ptr13768, i64** %vptr13773, align 8 ; &cloptr13767[1]
 %vptr13774 = alloca i64, align 8 
  %f13770 = load i64, i64* %i0ptr13768, align 8 
  store volatile i64 %f13770, i64* %vptr13774, align 8 ; load; *i0ptr13768
  %fptr13769 = inttoptr i64 %f13770 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13769(i64 %TJP$f, i64 %rva8745)                     ; tail call
  ret void

else13747:
 %vptr13775 = alloca i64, align 8 
  %h8750 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h8750, i64* %vptr13775, align 8 ; call prim_halt
  %vptr13781 = alloca i64*, align 8 
  %cloptr13776 = inttoptr i64 %h8750 to i64* 
  store volatile i64* %cloptr13776, i64** %vptr13781, align 8 ; closure/env cast; i64 -> i64*
  %vptr13782 = alloca i64*, align 8 
  %i0ptr13777 = getelementptr inbounds i64, i64* %cloptr13776, i64 1 
  store volatile i64* %i0ptr13777, i64** %vptr13782, align 8 ; &cloptr13776[1]
 %vptr13783 = alloca i64, align 8 
  %f13779 = load i64, i64* %i0ptr13777, align 8 
  store volatile i64 %f13779, i64* %vptr13783, align 8 ; load; *i0ptr13777
  %fptr13778 = inttoptr i64 %f13779 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13778(i64 %h8750, i64 %h8750)                       ; tail call
  ret void
}


define void @lam12406(i64 %env12407, i64 %rvp8741) {
 %vptr13786 = alloca i64, align 8 
  %envptr13784 = inttoptr i64 %env12407 to i64* 
  store volatile i64 %HYT$r, i64* %vptr13786, align 8 ; closure/env cast; i64 -> i64*
  %vptr13787 = alloca i64*, align 8 
  %envptr13785 = getelementptr inbounds i64, i64* %envptr13784, i64 5 
  store volatile i64* %envptr13785, i64** %vptr13787, align 8 ; &envptr13784[4]
 %vptr13788 = alloca i64, align 8 
  %HYT$r = load i64, i64* %envptr13785, align 8 
  store volatile i64 %HYT$r, i64* %vptr13788, align 8 ; load; *envptr13785
 %vptr13791 = alloca i64, align 8 
  %envptr13789 = inttoptr i64 %env12407 to i64* 
  store volatile i64 %cont7100, i64* %vptr13791, align 8 ; closure/env cast; i64 -> i64*
  %vptr13792 = alloca i64*, align 8 
  %envptr13790 = getelementptr inbounds i64, i64* %envptr13789, i64 4 
  store volatile i64* %envptr13790, i64** %vptr13792, align 8 ; &envptr13789[3]
 %vptr13793 = alloca i64, align 8 
  %cont7100 = load i64, i64* %envptr13790, align 8 
  store volatile i64 %cont7100, i64* %vptr13793, align 8 ; load; *envptr13790
 %vptr13796 = alloca i64, align 8 
  %envptr13794 = inttoptr i64 %env12407 to i64* 
  store volatile i64 %emsg08636, i64* %vptr13796, align 8 ; closure/env cast; i64 -> i64*
  %vptr13797 = alloca i64*, align 8 
  %envptr13795 = getelementptr inbounds i64, i64* %envptr13794, i64 3 
  store volatile i64* %envptr13795, i64** %vptr13797, align 8 ; &envptr13794[2]
 %vptr13798 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr13795, align 8 
  store volatile i64 %emsg08636, i64* %vptr13798, align 8 ; load; *envptr13795
 %vptr13801 = alloca i64, align 8 
  %envptr13799 = inttoptr i64 %env12407 to i64* 
  store volatile i64 %emsg18637, i64* %vptr13801, align 8 ; closure/env cast; i64 -> i64*
  %vptr13802 = alloca i64*, align 8 
  %envptr13800 = getelementptr inbounds i64, i64* %envptr13799, i64 2 
  store volatile i64* %envptr13800, i64** %vptr13802, align 8 ; &envptr13799[1]
 %vptr13803 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr13800, align 8 
  store volatile i64 %emsg18637, i64* %vptr13803, align 8 ; load; *envptr13800
 %vptr13804 = alloca i64, align 8 
  %_957101 = call i64 @prim_car(i64 %rvp8741) 
  store volatile i64 %_957101, i64* %vptr13804, align 8 ; call prim_car
 %vptr13805 = alloca i64, align 8 
  %rvp8737 = call i64 @prim_cdr(i64 %rvp8741) 
  store volatile i64 %rvp8737, i64* %vptr13805, align 8 ; call prim_cdr
 %vptr13806 = alloca i64, align 8 
  %n_638742 = call i64 @prim_null_63(i64 %rvp8737) 
  store volatile i64 %n_638742, i64* %vptr13806, align 8 ; call prim_null_63
  %cmpptr13810 = alloca i1, align 8  %cmp13807 = icmp eq i64 %n_638742, 15 store volatile i1 %cmp13807, i1* %cmpptr13810, align 8; false?
  br i1 %cmp13807, label %else13809, label %then13808                                ; if

then13808:
 %vptr13811 = alloca i64, align 8 
  %h8743 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8743, i64* %vptr13811, align 8 ; call prim_halt
  %vptr13817 = alloca i64*, align 8 
  %cloptr13812 = inttoptr i64 %h8743 to i64* 
  store volatile i64* %cloptr13812, i64** %vptr13817, align 8 ; closure/env cast; i64 -> i64*
  %vptr13818 = alloca i64*, align 8 
  %i0ptr13813 = getelementptr inbounds i64, i64* %cloptr13812, i64 1 
  store volatile i64* %i0ptr13813, i64** %vptr13818, align 8 ; &cloptr13812[1]
 %vptr13819 = alloca i64, align 8 
  %f13815 = load i64, i64* %i0ptr13813, align 8 
  store volatile i64 %f13815, i64* %vptr13819, align 8 ; load; *i0ptr13813
  %fptr13814 = inttoptr i64 %f13815 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13814(i64 %h8743, i64 %h8743)                       ; tail call
  ret void

else13809:
 %vptr13820 = alloca i64, align 8 
  %a6941 = call i64 @prim_car(i64 %rvp8737) 
  store volatile i64 %a6941, i64* %vptr13820, align 8 ; call prim_car
 %vptr13821 = alloca i64, align 8 
  %na8733 = call i64 @prim_cdr(i64 %rvp8737) 
  store volatile i64 %na8733, i64* %vptr13821, align 8 ; call prim_cdr
 %vptr13822 = alloca i64, align 8 
  %n_638738 = call i64 @prim_null_63(i64 %na8733) 
  store volatile i64 %n_638738, i64* %vptr13822, align 8 ; call prim_null_63
  %cmpptr13826 = alloca i1, align 8  %cmp13823 = icmp eq i64 %n_638738, 15 store volatile i1 %cmp13823, i1* %cmpptr13826, align 8; false?
  br i1 %cmp13823, label %else13825, label %then13824                                ; if

then13824:
 %vptr13827 = alloca i64, align 8 
  %retprim7102 = call i64 @prim_cons(i64 %a6941, i64 %HYT$r) 
  store volatile i64 %retprim7102, i64* %vptr13827, align 8 ; call prim_cons
 %vptr13828 = alloca i64, align 8 
  %arg7419 = add i64 0, 0 
  store volatile i64 %arg7419, i64* %vptr13828, align 8 ; quoted ()
 %vptr13829 = alloca i64, align 8 
  %rva8736 = add i64 0, 0 
  store volatile i64 %rva8736, i64* %vptr13829, align 8 ; quoted ()
 %vptr13830 = alloca i64, align 8 
  %rva8735 = call i64 @prim_cons(i64 %retprim7102, i64 %rva8736) 
  store volatile i64 %rva8735, i64* %vptr13830, align 8 ; call prim_cons
 %vptr13831 = alloca i64, align 8 
  %rva8734 = call i64 @prim_cons(i64 %arg7419, i64 %rva8735) 
  store volatile i64 %rva8734, i64* %vptr13831, align 8 ; call prim_cons
  %vptr13837 = alloca i64*, align 8 
  %cloptr13832 = inttoptr i64 %cont7100 to i64* 
  store volatile i64* %cloptr13832, i64** %vptr13837, align 8 ; closure/env cast; i64 -> i64*
  %vptr13838 = alloca i64*, align 8 
  %i0ptr13833 = getelementptr inbounds i64, i64* %cloptr13832, i64 1 
  store volatile i64* %i0ptr13833, i64** %vptr13838, align 8 ; &cloptr13832[1]
 %vptr13839 = alloca i64, align 8 
  %f13835 = load i64, i64* %i0ptr13833, align 8 
  store volatile i64 %f13835, i64* %vptr13839, align 8 ; load; *i0ptr13833
  %fptr13834 = inttoptr i64 %f13835 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13834(i64 %cont7100, i64 %rva8734)                  ; tail call
  ret void

else13825:
 %vptr13840 = alloca i64, align 8 
  %h8739 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h8739, i64* %vptr13840, align 8 ; call prim_halt
  %vptr13846 = alloca i64*, align 8 
  %cloptr13841 = inttoptr i64 %h8739 to i64* 
  store volatile i64* %cloptr13841, i64** %vptr13846, align 8 ; closure/env cast; i64 -> i64*
  %vptr13847 = alloca i64*, align 8 
  %i0ptr13842 = getelementptr inbounds i64, i64* %cloptr13841, i64 1 
  store volatile i64* %i0ptr13842, i64** %vptr13847, align 8 ; &cloptr13841[1]
 %vptr13848 = alloca i64, align 8 
  %f13844 = load i64, i64* %i0ptr13842, align 8 
  store volatile i64 %f13844, i64* %vptr13848, align 8 ; load; *i0ptr13842
  %fptr13843 = inttoptr i64 %f13844 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13843(i64 %h8739, i64 %h8739)                       ; tail call
  ret void
}


define void @lam12399(i64 %env12400, i64 %JF4$args7104) {
 %vptr13851 = alloca i64, align 8 
  %envptr13849 = inttoptr i64 %env12400 to i64* 
  store volatile i64 %emsg08636, i64* %vptr13851, align 8 ; closure/env cast; i64 -> i64*
  %vptr13852 = alloca i64*, align 8 
  %envptr13850 = getelementptr inbounds i64, i64* %envptr13849, i64 6 
  store volatile i64* %envptr13850, i64** %vptr13852, align 8 ; &envptr13849[5]
 %vptr13853 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr13850, align 8 
  store volatile i64 %emsg08636, i64* %vptr13853, align 8 ; load; *envptr13850
 %vptr13856 = alloca i64, align 8 
  %envptr13854 = inttoptr i64 %env12400 to i64* 
  store volatile i64 %JuU$_37drop_45right, i64* %vptr13856, align 8 ; closure/env cast; i64 -> i64*
  %vptr13857 = alloca i64*, align 8 
  %envptr13855 = getelementptr inbounds i64, i64* %envptr13854, i64 5 
  store volatile i64* %envptr13855, i64** %vptr13857, align 8 ; &envptr13854[4]
 %vptr13858 = alloca i64, align 8 
  %JuU$_37drop_45right = load i64, i64* %envptr13855, align 8 
  store volatile i64 %JuU$_37drop_45right, i64* %vptr13858, align 8 ; load; *envptr13855
 %vptr13861 = alloca i64, align 8 
  %envptr13859 = inttoptr i64 %env12400 to i64* 
  store volatile i64 %L15$_37last, i64* %vptr13861, align 8 ; closure/env cast; i64 -> i64*
  %vptr13862 = alloca i64*, align 8 
  %envptr13860 = getelementptr inbounds i64, i64* %envptr13859, i64 4 
  store volatile i64* %envptr13860, i64** %vptr13862, align 8 ; &envptr13859[3]
 %vptr13863 = alloca i64, align 8 
  %L15$_37last = load i64, i64* %envptr13860, align 8 
  store volatile i64 %L15$_37last, i64* %vptr13863, align 8 ; load; *envptr13860
 %vptr13866 = alloca i64, align 8 
  %envptr13864 = inttoptr i64 %env12400 to i64* 
  store volatile i64 %emsg18637, i64* %vptr13866, align 8 ; closure/env cast; i64 -> i64*
  %vptr13867 = alloca i64*, align 8 
  %envptr13865 = getelementptr inbounds i64, i64* %envptr13864, i64 3 
  store volatile i64* %envptr13865, i64** %vptr13867, align 8 ; &envptr13864[2]
 %vptr13868 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr13865, align 8 
  store volatile i64 %emsg18637, i64* %vptr13868, align 8 ; load; *envptr13865
 %vptr13871 = alloca i64, align 8 
  %envptr13869 = inttoptr i64 %env12400 to i64* 
  store volatile i64 %rC6$_37foldr, i64* %vptr13871, align 8 ; closure/env cast; i64 -> i64*
  %vptr13872 = alloca i64*, align 8 
  %envptr13870 = getelementptr inbounds i64, i64* %envptr13869, i64 2 
  store volatile i64* %envptr13870, i64** %vptr13872, align 8 ; &envptr13869[1]
 %vptr13873 = alloca i64, align 8 
  %rC6$_37foldr = load i64, i64* %envptr13870, align 8 
  store volatile i64 %rC6$_37foldr, i64* %vptr13873, align 8 ; load; *envptr13870
 %vptr13874 = alloca i64, align 8 
  %cont7103 = call i64 @prim_car(i64 %JF4$args7104) 
  store volatile i64 %cont7103, i64* %vptr13874, align 8 ; call prim_car
 %vptr13875 = alloca i64, align 8 
  %JF4$args = call i64 @prim_cdr(i64 %JF4$args7104) 
  store volatile i64 %JF4$args, i64* %vptr13875, align 8 ; call prim_cdr
 %vptr13876 = alloca i64, align 8 
  %Q2m$f = call i64 @prim_car(i64 %JF4$args) 
  store volatile i64 %Q2m$f, i64* %vptr13876, align 8 ; call prim_car
 %vptr13877 = alloca i64, align 8 
  %pdx$lsts = call i64 @prim_cdr(i64 %JF4$args) 
  store volatile i64 %pdx$lsts, i64* %vptr13877, align 8 ; call prim_cdr
 %vptr13878 = alloca i64, align 8 
  %arg7426 = add i64 0, 0 
  store volatile i64 %arg7426, i64* %vptr13878, align 8 ; quoted ()
 %vptr13879 = alloca i64, align 8 
  %a6945 = call i64 @prim_cons(i64 %arg7426, i64 %pdx$lsts) 
  store volatile i64 %a6945, i64* %vptr13879, align 8 ; call prim_cons
  %vptr13888 = alloca i64*, align 8 
  %cloptr13880 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr13880, i64** %vptr13888, align 8 ; malloc
  %vptr13889 = alloca i64*, align 8 
  %eptr13882 = getelementptr inbounds i64, i64* %cloptr13880, i64 2 
  store volatile i64* %eptr13882, i64** %vptr13889, align 8 ; &eptr13882[1]
  %vptr13890 = alloca i64*, align 8 
  %eptr13883 = getelementptr inbounds i64, i64* %cloptr13880, i64 3 
  store volatile i64* %eptr13883, i64** %vptr13890, align 8 ; &eptr13883[2]
  %vptr13891 = alloca i64*, align 8 
  %eptr13884 = getelementptr inbounds i64, i64* %cloptr13880, i64 4 
  store volatile i64* %eptr13884, i64** %vptr13891, align 8 ; &eptr13884[3]
  %vptr13892 = alloca i64*, align 8 
  %eptr13885 = getelementptr inbounds i64, i64* %cloptr13880, i64 5 
  store volatile i64* %eptr13885, i64** %vptr13892, align 8 ; &eptr13885[4]
  %vptr13893 = alloca i64*, align 8 
  %eptr13886 = getelementptr inbounds i64, i64* %cloptr13880, i64 6 
  store volatile i64* %eptr13886, i64** %vptr13893, align 8 ; &eptr13886[5]
  store i64 %Q2m$f, i64* %eptr13882                                                  ; *eptr13882 = %Q2m$f
  store i64 %emsg18637, i64* %eptr13883                                              ; *eptr13883 = %emsg18637
  store i64 %L15$_37last, i64* %eptr13884                                            ; *eptr13884 = %L15$_37last
  store i64 %JuU$_37drop_45right, i64* %eptr13885                                    ; *eptr13885 = %JuU$_37drop_45right
  store i64 %emsg08636, i64* %eptr13886                                              ; *eptr13886 = %emsg08636
  %vptr13894 = alloca i64*, align 8 
  %eptr13881 = getelementptr inbounds i64, i64* %cloptr13880, i64 1 
  store volatile i64* %eptr13881, i64** %vptr13894, align 8 ; &cloptr13880[1]
 %vptr13895 = alloca i64, align 8 
  %f13887 = ptrtoint void(i64,i64)* @lam12396 to i64 
  store volatile i64 %f13887, i64* %vptr13895, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f13887, i64* %eptr13881                                                 ; store fptr
 %vptr13896 = alloca i64, align 8 
  %arg7428 = ptrtoint i64* %cloptr13880 to i64 
  store volatile i64 %arg7428, i64* %vptr13896, align 8 ; closure cast; i64* -> i64
 %vptr13897 = alloca i64, align 8 
  %a6946 = call i64 @prim_cons(i64 %arg7428, i64 %a6945) 
  store volatile i64 %a6946, i64* %vptr13897, align 8 ; call prim_cons
 %vptr13898 = alloca i64, align 8 
  %cps_45lst7112 = call i64 @prim_cons(i64 %cont7103, i64 %a6946) 
  store volatile i64 %cps_45lst7112, i64* %vptr13898, align 8 ; call prim_cons
  %vptr13904 = alloca i64*, align 8 
  %cloptr13899 = inttoptr i64 %rC6$_37foldr to i64* 
  store volatile i64* %cloptr13899, i64** %vptr13904, align 8 ; closure/env cast; i64 -> i64*
  %vptr13905 = alloca i64*, align 8 
  %i0ptr13900 = getelementptr inbounds i64, i64* %cloptr13899, i64 1 
  store volatile i64* %i0ptr13900, i64** %vptr13905, align 8 ; &cloptr13899[1]
 %vptr13906 = alloca i64, align 8 
  %f13902 = load i64, i64* %i0ptr13900, align 8 
  store volatile i64 %f13902, i64* %vptr13906, align 8 ; load; *i0ptr13900
  %fptr13901 = inttoptr i64 %f13902 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13901(i64 %rC6$_37foldr, i64 %cps_45lst7112)        ; tail call
  ret void
}


define void @lam12396(i64 %env12397, i64 %cTu$fargs7106) {
 %vptr13909 = alloca i64, align 8 
  %envptr13907 = inttoptr i64 %env12397 to i64* 
  store volatile i64 %emsg08636, i64* %vptr13909, align 8 ; closure/env cast; i64 -> i64*
  %vptr13910 = alloca i64*, align 8 
  %envptr13908 = getelementptr inbounds i64, i64* %envptr13907, i64 6 
  store volatile i64* %envptr13908, i64** %vptr13910, align 8 ; &envptr13907[5]
 %vptr13911 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr13908, align 8 
  store volatile i64 %emsg08636, i64* %vptr13911, align 8 ; load; *envptr13908
 %vptr13914 = alloca i64, align 8 
  %envptr13912 = inttoptr i64 %env12397 to i64* 
  store volatile i64 %JuU$_37drop_45right, i64* %vptr13914, align 8 ; closure/env cast; i64 -> i64*
  %vptr13915 = alloca i64*, align 8 
  %envptr13913 = getelementptr inbounds i64, i64* %envptr13912, i64 5 
  store volatile i64* %envptr13913, i64** %vptr13915, align 8 ; &envptr13912[4]
 %vptr13916 = alloca i64, align 8 
  %JuU$_37drop_45right = load i64, i64* %envptr13913, align 8 
  store volatile i64 %JuU$_37drop_45right, i64* %vptr13916, align 8 ; load; *envptr13913
 %vptr13919 = alloca i64, align 8 
  %envptr13917 = inttoptr i64 %env12397 to i64* 
  store volatile i64 %L15$_37last, i64* %vptr13919, align 8 ; closure/env cast; i64 -> i64*
  %vptr13920 = alloca i64*, align 8 
  %envptr13918 = getelementptr inbounds i64, i64* %envptr13917, i64 4 
  store volatile i64* %envptr13918, i64** %vptr13920, align 8 ; &envptr13917[3]
 %vptr13921 = alloca i64, align 8 
  %L15$_37last = load i64, i64* %envptr13918, align 8 
  store volatile i64 %L15$_37last, i64* %vptr13921, align 8 ; load; *envptr13918
 %vptr13924 = alloca i64, align 8 
  %envptr13922 = inttoptr i64 %env12397 to i64* 
  store volatile i64 %emsg18637, i64* %vptr13924, align 8 ; closure/env cast; i64 -> i64*
  %vptr13925 = alloca i64*, align 8 
  %envptr13923 = getelementptr inbounds i64, i64* %envptr13922, i64 3 
  store volatile i64* %envptr13923, i64** %vptr13925, align 8 ; &envptr13922[2]
 %vptr13926 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr13923, align 8 
  store volatile i64 %emsg18637, i64* %vptr13926, align 8 ; load; *envptr13923
 %vptr13929 = alloca i64, align 8 
  %envptr13927 = inttoptr i64 %env12397 to i64* 
  store volatile i64 %Q2m$f, i64* %vptr13929, align 8 ; closure/env cast; i64 -> i64*
  %vptr13930 = alloca i64*, align 8 
  %envptr13928 = getelementptr inbounds i64, i64* %envptr13927, i64 2 
  store volatile i64* %envptr13928, i64** %vptr13930, align 8 ; &envptr13927[1]
 %vptr13931 = alloca i64, align 8 
  %Q2m$f = load i64, i64* %envptr13928, align 8 
  store volatile i64 %Q2m$f, i64* %vptr13931, align 8 ; load; *envptr13928
 %vptr13932 = alloca i64, align 8 
  %cont7105 = call i64 @prim_car(i64 %cTu$fargs7106) 
  store volatile i64 %cont7105, i64* %vptr13932, align 8 ; call prim_car
 %vptr13933 = alloca i64, align 8 
  %cTu$fargs = call i64 @prim_cdr(i64 %cTu$fargs7106) 
  store volatile i64 %cTu$fargs, i64* %vptr13933, align 8 ; call prim_cdr
  %vptr13943 = alloca i64*, align 8 
  %cloptr13934 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr13934, i64** %vptr13943, align 8 ; malloc
  %vptr13944 = alloca i64*, align 8 
  %eptr13936 = getelementptr inbounds i64, i64* %cloptr13934, i64 2 
  store volatile i64* %eptr13936, i64** %vptr13944, align 8 ; &eptr13936[1]
  %vptr13945 = alloca i64*, align 8 
  %eptr13937 = getelementptr inbounds i64, i64* %cloptr13934, i64 3 
  store volatile i64* %eptr13937, i64** %vptr13945, align 8 ; &eptr13937[2]
  %vptr13946 = alloca i64*, align 8 
  %eptr13938 = getelementptr inbounds i64, i64* %cloptr13934, i64 4 
  store volatile i64* %eptr13938, i64** %vptr13946, align 8 ; &eptr13938[3]
  %vptr13947 = alloca i64*, align 8 
  %eptr13939 = getelementptr inbounds i64, i64* %cloptr13934, i64 5 
  store volatile i64* %eptr13939, i64** %vptr13947, align 8 ; &eptr13939[4]
  %vptr13948 = alloca i64*, align 8 
  %eptr13940 = getelementptr inbounds i64, i64* %cloptr13934, i64 6 
  store volatile i64* %eptr13940, i64** %vptr13948, align 8 ; &eptr13940[5]
  %vptr13949 = alloca i64*, align 8 
  %eptr13941 = getelementptr inbounds i64, i64* %cloptr13934, i64 7 
  store volatile i64* %eptr13941, i64** %vptr13949, align 8 ; &eptr13941[6]
  store i64 %Q2m$f, i64* %eptr13936                                                  ; *eptr13936 = %Q2m$f
  store i64 %emsg18637, i64* %eptr13937                                              ; *eptr13937 = %emsg18637
  store i64 %cont7105, i64* %eptr13938                                               ; *eptr13938 = %cont7105
  store i64 %L15$_37last, i64* %eptr13939                                            ; *eptr13939 = %L15$_37last
  store i64 %cTu$fargs, i64* %eptr13940                                              ; *eptr13940 = %cTu$fargs
  store i64 %emsg08636, i64* %eptr13941                                              ; *eptr13941 = %emsg08636
  %vptr13950 = alloca i64*, align 8 
  %eptr13935 = getelementptr inbounds i64, i64* %cloptr13934, i64 1 
  store volatile i64* %eptr13935, i64** %vptr13950, align 8 ; &cloptr13934[1]
 %vptr13951 = alloca i64, align 8 
  %f13942 = ptrtoint void(i64,i64)* @lam12394 to i64 
  store volatile i64 %f13942, i64* %vptr13951, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f13942, i64* %eptr13935                                                 ; store fptr
 %vptr13952 = alloca i64, align 8 
  %arg7433 = ptrtoint i64* %cloptr13934 to i64 
  store volatile i64 %arg7433, i64* %vptr13952, align 8 ; closure cast; i64* -> i64
 %vptr13953 = alloca i64, align 8 
  %arg7431 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg7431, i64* %vptr13953, align 8 ; quoted int
 %vptr13954 = alloca i64, align 8 
  %rva8816 = add i64 0, 0 
  store volatile i64 %rva8816, i64* %vptr13954, align 8 ; quoted ()
 %vptr13955 = alloca i64, align 8 
  %rva8815 = call i64 @prim_cons(i64 %arg7431, i64 %rva8816) 
  store volatile i64 %rva8815, i64* %vptr13955, align 8 ; call prim_cons
 %vptr13956 = alloca i64, align 8 
  %rva8814 = call i64 @prim_cons(i64 %cTu$fargs, i64 %rva8815) 
  store volatile i64 %rva8814, i64* %vptr13956, align 8 ; call prim_cons
 %vptr13957 = alloca i64, align 8 
  %rva8813 = call i64 @prim_cons(i64 %arg7433, i64 %rva8814) 
  store volatile i64 %rva8813, i64* %vptr13957, align 8 ; call prim_cons
  %vptr13963 = alloca i64*, align 8 
  %cloptr13958 = inttoptr i64 %JuU$_37drop_45right to i64* 
  store volatile i64* %cloptr13958, i64** %vptr13963, align 8 ; closure/env cast; i64 -> i64*
  %vptr13964 = alloca i64*, align 8 
  %i0ptr13959 = getelementptr inbounds i64, i64* %cloptr13958, i64 1 
  store volatile i64* %i0ptr13959, i64** %vptr13964, align 8 ; &cloptr13958[1]
 %vptr13965 = alloca i64, align 8 
  %f13961 = load i64, i64* %i0ptr13959, align 8 
  store volatile i64 %f13961, i64* %vptr13965, align 8 ; load; *i0ptr13959
  %fptr13960 = inttoptr i64 %f13961 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr13960(i64 %JuU$_37drop_45right, i64 %rva8813)       ; tail call
  ret void
}


define void @lam12394(i64 %env12395, i64 %rvp8809) {
 %vptr13968 = alloca i64, align 8 
  %envptr13966 = inttoptr i64 %env12395 to i64* 
  store volatile i64 %emsg08636, i64* %vptr13968, align 8 ; closure/env cast; i64 -> i64*
  %vptr13969 = alloca i64*, align 8 
  %envptr13967 = getelementptr inbounds i64, i64* %envptr13966, i64 7 
  store volatile i64* %envptr13967, i64** %vptr13969, align 8 ; &envptr13966[6]
 %vptr13970 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr13967, align 8 
  store volatile i64 %emsg08636, i64* %vptr13970, align 8 ; load; *envptr13967
 %vptr13973 = alloca i64, align 8 
  %envptr13971 = inttoptr i64 %env12395 to i64* 
  store volatile i64 %cTu$fargs, i64* %vptr13973, align 8 ; closure/env cast; i64 -> i64*
  %vptr13974 = alloca i64*, align 8 
  %envptr13972 = getelementptr inbounds i64, i64* %envptr13971, i64 6 
  store volatile i64* %envptr13972, i64** %vptr13974, align 8 ; &envptr13971[5]
 %vptr13975 = alloca i64, align 8 
  %cTu$fargs = load i64, i64* %envptr13972, align 8 
  store volatile i64 %cTu$fargs, i64* %vptr13975, align 8 ; load; *envptr13972
 %vptr13978 = alloca i64, align 8 
  %envptr13976 = inttoptr i64 %env12395 to i64* 
  store volatile i64 %L15$_37last, i64* %vptr13978, align 8 ; closure/env cast; i64 -> i64*
  %vptr13979 = alloca i64*, align 8 
  %envptr13977 = getelementptr inbounds i64, i64* %envptr13976, i64 5 
  store volatile i64* %envptr13977, i64** %vptr13979, align 8 ; &envptr13976[4]
 %vptr13980 = alloca i64, align 8 
  %L15$_37last = load i64, i64* %envptr13977, align 8 
  store volatile i64 %L15$_37last, i64* %vptr13980, align 8 ; load; *envptr13977
 %vptr13983 = alloca i64, align 8 
  %envptr13981 = inttoptr i64 %env12395 to i64* 
  store volatile i64 %cont7105, i64* %vptr13983, align 8 ; closure/env cast; i64 -> i64*
  %vptr13984 = alloca i64*, align 8 
  %envptr13982 = getelementptr inbounds i64, i64* %envptr13981, i64 4 
  store volatile i64* %envptr13982, i64** %vptr13984, align 8 ; &envptr13981[3]
 %vptr13985 = alloca i64, align 8 
  %cont7105 = load i64, i64* %envptr13982, align 8 
  store volatile i64 %cont7105, i64* %vptr13985, align 8 ; load; *envptr13982
 %vptr13988 = alloca i64, align 8 
  %envptr13986 = inttoptr i64 %env12395 to i64* 
  store volatile i64 %emsg18637, i64* %vptr13988, align 8 ; closure/env cast; i64 -> i64*
  %vptr13989 = alloca i64*, align 8 
  %envptr13987 = getelementptr inbounds i64, i64* %envptr13986, i64 3 
  store volatile i64* %envptr13987, i64** %vptr13989, align 8 ; &envptr13986[2]
 %vptr13990 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr13987, align 8 
  store volatile i64 %emsg18637, i64* %vptr13990, align 8 ; load; *envptr13987
 %vptr13993 = alloca i64, align 8 
  %envptr13991 = inttoptr i64 %env12395 to i64* 
  store volatile i64 %Q2m$f, i64* %vptr13993, align 8 ; closure/env cast; i64 -> i64*
  %vptr13994 = alloca i64*, align 8 
  %envptr13992 = getelementptr inbounds i64, i64* %envptr13991, i64 2 
  store volatile i64* %envptr13992, i64** %vptr13994, align 8 ; &envptr13991[1]
 %vptr13995 = alloca i64, align 8 
  %Q2m$f = load i64, i64* %envptr13992, align 8 
  store volatile i64 %Q2m$f, i64* %vptr13995, align 8 ; load; *envptr13992
 %vptr13996 = alloca i64, align 8 
  %_957107 = call i64 @prim_car(i64 %rvp8809) 
  store volatile i64 %_957107, i64* %vptr13996, align 8 ; call prim_car
 %vptr13997 = alloca i64, align 8 
  %rvp8805 = call i64 @prim_cdr(i64 %rvp8809) 
  store volatile i64 %rvp8805, i64* %vptr13997, align 8 ; call prim_cdr
 %vptr13998 = alloca i64, align 8 
  %n_638810 = call i64 @prim_null_63(i64 %rvp8805) 
  store volatile i64 %n_638810, i64* %vptr13998, align 8 ; call prim_null_63
  %cmpptr14002 = alloca i1, align 8  %cmp13999 = icmp eq i64 %n_638810, 15 store volatile i1 %cmp13999, i1* %cmpptr14002, align 8; false?
  br i1 %cmp13999, label %else14001, label %then14000                                ; if

then14000:
 %vptr14003 = alloca i64, align 8 
  %h8811 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8811, i64* %vptr14003, align 8 ; call prim_halt
  %vptr14009 = alloca i64*, align 8 
  %cloptr14004 = inttoptr i64 %h8811 to i64* 
  store volatile i64* %cloptr14004, i64** %vptr14009, align 8 ; closure/env cast; i64 -> i64*
  %vptr14010 = alloca i64*, align 8 
  %i0ptr14005 = getelementptr inbounds i64, i64* %cloptr14004, i64 1 
  store volatile i64* %i0ptr14005, i64** %vptr14010, align 8 ; &cloptr14004[1]
 %vptr14011 = alloca i64, align 8 
  %f14007 = load i64, i64* %i0ptr14005, align 8 
  store volatile i64 %f14007, i64* %vptr14011, align 8 ; load; *i0ptr14005
  %fptr14006 = inttoptr i64 %f14007 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14006(i64 %h8811, i64 %h8811)                       ; tail call
  ret void

else14001:
 %vptr14012 = alloca i64, align 8 
  %a6942 = call i64 @prim_car(i64 %rvp8805) 
  store volatile i64 %a6942, i64* %vptr14012, align 8 ; call prim_car
 %vptr14013 = alloca i64, align 8 
  %na8778 = call i64 @prim_cdr(i64 %rvp8805) 
  store volatile i64 %na8778, i64* %vptr14013, align 8 ; call prim_cdr
 %vptr14014 = alloca i64, align 8 
  %n_638806 = call i64 @prim_null_63(i64 %na8778) 
  store volatile i64 %n_638806, i64* %vptr14014, align 8 ; call prim_null_63
  %cmpptr14018 = alloca i1, align 8  %cmp14015 = icmp eq i64 %n_638806, 15 store volatile i1 %cmp14015, i1* %cmpptr14018, align 8; false?
  br i1 %cmp14015, label %else14017, label %then14016                                ; if

then14016:
  %vptr14027 = alloca i64*, align 8 
  %cloptr14019 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr14019, i64** %vptr14027, align 8 ; malloc
  %vptr14028 = alloca i64*, align 8 
  %eptr14021 = getelementptr inbounds i64, i64* %cloptr14019, i64 2 
  store volatile i64* %eptr14021, i64** %vptr14028, align 8 ; &eptr14021[1]
  %vptr14029 = alloca i64*, align 8 
  %eptr14022 = getelementptr inbounds i64, i64* %cloptr14019, i64 3 
  store volatile i64* %eptr14022, i64** %vptr14029, align 8 ; &eptr14022[2]
  %vptr14030 = alloca i64*, align 8 
  %eptr14023 = getelementptr inbounds i64, i64* %cloptr14019, i64 4 
  store volatile i64* %eptr14023, i64** %vptr14030, align 8 ; &eptr14023[3]
  %vptr14031 = alloca i64*, align 8 
  %eptr14024 = getelementptr inbounds i64, i64* %cloptr14019, i64 5 
  store volatile i64* %eptr14024, i64** %vptr14031, align 8 ; &eptr14024[4]
  %vptr14032 = alloca i64*, align 8 
  %eptr14025 = getelementptr inbounds i64, i64* %cloptr14019, i64 6 
  store volatile i64* %eptr14025, i64** %vptr14032, align 8 ; &eptr14025[5]
  store i64 %emsg18637, i64* %eptr14021                                              ; *eptr14021 = %emsg18637
  store i64 %cont7105, i64* %eptr14022                                               ; *eptr14022 = %cont7105
  store i64 %L15$_37last, i64* %eptr14023                                            ; *eptr14023 = %L15$_37last
  store i64 %cTu$fargs, i64* %eptr14024                                              ; *eptr14024 = %cTu$fargs
  store i64 %emsg08636, i64* %eptr14025                                              ; *eptr14025 = %emsg08636
  %vptr14033 = alloca i64*, align 8 
  %eptr14020 = getelementptr inbounds i64, i64* %cloptr14019, i64 1 
  store volatile i64* %eptr14020, i64** %vptr14033, align 8 ; &cloptr14019[1]
 %vptr14034 = alloca i64, align 8 
  %f14026 = ptrtoint void(i64,i64)* @lam12392 to i64 
  store volatile i64 %f14026, i64* %vptr14034, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f14026, i64* %eptr14020                                                 ; store fptr
 %vptr14035 = alloca i64, align 8 
  %arg7436 = ptrtoint i64* %cloptr14019 to i64 
  store volatile i64 %arg7436, i64* %vptr14035, align 8 ; closure cast; i64* -> i64
 %vptr14036 = alloca i64, align 8 
  %cps_45lst7111 = call i64 @prim_cons(i64 %arg7436, i64 %a6942) 
  store volatile i64 %cps_45lst7111, i64* %vptr14036, align 8 ; call prim_cons
  %vptr14042 = alloca i64*, align 8 
  %cloptr14037 = inttoptr i64 %Q2m$f to i64* 
  store volatile i64* %cloptr14037, i64** %vptr14042, align 8 ; closure/env cast; i64 -> i64*
  %vptr14043 = alloca i64*, align 8 
  %i0ptr14038 = getelementptr inbounds i64, i64* %cloptr14037, i64 1 
  store volatile i64* %i0ptr14038, i64** %vptr14043, align 8 ; &cloptr14037[1]
 %vptr14044 = alloca i64, align 8 
  %f14040 = load i64, i64* %i0ptr14038, align 8 
  store volatile i64 %f14040, i64* %vptr14044, align 8 ; load; *i0ptr14038
  %fptr14039 = inttoptr i64 %f14040 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14039(i64 %Q2m$f, i64 %cps_45lst7111)               ; tail call
  ret void

else14017:
 %vptr14045 = alloca i64, align 8 
  %h8807 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h8807, i64* %vptr14045, align 8 ; call prim_halt
  %vptr14051 = alloca i64*, align 8 
  %cloptr14046 = inttoptr i64 %h8807 to i64* 
  store volatile i64* %cloptr14046, i64** %vptr14051, align 8 ; closure/env cast; i64 -> i64*
  %vptr14052 = alloca i64*, align 8 
  %i0ptr14047 = getelementptr inbounds i64, i64* %cloptr14046, i64 1 
  store volatile i64* %i0ptr14047, i64** %vptr14052, align 8 ; &cloptr14046[1]
 %vptr14053 = alloca i64, align 8 
  %f14049 = load i64, i64* %i0ptr14047, align 8 
  store volatile i64 %f14049, i64* %vptr14053, align 8 ; load; *i0ptr14047
  %fptr14048 = inttoptr i64 %f14049 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14048(i64 %h8807, i64 %h8807)                       ; tail call
  ret void
}


define void @lam12392(i64 %env12393, i64 %rvp8801) {
 %vptr14056 = alloca i64, align 8 
  %envptr14054 = inttoptr i64 %env12393 to i64* 
  store volatile i64 %emsg08636, i64* %vptr14056, align 8 ; closure/env cast; i64 -> i64*
  %vptr14057 = alloca i64*, align 8 
  %envptr14055 = getelementptr inbounds i64, i64* %envptr14054, i64 6 
  store volatile i64* %envptr14055, i64** %vptr14057, align 8 ; &envptr14054[5]
 %vptr14058 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr14055, align 8 
  store volatile i64 %emsg08636, i64* %vptr14058, align 8 ; load; *envptr14055
 %vptr14061 = alloca i64, align 8 
  %envptr14059 = inttoptr i64 %env12393 to i64* 
  store volatile i64 %cTu$fargs, i64* %vptr14061, align 8 ; closure/env cast; i64 -> i64*
  %vptr14062 = alloca i64*, align 8 
  %envptr14060 = getelementptr inbounds i64, i64* %envptr14059, i64 5 
  store volatile i64* %envptr14060, i64** %vptr14062, align 8 ; &envptr14059[4]
 %vptr14063 = alloca i64, align 8 
  %cTu$fargs = load i64, i64* %envptr14060, align 8 
  store volatile i64 %cTu$fargs, i64* %vptr14063, align 8 ; load; *envptr14060
 %vptr14066 = alloca i64, align 8 
  %envptr14064 = inttoptr i64 %env12393 to i64* 
  store volatile i64 %L15$_37last, i64* %vptr14066, align 8 ; closure/env cast; i64 -> i64*
  %vptr14067 = alloca i64*, align 8 
  %envptr14065 = getelementptr inbounds i64, i64* %envptr14064, i64 4 
  store volatile i64* %envptr14065, i64** %vptr14067, align 8 ; &envptr14064[3]
 %vptr14068 = alloca i64, align 8 
  %L15$_37last = load i64, i64* %envptr14065, align 8 
  store volatile i64 %L15$_37last, i64* %vptr14068, align 8 ; load; *envptr14065
 %vptr14071 = alloca i64, align 8 
  %envptr14069 = inttoptr i64 %env12393 to i64* 
  store volatile i64 %cont7105, i64* %vptr14071, align 8 ; closure/env cast; i64 -> i64*
  %vptr14072 = alloca i64*, align 8 
  %envptr14070 = getelementptr inbounds i64, i64* %envptr14069, i64 3 
  store volatile i64* %envptr14070, i64** %vptr14072, align 8 ; &envptr14069[2]
 %vptr14073 = alloca i64, align 8 
  %cont7105 = load i64, i64* %envptr14070, align 8 
  store volatile i64 %cont7105, i64* %vptr14073, align 8 ; load; *envptr14070
 %vptr14076 = alloca i64, align 8 
  %envptr14074 = inttoptr i64 %env12393 to i64* 
  store volatile i64 %emsg18637, i64* %vptr14076, align 8 ; closure/env cast; i64 -> i64*
  %vptr14077 = alloca i64*, align 8 
  %envptr14075 = getelementptr inbounds i64, i64* %envptr14074, i64 2 
  store volatile i64* %envptr14075, i64** %vptr14077, align 8 ; &envptr14074[1]
 %vptr14078 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr14075, align 8 
  store volatile i64 %emsg18637, i64* %vptr14078, align 8 ; load; *envptr14075
 %vptr14079 = alloca i64, align 8 
  %_957108 = call i64 @prim_car(i64 %rvp8801) 
  store volatile i64 %_957108, i64* %vptr14079, align 8 ; call prim_car
 %vptr14080 = alloca i64, align 8 
  %rvp8797 = call i64 @prim_cdr(i64 %rvp8801) 
  store volatile i64 %rvp8797, i64* %vptr14080, align 8 ; call prim_cdr
 %vptr14081 = alloca i64, align 8 
  %n_638802 = call i64 @prim_null_63(i64 %rvp8797) 
  store volatile i64 %n_638802, i64* %vptr14081, align 8 ; call prim_null_63
  %cmpptr14085 = alloca i1, align 8  %cmp14082 = icmp eq i64 %n_638802, 15 store volatile i1 %cmp14082, i1* %cmpptr14085, align 8; false?
  br i1 %cmp14082, label %else14084, label %then14083                                ; if

then14083:
 %vptr14086 = alloca i64, align 8 
  %h8803 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8803, i64* %vptr14086, align 8 ; call prim_halt
  %vptr14092 = alloca i64*, align 8 
  %cloptr14087 = inttoptr i64 %h8803 to i64* 
  store volatile i64* %cloptr14087, i64** %vptr14092, align 8 ; closure/env cast; i64 -> i64*
  %vptr14093 = alloca i64*, align 8 
  %i0ptr14088 = getelementptr inbounds i64, i64* %cloptr14087, i64 1 
  store volatile i64* %i0ptr14088, i64** %vptr14093, align 8 ; &cloptr14087[1]
 %vptr14094 = alloca i64, align 8 
  %f14090 = load i64, i64* %i0ptr14088, align 8 
  store volatile i64 %f14090, i64* %vptr14094, align 8 ; load; *i0ptr14088
  %fptr14089 = inttoptr i64 %f14090 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14089(i64 %h8803, i64 %h8803)                       ; tail call
  ret void

else14084:
 %vptr14095 = alloca i64, align 8 
  %a6943 = call i64 @prim_car(i64 %rvp8797) 
  store volatile i64 %a6943, i64* %vptr14095, align 8 ; call prim_car
 %vptr14096 = alloca i64, align 8 
  %na8780 = call i64 @prim_cdr(i64 %rvp8797) 
  store volatile i64 %na8780, i64* %vptr14096, align 8 ; call prim_cdr
 %vptr14097 = alloca i64, align 8 
  %n_638798 = call i64 @prim_null_63(i64 %na8780) 
  store volatile i64 %n_638798, i64* %vptr14097, align 8 ; call prim_null_63
  %cmpptr14101 = alloca i1, align 8  %cmp14098 = icmp eq i64 %n_638798, 15 store volatile i1 %cmp14098, i1* %cmpptr14101, align 8; false?
  br i1 %cmp14098, label %else14100, label %then14099                                ; if

then14099:
  %vptr14109 = alloca i64*, align 8 
  %cloptr14102 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr14102, i64** %vptr14109, align 8 ; malloc
  %vptr14110 = alloca i64*, align 8 
  %eptr14104 = getelementptr inbounds i64, i64* %cloptr14102, i64 2 
  store volatile i64* %eptr14104, i64** %vptr14110, align 8 ; &eptr14104[1]
  %vptr14111 = alloca i64*, align 8 
  %eptr14105 = getelementptr inbounds i64, i64* %cloptr14102, i64 3 
  store volatile i64* %eptr14105, i64** %vptr14111, align 8 ; &eptr14105[2]
  %vptr14112 = alloca i64*, align 8 
  %eptr14106 = getelementptr inbounds i64, i64* %cloptr14102, i64 4 
  store volatile i64* %eptr14106, i64** %vptr14112, align 8 ; &eptr14106[3]
  %vptr14113 = alloca i64*, align 8 
  %eptr14107 = getelementptr inbounds i64, i64* %cloptr14102, i64 5 
  store volatile i64* %eptr14107, i64** %vptr14113, align 8 ; &eptr14107[4]
  store i64 %emsg18637, i64* %eptr14104                                              ; *eptr14104 = %emsg18637
  store i64 %cont7105, i64* %eptr14105                                               ; *eptr14105 = %cont7105
  store i64 %a6943, i64* %eptr14106                                                  ; *eptr14106 = %a6943
  store i64 %emsg08636, i64* %eptr14107                                              ; *eptr14107 = %emsg08636
  %vptr14114 = alloca i64*, align 8 
  %eptr14103 = getelementptr inbounds i64, i64* %cloptr14102, i64 1 
  store volatile i64* %eptr14103, i64** %vptr14114, align 8 ; &cloptr14102[1]
 %vptr14115 = alloca i64, align 8 
  %f14108 = ptrtoint void(i64,i64)* @lam12390 to i64 
  store volatile i64 %f14108, i64* %vptr14115, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f14108, i64* %eptr14103                                                 ; store fptr
 %vptr14116 = alloca i64, align 8 
  %arg7438 = ptrtoint i64* %cloptr14102 to i64 
  store volatile i64 %arg7438, i64* %vptr14116, align 8 ; closure cast; i64* -> i64
 %vptr14117 = alloca i64, align 8 
  %rva8796 = add i64 0, 0 
  store volatile i64 %rva8796, i64* %vptr14117, align 8 ; quoted ()
 %vptr14118 = alloca i64, align 8 
  %rva8795 = call i64 @prim_cons(i64 %cTu$fargs, i64 %rva8796) 
  store volatile i64 %rva8795, i64* %vptr14118, align 8 ; call prim_cons
 %vptr14119 = alloca i64, align 8 
  %rva8794 = call i64 @prim_cons(i64 %arg7438, i64 %rva8795) 
  store volatile i64 %rva8794, i64* %vptr14119, align 8 ; call prim_cons
  %vptr14125 = alloca i64*, align 8 
  %cloptr14120 = inttoptr i64 %L15$_37last to i64* 
  store volatile i64* %cloptr14120, i64** %vptr14125, align 8 ; closure/env cast; i64 -> i64*
  %vptr14126 = alloca i64*, align 8 
  %i0ptr14121 = getelementptr inbounds i64, i64* %cloptr14120, i64 1 
  store volatile i64* %i0ptr14121, i64** %vptr14126, align 8 ; &cloptr14120[1]
 %vptr14127 = alloca i64, align 8 
  %f14123 = load i64, i64* %i0ptr14121, align 8 
  store volatile i64 %f14123, i64* %vptr14127, align 8 ; load; *i0ptr14121
  %fptr14122 = inttoptr i64 %f14123 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14122(i64 %L15$_37last, i64 %rva8794)               ; tail call
  ret void

else14100:
 %vptr14128 = alloca i64, align 8 
  %h8799 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h8799, i64* %vptr14128, align 8 ; call prim_halt
  %vptr14134 = alloca i64*, align 8 
  %cloptr14129 = inttoptr i64 %h8799 to i64* 
  store volatile i64* %cloptr14129, i64** %vptr14134, align 8 ; closure/env cast; i64 -> i64*
  %vptr14135 = alloca i64*, align 8 
  %i0ptr14130 = getelementptr inbounds i64, i64* %cloptr14129, i64 1 
  store volatile i64* %i0ptr14130, i64** %vptr14135, align 8 ; &cloptr14129[1]
 %vptr14136 = alloca i64, align 8 
  %f14132 = load i64, i64* %i0ptr14130, align 8 
  store volatile i64 %f14132, i64* %vptr14136, align 8 ; load; *i0ptr14130
  %fptr14131 = inttoptr i64 %f14132 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14131(i64 %h8799, i64 %h8799)                       ; tail call
  ret void
}


define void @lam12390(i64 %env12391, i64 %rvp8790) {
 %vptr14139 = alloca i64, align 8 
  %envptr14137 = inttoptr i64 %env12391 to i64* 
  store volatile i64 %emsg08636, i64* %vptr14139, align 8 ; closure/env cast; i64 -> i64*
  %vptr14140 = alloca i64*, align 8 
  %envptr14138 = getelementptr inbounds i64, i64* %envptr14137, i64 5 
  store volatile i64* %envptr14138, i64** %vptr14140, align 8 ; &envptr14137[4]
 %vptr14141 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr14138, align 8 
  store volatile i64 %emsg08636, i64* %vptr14141, align 8 ; load; *envptr14138
 %vptr14144 = alloca i64, align 8 
  %envptr14142 = inttoptr i64 %env12391 to i64* 
  store volatile i64 %a6943, i64* %vptr14144, align 8 ; closure/env cast; i64 -> i64*
  %vptr14145 = alloca i64*, align 8 
  %envptr14143 = getelementptr inbounds i64, i64* %envptr14142, i64 4 
  store volatile i64* %envptr14143, i64** %vptr14145, align 8 ; &envptr14142[3]
 %vptr14146 = alloca i64, align 8 
  %a6943 = load i64, i64* %envptr14143, align 8 
  store volatile i64 %a6943, i64* %vptr14146, align 8 ; load; *envptr14143
 %vptr14149 = alloca i64, align 8 
  %envptr14147 = inttoptr i64 %env12391 to i64* 
  store volatile i64 %cont7105, i64* %vptr14149, align 8 ; closure/env cast; i64 -> i64*
  %vptr14150 = alloca i64*, align 8 
  %envptr14148 = getelementptr inbounds i64, i64* %envptr14147, i64 3 
  store volatile i64* %envptr14148, i64** %vptr14150, align 8 ; &envptr14147[2]
 %vptr14151 = alloca i64, align 8 
  %cont7105 = load i64, i64* %envptr14148, align 8 
  store volatile i64 %cont7105, i64* %vptr14151, align 8 ; load; *envptr14148
 %vptr14154 = alloca i64, align 8 
  %envptr14152 = inttoptr i64 %env12391 to i64* 
  store volatile i64 %emsg18637, i64* %vptr14154, align 8 ; closure/env cast; i64 -> i64*
  %vptr14155 = alloca i64*, align 8 
  %envptr14153 = getelementptr inbounds i64, i64* %envptr14152, i64 2 
  store volatile i64* %envptr14153, i64** %vptr14155, align 8 ; &envptr14152[1]
 %vptr14156 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr14153, align 8 
  store volatile i64 %emsg18637, i64* %vptr14156, align 8 ; load; *envptr14153
 %vptr14157 = alloca i64, align 8 
  %_957109 = call i64 @prim_car(i64 %rvp8790) 
  store volatile i64 %_957109, i64* %vptr14157, align 8 ; call prim_car
 %vptr14158 = alloca i64, align 8 
  %rvp8786 = call i64 @prim_cdr(i64 %rvp8790) 
  store volatile i64 %rvp8786, i64* %vptr14158, align 8 ; call prim_cdr
 %vptr14159 = alloca i64, align 8 
  %n_638791 = call i64 @prim_null_63(i64 %rvp8786) 
  store volatile i64 %n_638791, i64* %vptr14159, align 8 ; call prim_null_63
  %cmpptr14163 = alloca i1, align 8  %cmp14160 = icmp eq i64 %n_638791, 15 store volatile i1 %cmp14160, i1* %cmpptr14163, align 8; false?
  br i1 %cmp14160, label %else14162, label %then14161                                ; if

then14161:
 %vptr14164 = alloca i64, align 8 
  %h8792 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8792, i64* %vptr14164, align 8 ; call prim_halt
  %vptr14170 = alloca i64*, align 8 
  %cloptr14165 = inttoptr i64 %h8792 to i64* 
  store volatile i64* %cloptr14165, i64** %vptr14170, align 8 ; closure/env cast; i64 -> i64*
  %vptr14171 = alloca i64*, align 8 
  %i0ptr14166 = getelementptr inbounds i64, i64* %cloptr14165, i64 1 
  store volatile i64* %i0ptr14166, i64** %vptr14171, align 8 ; &cloptr14165[1]
 %vptr14172 = alloca i64, align 8 
  %f14168 = load i64, i64* %i0ptr14166, align 8 
  store volatile i64 %f14168, i64* %vptr14172, align 8 ; load; *i0ptr14166
  %fptr14167 = inttoptr i64 %f14168 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14167(i64 %h8792, i64 %h8792)                       ; tail call
  ret void

else14162:
 %vptr14173 = alloca i64, align 8 
  %a6944 = call i64 @prim_car(i64 %rvp8786) 
  store volatile i64 %a6944, i64* %vptr14173, align 8 ; call prim_car
 %vptr14174 = alloca i64, align 8 
  %na8782 = call i64 @prim_cdr(i64 %rvp8786) 
  store volatile i64 %na8782, i64* %vptr14174, align 8 ; call prim_cdr
 %vptr14175 = alloca i64, align 8 
  %n_638787 = call i64 @prim_null_63(i64 %na8782) 
  store volatile i64 %n_638787, i64* %vptr14175, align 8 ; call prim_null_63
  %cmpptr14179 = alloca i1, align 8  %cmp14176 = icmp eq i64 %n_638787, 15 store volatile i1 %cmp14176, i1* %cmpptr14179, align 8; false?
  br i1 %cmp14176, label %else14178, label %then14177                                ; if

then14177:
 %vptr14180 = alloca i64, align 8 
  %retprim7110 = call i64 @prim_cons(i64 %a6943, i64 %a6944) 
  store volatile i64 %retprim7110, i64* %vptr14180, align 8 ; call prim_cons
 %vptr14181 = alloca i64, align 8 
  %arg7443 = add i64 0, 0 
  store volatile i64 %arg7443, i64* %vptr14181, align 8 ; quoted ()
 %vptr14182 = alloca i64, align 8 
  %rva8785 = add i64 0, 0 
  store volatile i64 %rva8785, i64* %vptr14182, align 8 ; quoted ()
 %vptr14183 = alloca i64, align 8 
  %rva8784 = call i64 @prim_cons(i64 %retprim7110, i64 %rva8785) 
  store volatile i64 %rva8784, i64* %vptr14183, align 8 ; call prim_cons
 %vptr14184 = alloca i64, align 8 
  %rva8783 = call i64 @prim_cons(i64 %arg7443, i64 %rva8784) 
  store volatile i64 %rva8783, i64* %vptr14184, align 8 ; call prim_cons
  %vptr14190 = alloca i64*, align 8 
  %cloptr14185 = inttoptr i64 %cont7105 to i64* 
  store volatile i64* %cloptr14185, i64** %vptr14190, align 8 ; closure/env cast; i64 -> i64*
  %vptr14191 = alloca i64*, align 8 
  %i0ptr14186 = getelementptr inbounds i64, i64* %cloptr14185, i64 1 
  store volatile i64* %i0ptr14186, i64** %vptr14191, align 8 ; &cloptr14185[1]
 %vptr14192 = alloca i64, align 8 
  %f14188 = load i64, i64* %i0ptr14186, align 8 
  store volatile i64 %f14188, i64* %vptr14192, align 8 ; load; *i0ptr14186
  %fptr14187 = inttoptr i64 %f14188 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14187(i64 %cont7105, i64 %rva8783)                  ; tail call
  ret void

else14178:
 %vptr14193 = alloca i64, align 8 
  %h8788 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h8788, i64* %vptr14193, align 8 ; call prim_halt
  %vptr14199 = alloca i64*, align 8 
  %cloptr14194 = inttoptr i64 %h8788 to i64* 
  store volatile i64* %cloptr14194, i64** %vptr14199, align 8 ; closure/env cast; i64 -> i64*
  %vptr14200 = alloca i64*, align 8 
  %i0ptr14195 = getelementptr inbounds i64, i64* %cloptr14194, i64 1 
  store volatile i64* %i0ptr14195, i64** %vptr14200, align 8 ; &cloptr14194[1]
 %vptr14201 = alloca i64, align 8 
  %f14197 = load i64, i64* %i0ptr14195, align 8 
  store volatile i64 %f14197, i64* %vptr14201, align 8 ; load; *i0ptr14195
  %fptr14196 = inttoptr i64 %f14197 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14196(i64 %h8788, i64 %h8788)                       ; tail call
  ret void
}


define void @lam12383(i64 %env12384, i64 %rvp10749) {
 %vptr14204 = alloca i64, align 8 
  %envptr14202 = inttoptr i64 %env12384 to i64* 
  store volatile i64 %F5P$_37foldl1, i64* %vptr14204, align 8 ; closure/env cast; i64 -> i64*
  %vptr14205 = alloca i64*, align 8 
  %envptr14203 = getelementptr inbounds i64, i64* %envptr14202, i64 5 
  store volatile i64* %envptr14203, i64** %vptr14205, align 8 ; &envptr14202[4]
 %vptr14206 = alloca i64, align 8 
  %F5P$_37foldl1 = load i64, i64* %envptr14203, align 8 
  store volatile i64 %F5P$_37foldl1, i64* %vptr14206, align 8 ; load; *envptr14203
 %vptr14209 = alloca i64, align 8 
  %envptr14207 = inttoptr i64 %env12384 to i64* 
  store volatile i64 %emsg08636, i64* %vptr14209, align 8 ; closure/env cast; i64 -> i64*
  %vptr14210 = alloca i64*, align 8 
  %envptr14208 = getelementptr inbounds i64, i64* %envptr14207, i64 4 
  store volatile i64* %envptr14208, i64** %vptr14210, align 8 ; &envptr14207[3]
 %vptr14211 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr14208, align 8 
  store volatile i64 %emsg08636, i64* %vptr14211, align 8 ; load; *envptr14208
 %vptr14214 = alloca i64, align 8 
  %envptr14212 = inttoptr i64 %env12384 to i64* 
  store volatile i64 %Jup$_37length, i64* %vptr14214, align 8 ; closure/env cast; i64 -> i64*
  %vptr14215 = alloca i64*, align 8 
  %envptr14213 = getelementptr inbounds i64, i64* %envptr14212, i64 3 
  store volatile i64* %envptr14213, i64** %vptr14215, align 8 ; &envptr14212[2]
 %vptr14216 = alloca i64, align 8 
  %Jup$_37length = load i64, i64* %envptr14213, align 8 
  store volatile i64 %Jup$_37length, i64* %vptr14216, align 8 ; load; *envptr14213
 %vptr14219 = alloca i64, align 8 
  %envptr14217 = inttoptr i64 %env12384 to i64* 
  store volatile i64 %emsg18637, i64* %vptr14219, align 8 ; closure/env cast; i64 -> i64*
  %vptr14220 = alloca i64*, align 8 
  %envptr14218 = getelementptr inbounds i64, i64* %envptr14217, i64 2 
  store volatile i64* %envptr14218, i64** %vptr14220, align 8 ; &envptr14217[1]
 %vptr14221 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr14218, align 8 
  store volatile i64 %emsg18637, i64* %vptr14221, align 8 ; load; *envptr14218
 %vptr14222 = alloca i64, align 8 
  %_957113 = call i64 @prim_car(i64 %rvp10749) 
  store volatile i64 %_957113, i64* %vptr14222, align 8 ; call prim_car
 %vptr14223 = alloca i64, align 8 
  %rvp10745 = call i64 @prim_cdr(i64 %rvp10749) 
  store volatile i64 %rvp10745, i64* %vptr14223, align 8 ; call prim_cdr
 %vptr14224 = alloca i64, align 8 
  %n_6310750 = call i64 @prim_null_63(i64 %rvp10745) 
  store volatile i64 %n_6310750, i64* %vptr14224, align 8 ; call prim_null_63
  %cmpptr14228 = alloca i1, align 8  %cmp14225 = icmp eq i64 %n_6310750, 15 store volatile i1 %cmp14225, i1* %cmpptr14228, align 8; false?
  br i1 %cmp14225, label %else14227, label %then14226                                ; if

then14226:
 %vptr14229 = alloca i64, align 8 
  %h10751 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10751, i64* %vptr14229, align 8 ; call prim_halt
  %vptr14235 = alloca i64*, align 8 
  %cloptr14230 = inttoptr i64 %h10751 to i64* 
  store volatile i64* %cloptr14230, i64** %vptr14235, align 8 ; closure/env cast; i64 -> i64*
  %vptr14236 = alloca i64*, align 8 
  %i0ptr14231 = getelementptr inbounds i64, i64* %cloptr14230, i64 1 
  store volatile i64* %i0ptr14231, i64** %vptr14236, align 8 ; &cloptr14230[1]
 %vptr14237 = alloca i64, align 8 
  %f14233 = load i64, i64* %i0ptr14231, align 8 
  store volatile i64 %f14233, i64* %vptr14237, align 8 ; load; *i0ptr14231
  %fptr14232 = inttoptr i64 %f14233 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14232(i64 %h10751, i64 %h10751)                     ; tail call
  ret void

else14227:
 %vptr14238 = alloca i64, align 8 
  %rQo$_37foldl = call i64 @prim_car(i64 %rvp10745) 
  store volatile i64 %rQo$_37foldl, i64* %vptr14238, align 8 ; call prim_car
 %vptr14239 = alloca i64, align 8 
  %na8818 = call i64 @prim_cdr(i64 %rvp10745) 
  store volatile i64 %na8818, i64* %vptr14239, align 8 ; call prim_cdr
 %vptr14240 = alloca i64, align 8 
  %n_6310746 = call i64 @prim_null_63(i64 %na8818) 
  store volatile i64 %n_6310746, i64* %vptr14240, align 8 ; call prim_null_63
  %cmpptr14244 = alloca i1, align 8  %cmp14241 = icmp eq i64 %n_6310746, 15 store volatile i1 %cmp14241, i1* %cmpptr14244, align 8; false?
  br i1 %cmp14241, label %else14243, label %then14242                                ; if

then14242:
  %vptr14250 = alloca i64*, align 8 
  %cloptr14245 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr14245, i64** %vptr14250, align 8 ; malloc
  %vptr14251 = alloca i64*, align 8 
  %eptr14247 = getelementptr inbounds i64, i64* %cloptr14245, i64 2 
  store volatile i64* %eptr14247, i64** %vptr14251, align 8 ; &eptr14247[1]
  %vptr14252 = alloca i64*, align 8 
  %eptr14248 = getelementptr inbounds i64, i64* %cloptr14245, i64 3 
  store volatile i64* %eptr14248, i64** %vptr14252, align 8 ; &eptr14248[2]
  store i64 %emsg18637, i64* %eptr14247                                              ; *eptr14247 = %emsg18637
  store i64 %emsg08636, i64* %eptr14248                                              ; *eptr14248 = %emsg08636
  %vptr14253 = alloca i64*, align 8 
  %eptr14246 = getelementptr inbounds i64, i64* %cloptr14245, i64 1 
  store volatile i64* %eptr14246, i64** %vptr14253, align 8 ; &cloptr14245[1]
 %vptr14254 = alloca i64, align 8 
  %f14249 = ptrtoint void(i64,i64)* @lam12381 to i64 
  store volatile i64 %f14249, i64* %vptr14254, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f14249, i64* %eptr14246                                                 ; store fptr
 %vptr14255 = alloca i64, align 8 
  %uLY$_37_62 = ptrtoint i64* %cloptr14245 to i64 
  store volatile i64 %uLY$_37_62, i64* %vptr14255, align 8 ; closure cast; i64* -> i64
  %vptr14261 = alloca i64*, align 8 
  %cloptr14256 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr14256, i64** %vptr14261, align 8 ; malloc
  %vptr14262 = alloca i64*, align 8 
  %eptr14258 = getelementptr inbounds i64, i64* %cloptr14256, i64 2 
  store volatile i64* %eptr14258, i64** %vptr14262, align 8 ; &eptr14258[1]
  %vptr14263 = alloca i64*, align 8 
  %eptr14259 = getelementptr inbounds i64, i64* %cloptr14256, i64 3 
  store volatile i64* %eptr14259, i64** %vptr14263, align 8 ; &eptr14259[2]
  store i64 %emsg18637, i64* %eptr14258                                              ; *eptr14258 = %emsg18637
  store i64 %emsg08636, i64* %eptr14259                                              ; *eptr14259 = %emsg08636
  %vptr14264 = alloca i64*, align 8 
  %eptr14257 = getelementptr inbounds i64, i64* %cloptr14256, i64 1 
  store volatile i64* %eptr14257, i64** %vptr14264, align 8 ; &cloptr14256[1]
 %vptr14265 = alloca i64, align 8 
  %f14260 = ptrtoint void(i64,i64)* @lam12377 to i64 
  store volatile i64 %f14260, i64* %vptr14265, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f14260, i64* %eptr14257                                                 ; store fptr
 %vptr14266 = alloca i64, align 8 
  %wpu$_37_62_61 = ptrtoint i64* %cloptr14256 to i64 
  store volatile i64 %wpu$_37_62_61, i64* %vptr14266, align 8 ; closure cast; i64* -> i64
 %vptr14267 = alloca i64, align 8 
  %arg7463 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg7463, i64* %vptr14267, align 8 ; quoted int
 %vptr14268 = alloca i64, align 8 
  %arg7462 = add i64 0, 0 
  store volatile i64 %arg7462, i64* %vptr14268, align 8 ; quoted ()
 %vptr14269 = alloca i64, align 8 
  %LQt$_37append = call i64 @prim_make_45vector(i64 %arg7463, i64 %arg7462) 
  store volatile i64 %LQt$_37append, i64* %vptr14269, align 8 ; call prim_make_45vector
 %vptr14270 = alloca i64, align 8 
  %arg7465 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg7465, i64* %vptr14270, align 8 ; quoted int
 %vptr14271 = alloca i64, align 8 
  %arg7464 = add i64 0, 0 
  store volatile i64 %arg7464, i64* %vptr14271, align 8 ; quoted ()
 %vptr14272 = alloca i64, align 8 
  %WM4$_37append2 = call i64 @prim_make_45vector(i64 %arg7465, i64 %arg7464) 
  store volatile i64 %WM4$_37append2, i64* %vptr14272, align 8 ; call prim_make_45vector
 %vptr14273 = alloca i64, align 8 
  %arg7467 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7467, i64* %vptr14273, align 8 ; quoted int
  %vptr14280 = alloca i64*, align 8 
  %cloptr14274 = call i64* @make_closure(i64 32) 
  store volatile i64* %cloptr14274, i64** %vptr14280, align 8 ; malloc
  %vptr14281 = alloca i64*, align 8 
  %eptr14276 = getelementptr inbounds i64, i64* %cloptr14274, i64 2 
  store volatile i64* %eptr14276, i64** %vptr14281, align 8 ; &eptr14276[1]
  %vptr14282 = alloca i64*, align 8 
  %eptr14277 = getelementptr inbounds i64, i64* %cloptr14274, i64 3 
  store volatile i64* %eptr14277, i64** %vptr14282, align 8 ; &eptr14277[2]
  %vptr14283 = alloca i64*, align 8 
  %eptr14278 = getelementptr inbounds i64, i64* %cloptr14274, i64 4 
  store volatile i64* %eptr14278, i64** %vptr14283, align 8 ; &eptr14278[3]
  store i64 %emsg18637, i64* %eptr14276                                              ; *eptr14276 = %emsg18637
  store i64 %WM4$_37append2, i64* %eptr14277                                         ; *eptr14277 = %WM4$_37append2
  store i64 %emsg08636, i64* %eptr14278                                              ; *eptr14278 = %emsg08636
  %vptr14284 = alloca i64*, align 8 
  %eptr14275 = getelementptr inbounds i64, i64* %cloptr14274, i64 1 
  store volatile i64* %eptr14275, i64** %vptr14284, align 8 ; &cloptr14274[1]
 %vptr14285 = alloca i64, align 8 
  %f14279 = ptrtoint void(i64,i64)* @lam12368 to i64 
  store volatile i64 %f14279, i64* %vptr14285, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f14279, i64* %eptr14275                                                 ; store fptr
 %vptr14286 = alloca i64, align 8 
  %arg7466 = ptrtoint i64* %cloptr14274 to i64 
  store volatile i64 %arg7466, i64* %vptr14286, align 8 ; closure cast; i64* -> i64
 %vptr14287 = alloca i64, align 8 
  %cwo$_950 = call i64 @prim_vector_45set_33(i64 %WM4$_37append2, i64 %arg7467, i64 %arg7466) 
  store volatile i64 %cwo$_950, i64* %vptr14287, align 8 ; call prim_vector_45set_33
 %vptr14288 = alloca i64, align 8 
  %arg7487 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7487, i64* %vptr14288, align 8 ; quoted int
  %vptr14296 = alloca i64*, align 8 
  %cloptr14289 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr14289, i64** %vptr14296, align 8 ; malloc
  %vptr14297 = alloca i64*, align 8 
  %eptr14291 = getelementptr inbounds i64, i64* %cloptr14289, i64 2 
  store volatile i64* %eptr14291, i64** %vptr14297, align 8 ; &eptr14291[1]
  %vptr14298 = alloca i64*, align 8 
  %eptr14292 = getelementptr inbounds i64, i64* %cloptr14289, i64 3 
  store volatile i64* %eptr14292, i64** %vptr14298, align 8 ; &eptr14292[2]
  %vptr14299 = alloca i64*, align 8 
  %eptr14293 = getelementptr inbounds i64, i64* %cloptr14289, i64 4 
  store volatile i64* %eptr14293, i64** %vptr14299, align 8 ; &eptr14293[3]
  %vptr14300 = alloca i64*, align 8 
  %eptr14294 = getelementptr inbounds i64, i64* %cloptr14289, i64 5 
  store volatile i64* %eptr14294, i64** %vptr14300, align 8 ; &eptr14294[4]
  store i64 %emsg18637, i64* %eptr14291                                              ; *eptr14291 = %emsg18637
  store i64 %WM4$_37append2, i64* %eptr14292                                         ; *eptr14292 = %WM4$_37append2
  store i64 %LQt$_37append, i64* %eptr14293                                          ; *eptr14293 = %LQt$_37append
  store i64 %emsg08636, i64* %eptr14294                                              ; *eptr14294 = %emsg08636
  %vptr14301 = alloca i64*, align 8 
  %eptr14290 = getelementptr inbounds i64, i64* %cloptr14289, i64 1 
  store volatile i64* %eptr14290, i64** %vptr14301, align 8 ; &cloptr14289[1]
 %vptr14302 = alloca i64, align 8 
  %f14295 = ptrtoint void(i64,i64)* @lam12357 to i64 
  store volatile i64 %f14295, i64* %vptr14302, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f14295, i64* %eptr14290                                                 ; store fptr
 %vptr14303 = alloca i64, align 8 
  %arg7486 = ptrtoint i64* %cloptr14289 to i64 
  store volatile i64 %arg7486, i64* %vptr14303, align 8 ; closure cast; i64* -> i64
 %vptr14304 = alloca i64, align 8 
  %Ts5$_951 = call i64 @prim_vector_45set_33(i64 %LQt$_37append, i64 %arg7487, i64 %arg7486) 
  store volatile i64 %Ts5$_951, i64* %vptr14304, align 8 ; call prim_vector_45set_33
 %vptr14305 = alloca i64, align 8 
  %arg7507 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7507, i64* %vptr14305, align 8 ; quoted int
 %vptr14306 = alloca i64, align 8 
  %retprim7295 = call i64 @prim_vector_45ref(i64 %LQt$_37append, i64 %arg7507) 
  store volatile i64 %retprim7295, i64* %vptr14306, align 8 ; call prim_vector_45ref
  %vptr14315 = alloca i64*, align 8 
  %cloptr14307 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr14307, i64** %vptr14315, align 8 ; malloc
  %vptr14316 = alloca i64*, align 8 
  %eptr14309 = getelementptr inbounds i64, i64* %cloptr14307, i64 2 
  store volatile i64* %eptr14309, i64** %vptr14316, align 8 ; &eptr14309[1]
  %vptr14317 = alloca i64*, align 8 
  %eptr14310 = getelementptr inbounds i64, i64* %cloptr14307, i64 3 
  store volatile i64* %eptr14310, i64** %vptr14317, align 8 ; &eptr14310[2]
  %vptr14318 = alloca i64*, align 8 
  %eptr14311 = getelementptr inbounds i64, i64* %cloptr14307, i64 4 
  store volatile i64* %eptr14311, i64** %vptr14318, align 8 ; &eptr14311[3]
  %vptr14319 = alloca i64*, align 8 
  %eptr14312 = getelementptr inbounds i64, i64* %cloptr14307, i64 5 
  store volatile i64* %eptr14312, i64** %vptr14319, align 8 ; &eptr14312[4]
  %vptr14320 = alloca i64*, align 8 
  %eptr14313 = getelementptr inbounds i64, i64* %cloptr14307, i64 6 
  store volatile i64* %eptr14313, i64** %vptr14320, align 8 ; &eptr14313[5]
  store i64 %emsg18637, i64* %eptr14309                                              ; *eptr14309 = %emsg18637
  store i64 %Jup$_37length, i64* %eptr14310                                          ; *eptr14310 = %Jup$_37length
  store i64 %emsg08636, i64* %eptr14311                                              ; *eptr14311 = %emsg08636
  store i64 %uLY$_37_62, i64* %eptr14312                                             ; *eptr14312 = %uLY$_37_62
  store i64 %F5P$_37foldl1, i64* %eptr14313                                          ; *eptr14313 = %F5P$_37foldl1
  %vptr14321 = alloca i64*, align 8 
  %eptr14308 = getelementptr inbounds i64, i64* %cloptr14307, i64 1 
  store volatile i64* %eptr14308, i64** %vptr14321, align 8 ; &cloptr14307[1]
 %vptr14322 = alloca i64, align 8 
  %f14314 = ptrtoint void(i64,i64)* @lam12346 to i64 
  store volatile i64 %f14314, i64* %vptr14322, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f14314, i64* %eptr14308                                                 ; store fptr
 %vptr14323 = alloca i64, align 8 
  %arg7511 = ptrtoint i64* %cloptr14307 to i64 
  store volatile i64 %arg7511, i64* %vptr14323, align 8 ; closure cast; i64* -> i64
 %vptr14324 = alloca i64, align 8 
  %arg7510 = add i64 0, 0 
  store volatile i64 %arg7510, i64* %vptr14324, align 8 ; quoted ()
 %vptr14325 = alloca i64, align 8 
  %rva10744 = add i64 0, 0 
  store volatile i64 %rva10744, i64* %vptr14325, align 8 ; quoted ()
 %vptr14326 = alloca i64, align 8 
  %rva10743 = call i64 @prim_cons(i64 %retprim7295, i64 %rva10744) 
  store volatile i64 %rva10743, i64* %vptr14326, align 8 ; call prim_cons
 %vptr14327 = alloca i64, align 8 
  %rva10742 = call i64 @prim_cons(i64 %arg7510, i64 %rva10743) 
  store volatile i64 %rva10742, i64* %vptr14327, align 8 ; call prim_cons
  %vptr14333 = alloca i64*, align 8 
  %cloptr14328 = inttoptr i64 %arg7511 to i64* 
  store volatile i64* %cloptr14328, i64** %vptr14333, align 8 ; closure/env cast; i64 -> i64*
  %vptr14334 = alloca i64*, align 8 
  %i0ptr14329 = getelementptr inbounds i64, i64* %cloptr14328, i64 1 
  store volatile i64* %i0ptr14329, i64** %vptr14334, align 8 ; &cloptr14328[1]
 %vptr14335 = alloca i64, align 8 
  %f14331 = load i64, i64* %i0ptr14329, align 8 
  store volatile i64 %f14331, i64* %vptr14335, align 8 ; load; *i0ptr14329
  %fptr14330 = inttoptr i64 %f14331 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14330(i64 %arg7511, i64 %rva10742)                  ; tail call
  ret void

else14243:
 %vptr14336 = alloca i64, align 8 
  %h10747 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10747, i64* %vptr14336, align 8 ; call prim_halt
  %vptr14342 = alloca i64*, align 8 
  %cloptr14337 = inttoptr i64 %h10747 to i64* 
  store volatile i64* %cloptr14337, i64** %vptr14342, align 8 ; closure/env cast; i64 -> i64*
  %vptr14343 = alloca i64*, align 8 
  %i0ptr14338 = getelementptr inbounds i64, i64* %cloptr14337, i64 1 
  store volatile i64* %i0ptr14338, i64** %vptr14343, align 8 ; &cloptr14337[1]
 %vptr14344 = alloca i64, align 8 
  %f14340 = load i64, i64* %i0ptr14338, align 8 
  store volatile i64 %f14340, i64* %vptr14344, align 8 ; load; *i0ptr14338
  %fptr14339 = inttoptr i64 %f14340 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14339(i64 %h10747, i64 %h10747)                     ; tail call
  ret void
}


define void @lam12381(i64 %env12382, i64 %rvp8832) {
 %vptr14347 = alloca i64, align 8 
  %envptr14345 = inttoptr i64 %env12382 to i64* 
  store volatile i64 %emsg08636, i64* %vptr14347, align 8 ; closure/env cast; i64 -> i64*
  %vptr14348 = alloca i64*, align 8 
  %envptr14346 = getelementptr inbounds i64, i64* %envptr14345, i64 3 
  store volatile i64* %envptr14346, i64** %vptr14348, align 8 ; &envptr14345[2]
 %vptr14349 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr14346, align 8 
  store volatile i64 %emsg08636, i64* %vptr14349, align 8 ; load; *envptr14346
 %vptr14352 = alloca i64, align 8 
  %envptr14350 = inttoptr i64 %env12382 to i64* 
  store volatile i64 %emsg18637, i64* %vptr14352, align 8 ; closure/env cast; i64 -> i64*
  %vptr14353 = alloca i64*, align 8 
  %envptr14351 = getelementptr inbounds i64, i64* %envptr14350, i64 2 
  store volatile i64* %envptr14351, i64** %vptr14353, align 8 ; &envptr14350[1]
 %vptr14354 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr14351, align 8 
  store volatile i64 %emsg18637, i64* %vptr14354, align 8 ; load; *envptr14351
 %vptr14355 = alloca i64, align 8 
  %cont7114 = call i64 @prim_car(i64 %rvp8832) 
  store volatile i64 %cont7114, i64* %vptr14355, align 8 ; call prim_car
 %vptr14356 = alloca i64, align 8 
  %rvp8828 = call i64 @prim_cdr(i64 %rvp8832) 
  store volatile i64 %rvp8828, i64* %vptr14356, align 8 ; call prim_cdr
 %vptr14357 = alloca i64, align 8 
  %n_638833 = call i64 @prim_null_63(i64 %rvp8828) 
  store volatile i64 %n_638833, i64* %vptr14357, align 8 ; call prim_null_63
  %cmpptr14361 = alloca i1, align 8  %cmp14358 = icmp eq i64 %n_638833, 15 store volatile i1 %cmp14358, i1* %cmpptr14361, align 8; false?
  br i1 %cmp14358, label %else14360, label %then14359                                ; if

then14359:
 %vptr14362 = alloca i64, align 8 
  %h8834 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8834, i64* %vptr14362, align 8 ; call prim_halt
  %vptr14368 = alloca i64*, align 8 
  %cloptr14363 = inttoptr i64 %h8834 to i64* 
  store volatile i64* %cloptr14363, i64** %vptr14368, align 8 ; closure/env cast; i64 -> i64*
  %vptr14369 = alloca i64*, align 8 
  %i0ptr14364 = getelementptr inbounds i64, i64* %cloptr14363, i64 1 
  store volatile i64* %i0ptr14364, i64** %vptr14369, align 8 ; &cloptr14363[1]
 %vptr14370 = alloca i64, align 8 
  %f14366 = load i64, i64* %i0ptr14364, align 8 
  store volatile i64 %f14366, i64* %vptr14370, align 8 ; load; *i0ptr14364
  %fptr14365 = inttoptr i64 %f14366 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14365(i64 %h8834, i64 %h8834)                       ; tail call
  ret void

else14360:
 %vptr14371 = alloca i64, align 8 
  %plR$a = call i64 @prim_car(i64 %rvp8828) 
  store volatile i64 %plR$a, i64* %vptr14371, align 8 ; call prim_car
 %vptr14372 = alloca i64, align 8 
  %rvp8824 = call i64 @prim_cdr(i64 %rvp8828) 
  store volatile i64 %rvp8824, i64* %vptr14372, align 8 ; call prim_cdr
 %vptr14373 = alloca i64, align 8 
  %n_638829 = call i64 @prim_null_63(i64 %rvp8824) 
  store volatile i64 %n_638829, i64* %vptr14373, align 8 ; call prim_null_63
  %cmpptr14377 = alloca i1, align 8  %cmp14374 = icmp eq i64 %n_638829, 15 store volatile i1 %cmp14374, i1* %cmpptr14377, align 8; false?
  br i1 %cmp14374, label %else14376, label %then14375                                ; if

then14375:
 %vptr14378 = alloca i64, align 8 
  %h8830 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8830, i64* %vptr14378, align 8 ; call prim_halt
  %vptr14384 = alloca i64*, align 8 
  %cloptr14379 = inttoptr i64 %h8830 to i64* 
  store volatile i64* %cloptr14379, i64** %vptr14384, align 8 ; closure/env cast; i64 -> i64*
  %vptr14385 = alloca i64*, align 8 
  %i0ptr14380 = getelementptr inbounds i64, i64* %cloptr14379, i64 1 
  store volatile i64* %i0ptr14380, i64** %vptr14385, align 8 ; &cloptr14379[1]
 %vptr14386 = alloca i64, align 8 
  %f14382 = load i64, i64* %i0ptr14380, align 8 
  store volatile i64 %f14382, i64* %vptr14386, align 8 ; load; *i0ptr14380
  %fptr14381 = inttoptr i64 %f14382 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14381(i64 %h8830, i64 %h8830)                       ; tail call
  ret void

else14376:
 %vptr14387 = alloca i64, align 8 
  %crq$b = call i64 @prim_car(i64 %rvp8824) 
  store volatile i64 %crq$b, i64* %vptr14387, align 8 ; call prim_car
 %vptr14388 = alloca i64, align 8 
  %na8820 = call i64 @prim_cdr(i64 %rvp8824) 
  store volatile i64 %na8820, i64* %vptr14388, align 8 ; call prim_cdr
 %vptr14389 = alloca i64, align 8 
  %n_638825 = call i64 @prim_null_63(i64 %na8820) 
  store volatile i64 %n_638825, i64* %vptr14389, align 8 ; call prim_null_63
  %cmpptr14393 = alloca i1, align 8  %cmp14390 = icmp eq i64 %n_638825, 15 store volatile i1 %cmp14390, i1* %cmpptr14393, align 8; false?
  br i1 %cmp14390, label %else14392, label %then14391                                ; if

then14391:
 %vptr14394 = alloca i64, align 8 
  %a6954 = call i64 @prim__60_61(i64 %plR$a, i64 %crq$b) 
  store volatile i64 %a6954, i64* %vptr14394, align 8 ; call prim__60_61
 %vptr14395 = alloca i64, align 8 
  %retprim7115 = call i64 @prim_not(i64 %a6954) 
  store volatile i64 %retprim7115, i64* %vptr14395, align 8 ; call prim_not
 %vptr14396 = alloca i64, align 8 
  %arg7454 = add i64 0, 0 
  store volatile i64 %arg7454, i64* %vptr14396, align 8 ; quoted ()
 %vptr14397 = alloca i64, align 8 
  %rva8823 = add i64 0, 0 
  store volatile i64 %rva8823, i64* %vptr14397, align 8 ; quoted ()
 %vptr14398 = alloca i64, align 8 
  %rva8822 = call i64 @prim_cons(i64 %retprim7115, i64 %rva8823) 
  store volatile i64 %rva8822, i64* %vptr14398, align 8 ; call prim_cons
 %vptr14399 = alloca i64, align 8 
  %rva8821 = call i64 @prim_cons(i64 %arg7454, i64 %rva8822) 
  store volatile i64 %rva8821, i64* %vptr14399, align 8 ; call prim_cons
  %vptr14405 = alloca i64*, align 8 
  %cloptr14400 = inttoptr i64 %cont7114 to i64* 
  store volatile i64* %cloptr14400, i64** %vptr14405, align 8 ; closure/env cast; i64 -> i64*
  %vptr14406 = alloca i64*, align 8 
  %i0ptr14401 = getelementptr inbounds i64, i64* %cloptr14400, i64 1 
  store volatile i64* %i0ptr14401, i64** %vptr14406, align 8 ; &cloptr14400[1]
 %vptr14407 = alloca i64, align 8 
  %f14403 = load i64, i64* %i0ptr14401, align 8 
  store volatile i64 %f14403, i64* %vptr14407, align 8 ; load; *i0ptr14401
  %fptr14402 = inttoptr i64 %f14403 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14402(i64 %cont7114, i64 %rva8821)                  ; tail call
  ret void

else14392:
 %vptr14408 = alloca i64, align 8 
  %h8826 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h8826, i64* %vptr14408, align 8 ; call prim_halt
  %vptr14414 = alloca i64*, align 8 
  %cloptr14409 = inttoptr i64 %h8826 to i64* 
  store volatile i64* %cloptr14409, i64** %vptr14414, align 8 ; closure/env cast; i64 -> i64*
  %vptr14415 = alloca i64*, align 8 
  %i0ptr14410 = getelementptr inbounds i64, i64* %cloptr14409, i64 1 
  store volatile i64* %i0ptr14410, i64** %vptr14415, align 8 ; &cloptr14409[1]
 %vptr14416 = alloca i64, align 8 
  %f14412 = load i64, i64* %i0ptr14410, align 8 
  store volatile i64 %f14412, i64* %vptr14416, align 8 ; load; *i0ptr14410
  %fptr14411 = inttoptr i64 %f14412 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14411(i64 %h8826, i64 %h8826)                       ; tail call
  ret void
}


define void @lam12377(i64 %env12378, i64 %rvp8849) {
 %vptr14419 = alloca i64, align 8 
  %envptr14417 = inttoptr i64 %env12378 to i64* 
  store volatile i64 %emsg08636, i64* %vptr14419, align 8 ; closure/env cast; i64 -> i64*
  %vptr14420 = alloca i64*, align 8 
  %envptr14418 = getelementptr inbounds i64, i64* %envptr14417, i64 3 
  store volatile i64* %envptr14418, i64** %vptr14420, align 8 ; &envptr14417[2]
 %vptr14421 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr14418, align 8 
  store volatile i64 %emsg08636, i64* %vptr14421, align 8 ; load; *envptr14418
 %vptr14424 = alloca i64, align 8 
  %envptr14422 = inttoptr i64 %env12378 to i64* 
  store volatile i64 %emsg18637, i64* %vptr14424, align 8 ; closure/env cast; i64 -> i64*
  %vptr14425 = alloca i64*, align 8 
  %envptr14423 = getelementptr inbounds i64, i64* %envptr14422, i64 2 
  store volatile i64* %envptr14423, i64** %vptr14425, align 8 ; &envptr14422[1]
 %vptr14426 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr14423, align 8 
  store volatile i64 %emsg18637, i64* %vptr14426, align 8 ; load; *envptr14423
 %vptr14427 = alloca i64, align 8 
  %cont7116 = call i64 @prim_car(i64 %rvp8849) 
  store volatile i64 %cont7116, i64* %vptr14427, align 8 ; call prim_car
 %vptr14428 = alloca i64, align 8 
  %rvp8845 = call i64 @prim_cdr(i64 %rvp8849) 
  store volatile i64 %rvp8845, i64* %vptr14428, align 8 ; call prim_cdr
 %vptr14429 = alloca i64, align 8 
  %n_638850 = call i64 @prim_null_63(i64 %rvp8845) 
  store volatile i64 %n_638850, i64* %vptr14429, align 8 ; call prim_null_63
  %cmpptr14433 = alloca i1, align 8  %cmp14430 = icmp eq i64 %n_638850, 15 store volatile i1 %cmp14430, i1* %cmpptr14433, align 8; false?
  br i1 %cmp14430, label %else14432, label %then14431                                ; if

then14431:
 %vptr14434 = alloca i64, align 8 
  %h8851 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8851, i64* %vptr14434, align 8 ; call prim_halt
  %vptr14440 = alloca i64*, align 8 
  %cloptr14435 = inttoptr i64 %h8851 to i64* 
  store volatile i64* %cloptr14435, i64** %vptr14440, align 8 ; closure/env cast; i64 -> i64*
  %vptr14441 = alloca i64*, align 8 
  %i0ptr14436 = getelementptr inbounds i64, i64* %cloptr14435, i64 1 
  store volatile i64* %i0ptr14436, i64** %vptr14441, align 8 ; &cloptr14435[1]
 %vptr14442 = alloca i64, align 8 
  %f14438 = load i64, i64* %i0ptr14436, align 8 
  store volatile i64 %f14438, i64* %vptr14442, align 8 ; load; *i0ptr14436
  %fptr14437 = inttoptr i64 %f14438 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14437(i64 %h8851, i64 %h8851)                       ; tail call
  ret void

else14432:
 %vptr14443 = alloca i64, align 8 
  %PGx$a = call i64 @prim_car(i64 %rvp8845) 
  store volatile i64 %PGx$a, i64* %vptr14443, align 8 ; call prim_car
 %vptr14444 = alloca i64, align 8 
  %rvp8841 = call i64 @prim_cdr(i64 %rvp8845) 
  store volatile i64 %rvp8841, i64* %vptr14444, align 8 ; call prim_cdr
 %vptr14445 = alloca i64, align 8 
  %n_638846 = call i64 @prim_null_63(i64 %rvp8841) 
  store volatile i64 %n_638846, i64* %vptr14445, align 8 ; call prim_null_63
  %cmpptr14449 = alloca i1, align 8  %cmp14446 = icmp eq i64 %n_638846, 15 store volatile i1 %cmp14446, i1* %cmpptr14449, align 8; false?
  br i1 %cmp14446, label %else14448, label %then14447                                ; if

then14447:
 %vptr14450 = alloca i64, align 8 
  %h8847 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8847, i64* %vptr14450, align 8 ; call prim_halt
  %vptr14456 = alloca i64*, align 8 
  %cloptr14451 = inttoptr i64 %h8847 to i64* 
  store volatile i64* %cloptr14451, i64** %vptr14456, align 8 ; closure/env cast; i64 -> i64*
  %vptr14457 = alloca i64*, align 8 
  %i0ptr14452 = getelementptr inbounds i64, i64* %cloptr14451, i64 1 
  store volatile i64* %i0ptr14452, i64** %vptr14457, align 8 ; &cloptr14451[1]
 %vptr14458 = alloca i64, align 8 
  %f14454 = load i64, i64* %i0ptr14452, align 8 
  store volatile i64 %f14454, i64* %vptr14458, align 8 ; load; *i0ptr14452
  %fptr14453 = inttoptr i64 %f14454 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14453(i64 %h8847, i64 %h8847)                       ; tail call
  ret void

else14448:
 %vptr14459 = alloca i64, align 8 
  %eAi$b = call i64 @prim_car(i64 %rvp8841) 
  store volatile i64 %eAi$b, i64* %vptr14459, align 8 ; call prim_car
 %vptr14460 = alloca i64, align 8 
  %na8837 = call i64 @prim_cdr(i64 %rvp8841) 
  store volatile i64 %na8837, i64* %vptr14460, align 8 ; call prim_cdr
 %vptr14461 = alloca i64, align 8 
  %n_638842 = call i64 @prim_null_63(i64 %na8837) 
  store volatile i64 %n_638842, i64* %vptr14461, align 8 ; call prim_null_63
  %cmpptr14465 = alloca i1, align 8  %cmp14462 = icmp eq i64 %n_638842, 15 store volatile i1 %cmp14462, i1* %cmpptr14465, align 8; false?
  br i1 %cmp14462, label %else14464, label %then14463                                ; if

then14463:
 %vptr14466 = alloca i64, align 8 
  %a6955 = call i64 @prim__60(i64 %PGx$a, i64 %eAi$b) 
  store volatile i64 %a6955, i64* %vptr14466, align 8 ; call prim__60
 %vptr14467 = alloca i64, align 8 
  %retprim7117 = call i64 @prim_not(i64 %a6955) 
  store volatile i64 %retprim7117, i64* %vptr14467, align 8 ; call prim_not
 %vptr14468 = alloca i64, align 8 
  %arg7460 = add i64 0, 0 
  store volatile i64 %arg7460, i64* %vptr14468, align 8 ; quoted ()
 %vptr14469 = alloca i64, align 8 
  %rva8840 = add i64 0, 0 
  store volatile i64 %rva8840, i64* %vptr14469, align 8 ; quoted ()
 %vptr14470 = alloca i64, align 8 
  %rva8839 = call i64 @prim_cons(i64 %retprim7117, i64 %rva8840) 
  store volatile i64 %rva8839, i64* %vptr14470, align 8 ; call prim_cons
 %vptr14471 = alloca i64, align 8 
  %rva8838 = call i64 @prim_cons(i64 %arg7460, i64 %rva8839) 
  store volatile i64 %rva8838, i64* %vptr14471, align 8 ; call prim_cons
  %vptr14477 = alloca i64*, align 8 
  %cloptr14472 = inttoptr i64 %cont7116 to i64* 
  store volatile i64* %cloptr14472, i64** %vptr14477, align 8 ; closure/env cast; i64 -> i64*
  %vptr14478 = alloca i64*, align 8 
  %i0ptr14473 = getelementptr inbounds i64, i64* %cloptr14472, i64 1 
  store volatile i64* %i0ptr14473, i64** %vptr14478, align 8 ; &cloptr14472[1]
 %vptr14479 = alloca i64, align 8 
  %f14475 = load i64, i64* %i0ptr14473, align 8 
  store volatile i64 %f14475, i64* %vptr14479, align 8 ; load; *i0ptr14473
  %fptr14474 = inttoptr i64 %f14475 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14474(i64 %cont7116, i64 %rva8838)                  ; tail call
  ret void

else14464:
 %vptr14480 = alloca i64, align 8 
  %h8843 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h8843, i64* %vptr14480, align 8 ; call prim_halt
  %vptr14486 = alloca i64*, align 8 
  %cloptr14481 = inttoptr i64 %h8843 to i64* 
  store volatile i64* %cloptr14481, i64** %vptr14486, align 8 ; closure/env cast; i64 -> i64*
  %vptr14487 = alloca i64*, align 8 
  %i0ptr14482 = getelementptr inbounds i64, i64* %cloptr14481, i64 1 
  store volatile i64* %i0ptr14482, i64** %vptr14487, align 8 ; &cloptr14481[1]
 %vptr14488 = alloca i64, align 8 
  %f14484 = load i64, i64* %i0ptr14482, align 8 
  store volatile i64 %f14484, i64* %vptr14488, align 8 ; load; *i0ptr14482
  %fptr14483 = inttoptr i64 %f14484 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14483(i64 %h8843, i64 %h8843)                       ; tail call
  ret void
}


define void @lam12368(i64 %env12369, i64 %rvp8883) {
 %vptr14491 = alloca i64, align 8 
  %envptr14489 = inttoptr i64 %env12369 to i64* 
  store volatile i64 %emsg08636, i64* %vptr14491, align 8 ; closure/env cast; i64 -> i64*
  %vptr14492 = alloca i64*, align 8 
  %envptr14490 = getelementptr inbounds i64, i64* %envptr14489, i64 4 
  store volatile i64* %envptr14490, i64** %vptr14492, align 8 ; &envptr14489[3]
 %vptr14493 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr14490, align 8 
  store volatile i64 %emsg08636, i64* %vptr14493, align 8 ; load; *envptr14490
 %vptr14496 = alloca i64, align 8 
  %envptr14494 = inttoptr i64 %env12369 to i64* 
  store volatile i64 %WM4$_37append2, i64* %vptr14496, align 8 ; closure/env cast; i64 -> i64*
  %vptr14497 = alloca i64*, align 8 
  %envptr14495 = getelementptr inbounds i64, i64* %envptr14494, i64 3 
  store volatile i64* %envptr14495, i64** %vptr14497, align 8 ; &envptr14494[2]
 %vptr14498 = alloca i64, align 8 
  %WM4$_37append2 = load i64, i64* %envptr14495, align 8 
  store volatile i64 %WM4$_37append2, i64* %vptr14498, align 8 ; load; *envptr14495
 %vptr14501 = alloca i64, align 8 
  %envptr14499 = inttoptr i64 %env12369 to i64* 
  store volatile i64 %emsg18637, i64* %vptr14501, align 8 ; closure/env cast; i64 -> i64*
  %vptr14502 = alloca i64*, align 8 
  %envptr14500 = getelementptr inbounds i64, i64* %envptr14499, i64 2 
  store volatile i64* %envptr14500, i64** %vptr14502, align 8 ; &envptr14499[1]
 %vptr14503 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr14500, align 8 
  store volatile i64 %emsg18637, i64* %vptr14503, align 8 ; load; *envptr14500
 %vptr14504 = alloca i64, align 8 
  %cont7288 = call i64 @prim_car(i64 %rvp8883) 
  store volatile i64 %cont7288, i64* %vptr14504, align 8 ; call prim_car
 %vptr14505 = alloca i64, align 8 
  %rvp8879 = call i64 @prim_cdr(i64 %rvp8883) 
  store volatile i64 %rvp8879, i64* %vptr14505, align 8 ; call prim_cdr
 %vptr14506 = alloca i64, align 8 
  %n_638884 = call i64 @prim_null_63(i64 %rvp8879) 
  store volatile i64 %n_638884, i64* %vptr14506, align 8 ; call prim_null_63
  %cmpptr14510 = alloca i1, align 8  %cmp14507 = icmp eq i64 %n_638884, 15 store volatile i1 %cmp14507, i1* %cmpptr14510, align 8; false?
  br i1 %cmp14507, label %else14509, label %then14508                                ; if

then14508:
 %vptr14511 = alloca i64, align 8 
  %h8885 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8885, i64* %vptr14511, align 8 ; call prim_halt
  %vptr14517 = alloca i64*, align 8 
  %cloptr14512 = inttoptr i64 %h8885 to i64* 
  store volatile i64* %cloptr14512, i64** %vptr14517, align 8 ; closure/env cast; i64 -> i64*
  %vptr14518 = alloca i64*, align 8 
  %i0ptr14513 = getelementptr inbounds i64, i64* %cloptr14512, i64 1 
  store volatile i64* %i0ptr14513, i64** %vptr14518, align 8 ; &cloptr14512[1]
 %vptr14519 = alloca i64, align 8 
  %f14515 = load i64, i64* %i0ptr14513, align 8 
  store volatile i64 %f14515, i64* %vptr14519, align 8 ; load; *i0ptr14513
  %fptr14514 = inttoptr i64 %f14515 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14514(i64 %h8885, i64 %h8885)                       ; tail call
  ret void

else14509:
 %vptr14520 = alloca i64, align 8 
  %DXP$ls0 = call i64 @prim_car(i64 %rvp8879) 
  store volatile i64 %DXP$ls0, i64* %vptr14520, align 8 ; call prim_car
 %vptr14521 = alloca i64, align 8 
  %rvp8875 = call i64 @prim_cdr(i64 %rvp8879) 
  store volatile i64 %rvp8875, i64* %vptr14521, align 8 ; call prim_cdr
 %vptr14522 = alloca i64, align 8 
  %n_638880 = call i64 @prim_null_63(i64 %rvp8875) 
  store volatile i64 %n_638880, i64* %vptr14522, align 8 ; call prim_null_63
  %cmpptr14526 = alloca i1, align 8  %cmp14523 = icmp eq i64 %n_638880, 15 store volatile i1 %cmp14523, i1* %cmpptr14526, align 8; false?
  br i1 %cmp14523, label %else14525, label %then14524                                ; if

then14524:
 %vptr14527 = alloca i64, align 8 
  %h8881 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8881, i64* %vptr14527, align 8 ; call prim_halt
  %vptr14533 = alloca i64*, align 8 
  %cloptr14528 = inttoptr i64 %h8881 to i64* 
  store volatile i64* %cloptr14528, i64** %vptr14533, align 8 ; closure/env cast; i64 -> i64*
  %vptr14534 = alloca i64*, align 8 
  %i0ptr14529 = getelementptr inbounds i64, i64* %cloptr14528, i64 1 
  store volatile i64* %i0ptr14529, i64** %vptr14534, align 8 ; &cloptr14528[1]
 %vptr14535 = alloca i64, align 8 
  %f14531 = load i64, i64* %i0ptr14529, align 8 
  store volatile i64 %f14531, i64* %vptr14535, align 8 ; load; *i0ptr14529
  %fptr14530 = inttoptr i64 %f14531 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14530(i64 %h8881, i64 %h8881)                       ; tail call
  ret void

else14525:
 %vptr14536 = alloca i64, align 8 
  %Lk9$ls1 = call i64 @prim_car(i64 %rvp8875) 
  store volatile i64 %Lk9$ls1, i64* %vptr14536, align 8 ; call prim_car
 %vptr14537 = alloca i64, align 8 
  %na8854 = call i64 @prim_cdr(i64 %rvp8875) 
  store volatile i64 %na8854, i64* %vptr14537, align 8 ; call prim_cdr
 %vptr14538 = alloca i64, align 8 
  %n_638876 = call i64 @prim_null_63(i64 %na8854) 
  store volatile i64 %n_638876, i64* %vptr14538, align 8 ; call prim_null_63
  %cmpptr14542 = alloca i1, align 8  %cmp14539 = icmp eq i64 %n_638876, 15 store volatile i1 %cmp14539, i1* %cmpptr14542, align 8; false?
  br i1 %cmp14539, label %else14541, label %then14540                                ; if

then14540:
 %vptr14543 = alloca i64, align 8 
  %a6956 = call i64 @prim_null_63(i64 %DXP$ls0) 
  store volatile i64 %a6956, i64* %vptr14543, align 8 ; call prim_null_63
  %cmpptr14547 = alloca i1, align 8  %cmp14544 = icmp eq i64 %a6956, 15 store volatile i1 %cmp14544, i1* %cmpptr14547, align 8; false?
  br i1 %cmp14544, label %else14546, label %then14545                                ; if

then14545:
 %vptr14548 = alloca i64, align 8 
  %arg7471 = add i64 0, 0 
  store volatile i64 %arg7471, i64* %vptr14548, align 8 ; quoted ()
 %vptr14549 = alloca i64, align 8 
  %rva8857 = add i64 0, 0 
  store volatile i64 %rva8857, i64* %vptr14549, align 8 ; quoted ()
 %vptr14550 = alloca i64, align 8 
  %rva8856 = call i64 @prim_cons(i64 %Lk9$ls1, i64 %rva8857) 
  store volatile i64 %rva8856, i64* %vptr14550, align 8 ; call prim_cons
 %vptr14551 = alloca i64, align 8 
  %rva8855 = call i64 @prim_cons(i64 %arg7471, i64 %rva8856) 
  store volatile i64 %rva8855, i64* %vptr14551, align 8 ; call prim_cons
  %vptr14557 = alloca i64*, align 8 
  %cloptr14552 = inttoptr i64 %cont7288 to i64* 
  store volatile i64* %cloptr14552, i64** %vptr14557, align 8 ; closure/env cast; i64 -> i64*
  %vptr14558 = alloca i64*, align 8 
  %i0ptr14553 = getelementptr inbounds i64, i64* %cloptr14552, i64 1 
  store volatile i64* %i0ptr14553, i64** %vptr14558, align 8 ; &cloptr14552[1]
 %vptr14559 = alloca i64, align 8 
  %f14555 = load i64, i64* %i0ptr14553, align 8 
  store volatile i64 %f14555, i64* %vptr14559, align 8 ; load; *i0ptr14553
  %fptr14554 = inttoptr i64 %f14555 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14554(i64 %cont7288, i64 %rva8855)                  ; tail call
  ret void

else14546:
 %vptr14560 = alloca i64, align 8 
  %a6957 = call i64 @prim_car(i64 %DXP$ls0) 
  store volatile i64 %a6957, i64* %vptr14560, align 8 ; call prim_car
 %vptr14561 = alloca i64, align 8 
  %arg7474 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7474, i64* %vptr14561, align 8 ; quoted int
 %vptr14562 = alloca i64, align 8 
  %a6958 = call i64 @prim_vector_45ref(i64 %WM4$_37append2, i64 %arg7474) 
  store volatile i64 %a6958, i64* %vptr14562, align 8 ; call prim_vector_45ref
 %vptr14563 = alloca i64, align 8 
  %a6959 = call i64 @prim_cdr(i64 %DXP$ls0) 
  store volatile i64 %a6959, i64* %vptr14563, align 8 ; call prim_cdr
  %vptr14571 = alloca i64*, align 8 
  %cloptr14564 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr14564, i64** %vptr14571, align 8 ; malloc
  %vptr14572 = alloca i64*, align 8 
  %eptr14566 = getelementptr inbounds i64, i64* %cloptr14564, i64 2 
  store volatile i64* %eptr14566, i64** %vptr14572, align 8 ; &eptr14566[1]
  %vptr14573 = alloca i64*, align 8 
  %eptr14567 = getelementptr inbounds i64, i64* %cloptr14564, i64 3 
  store volatile i64* %eptr14567, i64** %vptr14573, align 8 ; &eptr14567[2]
  %vptr14574 = alloca i64*, align 8 
  %eptr14568 = getelementptr inbounds i64, i64* %cloptr14564, i64 4 
  store volatile i64* %eptr14568, i64** %vptr14574, align 8 ; &eptr14568[3]
  %vptr14575 = alloca i64*, align 8 
  %eptr14569 = getelementptr inbounds i64, i64* %cloptr14564, i64 5 
  store volatile i64* %eptr14569, i64** %vptr14575, align 8 ; &eptr14569[4]
  store i64 %emsg18637, i64* %eptr14566                                              ; *eptr14566 = %emsg18637
  store i64 %cont7288, i64* %eptr14567                                               ; *eptr14567 = %cont7288
  store i64 %a6957, i64* %eptr14568                                                  ; *eptr14568 = %a6957
  store i64 %emsg08636, i64* %eptr14569                                              ; *eptr14569 = %emsg08636
  %vptr14576 = alloca i64*, align 8 
  %eptr14565 = getelementptr inbounds i64, i64* %cloptr14564, i64 1 
  store volatile i64* %eptr14565, i64** %vptr14576, align 8 ; &cloptr14564[1]
 %vptr14577 = alloca i64, align 8 
  %f14570 = ptrtoint void(i64,i64)* @lam12365 to i64 
  store volatile i64 %f14570, i64* %vptr14577, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f14570, i64* %eptr14565                                                 ; store fptr
 %vptr14578 = alloca i64, align 8 
  %arg7479 = ptrtoint i64* %cloptr14564 to i64 
  store volatile i64 %arg7479, i64* %vptr14578, align 8 ; closure cast; i64* -> i64
 %vptr14579 = alloca i64, align 8 
  %rva8874 = add i64 0, 0 
  store volatile i64 %rva8874, i64* %vptr14579, align 8 ; quoted ()
 %vptr14580 = alloca i64, align 8 
  %rva8873 = call i64 @prim_cons(i64 %Lk9$ls1, i64 %rva8874) 
  store volatile i64 %rva8873, i64* %vptr14580, align 8 ; call prim_cons
 %vptr14581 = alloca i64, align 8 
  %rva8872 = call i64 @prim_cons(i64 %a6959, i64 %rva8873) 
  store volatile i64 %rva8872, i64* %vptr14581, align 8 ; call prim_cons
 %vptr14582 = alloca i64, align 8 
  %rva8871 = call i64 @prim_cons(i64 %arg7479, i64 %rva8872) 
  store volatile i64 %rva8871, i64* %vptr14582, align 8 ; call prim_cons
  %vptr14588 = alloca i64*, align 8 
  %cloptr14583 = inttoptr i64 %a6958 to i64* 
  store volatile i64* %cloptr14583, i64** %vptr14588, align 8 ; closure/env cast; i64 -> i64*
  %vptr14589 = alloca i64*, align 8 
  %i0ptr14584 = getelementptr inbounds i64, i64* %cloptr14583, i64 1 
  store volatile i64* %i0ptr14584, i64** %vptr14589, align 8 ; &cloptr14583[1]
 %vptr14590 = alloca i64, align 8 
  %f14586 = load i64, i64* %i0ptr14584, align 8 
  store volatile i64 %f14586, i64* %vptr14590, align 8 ; load; *i0ptr14584
  %fptr14585 = inttoptr i64 %f14586 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14585(i64 %a6958, i64 %rva8871)                     ; tail call
  ret void

else14541:
 %vptr14591 = alloca i64, align 8 
  %h8877 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h8877, i64* %vptr14591, align 8 ; call prim_halt
  %vptr14597 = alloca i64*, align 8 
  %cloptr14592 = inttoptr i64 %h8877 to i64* 
  store volatile i64* %cloptr14592, i64** %vptr14597, align 8 ; closure/env cast; i64 -> i64*
  %vptr14598 = alloca i64*, align 8 
  %i0ptr14593 = getelementptr inbounds i64, i64* %cloptr14592, i64 1 
  store volatile i64* %i0ptr14593, i64** %vptr14598, align 8 ; &cloptr14592[1]
 %vptr14599 = alloca i64, align 8 
  %f14595 = load i64, i64* %i0ptr14593, align 8 
  store volatile i64 %f14595, i64* %vptr14599, align 8 ; load; *i0ptr14593
  %fptr14594 = inttoptr i64 %f14595 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14594(i64 %h8877, i64 %h8877)                       ; tail call
  ret void
}


define void @lam12365(i64 %env12366, i64 %rvp8867) {
 %vptr14602 = alloca i64, align 8 
  %envptr14600 = inttoptr i64 %env12366 to i64* 
  store volatile i64 %emsg08636, i64* %vptr14602, align 8 ; closure/env cast; i64 -> i64*
  %vptr14603 = alloca i64*, align 8 
  %envptr14601 = getelementptr inbounds i64, i64* %envptr14600, i64 5 
  store volatile i64* %envptr14601, i64** %vptr14603, align 8 ; &envptr14600[4]
 %vptr14604 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr14601, align 8 
  store volatile i64 %emsg08636, i64* %vptr14604, align 8 ; load; *envptr14601
 %vptr14607 = alloca i64, align 8 
  %envptr14605 = inttoptr i64 %env12366 to i64* 
  store volatile i64 %a6957, i64* %vptr14607, align 8 ; closure/env cast; i64 -> i64*
  %vptr14608 = alloca i64*, align 8 
  %envptr14606 = getelementptr inbounds i64, i64* %envptr14605, i64 4 
  store volatile i64* %envptr14606, i64** %vptr14608, align 8 ; &envptr14605[3]
 %vptr14609 = alloca i64, align 8 
  %a6957 = load i64, i64* %envptr14606, align 8 
  store volatile i64 %a6957, i64* %vptr14609, align 8 ; load; *envptr14606
 %vptr14612 = alloca i64, align 8 
  %envptr14610 = inttoptr i64 %env12366 to i64* 
  store volatile i64 %cont7288, i64* %vptr14612, align 8 ; closure/env cast; i64 -> i64*
  %vptr14613 = alloca i64*, align 8 
  %envptr14611 = getelementptr inbounds i64, i64* %envptr14610, i64 3 
  store volatile i64* %envptr14611, i64** %vptr14613, align 8 ; &envptr14610[2]
 %vptr14614 = alloca i64, align 8 
  %cont7288 = load i64, i64* %envptr14611, align 8 
  store volatile i64 %cont7288, i64* %vptr14614, align 8 ; load; *envptr14611
 %vptr14617 = alloca i64, align 8 
  %envptr14615 = inttoptr i64 %env12366 to i64* 
  store volatile i64 %emsg18637, i64* %vptr14617, align 8 ; closure/env cast; i64 -> i64*
  %vptr14618 = alloca i64*, align 8 
  %envptr14616 = getelementptr inbounds i64, i64* %envptr14615, i64 2 
  store volatile i64* %envptr14616, i64** %vptr14618, align 8 ; &envptr14615[1]
 %vptr14619 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr14616, align 8 
  store volatile i64 %emsg18637, i64* %vptr14619, align 8 ; load; *envptr14616
 %vptr14620 = alloca i64, align 8 
  %_957289 = call i64 @prim_car(i64 %rvp8867) 
  store volatile i64 %_957289, i64* %vptr14620, align 8 ; call prim_car
 %vptr14621 = alloca i64, align 8 
  %rvp8863 = call i64 @prim_cdr(i64 %rvp8867) 
  store volatile i64 %rvp8863, i64* %vptr14621, align 8 ; call prim_cdr
 %vptr14622 = alloca i64, align 8 
  %n_638868 = call i64 @prim_null_63(i64 %rvp8863) 
  store volatile i64 %n_638868, i64* %vptr14622, align 8 ; call prim_null_63
  %cmpptr14626 = alloca i1, align 8  %cmp14623 = icmp eq i64 %n_638868, 15 store volatile i1 %cmp14623, i1* %cmpptr14626, align 8; false?
  br i1 %cmp14623, label %else14625, label %then14624                                ; if

then14624:
 %vptr14627 = alloca i64, align 8 
  %h8869 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8869, i64* %vptr14627, align 8 ; call prim_halt
  %vptr14633 = alloca i64*, align 8 
  %cloptr14628 = inttoptr i64 %h8869 to i64* 
  store volatile i64* %cloptr14628, i64** %vptr14633, align 8 ; closure/env cast; i64 -> i64*
  %vptr14634 = alloca i64*, align 8 
  %i0ptr14629 = getelementptr inbounds i64, i64* %cloptr14628, i64 1 
  store volatile i64* %i0ptr14629, i64** %vptr14634, align 8 ; &cloptr14628[1]
 %vptr14635 = alloca i64, align 8 
  %f14631 = load i64, i64* %i0ptr14629, align 8 
  store volatile i64 %f14631, i64* %vptr14635, align 8 ; load; *i0ptr14629
  %fptr14630 = inttoptr i64 %f14631 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14630(i64 %h8869, i64 %h8869)                       ; tail call
  ret void

else14625:
 %vptr14636 = alloca i64, align 8 
  %a6960 = call i64 @prim_car(i64 %rvp8863) 
  store volatile i64 %a6960, i64* %vptr14636, align 8 ; call prim_car
 %vptr14637 = alloca i64, align 8 
  %na8859 = call i64 @prim_cdr(i64 %rvp8863) 
  store volatile i64 %na8859, i64* %vptr14637, align 8 ; call prim_cdr
 %vptr14638 = alloca i64, align 8 
  %n_638864 = call i64 @prim_null_63(i64 %na8859) 
  store volatile i64 %n_638864, i64* %vptr14638, align 8 ; call prim_null_63
  %cmpptr14642 = alloca i1, align 8  %cmp14639 = icmp eq i64 %n_638864, 15 store volatile i1 %cmp14639, i1* %cmpptr14642, align 8; false?
  br i1 %cmp14639, label %else14641, label %then14640                                ; if

then14640:
 %vptr14643 = alloca i64, align 8 
  %retprim7290 = call i64 @prim_cons(i64 %a6957, i64 %a6960) 
  store volatile i64 %retprim7290, i64* %vptr14643, align 8 ; call prim_cons
 %vptr14644 = alloca i64, align 8 
  %arg7484 = add i64 0, 0 
  store volatile i64 %arg7484, i64* %vptr14644, align 8 ; quoted ()
 %vptr14645 = alloca i64, align 8 
  %rva8862 = add i64 0, 0 
  store volatile i64 %rva8862, i64* %vptr14645, align 8 ; quoted ()
 %vptr14646 = alloca i64, align 8 
  %rva8861 = call i64 @prim_cons(i64 %retprim7290, i64 %rva8862) 
  store volatile i64 %rva8861, i64* %vptr14646, align 8 ; call prim_cons
 %vptr14647 = alloca i64, align 8 
  %rva8860 = call i64 @prim_cons(i64 %arg7484, i64 %rva8861) 
  store volatile i64 %rva8860, i64* %vptr14647, align 8 ; call prim_cons
  %vptr14653 = alloca i64*, align 8 
  %cloptr14648 = inttoptr i64 %cont7288 to i64* 
  store volatile i64* %cloptr14648, i64** %vptr14653, align 8 ; closure/env cast; i64 -> i64*
  %vptr14654 = alloca i64*, align 8 
  %i0ptr14649 = getelementptr inbounds i64, i64* %cloptr14648, i64 1 
  store volatile i64* %i0ptr14649, i64** %vptr14654, align 8 ; &cloptr14648[1]
 %vptr14655 = alloca i64, align 8 
  %f14651 = load i64, i64* %i0ptr14649, align 8 
  store volatile i64 %f14651, i64* %vptr14655, align 8 ; load; *i0ptr14649
  %fptr14650 = inttoptr i64 %f14651 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14650(i64 %cont7288, i64 %rva8860)                  ; tail call
  ret void

else14641:
 %vptr14656 = alloca i64, align 8 
  %h8865 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h8865, i64* %vptr14656, align 8 ; call prim_halt
  %vptr14662 = alloca i64*, align 8 
  %cloptr14657 = inttoptr i64 %h8865 to i64* 
  store volatile i64* %cloptr14657, i64** %vptr14662, align 8 ; closure/env cast; i64 -> i64*
  %vptr14663 = alloca i64*, align 8 
  %i0ptr14658 = getelementptr inbounds i64, i64* %cloptr14657, i64 1 
  store volatile i64* %i0ptr14658, i64** %vptr14663, align 8 ; &cloptr14657[1]
 %vptr14664 = alloca i64, align 8 
  %f14660 = load i64, i64* %i0ptr14658, align 8 
  store volatile i64 %f14660, i64* %vptr14664, align 8 ; load; *i0ptr14658
  %fptr14659 = inttoptr i64 %f14660 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14659(i64 %h8865, i64 %h8865)                       ; tail call
  ret void
}


define void @lam12357(i64 %env12358, i64 %jGe$xs7292) {
 %vptr14667 = alloca i64, align 8 
  %envptr14665 = inttoptr i64 %env12358 to i64* 
  store volatile i64 %emsg08636, i64* %vptr14667, align 8 ; closure/env cast; i64 -> i64*
  %vptr14668 = alloca i64*, align 8 
  %envptr14666 = getelementptr inbounds i64, i64* %envptr14665, i64 5 
  store volatile i64* %envptr14666, i64** %vptr14668, align 8 ; &envptr14665[4]
 %vptr14669 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr14666, align 8 
  store volatile i64 %emsg08636, i64* %vptr14669, align 8 ; load; *envptr14666
 %vptr14672 = alloca i64, align 8 
  %envptr14670 = inttoptr i64 %env12358 to i64* 
  store volatile i64 %LQt$_37append, i64* %vptr14672, align 8 ; closure/env cast; i64 -> i64*
  %vptr14673 = alloca i64*, align 8 
  %envptr14671 = getelementptr inbounds i64, i64* %envptr14670, i64 4 
  store volatile i64* %envptr14671, i64** %vptr14673, align 8 ; &envptr14670[3]
 %vptr14674 = alloca i64, align 8 
  %LQt$_37append = load i64, i64* %envptr14671, align 8 
  store volatile i64 %LQt$_37append, i64* %vptr14674, align 8 ; load; *envptr14671
 %vptr14677 = alloca i64, align 8 
  %envptr14675 = inttoptr i64 %env12358 to i64* 
  store volatile i64 %WM4$_37append2, i64* %vptr14677, align 8 ; closure/env cast; i64 -> i64*
  %vptr14678 = alloca i64*, align 8 
  %envptr14676 = getelementptr inbounds i64, i64* %envptr14675, i64 3 
  store volatile i64* %envptr14676, i64** %vptr14678, align 8 ; &envptr14675[2]
 %vptr14679 = alloca i64, align 8 
  %WM4$_37append2 = load i64, i64* %envptr14676, align 8 
  store volatile i64 %WM4$_37append2, i64* %vptr14679, align 8 ; load; *envptr14676
 %vptr14682 = alloca i64, align 8 
  %envptr14680 = inttoptr i64 %env12358 to i64* 
  store volatile i64 %emsg18637, i64* %vptr14682, align 8 ; closure/env cast; i64 -> i64*
  %vptr14683 = alloca i64*, align 8 
  %envptr14681 = getelementptr inbounds i64, i64* %envptr14680, i64 2 
  store volatile i64* %envptr14681, i64** %vptr14683, align 8 ; &envptr14680[1]
 %vptr14684 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr14681, align 8 
  store volatile i64 %emsg18637, i64* %vptr14684, align 8 ; load; *envptr14681
 %vptr14685 = alloca i64, align 8 
  %cont7291 = call i64 @prim_car(i64 %jGe$xs7292) 
  store volatile i64 %cont7291, i64* %vptr14685, align 8 ; call prim_car
 %vptr14686 = alloca i64, align 8 
  %jGe$xs = call i64 @prim_cdr(i64 %jGe$xs7292) 
  store volatile i64 %jGe$xs, i64* %vptr14686, align 8 ; call prim_cdr
 %vptr14687 = alloca i64, align 8 
  %a6961 = call i64 @prim_null_63(i64 %jGe$xs) 
  store volatile i64 %a6961, i64* %vptr14687, align 8 ; call prim_null_63
  %cmpptr14691 = alloca i1, align 8  %cmp14688 = icmp eq i64 %a6961, 15 store volatile i1 %cmp14688, i1* %cmpptr14691, align 8; false?
  br i1 %cmp14688, label %else14690, label %then14689                                ; if

then14689:
 %vptr14692 = alloca i64, align 8 
  %arg7493 = add i64 0, 0 
  store volatile i64 %arg7493, i64* %vptr14692, align 8 ; quoted ()
 %vptr14693 = alloca i64, align 8 
  %arg7492 = add i64 0, 0 
  store volatile i64 %arg7492, i64* %vptr14693, align 8 ; quoted ()
 %vptr14694 = alloca i64, align 8 
  %rva8889 = add i64 0, 0 
  store volatile i64 %rva8889, i64* %vptr14694, align 8 ; quoted ()
 %vptr14695 = alloca i64, align 8 
  %rva8888 = call i64 @prim_cons(i64 %arg7492, i64 %rva8889) 
  store volatile i64 %rva8888, i64* %vptr14695, align 8 ; call prim_cons
 %vptr14696 = alloca i64, align 8 
  %rva8887 = call i64 @prim_cons(i64 %arg7493, i64 %rva8888) 
  store volatile i64 %rva8887, i64* %vptr14696, align 8 ; call prim_cons
  %vptr14702 = alloca i64*, align 8 
  %cloptr14697 = inttoptr i64 %cont7291 to i64* 
  store volatile i64* %cloptr14697, i64** %vptr14702, align 8 ; closure/env cast; i64 -> i64*
  %vptr14703 = alloca i64*, align 8 
  %i0ptr14698 = getelementptr inbounds i64, i64* %cloptr14697, i64 1 
  store volatile i64* %i0ptr14698, i64** %vptr14703, align 8 ; &cloptr14697[1]
 %vptr14704 = alloca i64, align 8 
  %f14700 = load i64, i64* %i0ptr14698, align 8 
  store volatile i64 %f14700, i64* %vptr14704, align 8 ; load; *i0ptr14698
  %fptr14699 = inttoptr i64 %f14700 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14699(i64 %cont7291, i64 %rva8887)                  ; tail call
  ret void

else14690:
 %vptr14705 = alloca i64, align 8 
  %CFu$hd = call i64 @prim_car(i64 %jGe$xs) 
  store volatile i64 %CFu$hd, i64* %vptr14705, align 8 ; call prim_car
 %vptr14706 = alloca i64, align 8 
  %CYw$tl = call i64 @prim_cdr(i64 %jGe$xs) 
  store volatile i64 %CYw$tl, i64* %vptr14706, align 8 ; call prim_cdr
 %vptr14707 = alloca i64, align 8 
  %arg7497 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7497, i64* %vptr14707, align 8 ; quoted int
 %vptr14708 = alloca i64, align 8 
  %a6962 = call i64 @prim_vector_45ref(i64 %LQt$_37append, i64 %arg7497) 
  store volatile i64 %a6962, i64* %vptr14708, align 8 ; call prim_vector_45ref
  %vptr14717 = alloca i64*, align 8 
  %cloptr14709 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr14709, i64** %vptr14717, align 8 ; malloc
  %vptr14718 = alloca i64*, align 8 
  %eptr14711 = getelementptr inbounds i64, i64* %cloptr14709, i64 2 
  store volatile i64* %eptr14711, i64** %vptr14718, align 8 ; &eptr14711[1]
  %vptr14719 = alloca i64*, align 8 
  %eptr14712 = getelementptr inbounds i64, i64* %cloptr14709, i64 3 
  store volatile i64* %eptr14712, i64** %vptr14719, align 8 ; &eptr14712[2]
  %vptr14720 = alloca i64*, align 8 
  %eptr14713 = getelementptr inbounds i64, i64* %cloptr14709, i64 4 
  store volatile i64* %eptr14713, i64** %vptr14720, align 8 ; &eptr14713[3]
  %vptr14721 = alloca i64*, align 8 
  %eptr14714 = getelementptr inbounds i64, i64* %cloptr14709, i64 5 
  store volatile i64* %eptr14714, i64** %vptr14721, align 8 ; &eptr14714[4]
  %vptr14722 = alloca i64*, align 8 
  %eptr14715 = getelementptr inbounds i64, i64* %cloptr14709, i64 6 
  store volatile i64* %eptr14715, i64** %vptr14722, align 8 ; &eptr14715[5]
  store i64 %CFu$hd, i64* %eptr14711                                                 ; *eptr14711 = %CFu$hd
  store i64 %emsg18637, i64* %eptr14712                                              ; *eptr14712 = %emsg18637
  store i64 %WM4$_37append2, i64* %eptr14713                                         ; *eptr14713 = %WM4$_37append2
  store i64 %emsg08636, i64* %eptr14714                                              ; *eptr14714 = %emsg08636
  store i64 %cont7291, i64* %eptr14715                                               ; *eptr14715 = %cont7291
  %vptr14723 = alloca i64*, align 8 
  %eptr14710 = getelementptr inbounds i64, i64* %cloptr14709, i64 1 
  store volatile i64* %eptr14710, i64** %vptr14723, align 8 ; &cloptr14709[1]
 %vptr14724 = alloca i64, align 8 
  %f14716 = ptrtoint void(i64,i64)* @lam12354 to i64 
  store volatile i64 %f14716, i64* %vptr14724, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f14716, i64* %eptr14710                                                 ; store fptr
 %vptr14725 = alloca i64, align 8 
  %arg7500 = ptrtoint i64* %cloptr14709 to i64 
  store volatile i64 %arg7500, i64* %vptr14725, align 8 ; closure cast; i64* -> i64
 %vptr14726 = alloca i64, align 8 
  %cps_45lst7294 = call i64 @prim_cons(i64 %arg7500, i64 %CYw$tl) 
  store volatile i64 %cps_45lst7294, i64* %vptr14726, align 8 ; call prim_cons
  %vptr14732 = alloca i64*, align 8 
  %cloptr14727 = inttoptr i64 %a6962 to i64* 
  store volatile i64* %cloptr14727, i64** %vptr14732, align 8 ; closure/env cast; i64 -> i64*
  %vptr14733 = alloca i64*, align 8 
  %i0ptr14728 = getelementptr inbounds i64, i64* %cloptr14727, i64 1 
  store volatile i64* %i0ptr14728, i64** %vptr14733, align 8 ; &cloptr14727[1]
 %vptr14734 = alloca i64, align 8 
  %f14730 = load i64, i64* %i0ptr14728, align 8 
  store volatile i64 %f14730, i64* %vptr14734, align 8 ; load; *i0ptr14728
  %fptr14729 = inttoptr i64 %f14730 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14729(i64 %a6962, i64 %cps_45lst7294)               ; tail call
  ret void
}


define void @lam12354(i64 %env12355, i64 %rvp8900) {
 %vptr14737 = alloca i64, align 8 
  %envptr14735 = inttoptr i64 %env12355 to i64* 
  store volatile i64 %cont7291, i64* %vptr14737, align 8 ; closure/env cast; i64 -> i64*
  %vptr14738 = alloca i64*, align 8 
  %envptr14736 = getelementptr inbounds i64, i64* %envptr14735, i64 6 
  store volatile i64* %envptr14736, i64** %vptr14738, align 8 ; &envptr14735[5]
 %vptr14739 = alloca i64, align 8 
  %cont7291 = load i64, i64* %envptr14736, align 8 
  store volatile i64 %cont7291, i64* %vptr14739, align 8 ; load; *envptr14736
 %vptr14742 = alloca i64, align 8 
  %envptr14740 = inttoptr i64 %env12355 to i64* 
  store volatile i64 %emsg08636, i64* %vptr14742, align 8 ; closure/env cast; i64 -> i64*
  %vptr14743 = alloca i64*, align 8 
  %envptr14741 = getelementptr inbounds i64, i64* %envptr14740, i64 5 
  store volatile i64* %envptr14741, i64** %vptr14743, align 8 ; &envptr14740[4]
 %vptr14744 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr14741, align 8 
  store volatile i64 %emsg08636, i64* %vptr14744, align 8 ; load; *envptr14741
 %vptr14747 = alloca i64, align 8 
  %envptr14745 = inttoptr i64 %env12355 to i64* 
  store volatile i64 %WM4$_37append2, i64* %vptr14747, align 8 ; closure/env cast; i64 -> i64*
  %vptr14748 = alloca i64*, align 8 
  %envptr14746 = getelementptr inbounds i64, i64* %envptr14745, i64 4 
  store volatile i64* %envptr14746, i64** %vptr14748, align 8 ; &envptr14745[3]
 %vptr14749 = alloca i64, align 8 
  %WM4$_37append2 = load i64, i64* %envptr14746, align 8 
  store volatile i64 %WM4$_37append2, i64* %vptr14749, align 8 ; load; *envptr14746
 %vptr14752 = alloca i64, align 8 
  %envptr14750 = inttoptr i64 %env12355 to i64* 
  store volatile i64 %emsg18637, i64* %vptr14752, align 8 ; closure/env cast; i64 -> i64*
  %vptr14753 = alloca i64*, align 8 
  %envptr14751 = getelementptr inbounds i64, i64* %envptr14750, i64 3 
  store volatile i64* %envptr14751, i64** %vptr14753, align 8 ; &envptr14750[2]
 %vptr14754 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr14751, align 8 
  store volatile i64 %emsg18637, i64* %vptr14754, align 8 ; load; *envptr14751
 %vptr14757 = alloca i64, align 8 
  %envptr14755 = inttoptr i64 %env12355 to i64* 
  store volatile i64 %CFu$hd, i64* %vptr14757, align 8 ; closure/env cast; i64 -> i64*
  %vptr14758 = alloca i64*, align 8 
  %envptr14756 = getelementptr inbounds i64, i64* %envptr14755, i64 2 
  store volatile i64* %envptr14756, i64** %vptr14758, align 8 ; &envptr14755[1]
 %vptr14759 = alloca i64, align 8 
  %CFu$hd = load i64, i64* %envptr14756, align 8 
  store volatile i64 %CFu$hd, i64* %vptr14759, align 8 ; load; *envptr14756
 %vptr14760 = alloca i64, align 8 
  %_957293 = call i64 @prim_car(i64 %rvp8900) 
  store volatile i64 %_957293, i64* %vptr14760, align 8 ; call prim_car
 %vptr14761 = alloca i64, align 8 
  %rvp8896 = call i64 @prim_cdr(i64 %rvp8900) 
  store volatile i64 %rvp8896, i64* %vptr14761, align 8 ; call prim_cdr
 %vptr14762 = alloca i64, align 8 
  %n_638901 = call i64 @prim_null_63(i64 %rvp8896) 
  store volatile i64 %n_638901, i64* %vptr14762, align 8 ; call prim_null_63
  %cmpptr14766 = alloca i1, align 8  %cmp14763 = icmp eq i64 %n_638901, 15 store volatile i1 %cmp14763, i1* %cmpptr14766, align 8; false?
  br i1 %cmp14763, label %else14765, label %then14764                                ; if

then14764:
 %vptr14767 = alloca i64, align 8 
  %h8902 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8902, i64* %vptr14767, align 8 ; call prim_halt
  %vptr14773 = alloca i64*, align 8 
  %cloptr14768 = inttoptr i64 %h8902 to i64* 
  store volatile i64* %cloptr14768, i64** %vptr14773, align 8 ; closure/env cast; i64 -> i64*
  %vptr14774 = alloca i64*, align 8 
  %i0ptr14769 = getelementptr inbounds i64, i64* %cloptr14768, i64 1 
  store volatile i64* %i0ptr14769, i64** %vptr14774, align 8 ; &cloptr14768[1]
 %vptr14775 = alloca i64, align 8 
  %f14771 = load i64, i64* %i0ptr14769, align 8 
  store volatile i64 %f14771, i64* %vptr14775, align 8 ; load; *i0ptr14769
  %fptr14770 = inttoptr i64 %f14771 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14770(i64 %h8902, i64 %h8902)                       ; tail call
  ret void

else14765:
 %vptr14776 = alloca i64, align 8 
  %Ezu$result1 = call i64 @prim_car(i64 %rvp8896) 
  store volatile i64 %Ezu$result1, i64* %vptr14776, align 8 ; call prim_car
 %vptr14777 = alloca i64, align 8 
  %na8891 = call i64 @prim_cdr(i64 %rvp8896) 
  store volatile i64 %na8891, i64* %vptr14777, align 8 ; call prim_cdr
 %vptr14778 = alloca i64, align 8 
  %n_638897 = call i64 @prim_null_63(i64 %na8891) 
  store volatile i64 %n_638897, i64* %vptr14778, align 8 ; call prim_null_63
  %cmpptr14782 = alloca i1, align 8  %cmp14779 = icmp eq i64 %n_638897, 15 store volatile i1 %cmp14779, i1* %cmpptr14782, align 8; false?
  br i1 %cmp14779, label %else14781, label %then14780                                ; if

then14780:
 %vptr14783 = alloca i64, align 8 
  %arg7501 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7501, i64* %vptr14783, align 8 ; quoted int
 %vptr14784 = alloca i64, align 8 
  %a6963 = call i64 @prim_vector_45ref(i64 %WM4$_37append2, i64 %arg7501) 
  store volatile i64 %a6963, i64* %vptr14784, align 8 ; call prim_vector_45ref
 %vptr14785 = alloca i64, align 8 
  %rva8895 = add i64 0, 0 
  store volatile i64 %rva8895, i64* %vptr14785, align 8 ; quoted ()
 %vptr14786 = alloca i64, align 8 
  %rva8894 = call i64 @prim_cons(i64 %Ezu$result1, i64 %rva8895) 
  store volatile i64 %rva8894, i64* %vptr14786, align 8 ; call prim_cons
 %vptr14787 = alloca i64, align 8 
  %rva8893 = call i64 @prim_cons(i64 %CFu$hd, i64 %rva8894) 
  store volatile i64 %rva8893, i64* %vptr14787, align 8 ; call prim_cons
 %vptr14788 = alloca i64, align 8 
  %rva8892 = call i64 @prim_cons(i64 %cont7291, i64 %rva8893) 
  store volatile i64 %rva8892, i64* %vptr14788, align 8 ; call prim_cons
  %vptr14794 = alloca i64*, align 8 
  %cloptr14789 = inttoptr i64 %a6963 to i64* 
  store volatile i64* %cloptr14789, i64** %vptr14794, align 8 ; closure/env cast; i64 -> i64*
  %vptr14795 = alloca i64*, align 8 
  %i0ptr14790 = getelementptr inbounds i64, i64* %cloptr14789, i64 1 
  store volatile i64* %i0ptr14790, i64** %vptr14795, align 8 ; &cloptr14789[1]
 %vptr14796 = alloca i64, align 8 
  %f14792 = load i64, i64* %i0ptr14790, align 8 
  store volatile i64 %f14792, i64* %vptr14796, align 8 ; load; *i0ptr14790
  %fptr14791 = inttoptr i64 %f14792 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14791(i64 %a6963, i64 %rva8892)                     ; tail call
  ret void

else14781:
 %vptr14797 = alloca i64, align 8 
  %h8898 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h8898, i64* %vptr14797, align 8 ; call prim_halt
  %vptr14803 = alloca i64*, align 8 
  %cloptr14798 = inttoptr i64 %h8898 to i64* 
  store volatile i64* %cloptr14798, i64** %vptr14803, align 8 ; closure/env cast; i64 -> i64*
  %vptr14804 = alloca i64*, align 8 
  %i0ptr14799 = getelementptr inbounds i64, i64* %cloptr14798, i64 1 
  store volatile i64* %i0ptr14799, i64** %vptr14804, align 8 ; &cloptr14798[1]
 %vptr14805 = alloca i64, align 8 
  %f14801 = load i64, i64* %i0ptr14799, align 8 
  store volatile i64 %f14801, i64* %vptr14805, align 8 ; load; *i0ptr14799
  %fptr14800 = inttoptr i64 %f14801 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14800(i64 %h8898, i64 %h8898)                       ; tail call
  ret void
}


define void @lam12346(i64 %env12347, i64 %rvp10738) {
 %vptr14808 = alloca i64, align 8 
  %envptr14806 = inttoptr i64 %env12347 to i64* 
  store volatile i64 %F5P$_37foldl1, i64* %vptr14808, align 8 ; closure/env cast; i64 -> i64*
  %vptr14809 = alloca i64*, align 8 
  %envptr14807 = getelementptr inbounds i64, i64* %envptr14806, i64 6 
  store volatile i64* %envptr14807, i64** %vptr14809, align 8 ; &envptr14806[5]
 %vptr14810 = alloca i64, align 8 
  %F5P$_37foldl1 = load i64, i64* %envptr14807, align 8 
  store volatile i64 %F5P$_37foldl1, i64* %vptr14810, align 8 ; load; *envptr14807
 %vptr14813 = alloca i64, align 8 
  %envptr14811 = inttoptr i64 %env12347 to i64* 
  store volatile i64 %uLY$_37_62, i64* %vptr14813, align 8 ; closure/env cast; i64 -> i64*
  %vptr14814 = alloca i64*, align 8 
  %envptr14812 = getelementptr inbounds i64, i64* %envptr14811, i64 5 
  store volatile i64* %envptr14812, i64** %vptr14814, align 8 ; &envptr14811[4]
 %vptr14815 = alloca i64, align 8 
  %uLY$_37_62 = load i64, i64* %envptr14812, align 8 
  store volatile i64 %uLY$_37_62, i64* %vptr14815, align 8 ; load; *envptr14812
 %vptr14818 = alloca i64, align 8 
  %envptr14816 = inttoptr i64 %env12347 to i64* 
  store volatile i64 %emsg08636, i64* %vptr14818, align 8 ; closure/env cast; i64 -> i64*
  %vptr14819 = alloca i64*, align 8 
  %envptr14817 = getelementptr inbounds i64, i64* %envptr14816, i64 4 
  store volatile i64* %envptr14817, i64** %vptr14819, align 8 ; &envptr14816[3]
 %vptr14820 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr14817, align 8 
  store volatile i64 %emsg08636, i64* %vptr14820, align 8 ; load; *envptr14817
 %vptr14823 = alloca i64, align 8 
  %envptr14821 = inttoptr i64 %env12347 to i64* 
  store volatile i64 %Jup$_37length, i64* %vptr14823, align 8 ; closure/env cast; i64 -> i64*
  %vptr14824 = alloca i64*, align 8 
  %envptr14822 = getelementptr inbounds i64, i64* %envptr14821, i64 3 
  store volatile i64* %envptr14822, i64** %vptr14824, align 8 ; &envptr14821[2]
 %vptr14825 = alloca i64, align 8 
  %Jup$_37length = load i64, i64* %envptr14822, align 8 
  store volatile i64 %Jup$_37length, i64* %vptr14825, align 8 ; load; *envptr14822
 %vptr14828 = alloca i64, align 8 
  %envptr14826 = inttoptr i64 %env12347 to i64* 
  store volatile i64 %emsg18637, i64* %vptr14828, align 8 ; closure/env cast; i64 -> i64*
  %vptr14829 = alloca i64*, align 8 
  %envptr14827 = getelementptr inbounds i64, i64* %envptr14826, i64 2 
  store volatile i64* %envptr14827, i64** %vptr14829, align 8 ; &envptr14826[1]
 %vptr14830 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr14827, align 8 
  store volatile i64 %emsg18637, i64* %vptr14830, align 8 ; load; *envptr14827
 %vptr14831 = alloca i64, align 8 
  %_957118 = call i64 @prim_car(i64 %rvp10738) 
  store volatile i64 %_957118, i64* %vptr14831, align 8 ; call prim_car
 %vptr14832 = alloca i64, align 8 
  %rvp10734 = call i64 @prim_cdr(i64 %rvp10738) 
  store volatile i64 %rvp10734, i64* %vptr14832, align 8 ; call prim_cdr
 %vptr14833 = alloca i64, align 8 
  %n_6310739 = call i64 @prim_null_63(i64 %rvp10734) 
  store volatile i64 %n_6310739, i64* %vptr14833, align 8 ; call prim_null_63
  %cmpptr14837 = alloca i1, align 8  %cmp14834 = icmp eq i64 %n_6310739, 15 store volatile i1 %cmp14834, i1* %cmpptr14837, align 8; false?
  br i1 %cmp14834, label %else14836, label %then14835                                ; if

then14835:
 %vptr14838 = alloca i64, align 8 
  %h10740 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10740, i64* %vptr14838, align 8 ; call prim_halt
  %vptr14844 = alloca i64*, align 8 
  %cloptr14839 = inttoptr i64 %h10740 to i64* 
  store volatile i64* %cloptr14839, i64** %vptr14844, align 8 ; closure/env cast; i64 -> i64*
  %vptr14845 = alloca i64*, align 8 
  %i0ptr14840 = getelementptr inbounds i64, i64* %cloptr14839, i64 1 
  store volatile i64* %i0ptr14840, i64** %vptr14845, align 8 ; &cloptr14839[1]
 %vptr14846 = alloca i64, align 8 
  %f14842 = load i64, i64* %i0ptr14840, align 8 
  store volatile i64 %f14842, i64* %vptr14846, align 8 ; load; *i0ptr14840
  %fptr14841 = inttoptr i64 %f14842 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14841(i64 %h10740, i64 %h10740)                     ; tail call
  ret void

else14836:
 %vptr14847 = alloca i64, align 8 
  %QiN$_37append = call i64 @prim_car(i64 %rvp10734) 
  store volatile i64 %QiN$_37append, i64* %vptr14847, align 8 ; call prim_car
 %vptr14848 = alloca i64, align 8 
  %na8905 = call i64 @prim_cdr(i64 %rvp10734) 
  store volatile i64 %na8905, i64* %vptr14848, align 8 ; call prim_cdr
 %vptr14849 = alloca i64, align 8 
  %n_6310735 = call i64 @prim_null_63(i64 %na8905) 
  store volatile i64 %n_6310735, i64* %vptr14849, align 8 ; call prim_null_63
  %cmpptr14853 = alloca i1, align 8  %cmp14850 = icmp eq i64 %n_6310735, 15 store volatile i1 %cmp14850, i1* %cmpptr14853, align 8; false?
  br i1 %cmp14850, label %else14852, label %then14851                                ; if

then14851:
  %vptr14859 = alloca i64*, align 8 
  %cloptr14854 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr14854, i64** %vptr14859, align 8 ; malloc
  %vptr14860 = alloca i64*, align 8 
  %eptr14856 = getelementptr inbounds i64, i64* %cloptr14854, i64 2 
  store volatile i64* %eptr14856, i64** %vptr14860, align 8 ; &eptr14856[1]
  %vptr14861 = alloca i64*, align 8 
  %eptr14857 = getelementptr inbounds i64, i64* %cloptr14854, i64 3 
  store volatile i64* %eptr14857, i64** %vptr14861, align 8 ; &eptr14857[2]
  store i64 %emsg18637, i64* %eptr14856                                              ; *eptr14856 = %emsg18637
  store i64 %emsg08636, i64* %eptr14857                                              ; *eptr14857 = %emsg08636
  %vptr14862 = alloca i64*, align 8 
  %eptr14855 = getelementptr inbounds i64, i64* %cloptr14854, i64 1 
  store volatile i64* %eptr14855, i64** %vptr14862, align 8 ; &cloptr14854[1]
 %vptr14863 = alloca i64, align 8 
  %f14858 = ptrtoint void(i64,i64)* @lam12344 to i64 
  store volatile i64 %f14858, i64* %vptr14863, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f14858, i64* %eptr14855                                                 ; store fptr
 %vptr14864 = alloca i64, align 8 
  %vY8$_37list_63 = ptrtoint i64* %cloptr14854 to i64 
  store volatile i64 %vY8$_37list_63, i64* %vptr14864, align 8 ; closure cast; i64* -> i64
  %vptr14870 = alloca i64*, align 8 
  %cloptr14865 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr14865, i64** %vptr14870, align 8 ; malloc
  %vptr14871 = alloca i64*, align 8 
  %eptr14867 = getelementptr inbounds i64, i64* %cloptr14865, i64 2 
  store volatile i64* %eptr14867, i64** %vptr14871, align 8 ; &eptr14867[1]
  %vptr14872 = alloca i64*, align 8 
  %eptr14868 = getelementptr inbounds i64, i64* %cloptr14865, i64 3 
  store volatile i64* %eptr14868, i64** %vptr14872, align 8 ; &eptr14868[2]
  store i64 %emsg18637, i64* %eptr14867                                              ; *eptr14867 = %emsg18637
  store i64 %emsg08636, i64* %eptr14868                                              ; *eptr14868 = %emsg08636
  %vptr14873 = alloca i64*, align 8 
  %eptr14866 = getelementptr inbounds i64, i64* %cloptr14865, i64 1 
  store volatile i64* %eptr14866, i64** %vptr14873, align 8 ; &cloptr14865[1]
 %vptr14874 = alloca i64, align 8 
  %f14869 = ptrtoint void(i64,i64)* @lam12292 to i64 
  store volatile i64 %f14869, i64* %vptr14874, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f14869, i64* %eptr14866                                                 ; store fptr
 %vptr14875 = alloca i64, align 8 
  %zTP$_37drop = ptrtoint i64* %cloptr14865 to i64 
  store volatile i64 %zTP$_37drop, i64* %vptr14875, align 8 ; closure cast; i64* -> i64
  %vptr14881 = alloca i64*, align 8 
  %cloptr14876 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr14876, i64** %vptr14881, align 8 ; malloc
  %vptr14882 = alloca i64*, align 8 
  %eptr14878 = getelementptr inbounds i64, i64* %cloptr14876, i64 2 
  store volatile i64* %eptr14878, i64** %vptr14882, align 8 ; &eptr14878[1]
  %vptr14883 = alloca i64*, align 8 
  %eptr14879 = getelementptr inbounds i64, i64* %cloptr14876, i64 3 
  store volatile i64* %eptr14879, i64** %vptr14883, align 8 ; &eptr14879[2]
  store i64 %emsg18637, i64* %eptr14878                                              ; *eptr14878 = %emsg18637
  store i64 %emsg08636, i64* %eptr14879                                              ; *eptr14879 = %emsg08636
  %vptr14884 = alloca i64*, align 8 
  %eptr14877 = getelementptr inbounds i64, i64* %cloptr14876, i64 1 
  store volatile i64* %eptr14877, i64** %vptr14884, align 8 ; &cloptr14876[1]
 %vptr14885 = alloca i64, align 8 
  %f14880 = ptrtoint void(i64,i64)* @lam12242 to i64 
  store volatile i64 %f14880, i64* %vptr14885, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f14880, i64* %eptr14877                                                 ; store fptr
 %vptr14886 = alloca i64, align 8 
  %OZi$_37memv = ptrtoint i64* %cloptr14876 to i64 
  store volatile i64 %OZi$_37memv, i64* %vptr14886, align 8 ; closure cast; i64* -> i64
  %vptr14893 = alloca i64*, align 8 
  %cloptr14887 = call i64* @make_closure(i64 32) 
  store volatile i64* %cloptr14887, i64** %vptr14893, align 8 ; malloc
  %vptr14894 = alloca i64*, align 8 
  %eptr14889 = getelementptr inbounds i64, i64* %cloptr14887, i64 2 
  store volatile i64* %eptr14889, i64** %vptr14894, align 8 ; &eptr14889[1]
  %vptr14895 = alloca i64*, align 8 
  %eptr14890 = getelementptr inbounds i64, i64* %cloptr14887, i64 3 
  store volatile i64* %eptr14890, i64** %vptr14895, align 8 ; &eptr14890[2]
  %vptr14896 = alloca i64*, align 8 
  %eptr14891 = getelementptr inbounds i64, i64* %cloptr14887, i64 4 
  store volatile i64* %eptr14891, i64** %vptr14896, align 8 ; &eptr14891[3]
  store i64 %emsg18637, i64* %eptr14889                                              ; *eptr14889 = %emsg18637
  store i64 %emsg08636, i64* %eptr14890                                              ; *eptr14890 = %emsg08636
  store i64 %F5P$_37foldl1, i64* %eptr14891                                          ; *eptr14891 = %F5P$_37foldl1
  %vptr14897 = alloca i64*, align 8 
  %eptr14888 = getelementptr inbounds i64, i64* %cloptr14887, i64 1 
  store volatile i64* %eptr14888, i64** %vptr14897, align 8 ; &cloptr14887[1]
 %vptr14898 = alloca i64, align 8 
  %f14892 = ptrtoint void(i64,i64)* @lam12201 to i64 
  store volatile i64 %f14892, i64* %vptr14898, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f14892, i64* %eptr14888                                                 ; store fptr
 %vptr14899 = alloca i64, align 8 
  %r85$_37_47 = ptrtoint i64* %cloptr14887 to i64 
  store volatile i64 %r85$_37_47, i64* %vptr14899, align 8 ; closure cast; i64* -> i64
  %vptr14905 = alloca i64*, align 8 
  %cloptr14900 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr14900, i64** %vptr14905, align 8 ; malloc
  %vptr14906 = alloca i64*, align 8 
  %eptr14902 = getelementptr inbounds i64, i64* %cloptr14900, i64 2 
  store volatile i64* %eptr14902, i64** %vptr14906, align 8 ; &eptr14902[1]
  %vptr14907 = alloca i64*, align 8 
  %eptr14903 = getelementptr inbounds i64, i64* %cloptr14900, i64 3 
  store volatile i64* %eptr14903, i64** %vptr14907, align 8 ; &eptr14903[2]
  store i64 %emsg18637, i64* %eptr14902                                              ; *eptr14902 = %emsg18637
  store i64 %emsg08636, i64* %eptr14903                                              ; *eptr14903 = %emsg08636
  %vptr14908 = alloca i64*, align 8 
  %eptr14901 = getelementptr inbounds i64, i64* %cloptr14900, i64 1 
  store volatile i64* %eptr14901, i64** %vptr14908, align 8 ; &cloptr14900[1]
 %vptr14909 = alloca i64, align 8 
  %f14904 = ptrtoint void(i64,i64)* @lam12189 to i64 
  store volatile i64 %f14904, i64* %vptr14909, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f14904, i64* %eptr14901                                                 ; store fptr
 %vptr14910 = alloca i64, align 8 
  %x2E$_37first = ptrtoint i64* %cloptr14900 to i64 
  store volatile i64 %x2E$_37first, i64* %vptr14910, align 8 ; closure cast; i64* -> i64
  %vptr14916 = alloca i64*, align 8 
  %cloptr14911 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr14911, i64** %vptr14916, align 8 ; malloc
  %vptr14917 = alloca i64*, align 8 
  %eptr14913 = getelementptr inbounds i64, i64* %cloptr14911, i64 2 
  store volatile i64* %eptr14913, i64** %vptr14917, align 8 ; &eptr14913[1]
  %vptr14918 = alloca i64*, align 8 
  %eptr14914 = getelementptr inbounds i64, i64* %cloptr14911, i64 3 
  store volatile i64* %eptr14914, i64** %vptr14918, align 8 ; &eptr14914[2]
  store i64 %emsg18637, i64* %eptr14913                                              ; *eptr14913 = %emsg18637
  store i64 %emsg08636, i64* %eptr14914                                              ; *eptr14914 = %emsg08636
  %vptr14919 = alloca i64*, align 8 
  %eptr14912 = getelementptr inbounds i64, i64* %cloptr14911, i64 1 
  store volatile i64* %eptr14912, i64** %vptr14919, align 8 ; &cloptr14911[1]
 %vptr14920 = alloca i64, align 8 
  %f14915 = ptrtoint void(i64,i64)* @lam12185 to i64 
  store volatile i64 %f14915, i64* %vptr14920, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f14915, i64* %eptr14912                                                 ; store fptr
 %vptr14921 = alloca i64, align 8 
  %t9Z$_37second = ptrtoint i64* %cloptr14911 to i64 
  store volatile i64 %t9Z$_37second, i64* %vptr14921, align 8 ; closure cast; i64* -> i64
  %vptr14927 = alloca i64*, align 8 
  %cloptr14922 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr14922, i64** %vptr14927, align 8 ; malloc
  %vptr14928 = alloca i64*, align 8 
  %eptr14924 = getelementptr inbounds i64, i64* %cloptr14922, i64 2 
  store volatile i64* %eptr14924, i64** %vptr14928, align 8 ; &eptr14924[1]
  %vptr14929 = alloca i64*, align 8 
  %eptr14925 = getelementptr inbounds i64, i64* %cloptr14922, i64 3 
  store volatile i64* %eptr14925, i64** %vptr14929, align 8 ; &eptr14925[2]
  store i64 %emsg18637, i64* %eptr14924                                              ; *eptr14924 = %emsg18637
  store i64 %emsg08636, i64* %eptr14925                                              ; *eptr14925 = %emsg08636
  %vptr14930 = alloca i64*, align 8 
  %eptr14923 = getelementptr inbounds i64, i64* %cloptr14922, i64 1 
  store volatile i64* %eptr14923, i64** %vptr14930, align 8 ; &cloptr14922[1]
 %vptr14931 = alloca i64, align 8 
  %f14926 = ptrtoint void(i64,i64)* @lam12181 to i64 
  store volatile i64 %f14926, i64* %vptr14931, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f14926, i64* %eptr14923                                                 ; store fptr
 %vptr14932 = alloca i64, align 8 
  %hYJ$_37third = ptrtoint i64* %cloptr14922 to i64 
  store volatile i64 %hYJ$_37third, i64* %vptr14932, align 8 ; closure cast; i64* -> i64
  %vptr14938 = alloca i64*, align 8 
  %cloptr14933 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr14933, i64** %vptr14938, align 8 ; malloc
  %vptr14939 = alloca i64*, align 8 
  %eptr14935 = getelementptr inbounds i64, i64* %cloptr14933, i64 2 
  store volatile i64* %eptr14935, i64** %vptr14939, align 8 ; &eptr14935[1]
  %vptr14940 = alloca i64*, align 8 
  %eptr14936 = getelementptr inbounds i64, i64* %cloptr14933, i64 3 
  store volatile i64* %eptr14936, i64** %vptr14940, align 8 ; &eptr14936[2]
  store i64 %emsg18637, i64* %eptr14935                                              ; *eptr14935 = %emsg18637
  store i64 %emsg08636, i64* %eptr14936                                              ; *eptr14936 = %emsg08636
  %vptr14941 = alloca i64*, align 8 
  %eptr14934 = getelementptr inbounds i64, i64* %cloptr14933, i64 1 
  store volatile i64* %eptr14934, i64** %vptr14941, align 8 ; &cloptr14933[1]
 %vptr14942 = alloca i64, align 8 
  %f14937 = ptrtoint void(i64,i64)* @lam12177 to i64 
  store volatile i64 %f14937, i64* %vptr14942, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f14937, i64* %eptr14934                                                 ; store fptr
 %vptr14943 = alloca i64, align 8 
  %kMl$_37fourth = ptrtoint i64* %cloptr14933 to i64 
  store volatile i64 %kMl$_37fourth, i64* %vptr14943, align 8 ; closure cast; i64* -> i64
  %vptr14949 = alloca i64*, align 8 
  %cloptr14944 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr14944, i64** %vptr14949, align 8 ; malloc
  %vptr14950 = alloca i64*, align 8 
  %eptr14946 = getelementptr inbounds i64, i64* %cloptr14944, i64 2 
  store volatile i64* %eptr14946, i64** %vptr14950, align 8 ; &eptr14946[1]
  %vptr14951 = alloca i64*, align 8 
  %eptr14947 = getelementptr inbounds i64, i64* %cloptr14944, i64 3 
  store volatile i64* %eptr14947, i64** %vptr14951, align 8 ; &eptr14947[2]
  store i64 %emsg18637, i64* %eptr14946                                              ; *eptr14946 = %emsg18637
  store i64 %emsg08636, i64* %eptr14947                                              ; *eptr14947 = %emsg08636
  %vptr14952 = alloca i64*, align 8 
  %eptr14945 = getelementptr inbounds i64, i64* %cloptr14944, i64 1 
  store volatile i64* %eptr14945, i64** %vptr14952, align 8 ; &cloptr14944[1]
 %vptr14953 = alloca i64, align 8 
  %f14948 = ptrtoint void(i64,i64)* @lam12173 to i64 
  store volatile i64 %f14948, i64* %vptr14953, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f14948, i64* %eptr14945                                                 ; store fptr
 %vptr14954 = alloca i64, align 8 
  %pYL$hash_45ref_45internal = ptrtoint i64* %cloptr14944 to i64 
  store volatile i64 %pYL$hash_45ref_45internal, i64* %vptr14954, align 8 ; closure cast; i64* -> i64
  %vptr14960 = alloca i64*, align 8 
  %cloptr14955 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr14955, i64** %vptr14960, align 8 ; malloc
  %vptr14961 = alloca i64*, align 8 
  %eptr14957 = getelementptr inbounds i64, i64* %cloptr14955, i64 2 
  store volatile i64* %eptr14957, i64** %vptr14961, align 8 ; &eptr14957[1]
  %vptr14962 = alloca i64*, align 8 
  %eptr14958 = getelementptr inbounds i64, i64* %cloptr14955, i64 3 
  store volatile i64* %eptr14958, i64** %vptr14962, align 8 ; &eptr14958[2]
  store i64 %emsg18637, i64* %eptr14957                                              ; *eptr14957 = %emsg18637
  store i64 %emsg08636, i64* %eptr14958                                              ; *eptr14958 = %emsg08636
  %vptr14963 = alloca i64*, align 8 
  %eptr14956 = getelementptr inbounds i64, i64* %cloptr14955, i64 1 
  store volatile i64* %eptr14956, i64** %vptr14963, align 8 ; &cloptr14955[1]
 %vptr14964 = alloca i64, align 8 
  %f14959 = ptrtoint void(i64,i64)* @lam12164 to i64 
  store volatile i64 %f14959, i64* %vptr14964, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f14959, i64* %eptr14956                                                 ; store fptr
 %vptr14965 = alloca i64, align 8 
  %ilI$promise_63 = ptrtoint i64* %cloptr14955 to i64 
  store volatile i64 %ilI$promise_63, i64* %vptr14965, align 8 ; closure cast; i64* -> i64
  %vptr14969 = alloca i64*, align 8 
  %cloptr14966 = call i64* @make_closure(i64 8) 
  store volatile i64* %cloptr14966, i64** %vptr14969, align 8 ; malloc
  %vptr14970 = alloca i64*, align 8 
  %eptr14967 = getelementptr inbounds i64, i64* %cloptr14966, i64 1 
  store volatile i64* %eptr14967, i64** %vptr14970, align 8 ; &cloptr14966[1]
 %vptr14971 = alloca i64, align 8 
  %f14968 = ptrtoint void(i64,i64)* @lam12156 to i64 
  store volatile i64 %f14968, i64* %vptr14971, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f14968, i64* %eptr14967                                                 ; store fptr
 %vptr14972 = alloca i64, align 8 
  %arg7787 = ptrtoint i64* %cloptr14966 to i64 
  store volatile i64 %arg7787, i64* %vptr14972, align 8 ; closure cast; i64* -> i64
  %vptr14981 = alloca i64*, align 8 
  %cloptr14973 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr14973, i64** %vptr14981, align 8 ; malloc
  %vptr14982 = alloca i64*, align 8 
  %eptr14975 = getelementptr inbounds i64, i64* %cloptr14973, i64 2 
  store volatile i64* %eptr14975, i64** %vptr14982, align 8 ; &eptr14975[1]
  %vptr14983 = alloca i64*, align 8 
  %eptr14976 = getelementptr inbounds i64, i64* %cloptr14973, i64 3 
  store volatile i64* %eptr14976, i64** %vptr14983, align 8 ; &eptr14976[2]
  %vptr14984 = alloca i64*, align 8 
  %eptr14977 = getelementptr inbounds i64, i64* %cloptr14973, i64 4 
  store volatile i64* %eptr14977, i64** %vptr14984, align 8 ; &eptr14977[3]
  %vptr14985 = alloca i64*, align 8 
  %eptr14978 = getelementptr inbounds i64, i64* %cloptr14973, i64 5 
  store volatile i64* %eptr14978, i64** %vptr14985, align 8 ; &eptr14978[4]
  %vptr14986 = alloca i64*, align 8 
  %eptr14979 = getelementptr inbounds i64, i64* %cloptr14973, i64 6 
  store volatile i64* %eptr14979, i64** %vptr14986, align 8 ; &eptr14979[5]
  store i64 %emsg18637, i64* %eptr14975                                              ; *eptr14975 = %emsg18637
  store i64 %Jup$_37length, i64* %eptr14976                                          ; *eptr14976 = %Jup$_37length
  store i64 %zTP$_37drop, i64* %eptr14977                                            ; *eptr14977 = %zTP$_37drop
  store i64 %emsg08636, i64* %eptr14978                                              ; *eptr14978 = %emsg08636
  store i64 %uLY$_37_62, i64* %eptr14979                                             ; *eptr14979 = %uLY$_37_62
  %vptr14987 = alloca i64*, align 8 
  %eptr14974 = getelementptr inbounds i64, i64* %cloptr14973, i64 1 
  store volatile i64* %eptr14974, i64** %vptr14987, align 8 ; &cloptr14973[1]
 %vptr14988 = alloca i64, align 8 
  %f14980 = ptrtoint void(i64,i64)* @lam12152 to i64 
  store volatile i64 %f14980, i64* %vptr14988, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f14980, i64* %eptr14974                                                 ; store fptr
 %vptr14989 = alloca i64, align 8 
  %arg7786 = ptrtoint i64* %cloptr14973 to i64 
  store volatile i64 %arg7786, i64* %vptr14989, align 8 ; closure cast; i64* -> i64
 %vptr14990 = alloca i64, align 8 
  %rva10733 = add i64 0, 0 
  store volatile i64 %rva10733, i64* %vptr14990, align 8 ; quoted ()
 %vptr14991 = alloca i64, align 8 
  %rva10732 = call i64 @prim_cons(i64 %arg7786, i64 %rva10733) 
  store volatile i64 %rva10732, i64* %vptr14991, align 8 ; call prim_cons
  %vptr14997 = alloca i64*, align 8 
  %cloptr14992 = inttoptr i64 %arg7787 to i64* 
  store volatile i64* %cloptr14992, i64** %vptr14997, align 8 ; closure/env cast; i64 -> i64*
  %vptr14998 = alloca i64*, align 8 
  %i0ptr14993 = getelementptr inbounds i64, i64* %cloptr14992, i64 1 
  store volatile i64* %i0ptr14993, i64** %vptr14998, align 8 ; &cloptr14992[1]
 %vptr14999 = alloca i64, align 8 
  %f14995 = load i64, i64* %i0ptr14993, align 8 
  store volatile i64 %f14995, i64* %vptr14999, align 8 ; load; *i0ptr14993
  %fptr14994 = inttoptr i64 %f14995 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr14994(i64 %arg7787, i64 %rva10732)                  ; tail call
  ret void

else14852:
 %vptr15000 = alloca i64, align 8 
  %h10736 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10736, i64* %vptr15000, align 8 ; call prim_halt
  %vptr15006 = alloca i64*, align 8 
  %cloptr15001 = inttoptr i64 %h10736 to i64* 
  store volatile i64* %cloptr15001, i64** %vptr15006, align 8 ; closure/env cast; i64 -> i64*
  %vptr15007 = alloca i64*, align 8 
  %i0ptr15002 = getelementptr inbounds i64, i64* %cloptr15001, i64 1 
  store volatile i64* %i0ptr15002, i64** %vptr15007, align 8 ; &cloptr15001[1]
 %vptr15008 = alloca i64, align 8 
  %f15004 = load i64, i64* %i0ptr15002, align 8 
  store volatile i64 %f15004, i64* %vptr15008, align 8 ; load; *i0ptr15002
  %fptr15003 = inttoptr i64 %f15004 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15003(i64 %h10736, i64 %h10736)                     ; tail call
  ret void
}


define void @lam12344(i64 %env12345, i64 %rvp9018) {
 %vptr15011 = alloca i64, align 8 
  %envptr15009 = inttoptr i64 %env12345 to i64* 
  store volatile i64 %emsg08636, i64* %vptr15011, align 8 ; closure/env cast; i64 -> i64*
  %vptr15012 = alloca i64*, align 8 
  %envptr15010 = getelementptr inbounds i64, i64* %envptr15009, i64 3 
  store volatile i64* %envptr15010, i64** %vptr15012, align 8 ; &envptr15009[2]
 %vptr15013 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr15010, align 8 
  store volatile i64 %emsg08636, i64* %vptr15013, align 8 ; load; *envptr15010
 %vptr15016 = alloca i64, align 8 
  %envptr15014 = inttoptr i64 %env12345 to i64* 
  store volatile i64 %emsg18637, i64* %vptr15016, align 8 ; closure/env cast; i64 -> i64*
  %vptr15017 = alloca i64*, align 8 
  %envptr15015 = getelementptr inbounds i64, i64* %envptr15014, i64 2 
  store volatile i64* %envptr15015, i64** %vptr15017, align 8 ; &envptr15014[1]
 %vptr15018 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr15015, align 8 
  store volatile i64 %emsg18637, i64* %vptr15018, align 8 ; load; *envptr15015
 %vptr15019 = alloca i64, align 8 
  %cont7119 = call i64 @prim_car(i64 %rvp9018) 
  store volatile i64 %cont7119, i64* %vptr15019, align 8 ; call prim_car
 %vptr15020 = alloca i64, align 8 
  %rvp9014 = call i64 @prim_cdr(i64 %rvp9018) 
  store volatile i64 %rvp9014, i64* %vptr15020, align 8 ; call prim_cdr
 %vptr15021 = alloca i64, align 8 
  %n_639019 = call i64 @prim_null_63(i64 %rvp9014) 
  store volatile i64 %n_639019, i64* %vptr15021, align 8 ; call prim_null_63
  %cmpptr15025 = alloca i1, align 8  %cmp15022 = icmp eq i64 %n_639019, 15 store volatile i1 %cmp15022, i1* %cmpptr15025, align 8; false?
  br i1 %cmp15022, label %else15024, label %then15023                                ; if

then15023:
 %vptr15026 = alloca i64, align 8 
  %h9020 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9020, i64* %vptr15026, align 8 ; call prim_halt
  %vptr15032 = alloca i64*, align 8 
  %cloptr15027 = inttoptr i64 %h9020 to i64* 
  store volatile i64* %cloptr15027, i64** %vptr15032, align 8 ; closure/env cast; i64 -> i64*
  %vptr15033 = alloca i64*, align 8 
  %i0ptr15028 = getelementptr inbounds i64, i64* %cloptr15027, i64 1 
  store volatile i64* %i0ptr15028, i64** %vptr15033, align 8 ; &cloptr15027[1]
 %vptr15034 = alloca i64, align 8 
  %f15030 = load i64, i64* %i0ptr15028, align 8 
  store volatile i64 %f15030, i64* %vptr15034, align 8 ; load; *i0ptr15028
  %fptr15029 = inttoptr i64 %f15030 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15029(i64 %h9020, i64 %h9020)                       ; tail call
  ret void

else15024:
 %vptr15035 = alloca i64, align 8 
  %nCQ$a = call i64 @prim_car(i64 %rvp9014) 
  store volatile i64 %nCQ$a, i64* %vptr15035, align 8 ; call prim_car
 %vptr15036 = alloca i64, align 8 
  %na8907 = call i64 @prim_cdr(i64 %rvp9014) 
  store volatile i64 %na8907, i64* %vptr15036, align 8 ; call prim_cdr
 %vptr15037 = alloca i64, align 8 
  %n_639015 = call i64 @prim_null_63(i64 %na8907) 
  store volatile i64 %n_639015, i64* %vptr15037, align 8 ; call prim_null_63
  %cmpptr15041 = alloca i1, align 8  %cmp15038 = icmp eq i64 %n_639015, 15 store volatile i1 %cmp15038, i1* %cmpptr15041, align 8; false?
  br i1 %cmp15038, label %else15040, label %then15039                                ; if

then15039:
 %vptr15042 = alloca i64, align 8 
  %arg7513 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg7513, i64* %vptr15042, align 8 ; quoted int
 %vptr15043 = alloca i64, align 8 
  %Zvj$a = call i64 @prim_make_45vector(i64 %arg7513, i64 %nCQ$a) 
  store volatile i64 %Zvj$a, i64* %vptr15043, align 8 ; call prim_make_45vector
  %vptr15049 = alloca i64*, align 8 
  %cloptr15044 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr15044, i64** %vptr15049, align 8 ; malloc
  %vptr15050 = alloca i64*, align 8 
  %eptr15046 = getelementptr inbounds i64, i64* %cloptr15044, i64 2 
  store volatile i64* %eptr15046, i64** %vptr15050, align 8 ; &eptr15046[1]
  %vptr15051 = alloca i64*, align 8 
  %eptr15047 = getelementptr inbounds i64, i64* %cloptr15044, i64 3 
  store volatile i64* %eptr15047, i64** %vptr15051, align 8 ; &eptr15047[2]
  store i64 %emsg18637, i64* %eptr15046                                              ; *eptr15046 = %emsg18637
  store i64 %emsg08636, i64* %eptr15047                                              ; *eptr15047 = %emsg08636
  %vptr15052 = alloca i64*, align 8 
  %eptr15045 = getelementptr inbounds i64, i64* %cloptr15044, i64 1 
  store volatile i64* %eptr15045, i64** %vptr15052, align 8 ; &cloptr15044[1]
 %vptr15053 = alloca i64, align 8 
  %f15048 = ptrtoint void(i64,i64)* @lam12341 to i64 
  store volatile i64 %f15048, i64* %vptr15053, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f15048, i64* %eptr15045                                                 ; store fptr
 %vptr15054 = alloca i64, align 8 
  %arg7516 = ptrtoint i64* %cloptr15044 to i64 
  store volatile i64 %arg7516, i64* %vptr15054, align 8 ; closure cast; i64* -> i64
  %vptr15062 = alloca i64*, align 8 
  %cloptr15055 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr15055, i64** %vptr15062, align 8 ; malloc
  %vptr15063 = alloca i64*, align 8 
  %eptr15057 = getelementptr inbounds i64, i64* %cloptr15055, i64 2 
  store volatile i64* %eptr15057, i64** %vptr15063, align 8 ; &eptr15057[1]
  %vptr15064 = alloca i64*, align 8 
  %eptr15058 = getelementptr inbounds i64, i64* %cloptr15055, i64 3 
  store volatile i64* %eptr15058, i64** %vptr15064, align 8 ; &eptr15058[2]
  %vptr15065 = alloca i64*, align 8 
  %eptr15059 = getelementptr inbounds i64, i64* %cloptr15055, i64 4 
  store volatile i64* %eptr15059, i64** %vptr15065, align 8 ; &eptr15059[3]
  %vptr15066 = alloca i64*, align 8 
  %eptr15060 = getelementptr inbounds i64, i64* %cloptr15055, i64 5 
  store volatile i64* %eptr15060, i64** %vptr15066, align 8 ; &eptr15060[4]
  store i64 %emsg18637, i64* %eptr15057                                              ; *eptr15057 = %emsg18637
  store i64 %cont7119, i64* %eptr15058                                               ; *eptr15058 = %cont7119
  store i64 %emsg08636, i64* %eptr15059                                              ; *eptr15059 = %emsg08636
  store i64 %Zvj$a, i64* %eptr15060                                                  ; *eptr15060 = %Zvj$a
  %vptr15067 = alloca i64*, align 8 
  %eptr15056 = getelementptr inbounds i64, i64* %cloptr15055, i64 1 
  store volatile i64* %eptr15056, i64** %vptr15067, align 8 ; &cloptr15055[1]
 %vptr15068 = alloca i64, align 8 
  %f15061 = ptrtoint void(i64,i64)* @lam12337 to i64 
  store volatile i64 %f15061, i64* %vptr15068, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f15061, i64* %eptr15056                                                 ; store fptr
 %vptr15069 = alloca i64, align 8 
  %arg7515 = ptrtoint i64* %cloptr15055 to i64 
  store volatile i64 %arg7515, i64* %vptr15069, align 8 ; closure cast; i64* -> i64
  %vptr15077 = alloca i64*, align 8 
  %cloptr15070 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr15070, i64** %vptr15077, align 8 ; malloc
  %vptr15078 = alloca i64*, align 8 
  %eptr15072 = getelementptr inbounds i64, i64* %cloptr15070, i64 2 
  store volatile i64* %eptr15072, i64** %vptr15078, align 8 ; &eptr15072[1]
  %vptr15079 = alloca i64*, align 8 
  %eptr15073 = getelementptr inbounds i64, i64* %cloptr15070, i64 3 
  store volatile i64* %eptr15073, i64** %vptr15079, align 8 ; &eptr15073[2]
  %vptr15080 = alloca i64*, align 8 
  %eptr15074 = getelementptr inbounds i64, i64* %cloptr15070, i64 4 
  store volatile i64* %eptr15074, i64** %vptr15080, align 8 ; &eptr15074[3]
  %vptr15081 = alloca i64*, align 8 
  %eptr15075 = getelementptr inbounds i64, i64* %cloptr15070, i64 5 
  store volatile i64* %eptr15075, i64** %vptr15081, align 8 ; &eptr15075[4]
  store i64 %emsg18637, i64* %eptr15072                                              ; *eptr15072 = %emsg18637
  store i64 %cont7119, i64* %eptr15073                                               ; *eptr15073 = %cont7119
  store i64 %emsg08636, i64* %eptr15074                                              ; *eptr15074 = %emsg08636
  store i64 %Zvj$a, i64* %eptr15075                                                  ; *eptr15075 = %Zvj$a
  %vptr15082 = alloca i64*, align 8 
  %eptr15071 = getelementptr inbounds i64, i64* %cloptr15070, i64 1 
  store volatile i64* %eptr15071, i64** %vptr15082, align 8 ; &cloptr15070[1]
 %vptr15083 = alloca i64, align 8 
  %f15076 = ptrtoint void(i64,i64)* @lam12315 to i64 
  store volatile i64 %f15076, i64* %vptr15083, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f15076, i64* %eptr15071                                                 ; store fptr
 %vptr15084 = alloca i64, align 8 
  %arg7514 = ptrtoint i64* %cloptr15070 to i64 
  store volatile i64 %arg7514, i64* %vptr15084, align 8 ; closure cast; i64* -> i64
 %vptr15085 = alloca i64, align 8 
  %rva9013 = add i64 0, 0 
  store volatile i64 %rva9013, i64* %vptr15085, align 8 ; quoted ()
 %vptr15086 = alloca i64, align 8 
  %rva9012 = call i64 @prim_cons(i64 %arg7514, i64 %rva9013) 
  store volatile i64 %rva9012, i64* %vptr15086, align 8 ; call prim_cons
 %vptr15087 = alloca i64, align 8 
  %rva9011 = call i64 @prim_cons(i64 %arg7515, i64 %rva9012) 
  store volatile i64 %rva9011, i64* %vptr15087, align 8 ; call prim_cons
  %vptr15093 = alloca i64*, align 8 
  %cloptr15088 = inttoptr i64 %arg7516 to i64* 
  store volatile i64* %cloptr15088, i64** %vptr15093, align 8 ; closure/env cast; i64 -> i64*
  %vptr15094 = alloca i64*, align 8 
  %i0ptr15089 = getelementptr inbounds i64, i64* %cloptr15088, i64 1 
  store volatile i64* %i0ptr15089, i64** %vptr15094, align 8 ; &cloptr15088[1]
 %vptr15095 = alloca i64, align 8 
  %f15091 = load i64, i64* %i0ptr15089, align 8 
  store volatile i64 %f15091, i64* %vptr15095, align 8 ; load; *i0ptr15089
  %fptr15090 = inttoptr i64 %f15091 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15090(i64 %arg7516, i64 %rva9011)                   ; tail call
  ret void

else15040:
 %vptr15096 = alloca i64, align 8 
  %h9016 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9016, i64* %vptr15096, align 8 ; call prim_halt
  %vptr15102 = alloca i64*, align 8 
  %cloptr15097 = inttoptr i64 %h9016 to i64* 
  store volatile i64* %cloptr15097, i64** %vptr15102, align 8 ; closure/env cast; i64 -> i64*
  %vptr15103 = alloca i64*, align 8 
  %i0ptr15098 = getelementptr inbounds i64, i64* %cloptr15097, i64 1 
  store volatile i64* %i0ptr15098, i64** %vptr15103, align 8 ; &cloptr15097[1]
 %vptr15104 = alloca i64, align 8 
  %f15100 = load i64, i64* %i0ptr15098, align 8 
  store volatile i64 %f15100, i64* %vptr15104, align 8 ; load; *i0ptr15098
  %fptr15099 = inttoptr i64 %f15100 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15099(i64 %h9016, i64 %h9016)                       ; tail call
  ret void
}


define void @lam12341(i64 %env12342, i64 %rvp8917) {
 %vptr15107 = alloca i64, align 8 
  %envptr15105 = inttoptr i64 %env12342 to i64* 
  store volatile i64 %emsg08636, i64* %vptr15107, align 8 ; closure/env cast; i64 -> i64*
  %vptr15108 = alloca i64*, align 8 
  %envptr15106 = getelementptr inbounds i64, i64* %envptr15105, i64 3 
  store volatile i64* %envptr15106, i64** %vptr15108, align 8 ; &envptr15105[2]
 %vptr15109 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr15106, align 8 
  store volatile i64 %emsg08636, i64* %vptr15109, align 8 ; load; *envptr15106
 %vptr15112 = alloca i64, align 8 
  %envptr15110 = inttoptr i64 %env12342 to i64* 
  store volatile i64 %emsg18637, i64* %vptr15112, align 8 ; closure/env cast; i64 -> i64*
  %vptr15113 = alloca i64*, align 8 
  %envptr15111 = getelementptr inbounds i64, i64* %envptr15110, i64 2 
  store volatile i64* %envptr15111, i64** %vptr15113, align 8 ; &envptr15110[1]
 %vptr15114 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr15111, align 8 
  store volatile i64 %emsg18637, i64* %vptr15114, align 8 ; load; *envptr15111
 %vptr15115 = alloca i64, align 8 
  %cont7125 = call i64 @prim_car(i64 %rvp8917) 
  store volatile i64 %cont7125, i64* %vptr15115, align 8 ; call prim_car
 %vptr15116 = alloca i64, align 8 
  %rvp8913 = call i64 @prim_cdr(i64 %rvp8917) 
  store volatile i64 %rvp8913, i64* %vptr15116, align 8 ; call prim_cdr
 %vptr15117 = alloca i64, align 8 
  %n_638918 = call i64 @prim_null_63(i64 %rvp8913) 
  store volatile i64 %n_638918, i64* %vptr15117, align 8 ; call prim_null_63
  %cmpptr15121 = alloca i1, align 8  %cmp15118 = icmp eq i64 %n_638918, 15 store volatile i1 %cmp15118, i1* %cmpptr15121, align 8; false?
  br i1 %cmp15118, label %else15120, label %then15119                                ; if

then15119:
 %vptr15122 = alloca i64, align 8 
  %h8919 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8919, i64* %vptr15122, align 8 ; call prim_halt
  %vptr15128 = alloca i64*, align 8 
  %cloptr15123 = inttoptr i64 %h8919 to i64* 
  store volatile i64* %cloptr15123, i64** %vptr15128, align 8 ; closure/env cast; i64 -> i64*
  %vptr15129 = alloca i64*, align 8 
  %i0ptr15124 = getelementptr inbounds i64, i64* %cloptr15123, i64 1 
  store volatile i64* %i0ptr15124, i64** %vptr15129, align 8 ; &cloptr15123[1]
 %vptr15130 = alloca i64, align 8 
  %f15126 = load i64, i64* %i0ptr15124, align 8 
  store volatile i64 %f15126, i64* %vptr15130, align 8 ; load; *i0ptr15124
  %fptr15125 = inttoptr i64 %f15126 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15125(i64 %h8919, i64 %h8919)                       ; tail call
  ret void

else15120:
 %vptr15131 = alloca i64, align 8 
  %qhM$k = call i64 @prim_car(i64 %rvp8913) 
  store volatile i64 %qhM$k, i64* %vptr15131, align 8 ; call prim_car
 %vptr15132 = alloca i64, align 8 
  %na8909 = call i64 @prim_cdr(i64 %rvp8913) 
  store volatile i64 %na8909, i64* %vptr15132, align 8 ; call prim_cdr
 %vptr15133 = alloca i64, align 8 
  %n_638914 = call i64 @prim_null_63(i64 %na8909) 
  store volatile i64 %n_638914, i64* %vptr15133, align 8 ; call prim_null_63
  %cmpptr15137 = alloca i1, align 8  %cmp15134 = icmp eq i64 %n_638914, 15 store volatile i1 %cmp15134, i1* %cmpptr15137, align 8; false?
  br i1 %cmp15134, label %else15136, label %then15135                                ; if

then15135:
 %vptr15138 = alloca i64, align 8 
  %arg7518 = add i64 0, 0 
  store volatile i64 %arg7518, i64* %vptr15138, align 8 ; quoted ()
 %vptr15139 = alloca i64, align 8 
  %rva8912 = add i64 0, 0 
  store volatile i64 %rva8912, i64* %vptr15139, align 8 ; quoted ()
 %vptr15140 = alloca i64, align 8 
  %rva8911 = call i64 @prim_cons(i64 %qhM$k, i64 %rva8912) 
  store volatile i64 %rva8911, i64* %vptr15140, align 8 ; call prim_cons
 %vptr15141 = alloca i64, align 8 
  %rva8910 = call i64 @prim_cons(i64 %arg7518, i64 %rva8911) 
  store volatile i64 %rva8910, i64* %vptr15141, align 8 ; call prim_cons
  %vptr15147 = alloca i64*, align 8 
  %cloptr15142 = inttoptr i64 %cont7125 to i64* 
  store volatile i64* %cloptr15142, i64** %vptr15147, align 8 ; closure/env cast; i64 -> i64*
  %vptr15148 = alloca i64*, align 8 
  %i0ptr15143 = getelementptr inbounds i64, i64* %cloptr15142, i64 1 
  store volatile i64* %i0ptr15143, i64** %vptr15148, align 8 ; &cloptr15142[1]
 %vptr15149 = alloca i64, align 8 
  %f15145 = load i64, i64* %i0ptr15143, align 8 
  store volatile i64 %f15145, i64* %vptr15149, align 8 ; load; *i0ptr15143
  %fptr15144 = inttoptr i64 %f15145 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15144(i64 %cont7125, i64 %rva8910)                  ; tail call
  ret void

else15136:
 %vptr15150 = alloca i64, align 8 
  %h8915 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h8915, i64* %vptr15150, align 8 ; call prim_halt
  %vptr15156 = alloca i64*, align 8 
  %cloptr15151 = inttoptr i64 %h8915 to i64* 
  store volatile i64* %cloptr15151, i64** %vptr15156, align 8 ; closure/env cast; i64 -> i64*
  %vptr15157 = alloca i64*, align 8 
  %i0ptr15152 = getelementptr inbounds i64, i64* %cloptr15151, i64 1 
  store volatile i64* %i0ptr15152, i64** %vptr15157, align 8 ; &cloptr15151[1]
 %vptr15158 = alloca i64, align 8 
  %f15154 = load i64, i64* %i0ptr15152, align 8 
  store volatile i64 %f15154, i64* %vptr15158, align 8 ; load; *i0ptr15152
  %fptr15153 = inttoptr i64 %f15154 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15153(i64 %h8915, i64 %h8915)                       ; tail call
  ret void
}


define void @lam12337(i64 %env12338, i64 %rvp8962) {
 %vptr15161 = alloca i64, align 8 
  %envptr15159 = inttoptr i64 %env12338 to i64* 
  store volatile i64 %Zvj$a, i64* %vptr15161, align 8 ; closure/env cast; i64 -> i64*
  %vptr15162 = alloca i64*, align 8 
  %envptr15160 = getelementptr inbounds i64, i64* %envptr15159, i64 5 
  store volatile i64* %envptr15160, i64** %vptr15162, align 8 ; &envptr15159[4]
 %vptr15163 = alloca i64, align 8 
  %Zvj$a = load i64, i64* %envptr15160, align 8 
  store volatile i64 %Zvj$a, i64* %vptr15163, align 8 ; load; *envptr15160
 %vptr15166 = alloca i64, align 8 
  %envptr15164 = inttoptr i64 %env12338 to i64* 
  store volatile i64 %emsg08636, i64* %vptr15166, align 8 ; closure/env cast; i64 -> i64*
  %vptr15167 = alloca i64*, align 8 
  %envptr15165 = getelementptr inbounds i64, i64* %envptr15164, i64 4 
  store volatile i64* %envptr15165, i64** %vptr15167, align 8 ; &envptr15164[3]
 %vptr15168 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr15165, align 8 
  store volatile i64 %emsg08636, i64* %vptr15168, align 8 ; load; *envptr15165
 %vptr15171 = alloca i64, align 8 
  %envptr15169 = inttoptr i64 %env12338 to i64* 
  store volatile i64 %cont7119, i64* %vptr15171, align 8 ; closure/env cast; i64 -> i64*
  %vptr15172 = alloca i64*, align 8 
  %envptr15170 = getelementptr inbounds i64, i64* %envptr15169, i64 3 
  store volatile i64* %envptr15170, i64** %vptr15172, align 8 ; &envptr15169[2]
 %vptr15173 = alloca i64, align 8 
  %cont7119 = load i64, i64* %envptr15170, align 8 
  store volatile i64 %cont7119, i64* %vptr15173, align 8 ; load; *envptr15170
 %vptr15176 = alloca i64, align 8 
  %envptr15174 = inttoptr i64 %env12338 to i64* 
  store volatile i64 %emsg18637, i64* %vptr15176, align 8 ; closure/env cast; i64 -> i64*
  %vptr15177 = alloca i64*, align 8 
  %envptr15175 = getelementptr inbounds i64, i64* %envptr15174, i64 2 
  store volatile i64* %envptr15175, i64** %vptr15177, align 8 ; &envptr15174[1]
 %vptr15178 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr15175, align 8 
  store volatile i64 %emsg18637, i64* %vptr15178, align 8 ; load; *envptr15175
 %vptr15179 = alloca i64, align 8 
  %_957120 = call i64 @prim_car(i64 %rvp8962) 
  store volatile i64 %_957120, i64* %vptr15179, align 8 ; call prim_car
 %vptr15180 = alloca i64, align 8 
  %rvp8958 = call i64 @prim_cdr(i64 %rvp8962) 
  store volatile i64 %rvp8958, i64* %vptr15180, align 8 ; call prim_cdr
 %vptr15181 = alloca i64, align 8 
  %n_638963 = call i64 @prim_null_63(i64 %rvp8958) 
  store volatile i64 %n_638963, i64* %vptr15181, align 8 ; call prim_null_63
  %cmpptr15185 = alloca i1, align 8  %cmp15182 = icmp eq i64 %n_638963, 15 store volatile i1 %cmp15182, i1* %cmpptr15185, align 8; false?
  br i1 %cmp15182, label %else15184, label %then15183                                ; if

then15183:
 %vptr15186 = alloca i64, align 8 
  %h8964 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8964, i64* %vptr15186, align 8 ; call prim_halt
  %vptr15192 = alloca i64*, align 8 
  %cloptr15187 = inttoptr i64 %h8964 to i64* 
  store volatile i64* %cloptr15187, i64** %vptr15192, align 8 ; closure/env cast; i64 -> i64*
  %vptr15193 = alloca i64*, align 8 
  %i0ptr15188 = getelementptr inbounds i64, i64* %cloptr15187, i64 1 
  store volatile i64* %i0ptr15188, i64** %vptr15193, align 8 ; &cloptr15187[1]
 %vptr15194 = alloca i64, align 8 
  %f15190 = load i64, i64* %i0ptr15188, align 8 
  store volatile i64 %f15190, i64* %vptr15194, align 8 ; load; *i0ptr15188
  %fptr15189 = inttoptr i64 %f15190 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15189(i64 %h8964, i64 %h8964)                       ; tail call
  ret void

else15184:
 %vptr15195 = alloca i64, align 8 
  %dYN$cc = call i64 @prim_car(i64 %rvp8958) 
  store volatile i64 %dYN$cc, i64* %vptr15195, align 8 ; call prim_car
 %vptr15196 = alloca i64, align 8 
  %na8922 = call i64 @prim_cdr(i64 %rvp8958) 
  store volatile i64 %na8922, i64* %vptr15196, align 8 ; call prim_cdr
 %vptr15197 = alloca i64, align 8 
  %n_638959 = call i64 @prim_null_63(i64 %na8922) 
  store volatile i64 %n_638959, i64* %vptr15197, align 8 ; call prim_null_63
  %cmpptr15201 = alloca i1, align 8  %cmp15198 = icmp eq i64 %n_638959, 15 store volatile i1 %cmp15198, i1* %cmpptr15201, align 8; false?
  br i1 %cmp15198, label %else15200, label %then15199                                ; if

then15199:
 %vptr15202 = alloca i64, align 8 
  %arg7520 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7520, i64* %vptr15202, align 8 ; quoted int
 %vptr15203 = alloca i64, align 8 
  %a6964 = call i64 @prim_vector_45ref(i64 %Zvj$a, i64 %arg7520) 
  store volatile i64 %a6964, i64* %vptr15203, align 8 ; call prim_vector_45ref
 %vptr15204 = alloca i64, align 8 
  %a6965 = call i64 @prim_null_63(i64 %a6964) 
  store volatile i64 %a6965, i64* %vptr15204, align 8 ; call prim_null_63
  %cmpptr15208 = alloca i1, align 8  %cmp15205 = icmp eq i64 %a6965, 15 store volatile i1 %cmp15205, i1* %cmpptr15208, align 8; false?
  br i1 %cmp15205, label %else15207, label %then15206                                ; if

then15206:
 %vptr15209 = alloca i64, align 8 
  %arg7524 = add i64 0, 0 
  store volatile i64 %arg7524, i64* %vptr15209, align 8 ; quoted ()
 %vptr15210 = alloca i64, align 8 
  %arg7523 = call i64 @const_init_true() 
  store volatile i64 %arg7523, i64* %vptr15210, align 8 ; quoted #t
 %vptr15211 = alloca i64, align 8 
  %rva8925 = add i64 0, 0 
  store volatile i64 %rva8925, i64* %vptr15211, align 8 ; quoted ()
 %vptr15212 = alloca i64, align 8 
  %rva8924 = call i64 @prim_cons(i64 %arg7523, i64 %rva8925) 
  store volatile i64 %rva8924, i64* %vptr15212, align 8 ; call prim_cons
 %vptr15213 = alloca i64, align 8 
  %rva8923 = call i64 @prim_cons(i64 %arg7524, i64 %rva8924) 
  store volatile i64 %rva8923, i64* %vptr15213, align 8 ; call prim_cons
  %vptr15219 = alloca i64*, align 8 
  %cloptr15214 = inttoptr i64 %cont7119 to i64* 
  store volatile i64* %cloptr15214, i64** %vptr15219, align 8 ; closure/env cast; i64 -> i64*
  %vptr15220 = alloca i64*, align 8 
  %i0ptr15215 = getelementptr inbounds i64, i64* %cloptr15214, i64 1 
  store volatile i64* %i0ptr15215, i64** %vptr15220, align 8 ; &cloptr15214[1]
 %vptr15221 = alloca i64, align 8 
  %f15217 = load i64, i64* %i0ptr15215, align 8 
  store volatile i64 %f15217, i64* %vptr15221, align 8 ; load; *i0ptr15215
  %fptr15216 = inttoptr i64 %f15217 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15216(i64 %cont7119, i64 %rva8923)                  ; tail call
  ret void

else15207:
 %vptr15222 = alloca i64, align 8 
  %arg7526 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7526, i64* %vptr15222, align 8 ; quoted int
 %vptr15223 = alloca i64, align 8 
  %a6966 = call i64 @prim_vector_45ref(i64 %Zvj$a, i64 %arg7526) 
  store volatile i64 %a6966, i64* %vptr15223, align 8 ; call prim_vector_45ref
 %vptr15224 = alloca i64, align 8 
  %a6967 = call i64 @prim_cons_63(i64 %a6966) 
  store volatile i64 %a6967, i64* %vptr15224, align 8 ; call prim_cons_63
  %cmpptr15228 = alloca i1, align 8  %cmp15225 = icmp eq i64 %a6967, 15 store volatile i1 %cmp15225, i1* %cmpptr15228, align 8; false?
  br i1 %cmp15225, label %else15227, label %then15226                                ; if

then15226:
 %vptr15229 = alloca i64, align 8 
  %arg7529 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7529, i64* %vptr15229, align 8 ; quoted int
 %vptr15230 = alloca i64, align 8 
  %a6968 = call i64 @prim_vector_45ref(i64 %Zvj$a, i64 %arg7529) 
  store volatile i64 %a6968, i64* %vptr15230, align 8 ; call prim_vector_45ref
 %vptr15231 = alloca i64, align 8 
  %retprim7124 = call i64 @prim_cdr(i64 %a6968) 
  store volatile i64 %retprim7124, i64* %vptr15231, align 8 ; call prim_cdr
  %vptr15240 = alloca i64*, align 8 
  %cloptr15232 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr15232, i64** %vptr15240, align 8 ; malloc
  %vptr15241 = alloca i64*, align 8 
  %eptr15234 = getelementptr inbounds i64, i64* %cloptr15232, i64 2 
  store volatile i64* %eptr15234, i64** %vptr15241, align 8 ; &eptr15234[1]
  %vptr15242 = alloca i64*, align 8 
  %eptr15235 = getelementptr inbounds i64, i64* %cloptr15232, i64 3 
  store volatile i64* %eptr15235, i64** %vptr15242, align 8 ; &eptr15235[2]
  %vptr15243 = alloca i64*, align 8 
  %eptr15236 = getelementptr inbounds i64, i64* %cloptr15232, i64 4 
  store volatile i64* %eptr15236, i64** %vptr15243, align 8 ; &eptr15236[3]
  %vptr15244 = alloca i64*, align 8 
  %eptr15237 = getelementptr inbounds i64, i64* %cloptr15232, i64 5 
  store volatile i64* %eptr15237, i64** %vptr15244, align 8 ; &eptr15237[4]
  %vptr15245 = alloca i64*, align 8 
  %eptr15238 = getelementptr inbounds i64, i64* %cloptr15232, i64 6 
  store volatile i64* %eptr15238, i64** %vptr15245, align 8 ; &eptr15238[5]
  store i64 %emsg18637, i64* %eptr15234                                              ; *eptr15234 = %emsg18637
  store i64 %cont7119, i64* %eptr15235                                               ; *eptr15235 = %cont7119
  store i64 %dYN$cc, i64* %eptr15236                                                 ; *eptr15236 = %dYN$cc
  store i64 %emsg08636, i64* %eptr15237                                              ; *eptr15237 = %emsg08636
  store i64 %Zvj$a, i64* %eptr15238                                                  ; *eptr15238 = %Zvj$a
  %vptr15246 = alloca i64*, align 8 
  %eptr15233 = getelementptr inbounds i64, i64* %cloptr15232, i64 1 
  store volatile i64* %eptr15233, i64** %vptr15246, align 8 ; &cloptr15232[1]
 %vptr15247 = alloca i64, align 8 
  %f15239 = ptrtoint void(i64,i64)* @lam12329 to i64 
  store volatile i64 %f15239, i64* %vptr15247, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f15239, i64* %eptr15233                                                 ; store fptr
 %vptr15248 = alloca i64, align 8 
  %arg7534 = ptrtoint i64* %cloptr15232 to i64 
  store volatile i64 %arg7534, i64* %vptr15248, align 8 ; closure cast; i64* -> i64
 %vptr15249 = alloca i64, align 8 
  %arg7533 = add i64 0, 0 
  store volatile i64 %arg7533, i64* %vptr15249, align 8 ; quoted ()
 %vptr15250 = alloca i64, align 8 
  %rva8954 = add i64 0, 0 
  store volatile i64 %rva8954, i64* %vptr15250, align 8 ; quoted ()
 %vptr15251 = alloca i64, align 8 
  %rva8953 = call i64 @prim_cons(i64 %retprim7124, i64 %rva8954) 
  store volatile i64 %rva8953, i64* %vptr15251, align 8 ; call prim_cons
 %vptr15252 = alloca i64, align 8 
  %rva8952 = call i64 @prim_cons(i64 %arg7533, i64 %rva8953) 
  store volatile i64 %rva8952, i64* %vptr15252, align 8 ; call prim_cons
  %vptr15258 = alloca i64*, align 8 
  %cloptr15253 = inttoptr i64 %arg7534 to i64* 
  store volatile i64* %cloptr15253, i64** %vptr15258, align 8 ; closure/env cast; i64 -> i64*
  %vptr15259 = alloca i64*, align 8 
  %i0ptr15254 = getelementptr inbounds i64, i64* %cloptr15253, i64 1 
  store volatile i64* %i0ptr15254, i64** %vptr15259, align 8 ; &cloptr15253[1]
 %vptr15260 = alloca i64, align 8 
  %f15256 = load i64, i64* %i0ptr15254, align 8 
  store volatile i64 %f15256, i64* %vptr15260, align 8 ; load; *i0ptr15254
  %fptr15255 = inttoptr i64 %f15256 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15255(i64 %arg7534, i64 %rva8952)                   ; tail call
  ret void

else15227:
 %vptr15261 = alloca i64, align 8 
  %arg7548 = add i64 0, 0 
  store volatile i64 %arg7548, i64* %vptr15261, align 8 ; quoted ()
 %vptr15262 = alloca i64, align 8 
  %arg7547 = call i64 @const_init_false() 
  store volatile i64 %arg7547, i64* %vptr15262, align 8 ; quoted #f
 %vptr15263 = alloca i64, align 8 
  %rva8957 = add i64 0, 0 
  store volatile i64 %rva8957, i64* %vptr15263, align 8 ; quoted ()
 %vptr15264 = alloca i64, align 8 
  %rva8956 = call i64 @prim_cons(i64 %arg7547, i64 %rva8957) 
  store volatile i64 %rva8956, i64* %vptr15264, align 8 ; call prim_cons
 %vptr15265 = alloca i64, align 8 
  %rva8955 = call i64 @prim_cons(i64 %arg7548, i64 %rva8956) 
  store volatile i64 %rva8955, i64* %vptr15265, align 8 ; call prim_cons
  %vptr15271 = alloca i64*, align 8 
  %cloptr15266 = inttoptr i64 %cont7119 to i64* 
  store volatile i64* %cloptr15266, i64** %vptr15271, align 8 ; closure/env cast; i64 -> i64*
  %vptr15272 = alloca i64*, align 8 
  %i0ptr15267 = getelementptr inbounds i64, i64* %cloptr15266, i64 1 
  store volatile i64* %i0ptr15267, i64** %vptr15272, align 8 ; &cloptr15266[1]
 %vptr15273 = alloca i64, align 8 
  %f15269 = load i64, i64* %i0ptr15267, align 8 
  store volatile i64 %f15269, i64* %vptr15273, align 8 ; load; *i0ptr15267
  %fptr15268 = inttoptr i64 %f15269 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15268(i64 %cont7119, i64 %rva8955)                  ; tail call
  ret void

else15200:
 %vptr15274 = alloca i64, align 8 
  %h8960 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h8960, i64* %vptr15274, align 8 ; call prim_halt
  %vptr15280 = alloca i64*, align 8 
  %cloptr15275 = inttoptr i64 %h8960 to i64* 
  store volatile i64* %cloptr15275, i64** %vptr15280, align 8 ; closure/env cast; i64 -> i64*
  %vptr15281 = alloca i64*, align 8 
  %i0ptr15276 = getelementptr inbounds i64, i64* %cloptr15275, i64 1 
  store volatile i64* %i0ptr15276, i64** %vptr15281, align 8 ; &cloptr15275[1]
 %vptr15282 = alloca i64, align 8 
  %f15278 = load i64, i64* %i0ptr15276, align 8 
  store volatile i64 %f15278, i64* %vptr15282, align 8 ; load; *i0ptr15276
  %fptr15277 = inttoptr i64 %f15278 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15277(i64 %h8960, i64 %h8960)                       ; tail call
  ret void
}


define void @lam12329(i64 %env12330, i64 %rvp8948) {
 %vptr15285 = alloca i64, align 8 
  %envptr15283 = inttoptr i64 %env12330 to i64* 
  store volatile i64 %Zvj$a, i64* %vptr15285, align 8 ; closure/env cast; i64 -> i64*
  %vptr15286 = alloca i64*, align 8 
  %envptr15284 = getelementptr inbounds i64, i64* %envptr15283, i64 6 
  store volatile i64* %envptr15284, i64** %vptr15286, align 8 ; &envptr15283[5]
 %vptr15287 = alloca i64, align 8 
  %Zvj$a = load i64, i64* %envptr15284, align 8 
  store volatile i64 %Zvj$a, i64* %vptr15287, align 8 ; load; *envptr15284
 %vptr15290 = alloca i64, align 8 
  %envptr15288 = inttoptr i64 %env12330 to i64* 
  store volatile i64 %emsg08636, i64* %vptr15290, align 8 ; closure/env cast; i64 -> i64*
  %vptr15291 = alloca i64*, align 8 
  %envptr15289 = getelementptr inbounds i64, i64* %envptr15288, i64 5 
  store volatile i64* %envptr15289, i64** %vptr15291, align 8 ; &envptr15288[4]
 %vptr15292 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr15289, align 8 
  store volatile i64 %emsg08636, i64* %vptr15292, align 8 ; load; *envptr15289
 %vptr15295 = alloca i64, align 8 
  %envptr15293 = inttoptr i64 %env12330 to i64* 
  store volatile i64 %dYN$cc, i64* %vptr15295, align 8 ; closure/env cast; i64 -> i64*
  %vptr15296 = alloca i64*, align 8 
  %envptr15294 = getelementptr inbounds i64, i64* %envptr15293, i64 4 
  store volatile i64* %envptr15294, i64** %vptr15296, align 8 ; &envptr15293[3]
 %vptr15297 = alloca i64, align 8 
  %dYN$cc = load i64, i64* %envptr15294, align 8 
  store volatile i64 %dYN$cc, i64* %vptr15297, align 8 ; load; *envptr15294
 %vptr15300 = alloca i64, align 8 
  %envptr15298 = inttoptr i64 %env12330 to i64* 
  store volatile i64 %cont7119, i64* %vptr15300, align 8 ; closure/env cast; i64 -> i64*
  %vptr15301 = alloca i64*, align 8 
  %envptr15299 = getelementptr inbounds i64, i64* %envptr15298, i64 3 
  store volatile i64* %envptr15299, i64** %vptr15301, align 8 ; &envptr15298[2]
 %vptr15302 = alloca i64, align 8 
  %cont7119 = load i64, i64* %envptr15299, align 8 
  store volatile i64 %cont7119, i64* %vptr15302, align 8 ; load; *envptr15299
 %vptr15305 = alloca i64, align 8 
  %envptr15303 = inttoptr i64 %env12330 to i64* 
  store volatile i64 %emsg18637, i64* %vptr15305, align 8 ; closure/env cast; i64 -> i64*
  %vptr15306 = alloca i64*, align 8 
  %envptr15304 = getelementptr inbounds i64, i64* %envptr15303, i64 2 
  store volatile i64* %envptr15304, i64** %vptr15306, align 8 ; &envptr15303[1]
 %vptr15307 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr15304, align 8 
  store volatile i64 %emsg18637, i64* %vptr15307, align 8 ; load; *envptr15304
 %vptr15308 = alloca i64, align 8 
  %_957121 = call i64 @prim_car(i64 %rvp8948) 
  store volatile i64 %_957121, i64* %vptr15308, align 8 ; call prim_car
 %vptr15309 = alloca i64, align 8 
  %rvp8944 = call i64 @prim_cdr(i64 %rvp8948) 
  store volatile i64 %rvp8944, i64* %vptr15309, align 8 ; call prim_cdr
 %vptr15310 = alloca i64, align 8 
  %n_638949 = call i64 @prim_null_63(i64 %rvp8944) 
  store volatile i64 %n_638949, i64* %vptr15310, align 8 ; call prim_null_63
  %cmpptr15314 = alloca i1, align 8  %cmp15311 = icmp eq i64 %n_638949, 15 store volatile i1 %cmp15311, i1* %cmpptr15314, align 8; false?
  br i1 %cmp15311, label %else15313, label %then15312                                ; if

then15312:
 %vptr15315 = alloca i64, align 8 
  %h8950 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8950, i64* %vptr15315, align 8 ; call prim_halt
  %vptr15321 = alloca i64*, align 8 
  %cloptr15316 = inttoptr i64 %h8950 to i64* 
  store volatile i64* %cloptr15316, i64** %vptr15321, align 8 ; closure/env cast; i64 -> i64*
  %vptr15322 = alloca i64*, align 8 
  %i0ptr15317 = getelementptr inbounds i64, i64* %cloptr15316, i64 1 
  store volatile i64* %i0ptr15317, i64** %vptr15322, align 8 ; &cloptr15316[1]
 %vptr15323 = alloca i64, align 8 
  %f15319 = load i64, i64* %i0ptr15317, align 8 
  store volatile i64 %f15319, i64* %vptr15323, align 8 ; load; *i0ptr15317
  %fptr15318 = inttoptr i64 %f15319 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15318(i64 %h8950, i64 %h8950)                       ; tail call
  ret void

else15313:
 %vptr15324 = alloca i64, align 8 
  %RlM$b = call i64 @prim_car(i64 %rvp8944) 
  store volatile i64 %RlM$b, i64* %vptr15324, align 8 ; call prim_car
 %vptr15325 = alloca i64, align 8 
  %na8927 = call i64 @prim_cdr(i64 %rvp8944) 
  store volatile i64 %na8927, i64* %vptr15325, align 8 ; call prim_cdr
 %vptr15326 = alloca i64, align 8 
  %n_638945 = call i64 @prim_null_63(i64 %na8927) 
  store volatile i64 %n_638945, i64* %vptr15326, align 8 ; call prim_null_63
  %cmpptr15330 = alloca i1, align 8  %cmp15327 = icmp eq i64 %n_638945, 15 store volatile i1 %cmp15327, i1* %cmpptr15330, align 8; false?
  br i1 %cmp15327, label %else15329, label %then15328                                ; if

then15328:
 %vptr15331 = alloca i64, align 8 
  %arg7535 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7535, i64* %vptr15331, align 8 ; quoted int
 %vptr15332 = alloca i64, align 8 
  %a6969 = call i64 @prim_vector_45ref(i64 %Zvj$a, i64 %arg7535) 
  store volatile i64 %a6969, i64* %vptr15332, align 8 ; call prim_vector_45ref
 %vptr15333 = alloca i64, align 8 
  %a6970 = call i64 @prim_cdr(i64 %a6969) 
  store volatile i64 %a6970, i64* %vptr15333, align 8 ; call prim_cdr
 %vptr15334 = alloca i64, align 8 
  %arg7539 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7539, i64* %vptr15334, align 8 ; quoted int
 %vptr15335 = alloca i64, align 8 
  %retprim7123 = call i64 @prim_vector_45set_33(i64 %Zvj$a, i64 %arg7539, i64 %a6970) 
  store volatile i64 %retprim7123, i64* %vptr15335, align 8 ; call prim_vector_45set_33
  %vptr15343 = alloca i64*, align 8 
  %cloptr15336 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr15336, i64** %vptr15343, align 8 ; malloc
  %vptr15344 = alloca i64*, align 8 
  %eptr15338 = getelementptr inbounds i64, i64* %cloptr15336, i64 2 
  store volatile i64* %eptr15338, i64** %vptr15344, align 8 ; &eptr15338[1]
  %vptr15345 = alloca i64*, align 8 
  %eptr15339 = getelementptr inbounds i64, i64* %cloptr15336, i64 3 
  store volatile i64* %eptr15339, i64** %vptr15345, align 8 ; &eptr15339[2]
  %vptr15346 = alloca i64*, align 8 
  %eptr15340 = getelementptr inbounds i64, i64* %cloptr15336, i64 4 
  store volatile i64* %eptr15340, i64** %vptr15346, align 8 ; &eptr15340[3]
  %vptr15347 = alloca i64*, align 8 
  %eptr15341 = getelementptr inbounds i64, i64* %cloptr15336, i64 5 
  store volatile i64* %eptr15341, i64** %vptr15347, align 8 ; &eptr15341[4]
  store i64 %emsg18637, i64* %eptr15338                                              ; *eptr15338 = %emsg18637
  store i64 %cont7119, i64* %eptr15339                                               ; *eptr15339 = %cont7119
  store i64 %dYN$cc, i64* %eptr15340                                                 ; *eptr15340 = %dYN$cc
  store i64 %emsg08636, i64* %eptr15341                                              ; *eptr15341 = %emsg08636
  %vptr15348 = alloca i64*, align 8 
  %eptr15337 = getelementptr inbounds i64, i64* %cloptr15336, i64 1 
  store volatile i64* %eptr15337, i64** %vptr15348, align 8 ; &cloptr15336[1]
 %vptr15349 = alloca i64, align 8 
  %f15342 = ptrtoint void(i64,i64)* @lam12325 to i64 
  store volatile i64 %f15342, i64* %vptr15349, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f15342, i64* %eptr15337                                                 ; store fptr
 %vptr15350 = alloca i64, align 8 
  %arg7543 = ptrtoint i64* %cloptr15336 to i64 
  store volatile i64 %arg7543, i64* %vptr15350, align 8 ; closure cast; i64* -> i64
 %vptr15351 = alloca i64, align 8 
  %arg7542 = add i64 0, 0 
  store volatile i64 %arg7542, i64* %vptr15351, align 8 ; quoted ()
 %vptr15352 = alloca i64, align 8 
  %rva8943 = add i64 0, 0 
  store volatile i64 %rva8943, i64* %vptr15352, align 8 ; quoted ()
 %vptr15353 = alloca i64, align 8 
  %rva8942 = call i64 @prim_cons(i64 %retprim7123, i64 %rva8943) 
  store volatile i64 %rva8942, i64* %vptr15353, align 8 ; call prim_cons
 %vptr15354 = alloca i64, align 8 
  %rva8941 = call i64 @prim_cons(i64 %arg7542, i64 %rva8942) 
  store volatile i64 %rva8941, i64* %vptr15354, align 8 ; call prim_cons
  %vptr15360 = alloca i64*, align 8 
  %cloptr15355 = inttoptr i64 %arg7543 to i64* 
  store volatile i64* %cloptr15355, i64** %vptr15360, align 8 ; closure/env cast; i64 -> i64*
  %vptr15361 = alloca i64*, align 8 
  %i0ptr15356 = getelementptr inbounds i64, i64* %cloptr15355, i64 1 
  store volatile i64* %i0ptr15356, i64** %vptr15361, align 8 ; &cloptr15355[1]
 %vptr15362 = alloca i64, align 8 
  %f15358 = load i64, i64* %i0ptr15356, align 8 
  store volatile i64 %f15358, i64* %vptr15362, align 8 ; load; *i0ptr15356
  %fptr15357 = inttoptr i64 %f15358 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15357(i64 %arg7543, i64 %rva8941)                   ; tail call
  ret void

else15329:
 %vptr15363 = alloca i64, align 8 
  %h8946 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h8946, i64* %vptr15363, align 8 ; call prim_halt
  %vptr15369 = alloca i64*, align 8 
  %cloptr15364 = inttoptr i64 %h8946 to i64* 
  store volatile i64* %cloptr15364, i64** %vptr15369, align 8 ; closure/env cast; i64 -> i64*
  %vptr15370 = alloca i64*, align 8 
  %i0ptr15365 = getelementptr inbounds i64, i64* %cloptr15364, i64 1 
  store volatile i64* %i0ptr15365, i64** %vptr15370, align 8 ; &cloptr15364[1]
 %vptr15371 = alloca i64, align 8 
  %f15367 = load i64, i64* %i0ptr15365, align 8 
  store volatile i64 %f15367, i64* %vptr15371, align 8 ; load; *i0ptr15365
  %fptr15366 = inttoptr i64 %f15367 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15366(i64 %h8946, i64 %h8946)                       ; tail call
  ret void
}


define void @lam12325(i64 %env12326, i64 %rvp8937) {
 %vptr15374 = alloca i64, align 8 
  %envptr15372 = inttoptr i64 %env12326 to i64* 
  store volatile i64 %emsg08636, i64* %vptr15374, align 8 ; closure/env cast; i64 -> i64*
  %vptr15375 = alloca i64*, align 8 
  %envptr15373 = getelementptr inbounds i64, i64* %envptr15372, i64 5 
  store volatile i64* %envptr15373, i64** %vptr15375, align 8 ; &envptr15372[4]
 %vptr15376 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr15373, align 8 
  store volatile i64 %emsg08636, i64* %vptr15376, align 8 ; load; *envptr15373
 %vptr15379 = alloca i64, align 8 
  %envptr15377 = inttoptr i64 %env12326 to i64* 
  store volatile i64 %dYN$cc, i64* %vptr15379, align 8 ; closure/env cast; i64 -> i64*
  %vptr15380 = alloca i64*, align 8 
  %envptr15378 = getelementptr inbounds i64, i64* %envptr15377, i64 4 
  store volatile i64* %envptr15378, i64** %vptr15380, align 8 ; &envptr15377[3]
 %vptr15381 = alloca i64, align 8 
  %dYN$cc = load i64, i64* %envptr15378, align 8 
  store volatile i64 %dYN$cc, i64* %vptr15381, align 8 ; load; *envptr15378
 %vptr15384 = alloca i64, align 8 
  %envptr15382 = inttoptr i64 %env12326 to i64* 
  store volatile i64 %cont7119, i64* %vptr15384, align 8 ; closure/env cast; i64 -> i64*
  %vptr15385 = alloca i64*, align 8 
  %envptr15383 = getelementptr inbounds i64, i64* %envptr15382, i64 3 
  store volatile i64* %envptr15383, i64** %vptr15385, align 8 ; &envptr15382[2]
 %vptr15386 = alloca i64, align 8 
  %cont7119 = load i64, i64* %envptr15383, align 8 
  store volatile i64 %cont7119, i64* %vptr15386, align 8 ; load; *envptr15383
 %vptr15389 = alloca i64, align 8 
  %envptr15387 = inttoptr i64 %env12326 to i64* 
  store volatile i64 %emsg18637, i64* %vptr15389, align 8 ; closure/env cast; i64 -> i64*
  %vptr15390 = alloca i64*, align 8 
  %envptr15388 = getelementptr inbounds i64, i64* %envptr15387, i64 2 
  store volatile i64* %envptr15388, i64** %vptr15390, align 8 ; &envptr15387[1]
 %vptr15391 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr15388, align 8 
  store volatile i64 %emsg18637, i64* %vptr15391, align 8 ; load; *envptr15388
 %vptr15392 = alloca i64, align 8 
  %_957122 = call i64 @prim_car(i64 %rvp8937) 
  store volatile i64 %_957122, i64* %vptr15392, align 8 ; call prim_car
 %vptr15393 = alloca i64, align 8 
  %rvp8933 = call i64 @prim_cdr(i64 %rvp8937) 
  store volatile i64 %rvp8933, i64* %vptr15393, align 8 ; call prim_cdr
 %vptr15394 = alloca i64, align 8 
  %n_638938 = call i64 @prim_null_63(i64 %rvp8933) 
  store volatile i64 %n_638938, i64* %vptr15394, align 8 ; call prim_null_63
  %cmpptr15398 = alloca i1, align 8  %cmp15395 = icmp eq i64 %n_638938, 15 store volatile i1 %cmp15395, i1* %cmpptr15398, align 8; false?
  br i1 %cmp15395, label %else15397, label %then15396                                ; if

then15396:
 %vptr15399 = alloca i64, align 8 
  %h8939 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8939, i64* %vptr15399, align 8 ; call prim_halt
  %vptr15405 = alloca i64*, align 8 
  %cloptr15400 = inttoptr i64 %h8939 to i64* 
  store volatile i64* %cloptr15400, i64** %vptr15405, align 8 ; closure/env cast; i64 -> i64*
  %vptr15406 = alloca i64*, align 8 
  %i0ptr15401 = getelementptr inbounds i64, i64* %cloptr15400, i64 1 
  store volatile i64* %i0ptr15401, i64** %vptr15406, align 8 ; &cloptr15400[1]
 %vptr15407 = alloca i64, align 8 
  %f15403 = load i64, i64* %i0ptr15401, align 8 
  store volatile i64 %f15403, i64* %vptr15407, align 8 ; load; *i0ptr15401
  %fptr15402 = inttoptr i64 %f15403 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15402(i64 %h8939, i64 %h8939)                       ; tail call
  ret void

else15397:
 %vptr15408 = alloca i64, align 8 
  %oK1$_950 = call i64 @prim_car(i64 %rvp8933) 
  store volatile i64 %oK1$_950, i64* %vptr15408, align 8 ; call prim_car
 %vptr15409 = alloca i64, align 8 
  %na8929 = call i64 @prim_cdr(i64 %rvp8933) 
  store volatile i64 %na8929, i64* %vptr15409, align 8 ; call prim_cdr
 %vptr15410 = alloca i64, align 8 
  %n_638934 = call i64 @prim_null_63(i64 %na8929) 
  store volatile i64 %n_638934, i64* %vptr15410, align 8 ; call prim_null_63
  %cmpptr15414 = alloca i1, align 8  %cmp15411 = icmp eq i64 %n_638934, 15 store volatile i1 %cmp15411, i1* %cmpptr15414, align 8; false?
  br i1 %cmp15411, label %else15413, label %then15412                                ; if

then15412:
 %vptr15415 = alloca i64, align 8 
  %rva8932 = add i64 0, 0 
  store volatile i64 %rva8932, i64* %vptr15415, align 8 ; quoted ()
 %vptr15416 = alloca i64, align 8 
  %rva8931 = call i64 @prim_cons(i64 %dYN$cc, i64 %rva8932) 
  store volatile i64 %rva8931, i64* %vptr15416, align 8 ; call prim_cons
 %vptr15417 = alloca i64, align 8 
  %rva8930 = call i64 @prim_cons(i64 %cont7119, i64 %rva8931) 
  store volatile i64 %rva8930, i64* %vptr15417, align 8 ; call prim_cons
  %vptr15423 = alloca i64*, align 8 
  %cloptr15418 = inttoptr i64 %dYN$cc to i64* 
  store volatile i64* %cloptr15418, i64** %vptr15423, align 8 ; closure/env cast; i64 -> i64*
  %vptr15424 = alloca i64*, align 8 
  %i0ptr15419 = getelementptr inbounds i64, i64* %cloptr15418, i64 1 
  store volatile i64* %i0ptr15419, i64** %vptr15424, align 8 ; &cloptr15418[1]
 %vptr15425 = alloca i64, align 8 
  %f15421 = load i64, i64* %i0ptr15419, align 8 
  store volatile i64 %f15421, i64* %vptr15425, align 8 ; load; *i0ptr15419
  %fptr15420 = inttoptr i64 %f15421 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15420(i64 %dYN$cc, i64 %rva8930)                    ; tail call
  ret void

else15413:
 %vptr15426 = alloca i64, align 8 
  %h8935 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h8935, i64* %vptr15426, align 8 ; call prim_halt
  %vptr15432 = alloca i64*, align 8 
  %cloptr15427 = inttoptr i64 %h8935 to i64* 
  store volatile i64* %cloptr15427, i64** %vptr15432, align 8 ; closure/env cast; i64 -> i64*
  %vptr15433 = alloca i64*, align 8 
  %i0ptr15428 = getelementptr inbounds i64, i64* %cloptr15427, i64 1 
  store volatile i64* %i0ptr15428, i64** %vptr15433, align 8 ; &cloptr15427[1]
 %vptr15434 = alloca i64, align 8 
  %f15430 = load i64, i64* %i0ptr15428, align 8 
  store volatile i64 %f15430, i64* %vptr15434, align 8 ; load; *i0ptr15428
  %fptr15429 = inttoptr i64 %f15430 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15429(i64 %h8935, i64 %h8935)                       ; tail call
  ret void
}


define void @lam12315(i64 %env12316, i64 %rvp9007) {
 %vptr15437 = alloca i64, align 8 
  %envptr15435 = inttoptr i64 %env12316 to i64* 
  store volatile i64 %Zvj$a, i64* %vptr15437, align 8 ; closure/env cast; i64 -> i64*
  %vptr15438 = alloca i64*, align 8 
  %envptr15436 = getelementptr inbounds i64, i64* %envptr15435, i64 5 
  store volatile i64* %envptr15436, i64** %vptr15438, align 8 ; &envptr15435[4]
 %vptr15439 = alloca i64, align 8 
  %Zvj$a = load i64, i64* %envptr15436, align 8 
  store volatile i64 %Zvj$a, i64* %vptr15439, align 8 ; load; *envptr15436
 %vptr15442 = alloca i64, align 8 
  %envptr15440 = inttoptr i64 %env12316 to i64* 
  store volatile i64 %emsg08636, i64* %vptr15442, align 8 ; closure/env cast; i64 -> i64*
  %vptr15443 = alloca i64*, align 8 
  %envptr15441 = getelementptr inbounds i64, i64* %envptr15440, i64 4 
  store volatile i64* %envptr15441, i64** %vptr15443, align 8 ; &envptr15440[3]
 %vptr15444 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr15441, align 8 
  store volatile i64 %emsg08636, i64* %vptr15444, align 8 ; load; *envptr15441
 %vptr15447 = alloca i64, align 8 
  %envptr15445 = inttoptr i64 %env12316 to i64* 
  store volatile i64 %cont7119, i64* %vptr15447, align 8 ; closure/env cast; i64 -> i64*
  %vptr15448 = alloca i64*, align 8 
  %envptr15446 = getelementptr inbounds i64, i64* %envptr15445, i64 3 
  store volatile i64* %envptr15446, i64** %vptr15448, align 8 ; &envptr15445[2]
 %vptr15449 = alloca i64, align 8 
  %cont7119 = load i64, i64* %envptr15446, align 8 
  store volatile i64 %cont7119, i64* %vptr15449, align 8 ; load; *envptr15446
 %vptr15452 = alloca i64, align 8 
  %envptr15450 = inttoptr i64 %env12316 to i64* 
  store volatile i64 %emsg18637, i64* %vptr15452, align 8 ; closure/env cast; i64 -> i64*
  %vptr15453 = alloca i64*, align 8 
  %envptr15451 = getelementptr inbounds i64, i64* %envptr15450, i64 2 
  store volatile i64* %envptr15451, i64** %vptr15453, align 8 ; &envptr15450[1]
 %vptr15454 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr15451, align 8 
  store volatile i64 %emsg18637, i64* %vptr15454, align 8 ; load; *envptr15451
 %vptr15455 = alloca i64, align 8 
  %_957120 = call i64 @prim_car(i64 %rvp9007) 
  store volatile i64 %_957120, i64* %vptr15455, align 8 ; call prim_car
 %vptr15456 = alloca i64, align 8 
  %rvp9003 = call i64 @prim_cdr(i64 %rvp9007) 
  store volatile i64 %rvp9003, i64* %vptr15456, align 8 ; call prim_cdr
 %vptr15457 = alloca i64, align 8 
  %n_639008 = call i64 @prim_null_63(i64 %rvp9003) 
  store volatile i64 %n_639008, i64* %vptr15457, align 8 ; call prim_null_63
  %cmpptr15461 = alloca i1, align 8  %cmp15458 = icmp eq i64 %n_639008, 15 store volatile i1 %cmp15458, i1* %cmpptr15461, align 8; false?
  br i1 %cmp15458, label %else15460, label %then15459                                ; if

then15459:
 %vptr15462 = alloca i64, align 8 
  %h9009 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9009, i64* %vptr15462, align 8 ; call prim_halt
  %vptr15468 = alloca i64*, align 8 
  %cloptr15463 = inttoptr i64 %h9009 to i64* 
  store volatile i64* %cloptr15463, i64** %vptr15468, align 8 ; closure/env cast; i64 -> i64*
  %vptr15469 = alloca i64*, align 8 
  %i0ptr15464 = getelementptr inbounds i64, i64* %cloptr15463, i64 1 
  store volatile i64* %i0ptr15464, i64** %vptr15469, align 8 ; &cloptr15463[1]
 %vptr15470 = alloca i64, align 8 
  %f15466 = load i64, i64* %i0ptr15464, align 8 
  store volatile i64 %f15466, i64* %vptr15470, align 8 ; load; *i0ptr15464
  %fptr15465 = inttoptr i64 %f15466 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15465(i64 %h9009, i64 %h9009)                       ; tail call
  ret void

else15460:
 %vptr15471 = alloca i64, align 8 
  %dYN$cc = call i64 @prim_car(i64 %rvp9003) 
  store volatile i64 %dYN$cc, i64* %vptr15471, align 8 ; call prim_car
 %vptr15472 = alloca i64, align 8 
  %na8967 = call i64 @prim_cdr(i64 %rvp9003) 
  store volatile i64 %na8967, i64* %vptr15472, align 8 ; call prim_cdr
 %vptr15473 = alloca i64, align 8 
  %n_639004 = call i64 @prim_null_63(i64 %na8967) 
  store volatile i64 %n_639004, i64* %vptr15473, align 8 ; call prim_null_63
  %cmpptr15477 = alloca i1, align 8  %cmp15474 = icmp eq i64 %n_639004, 15 store volatile i1 %cmp15474, i1* %cmpptr15477, align 8; false?
  br i1 %cmp15474, label %else15476, label %then15475                                ; if

then15475:
 %vptr15478 = alloca i64, align 8 
  %arg7550 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7550, i64* %vptr15478, align 8 ; quoted int
 %vptr15479 = alloca i64, align 8 
  %a6964 = call i64 @prim_vector_45ref(i64 %Zvj$a, i64 %arg7550) 
  store volatile i64 %a6964, i64* %vptr15479, align 8 ; call prim_vector_45ref
 %vptr15480 = alloca i64, align 8 
  %a6965 = call i64 @prim_null_63(i64 %a6964) 
  store volatile i64 %a6965, i64* %vptr15480, align 8 ; call prim_null_63
  %cmpptr15484 = alloca i1, align 8  %cmp15481 = icmp eq i64 %a6965, 15 store volatile i1 %cmp15481, i1* %cmpptr15484, align 8; false?
  br i1 %cmp15481, label %else15483, label %then15482                                ; if

then15482:
 %vptr15485 = alloca i64, align 8 
  %arg7554 = add i64 0, 0 
  store volatile i64 %arg7554, i64* %vptr15485, align 8 ; quoted ()
 %vptr15486 = alloca i64, align 8 
  %arg7553 = call i64 @const_init_true() 
  store volatile i64 %arg7553, i64* %vptr15486, align 8 ; quoted #t
 %vptr15487 = alloca i64, align 8 
  %rva8970 = add i64 0, 0 
  store volatile i64 %rva8970, i64* %vptr15487, align 8 ; quoted ()
 %vptr15488 = alloca i64, align 8 
  %rva8969 = call i64 @prim_cons(i64 %arg7553, i64 %rva8970) 
  store volatile i64 %rva8969, i64* %vptr15488, align 8 ; call prim_cons
 %vptr15489 = alloca i64, align 8 
  %rva8968 = call i64 @prim_cons(i64 %arg7554, i64 %rva8969) 
  store volatile i64 %rva8968, i64* %vptr15489, align 8 ; call prim_cons
  %vptr15495 = alloca i64*, align 8 
  %cloptr15490 = inttoptr i64 %cont7119 to i64* 
  store volatile i64* %cloptr15490, i64** %vptr15495, align 8 ; closure/env cast; i64 -> i64*
  %vptr15496 = alloca i64*, align 8 
  %i0ptr15491 = getelementptr inbounds i64, i64* %cloptr15490, i64 1 
  store volatile i64* %i0ptr15491, i64** %vptr15496, align 8 ; &cloptr15490[1]
 %vptr15497 = alloca i64, align 8 
  %f15493 = load i64, i64* %i0ptr15491, align 8 
  store volatile i64 %f15493, i64* %vptr15497, align 8 ; load; *i0ptr15491
  %fptr15492 = inttoptr i64 %f15493 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15492(i64 %cont7119, i64 %rva8968)                  ; tail call
  ret void

else15483:
 %vptr15498 = alloca i64, align 8 
  %arg7556 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7556, i64* %vptr15498, align 8 ; quoted int
 %vptr15499 = alloca i64, align 8 
  %a6966 = call i64 @prim_vector_45ref(i64 %Zvj$a, i64 %arg7556) 
  store volatile i64 %a6966, i64* %vptr15499, align 8 ; call prim_vector_45ref
 %vptr15500 = alloca i64, align 8 
  %a6967 = call i64 @prim_cons_63(i64 %a6966) 
  store volatile i64 %a6967, i64* %vptr15500, align 8 ; call prim_cons_63
  %cmpptr15504 = alloca i1, align 8  %cmp15501 = icmp eq i64 %a6967, 15 store volatile i1 %cmp15501, i1* %cmpptr15504, align 8; false?
  br i1 %cmp15501, label %else15503, label %then15502                                ; if

then15502:
 %vptr15505 = alloca i64, align 8 
  %arg7559 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7559, i64* %vptr15505, align 8 ; quoted int
 %vptr15506 = alloca i64, align 8 
  %a6968 = call i64 @prim_vector_45ref(i64 %Zvj$a, i64 %arg7559) 
  store volatile i64 %a6968, i64* %vptr15506, align 8 ; call prim_vector_45ref
 %vptr15507 = alloca i64, align 8 
  %retprim7124 = call i64 @prim_cdr(i64 %a6968) 
  store volatile i64 %retprim7124, i64* %vptr15507, align 8 ; call prim_cdr
  %vptr15516 = alloca i64*, align 8 
  %cloptr15508 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr15508, i64** %vptr15516, align 8 ; malloc
  %vptr15517 = alloca i64*, align 8 
  %eptr15510 = getelementptr inbounds i64, i64* %cloptr15508, i64 2 
  store volatile i64* %eptr15510, i64** %vptr15517, align 8 ; &eptr15510[1]
  %vptr15518 = alloca i64*, align 8 
  %eptr15511 = getelementptr inbounds i64, i64* %cloptr15508, i64 3 
  store volatile i64* %eptr15511, i64** %vptr15518, align 8 ; &eptr15511[2]
  %vptr15519 = alloca i64*, align 8 
  %eptr15512 = getelementptr inbounds i64, i64* %cloptr15508, i64 4 
  store volatile i64* %eptr15512, i64** %vptr15519, align 8 ; &eptr15512[3]
  %vptr15520 = alloca i64*, align 8 
  %eptr15513 = getelementptr inbounds i64, i64* %cloptr15508, i64 5 
  store volatile i64* %eptr15513, i64** %vptr15520, align 8 ; &eptr15513[4]
  %vptr15521 = alloca i64*, align 8 
  %eptr15514 = getelementptr inbounds i64, i64* %cloptr15508, i64 6 
  store volatile i64* %eptr15514, i64** %vptr15521, align 8 ; &eptr15514[5]
  store i64 %emsg18637, i64* %eptr15510                                              ; *eptr15510 = %emsg18637
  store i64 %cont7119, i64* %eptr15511                                               ; *eptr15511 = %cont7119
  store i64 %dYN$cc, i64* %eptr15512                                                 ; *eptr15512 = %dYN$cc
  store i64 %emsg08636, i64* %eptr15513                                              ; *eptr15513 = %emsg08636
  store i64 %Zvj$a, i64* %eptr15514                                                  ; *eptr15514 = %Zvj$a
  %vptr15522 = alloca i64*, align 8 
  %eptr15509 = getelementptr inbounds i64, i64* %cloptr15508, i64 1 
  store volatile i64* %eptr15509, i64** %vptr15522, align 8 ; &cloptr15508[1]
 %vptr15523 = alloca i64, align 8 
  %f15515 = ptrtoint void(i64,i64)* @lam12307 to i64 
  store volatile i64 %f15515, i64* %vptr15523, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f15515, i64* %eptr15509                                                 ; store fptr
 %vptr15524 = alloca i64, align 8 
  %arg7564 = ptrtoint i64* %cloptr15508 to i64 
  store volatile i64 %arg7564, i64* %vptr15524, align 8 ; closure cast; i64* -> i64
 %vptr15525 = alloca i64, align 8 
  %arg7563 = add i64 0, 0 
  store volatile i64 %arg7563, i64* %vptr15525, align 8 ; quoted ()
 %vptr15526 = alloca i64, align 8 
  %rva8999 = add i64 0, 0 
  store volatile i64 %rva8999, i64* %vptr15526, align 8 ; quoted ()
 %vptr15527 = alloca i64, align 8 
  %rva8998 = call i64 @prim_cons(i64 %retprim7124, i64 %rva8999) 
  store volatile i64 %rva8998, i64* %vptr15527, align 8 ; call prim_cons
 %vptr15528 = alloca i64, align 8 
  %rva8997 = call i64 @prim_cons(i64 %arg7563, i64 %rva8998) 
  store volatile i64 %rva8997, i64* %vptr15528, align 8 ; call prim_cons
  %vptr15534 = alloca i64*, align 8 
  %cloptr15529 = inttoptr i64 %arg7564 to i64* 
  store volatile i64* %cloptr15529, i64** %vptr15534, align 8 ; closure/env cast; i64 -> i64*
  %vptr15535 = alloca i64*, align 8 
  %i0ptr15530 = getelementptr inbounds i64, i64* %cloptr15529, i64 1 
  store volatile i64* %i0ptr15530, i64** %vptr15535, align 8 ; &cloptr15529[1]
 %vptr15536 = alloca i64, align 8 
  %f15532 = load i64, i64* %i0ptr15530, align 8 
  store volatile i64 %f15532, i64* %vptr15536, align 8 ; load; *i0ptr15530
  %fptr15531 = inttoptr i64 %f15532 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15531(i64 %arg7564, i64 %rva8997)                   ; tail call
  ret void

else15503:
 %vptr15537 = alloca i64, align 8 
  %arg7578 = add i64 0, 0 
  store volatile i64 %arg7578, i64* %vptr15537, align 8 ; quoted ()
 %vptr15538 = alloca i64, align 8 
  %arg7577 = call i64 @const_init_false() 
  store volatile i64 %arg7577, i64* %vptr15538, align 8 ; quoted #f
 %vptr15539 = alloca i64, align 8 
  %rva9002 = add i64 0, 0 
  store volatile i64 %rva9002, i64* %vptr15539, align 8 ; quoted ()
 %vptr15540 = alloca i64, align 8 
  %rva9001 = call i64 @prim_cons(i64 %arg7577, i64 %rva9002) 
  store volatile i64 %rva9001, i64* %vptr15540, align 8 ; call prim_cons
 %vptr15541 = alloca i64, align 8 
  %rva9000 = call i64 @prim_cons(i64 %arg7578, i64 %rva9001) 
  store volatile i64 %rva9000, i64* %vptr15541, align 8 ; call prim_cons
  %vptr15547 = alloca i64*, align 8 
  %cloptr15542 = inttoptr i64 %cont7119 to i64* 
  store volatile i64* %cloptr15542, i64** %vptr15547, align 8 ; closure/env cast; i64 -> i64*
  %vptr15548 = alloca i64*, align 8 
  %i0ptr15543 = getelementptr inbounds i64, i64* %cloptr15542, i64 1 
  store volatile i64* %i0ptr15543, i64** %vptr15548, align 8 ; &cloptr15542[1]
 %vptr15549 = alloca i64, align 8 
  %f15545 = load i64, i64* %i0ptr15543, align 8 
  store volatile i64 %f15545, i64* %vptr15549, align 8 ; load; *i0ptr15543
  %fptr15544 = inttoptr i64 %f15545 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15544(i64 %cont7119, i64 %rva9000)                  ; tail call
  ret void

else15476:
 %vptr15550 = alloca i64, align 8 
  %h9005 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9005, i64* %vptr15550, align 8 ; call prim_halt
  %vptr15556 = alloca i64*, align 8 
  %cloptr15551 = inttoptr i64 %h9005 to i64* 
  store volatile i64* %cloptr15551, i64** %vptr15556, align 8 ; closure/env cast; i64 -> i64*
  %vptr15557 = alloca i64*, align 8 
  %i0ptr15552 = getelementptr inbounds i64, i64* %cloptr15551, i64 1 
  store volatile i64* %i0ptr15552, i64** %vptr15557, align 8 ; &cloptr15551[1]
 %vptr15558 = alloca i64, align 8 
  %f15554 = load i64, i64* %i0ptr15552, align 8 
  store volatile i64 %f15554, i64* %vptr15558, align 8 ; load; *i0ptr15552
  %fptr15553 = inttoptr i64 %f15554 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15553(i64 %h9005, i64 %h9005)                       ; tail call
  ret void
}


define void @lam12307(i64 %env12308, i64 %rvp8993) {
 %vptr15561 = alloca i64, align 8 
  %envptr15559 = inttoptr i64 %env12308 to i64* 
  store volatile i64 %Zvj$a, i64* %vptr15561, align 8 ; closure/env cast; i64 -> i64*
  %vptr15562 = alloca i64*, align 8 
  %envptr15560 = getelementptr inbounds i64, i64* %envptr15559, i64 6 
  store volatile i64* %envptr15560, i64** %vptr15562, align 8 ; &envptr15559[5]
 %vptr15563 = alloca i64, align 8 
  %Zvj$a = load i64, i64* %envptr15560, align 8 
  store volatile i64 %Zvj$a, i64* %vptr15563, align 8 ; load; *envptr15560
 %vptr15566 = alloca i64, align 8 
  %envptr15564 = inttoptr i64 %env12308 to i64* 
  store volatile i64 %emsg08636, i64* %vptr15566, align 8 ; closure/env cast; i64 -> i64*
  %vptr15567 = alloca i64*, align 8 
  %envptr15565 = getelementptr inbounds i64, i64* %envptr15564, i64 5 
  store volatile i64* %envptr15565, i64** %vptr15567, align 8 ; &envptr15564[4]
 %vptr15568 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr15565, align 8 
  store volatile i64 %emsg08636, i64* %vptr15568, align 8 ; load; *envptr15565
 %vptr15571 = alloca i64, align 8 
  %envptr15569 = inttoptr i64 %env12308 to i64* 
  store volatile i64 %dYN$cc, i64* %vptr15571, align 8 ; closure/env cast; i64 -> i64*
  %vptr15572 = alloca i64*, align 8 
  %envptr15570 = getelementptr inbounds i64, i64* %envptr15569, i64 4 
  store volatile i64* %envptr15570, i64** %vptr15572, align 8 ; &envptr15569[3]
 %vptr15573 = alloca i64, align 8 
  %dYN$cc = load i64, i64* %envptr15570, align 8 
  store volatile i64 %dYN$cc, i64* %vptr15573, align 8 ; load; *envptr15570
 %vptr15576 = alloca i64, align 8 
  %envptr15574 = inttoptr i64 %env12308 to i64* 
  store volatile i64 %cont7119, i64* %vptr15576, align 8 ; closure/env cast; i64 -> i64*
  %vptr15577 = alloca i64*, align 8 
  %envptr15575 = getelementptr inbounds i64, i64* %envptr15574, i64 3 
  store volatile i64* %envptr15575, i64** %vptr15577, align 8 ; &envptr15574[2]
 %vptr15578 = alloca i64, align 8 
  %cont7119 = load i64, i64* %envptr15575, align 8 
  store volatile i64 %cont7119, i64* %vptr15578, align 8 ; load; *envptr15575
 %vptr15581 = alloca i64, align 8 
  %envptr15579 = inttoptr i64 %env12308 to i64* 
  store volatile i64 %emsg18637, i64* %vptr15581, align 8 ; closure/env cast; i64 -> i64*
  %vptr15582 = alloca i64*, align 8 
  %envptr15580 = getelementptr inbounds i64, i64* %envptr15579, i64 2 
  store volatile i64* %envptr15580, i64** %vptr15582, align 8 ; &envptr15579[1]
 %vptr15583 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr15580, align 8 
  store volatile i64 %emsg18637, i64* %vptr15583, align 8 ; load; *envptr15580
 %vptr15584 = alloca i64, align 8 
  %_957121 = call i64 @prim_car(i64 %rvp8993) 
  store volatile i64 %_957121, i64* %vptr15584, align 8 ; call prim_car
 %vptr15585 = alloca i64, align 8 
  %rvp8989 = call i64 @prim_cdr(i64 %rvp8993) 
  store volatile i64 %rvp8989, i64* %vptr15585, align 8 ; call prim_cdr
 %vptr15586 = alloca i64, align 8 
  %n_638994 = call i64 @prim_null_63(i64 %rvp8989) 
  store volatile i64 %n_638994, i64* %vptr15586, align 8 ; call prim_null_63
  %cmpptr15590 = alloca i1, align 8  %cmp15587 = icmp eq i64 %n_638994, 15 store volatile i1 %cmp15587, i1* %cmpptr15590, align 8; false?
  br i1 %cmp15587, label %else15589, label %then15588                                ; if

then15588:
 %vptr15591 = alloca i64, align 8 
  %h8995 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8995, i64* %vptr15591, align 8 ; call prim_halt
  %vptr15597 = alloca i64*, align 8 
  %cloptr15592 = inttoptr i64 %h8995 to i64* 
  store volatile i64* %cloptr15592, i64** %vptr15597, align 8 ; closure/env cast; i64 -> i64*
  %vptr15598 = alloca i64*, align 8 
  %i0ptr15593 = getelementptr inbounds i64, i64* %cloptr15592, i64 1 
  store volatile i64* %i0ptr15593, i64** %vptr15598, align 8 ; &cloptr15592[1]
 %vptr15599 = alloca i64, align 8 
  %f15595 = load i64, i64* %i0ptr15593, align 8 
  store volatile i64 %f15595, i64* %vptr15599, align 8 ; load; *i0ptr15593
  %fptr15594 = inttoptr i64 %f15595 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15594(i64 %h8995, i64 %h8995)                       ; tail call
  ret void

else15589:
 %vptr15600 = alloca i64, align 8 
  %RlM$b = call i64 @prim_car(i64 %rvp8989) 
  store volatile i64 %RlM$b, i64* %vptr15600, align 8 ; call prim_car
 %vptr15601 = alloca i64, align 8 
  %na8972 = call i64 @prim_cdr(i64 %rvp8989) 
  store volatile i64 %na8972, i64* %vptr15601, align 8 ; call prim_cdr
 %vptr15602 = alloca i64, align 8 
  %n_638990 = call i64 @prim_null_63(i64 %na8972) 
  store volatile i64 %n_638990, i64* %vptr15602, align 8 ; call prim_null_63
  %cmpptr15606 = alloca i1, align 8  %cmp15603 = icmp eq i64 %n_638990, 15 store volatile i1 %cmp15603, i1* %cmpptr15606, align 8; false?
  br i1 %cmp15603, label %else15605, label %then15604                                ; if

then15604:
 %vptr15607 = alloca i64, align 8 
  %arg7565 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7565, i64* %vptr15607, align 8 ; quoted int
 %vptr15608 = alloca i64, align 8 
  %a6969 = call i64 @prim_vector_45ref(i64 %Zvj$a, i64 %arg7565) 
  store volatile i64 %a6969, i64* %vptr15608, align 8 ; call prim_vector_45ref
 %vptr15609 = alloca i64, align 8 
  %a6970 = call i64 @prim_cdr(i64 %a6969) 
  store volatile i64 %a6970, i64* %vptr15609, align 8 ; call prim_cdr
 %vptr15610 = alloca i64, align 8 
  %arg7569 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7569, i64* %vptr15610, align 8 ; quoted int
 %vptr15611 = alloca i64, align 8 
  %retprim7123 = call i64 @prim_vector_45set_33(i64 %Zvj$a, i64 %arg7569, i64 %a6970) 
  store volatile i64 %retprim7123, i64* %vptr15611, align 8 ; call prim_vector_45set_33
  %vptr15619 = alloca i64*, align 8 
  %cloptr15612 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr15612, i64** %vptr15619, align 8 ; malloc
  %vptr15620 = alloca i64*, align 8 
  %eptr15614 = getelementptr inbounds i64, i64* %cloptr15612, i64 2 
  store volatile i64* %eptr15614, i64** %vptr15620, align 8 ; &eptr15614[1]
  %vptr15621 = alloca i64*, align 8 
  %eptr15615 = getelementptr inbounds i64, i64* %cloptr15612, i64 3 
  store volatile i64* %eptr15615, i64** %vptr15621, align 8 ; &eptr15615[2]
  %vptr15622 = alloca i64*, align 8 
  %eptr15616 = getelementptr inbounds i64, i64* %cloptr15612, i64 4 
  store volatile i64* %eptr15616, i64** %vptr15622, align 8 ; &eptr15616[3]
  %vptr15623 = alloca i64*, align 8 
  %eptr15617 = getelementptr inbounds i64, i64* %cloptr15612, i64 5 
  store volatile i64* %eptr15617, i64** %vptr15623, align 8 ; &eptr15617[4]
  store i64 %emsg18637, i64* %eptr15614                                              ; *eptr15614 = %emsg18637
  store i64 %cont7119, i64* %eptr15615                                               ; *eptr15615 = %cont7119
  store i64 %dYN$cc, i64* %eptr15616                                                 ; *eptr15616 = %dYN$cc
  store i64 %emsg08636, i64* %eptr15617                                              ; *eptr15617 = %emsg08636
  %vptr15624 = alloca i64*, align 8 
  %eptr15613 = getelementptr inbounds i64, i64* %cloptr15612, i64 1 
  store volatile i64* %eptr15613, i64** %vptr15624, align 8 ; &cloptr15612[1]
 %vptr15625 = alloca i64, align 8 
  %f15618 = ptrtoint void(i64,i64)* @lam12303 to i64 
  store volatile i64 %f15618, i64* %vptr15625, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f15618, i64* %eptr15613                                                 ; store fptr
 %vptr15626 = alloca i64, align 8 
  %arg7573 = ptrtoint i64* %cloptr15612 to i64 
  store volatile i64 %arg7573, i64* %vptr15626, align 8 ; closure cast; i64* -> i64
 %vptr15627 = alloca i64, align 8 
  %arg7572 = add i64 0, 0 
  store volatile i64 %arg7572, i64* %vptr15627, align 8 ; quoted ()
 %vptr15628 = alloca i64, align 8 
  %rva8988 = add i64 0, 0 
  store volatile i64 %rva8988, i64* %vptr15628, align 8 ; quoted ()
 %vptr15629 = alloca i64, align 8 
  %rva8987 = call i64 @prim_cons(i64 %retprim7123, i64 %rva8988) 
  store volatile i64 %rva8987, i64* %vptr15629, align 8 ; call prim_cons
 %vptr15630 = alloca i64, align 8 
  %rva8986 = call i64 @prim_cons(i64 %arg7572, i64 %rva8987) 
  store volatile i64 %rva8986, i64* %vptr15630, align 8 ; call prim_cons
  %vptr15636 = alloca i64*, align 8 
  %cloptr15631 = inttoptr i64 %arg7573 to i64* 
  store volatile i64* %cloptr15631, i64** %vptr15636, align 8 ; closure/env cast; i64 -> i64*
  %vptr15637 = alloca i64*, align 8 
  %i0ptr15632 = getelementptr inbounds i64, i64* %cloptr15631, i64 1 
  store volatile i64* %i0ptr15632, i64** %vptr15637, align 8 ; &cloptr15631[1]
 %vptr15638 = alloca i64, align 8 
  %f15634 = load i64, i64* %i0ptr15632, align 8 
  store volatile i64 %f15634, i64* %vptr15638, align 8 ; load; *i0ptr15632
  %fptr15633 = inttoptr i64 %f15634 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15633(i64 %arg7573, i64 %rva8986)                   ; tail call
  ret void

else15605:
 %vptr15639 = alloca i64, align 8 
  %h8991 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h8991, i64* %vptr15639, align 8 ; call prim_halt
  %vptr15645 = alloca i64*, align 8 
  %cloptr15640 = inttoptr i64 %h8991 to i64* 
  store volatile i64* %cloptr15640, i64** %vptr15645, align 8 ; closure/env cast; i64 -> i64*
  %vptr15646 = alloca i64*, align 8 
  %i0ptr15641 = getelementptr inbounds i64, i64* %cloptr15640, i64 1 
  store volatile i64* %i0ptr15641, i64** %vptr15646, align 8 ; &cloptr15640[1]
 %vptr15647 = alloca i64, align 8 
  %f15643 = load i64, i64* %i0ptr15641, align 8 
  store volatile i64 %f15643, i64* %vptr15647, align 8 ; load; *i0ptr15641
  %fptr15642 = inttoptr i64 %f15643 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15642(i64 %h8991, i64 %h8991)                       ; tail call
  ret void
}


define void @lam12303(i64 %env12304, i64 %rvp8982) {
 %vptr15650 = alloca i64, align 8 
  %envptr15648 = inttoptr i64 %env12304 to i64* 
  store volatile i64 %emsg08636, i64* %vptr15650, align 8 ; closure/env cast; i64 -> i64*
  %vptr15651 = alloca i64*, align 8 
  %envptr15649 = getelementptr inbounds i64, i64* %envptr15648, i64 5 
  store volatile i64* %envptr15649, i64** %vptr15651, align 8 ; &envptr15648[4]
 %vptr15652 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr15649, align 8 
  store volatile i64 %emsg08636, i64* %vptr15652, align 8 ; load; *envptr15649
 %vptr15655 = alloca i64, align 8 
  %envptr15653 = inttoptr i64 %env12304 to i64* 
  store volatile i64 %dYN$cc, i64* %vptr15655, align 8 ; closure/env cast; i64 -> i64*
  %vptr15656 = alloca i64*, align 8 
  %envptr15654 = getelementptr inbounds i64, i64* %envptr15653, i64 4 
  store volatile i64* %envptr15654, i64** %vptr15656, align 8 ; &envptr15653[3]
 %vptr15657 = alloca i64, align 8 
  %dYN$cc = load i64, i64* %envptr15654, align 8 
  store volatile i64 %dYN$cc, i64* %vptr15657, align 8 ; load; *envptr15654
 %vptr15660 = alloca i64, align 8 
  %envptr15658 = inttoptr i64 %env12304 to i64* 
  store volatile i64 %cont7119, i64* %vptr15660, align 8 ; closure/env cast; i64 -> i64*
  %vptr15661 = alloca i64*, align 8 
  %envptr15659 = getelementptr inbounds i64, i64* %envptr15658, i64 3 
  store volatile i64* %envptr15659, i64** %vptr15661, align 8 ; &envptr15658[2]
 %vptr15662 = alloca i64, align 8 
  %cont7119 = load i64, i64* %envptr15659, align 8 
  store volatile i64 %cont7119, i64* %vptr15662, align 8 ; load; *envptr15659
 %vptr15665 = alloca i64, align 8 
  %envptr15663 = inttoptr i64 %env12304 to i64* 
  store volatile i64 %emsg18637, i64* %vptr15665, align 8 ; closure/env cast; i64 -> i64*
  %vptr15666 = alloca i64*, align 8 
  %envptr15664 = getelementptr inbounds i64, i64* %envptr15663, i64 2 
  store volatile i64* %envptr15664, i64** %vptr15666, align 8 ; &envptr15663[1]
 %vptr15667 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr15664, align 8 
  store volatile i64 %emsg18637, i64* %vptr15667, align 8 ; load; *envptr15664
 %vptr15668 = alloca i64, align 8 
  %_957122 = call i64 @prim_car(i64 %rvp8982) 
  store volatile i64 %_957122, i64* %vptr15668, align 8 ; call prim_car
 %vptr15669 = alloca i64, align 8 
  %rvp8978 = call i64 @prim_cdr(i64 %rvp8982) 
  store volatile i64 %rvp8978, i64* %vptr15669, align 8 ; call prim_cdr
 %vptr15670 = alloca i64, align 8 
  %n_638983 = call i64 @prim_null_63(i64 %rvp8978) 
  store volatile i64 %n_638983, i64* %vptr15670, align 8 ; call prim_null_63
  %cmpptr15674 = alloca i1, align 8  %cmp15671 = icmp eq i64 %n_638983, 15 store volatile i1 %cmp15671, i1* %cmpptr15674, align 8; false?
  br i1 %cmp15671, label %else15673, label %then15672                                ; if

then15672:
 %vptr15675 = alloca i64, align 8 
  %h8984 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h8984, i64* %vptr15675, align 8 ; call prim_halt
  %vptr15681 = alloca i64*, align 8 
  %cloptr15676 = inttoptr i64 %h8984 to i64* 
  store volatile i64* %cloptr15676, i64** %vptr15681, align 8 ; closure/env cast; i64 -> i64*
  %vptr15682 = alloca i64*, align 8 
  %i0ptr15677 = getelementptr inbounds i64, i64* %cloptr15676, i64 1 
  store volatile i64* %i0ptr15677, i64** %vptr15682, align 8 ; &cloptr15676[1]
 %vptr15683 = alloca i64, align 8 
  %f15679 = load i64, i64* %i0ptr15677, align 8 
  store volatile i64 %f15679, i64* %vptr15683, align 8 ; load; *i0ptr15677
  %fptr15678 = inttoptr i64 %f15679 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15678(i64 %h8984, i64 %h8984)                       ; tail call
  ret void

else15673:
 %vptr15684 = alloca i64, align 8 
  %oK1$_950 = call i64 @prim_car(i64 %rvp8978) 
  store volatile i64 %oK1$_950, i64* %vptr15684, align 8 ; call prim_car
 %vptr15685 = alloca i64, align 8 
  %na8974 = call i64 @prim_cdr(i64 %rvp8978) 
  store volatile i64 %na8974, i64* %vptr15685, align 8 ; call prim_cdr
 %vptr15686 = alloca i64, align 8 
  %n_638979 = call i64 @prim_null_63(i64 %na8974) 
  store volatile i64 %n_638979, i64* %vptr15686, align 8 ; call prim_null_63
  %cmpptr15690 = alloca i1, align 8  %cmp15687 = icmp eq i64 %n_638979, 15 store volatile i1 %cmp15687, i1* %cmpptr15690, align 8; false?
  br i1 %cmp15687, label %else15689, label %then15688                                ; if

then15688:
 %vptr15691 = alloca i64, align 8 
  %rva8977 = add i64 0, 0 
  store volatile i64 %rva8977, i64* %vptr15691, align 8 ; quoted ()
 %vptr15692 = alloca i64, align 8 
  %rva8976 = call i64 @prim_cons(i64 %dYN$cc, i64 %rva8977) 
  store volatile i64 %rva8976, i64* %vptr15692, align 8 ; call prim_cons
 %vptr15693 = alloca i64, align 8 
  %rva8975 = call i64 @prim_cons(i64 %cont7119, i64 %rva8976) 
  store volatile i64 %rva8975, i64* %vptr15693, align 8 ; call prim_cons
  %vptr15699 = alloca i64*, align 8 
  %cloptr15694 = inttoptr i64 %dYN$cc to i64* 
  store volatile i64* %cloptr15694, i64** %vptr15699, align 8 ; closure/env cast; i64 -> i64*
  %vptr15700 = alloca i64*, align 8 
  %i0ptr15695 = getelementptr inbounds i64, i64* %cloptr15694, i64 1 
  store volatile i64* %i0ptr15695, i64** %vptr15700, align 8 ; &cloptr15694[1]
 %vptr15701 = alloca i64, align 8 
  %f15697 = load i64, i64* %i0ptr15695, align 8 
  store volatile i64 %f15697, i64* %vptr15701, align 8 ; load; *i0ptr15695
  %fptr15696 = inttoptr i64 %f15697 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15696(i64 %dYN$cc, i64 %rva8975)                    ; tail call
  ret void

else15689:
 %vptr15702 = alloca i64, align 8 
  %h8980 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h8980, i64* %vptr15702, align 8 ; call prim_halt
  %vptr15708 = alloca i64*, align 8 
  %cloptr15703 = inttoptr i64 %h8980 to i64* 
  store volatile i64* %cloptr15703, i64** %vptr15708, align 8 ; closure/env cast; i64 -> i64*
  %vptr15709 = alloca i64*, align 8 
  %i0ptr15704 = getelementptr inbounds i64, i64* %cloptr15703, i64 1 
  store volatile i64* %i0ptr15704, i64** %vptr15709, align 8 ; &cloptr15703[1]
 %vptr15710 = alloca i64, align 8 
  %f15706 = load i64, i64* %i0ptr15704, align 8 
  store volatile i64 %f15706, i64* %vptr15710, align 8 ; load; *i0ptr15704
  %fptr15705 = inttoptr i64 %f15706 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15705(i64 %h8980, i64 %h8980)                       ; tail call
  ret void
}


define void @lam12292(i64 %env12293, i64 %rvp9132) {
 %vptr15713 = alloca i64, align 8 
  %envptr15711 = inttoptr i64 %env12293 to i64* 
  store volatile i64 %emsg08636, i64* %vptr15713, align 8 ; closure/env cast; i64 -> i64*
  %vptr15714 = alloca i64*, align 8 
  %envptr15712 = getelementptr inbounds i64, i64* %envptr15711, i64 3 
  store volatile i64* %envptr15712, i64** %vptr15714, align 8 ; &envptr15711[2]
 %vptr15715 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr15712, align 8 
  store volatile i64 %emsg08636, i64* %vptr15715, align 8 ; load; *envptr15712
 %vptr15718 = alloca i64, align 8 
  %envptr15716 = inttoptr i64 %env12293 to i64* 
  store volatile i64 %emsg18637, i64* %vptr15718, align 8 ; closure/env cast; i64 -> i64*
  %vptr15719 = alloca i64*, align 8 
  %envptr15717 = getelementptr inbounds i64, i64* %envptr15716, i64 2 
  store volatile i64* %envptr15717, i64** %vptr15719, align 8 ; &envptr15716[1]
 %vptr15720 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr15717, align 8 
  store volatile i64 %emsg18637, i64* %vptr15720, align 8 ; load; *envptr15717
 %vptr15721 = alloca i64, align 8 
  %cont7126 = call i64 @prim_car(i64 %rvp9132) 
  store volatile i64 %cont7126, i64* %vptr15721, align 8 ; call prim_car
 %vptr15722 = alloca i64, align 8 
  %rvp9128 = call i64 @prim_cdr(i64 %rvp9132) 
  store volatile i64 %rvp9128, i64* %vptr15722, align 8 ; call prim_cdr
 %vptr15723 = alloca i64, align 8 
  %n_639133 = call i64 @prim_null_63(i64 %rvp9128) 
  store volatile i64 %n_639133, i64* %vptr15723, align 8 ; call prim_null_63
  %cmpptr15727 = alloca i1, align 8  %cmp15724 = icmp eq i64 %n_639133, 15 store volatile i1 %cmp15724, i1* %cmpptr15727, align 8; false?
  br i1 %cmp15724, label %else15726, label %then15725                                ; if

then15725:
 %vptr15728 = alloca i64, align 8 
  %h9134 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9134, i64* %vptr15728, align 8 ; call prim_halt
  %vptr15734 = alloca i64*, align 8 
  %cloptr15729 = inttoptr i64 %h9134 to i64* 
  store volatile i64* %cloptr15729, i64** %vptr15734, align 8 ; closure/env cast; i64 -> i64*
  %vptr15735 = alloca i64*, align 8 
  %i0ptr15730 = getelementptr inbounds i64, i64* %cloptr15729, i64 1 
  store volatile i64* %i0ptr15730, i64** %vptr15735, align 8 ; &cloptr15729[1]
 %vptr15736 = alloca i64, align 8 
  %f15732 = load i64, i64* %i0ptr15730, align 8 
  store volatile i64 %f15732, i64* %vptr15736, align 8 ; load; *i0ptr15730
  %fptr15731 = inttoptr i64 %f15732 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15731(i64 %h9134, i64 %h9134)                       ; tail call
  ret void

else15726:
 %vptr15737 = alloca i64, align 8 
  %tUI$lst = call i64 @prim_car(i64 %rvp9128) 
  store volatile i64 %tUI$lst, i64* %vptr15737, align 8 ; call prim_car
 %vptr15738 = alloca i64, align 8 
  %rvp9124 = call i64 @prim_cdr(i64 %rvp9128) 
  store volatile i64 %rvp9124, i64* %vptr15738, align 8 ; call prim_cdr
 %vptr15739 = alloca i64, align 8 
  %n_639129 = call i64 @prim_null_63(i64 %rvp9124) 
  store volatile i64 %n_639129, i64* %vptr15739, align 8 ; call prim_null_63
  %cmpptr15743 = alloca i1, align 8  %cmp15740 = icmp eq i64 %n_639129, 15 store volatile i1 %cmp15740, i1* %cmpptr15743, align 8; false?
  br i1 %cmp15740, label %else15742, label %then15741                                ; if

then15741:
 %vptr15744 = alloca i64, align 8 
  %h9130 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9130, i64* %vptr15744, align 8 ; call prim_halt
  %vptr15750 = alloca i64*, align 8 
  %cloptr15745 = inttoptr i64 %h9130 to i64* 
  store volatile i64* %cloptr15745, i64** %vptr15750, align 8 ; closure/env cast; i64 -> i64*
  %vptr15751 = alloca i64*, align 8 
  %i0ptr15746 = getelementptr inbounds i64, i64* %cloptr15745, i64 1 
  store volatile i64* %i0ptr15746, i64** %vptr15751, align 8 ; &cloptr15745[1]
 %vptr15752 = alloca i64, align 8 
  %f15748 = load i64, i64* %i0ptr15746, align 8 
  store volatile i64 %f15748, i64* %vptr15752, align 8 ; load; *i0ptr15746
  %fptr15747 = inttoptr i64 %f15748 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15747(i64 %h9130, i64 %h9130)                       ; tail call
  ret void

else15742:
 %vptr15753 = alloca i64, align 8 
  %md3$n = call i64 @prim_car(i64 %rvp9124) 
  store volatile i64 %md3$n, i64* %vptr15753, align 8 ; call prim_car
 %vptr15754 = alloca i64, align 8 
  %na9023 = call i64 @prim_cdr(i64 %rvp9124) 
  store volatile i64 %na9023, i64* %vptr15754, align 8 ; call prim_cdr
 %vptr15755 = alloca i64, align 8 
  %n_639125 = call i64 @prim_null_63(i64 %na9023) 
  store volatile i64 %n_639125, i64* %vptr15755, align 8 ; call prim_null_63
  %cmpptr15759 = alloca i1, align 8  %cmp15756 = icmp eq i64 %n_639125, 15 store volatile i1 %cmp15756, i1* %cmpptr15759, align 8; false?
  br i1 %cmp15756, label %else15758, label %then15757                                ; if

then15757:
 %vptr15760 = alloca i64, align 8 
  %arg7581 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg7581, i64* %vptr15760, align 8 ; quoted int
 %vptr15761 = alloca i64, align 8 
  %M8f$lst = call i64 @prim_make_45vector(i64 %arg7581, i64 %tUI$lst) 
  store volatile i64 %M8f$lst, i64* %vptr15761, align 8 ; call prim_make_45vector
 %vptr15762 = alloca i64, align 8 
  %arg7583 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg7583, i64* %vptr15762, align 8 ; quoted int
 %vptr15763 = alloca i64, align 8 
  %ReM$n = call i64 @prim_make_45vector(i64 %arg7583, i64 %md3$n) 
  store volatile i64 %ReM$n, i64* %vptr15763, align 8 ; call prim_make_45vector
  %vptr15769 = alloca i64*, align 8 
  %cloptr15764 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr15764, i64** %vptr15769, align 8 ; malloc
  %vptr15770 = alloca i64*, align 8 
  %eptr15766 = getelementptr inbounds i64, i64* %cloptr15764, i64 2 
  store volatile i64* %eptr15766, i64** %vptr15770, align 8 ; &eptr15766[1]
  %vptr15771 = alloca i64*, align 8 
  %eptr15767 = getelementptr inbounds i64, i64* %cloptr15764, i64 3 
  store volatile i64* %eptr15767, i64** %vptr15771, align 8 ; &eptr15767[2]
  store i64 %emsg18637, i64* %eptr15766                                              ; *eptr15766 = %emsg18637
  store i64 %emsg08636, i64* %eptr15767                                              ; *eptr15767 = %emsg08636
  %vptr15772 = alloca i64*, align 8 
  %eptr15765 = getelementptr inbounds i64, i64* %cloptr15764, i64 1 
  store volatile i64* %eptr15765, i64** %vptr15772, align 8 ; &cloptr15764[1]
 %vptr15773 = alloca i64, align 8 
  %f15768 = ptrtoint void(i64,i64)* @lam12288 to i64 
  store volatile i64 %f15768, i64* %vptr15773, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f15768, i64* %eptr15765                                                 ; store fptr
 %vptr15774 = alloca i64, align 8 
  %arg7586 = ptrtoint i64* %cloptr15764 to i64 
  store volatile i64 %arg7586, i64* %vptr15774, align 8 ; closure cast; i64* -> i64
  %vptr15783 = alloca i64*, align 8 
  %cloptr15775 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr15775, i64** %vptr15783, align 8 ; malloc
  %vptr15784 = alloca i64*, align 8 
  %eptr15777 = getelementptr inbounds i64, i64* %cloptr15775, i64 2 
  store volatile i64* %eptr15777, i64** %vptr15784, align 8 ; &eptr15777[1]
  %vptr15785 = alloca i64*, align 8 
  %eptr15778 = getelementptr inbounds i64, i64* %cloptr15775, i64 3 
  store volatile i64* %eptr15778, i64** %vptr15785, align 8 ; &eptr15778[2]
  %vptr15786 = alloca i64*, align 8 
  %eptr15779 = getelementptr inbounds i64, i64* %cloptr15775, i64 4 
  store volatile i64* %eptr15779, i64** %vptr15786, align 8 ; &eptr15779[3]
  %vptr15787 = alloca i64*, align 8 
  %eptr15780 = getelementptr inbounds i64, i64* %cloptr15775, i64 5 
  store volatile i64* %eptr15780, i64** %vptr15787, align 8 ; &eptr15780[4]
  %vptr15788 = alloca i64*, align 8 
  %eptr15781 = getelementptr inbounds i64, i64* %cloptr15775, i64 6 
  store volatile i64* %eptr15781, i64** %vptr15788, align 8 ; &eptr15781[5]
  store i64 %M8f$lst, i64* %eptr15777                                                ; *eptr15777 = %M8f$lst
  store i64 %emsg18637, i64* %eptr15778                                              ; *eptr15778 = %emsg18637
  store i64 %cont7126, i64* %eptr15779                                               ; *eptr15779 = %cont7126
  store i64 %ReM$n, i64* %eptr15780                                                  ; *eptr15780 = %ReM$n
  store i64 %emsg08636, i64* %eptr15781                                              ; *eptr15781 = %emsg08636
  %vptr15789 = alloca i64*, align 8 
  %eptr15776 = getelementptr inbounds i64, i64* %cloptr15775, i64 1 
  store volatile i64* %eptr15776, i64** %vptr15789, align 8 ; &cloptr15775[1]
 %vptr15790 = alloca i64, align 8 
  %f15782 = ptrtoint void(i64,i64)* @lam12285 to i64 
  store volatile i64 %f15782, i64* %vptr15790, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f15782, i64* %eptr15776                                                 ; store fptr
 %vptr15791 = alloca i64, align 8 
  %arg7585 = ptrtoint i64* %cloptr15775 to i64 
  store volatile i64 %arg7585, i64* %vptr15791, align 8 ; closure cast; i64* -> i64
  %vptr15800 = alloca i64*, align 8 
  %cloptr15792 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr15792, i64** %vptr15800, align 8 ; malloc
  %vptr15801 = alloca i64*, align 8 
  %eptr15794 = getelementptr inbounds i64, i64* %cloptr15792, i64 2 
  store volatile i64* %eptr15794, i64** %vptr15801, align 8 ; &eptr15794[1]
  %vptr15802 = alloca i64*, align 8 
  %eptr15795 = getelementptr inbounds i64, i64* %cloptr15792, i64 3 
  store volatile i64* %eptr15795, i64** %vptr15802, align 8 ; &eptr15795[2]
  %vptr15803 = alloca i64*, align 8 
  %eptr15796 = getelementptr inbounds i64, i64* %cloptr15792, i64 4 
  store volatile i64* %eptr15796, i64** %vptr15803, align 8 ; &eptr15796[3]
  %vptr15804 = alloca i64*, align 8 
  %eptr15797 = getelementptr inbounds i64, i64* %cloptr15792, i64 5 
  store volatile i64* %eptr15797, i64** %vptr15804, align 8 ; &eptr15797[4]
  %vptr15805 = alloca i64*, align 8 
  %eptr15798 = getelementptr inbounds i64, i64* %cloptr15792, i64 6 
  store volatile i64* %eptr15798, i64** %vptr15805, align 8 ; &eptr15798[5]
  store i64 %M8f$lst, i64* %eptr15794                                                ; *eptr15794 = %M8f$lst
  store i64 %emsg18637, i64* %eptr15795                                              ; *eptr15795 = %emsg18637
  store i64 %cont7126, i64* %eptr15796                                               ; *eptr15796 = %cont7126
  store i64 %ReM$n, i64* %eptr15797                                                  ; *eptr15797 = %ReM$n
  store i64 %emsg08636, i64* %eptr15798                                              ; *eptr15798 = %emsg08636
  %vptr15806 = alloca i64*, align 8 
  %eptr15793 = getelementptr inbounds i64, i64* %cloptr15792, i64 1 
  store volatile i64* %eptr15793, i64** %vptr15806, align 8 ; &cloptr15792[1]
 %vptr15807 = alloca i64, align 8 
  %f15799 = ptrtoint void(i64,i64)* @lam12264 to i64 
  store volatile i64 %f15799, i64* %vptr15807, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f15799, i64* %eptr15793                                                 ; store fptr
 %vptr15808 = alloca i64, align 8 
  %arg7584 = ptrtoint i64* %cloptr15792 to i64 
  store volatile i64 %arg7584, i64* %vptr15808, align 8 ; closure cast; i64* -> i64
 %vptr15809 = alloca i64, align 8 
  %rva9123 = add i64 0, 0 
  store volatile i64 %rva9123, i64* %vptr15809, align 8 ; quoted ()
 %vptr15810 = alloca i64, align 8 
  %rva9122 = call i64 @prim_cons(i64 %arg7584, i64 %rva9123) 
  store volatile i64 %rva9122, i64* %vptr15810, align 8 ; call prim_cons
 %vptr15811 = alloca i64, align 8 
  %rva9121 = call i64 @prim_cons(i64 %arg7585, i64 %rva9122) 
  store volatile i64 %rva9121, i64* %vptr15811, align 8 ; call prim_cons
  %vptr15817 = alloca i64*, align 8 
  %cloptr15812 = inttoptr i64 %arg7586 to i64* 
  store volatile i64* %cloptr15812, i64** %vptr15817, align 8 ; closure/env cast; i64 -> i64*
  %vptr15818 = alloca i64*, align 8 
  %i0ptr15813 = getelementptr inbounds i64, i64* %cloptr15812, i64 1 
  store volatile i64* %i0ptr15813, i64** %vptr15818, align 8 ; &cloptr15812[1]
 %vptr15819 = alloca i64, align 8 
  %f15815 = load i64, i64* %i0ptr15813, align 8 
  store volatile i64 %f15815, i64* %vptr15819, align 8 ; load; *i0ptr15813
  %fptr15814 = inttoptr i64 %f15815 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15814(i64 %arg7586, i64 %rva9121)                   ; tail call
  ret void

else15758:
 %vptr15820 = alloca i64, align 8 
  %h9126 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9126, i64* %vptr15820, align 8 ; call prim_halt
  %vptr15826 = alloca i64*, align 8 
  %cloptr15821 = inttoptr i64 %h9126 to i64* 
  store volatile i64* %cloptr15821, i64** %vptr15826, align 8 ; closure/env cast; i64 -> i64*
  %vptr15827 = alloca i64*, align 8 
  %i0ptr15822 = getelementptr inbounds i64, i64* %cloptr15821, i64 1 
  store volatile i64* %i0ptr15822, i64** %vptr15827, align 8 ; &cloptr15821[1]
 %vptr15828 = alloca i64, align 8 
  %f15824 = load i64, i64* %i0ptr15822, align 8 
  store volatile i64 %f15824, i64* %vptr15828, align 8 ; load; *i0ptr15822
  %fptr15823 = inttoptr i64 %f15824 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15823(i64 %h9126, i64 %h9126)                       ; tail call
  ret void
}


define void @lam12288(i64 %env12289, i64 %rvp9033) {
 %vptr15831 = alloca i64, align 8 
  %envptr15829 = inttoptr i64 %env12289 to i64* 
  store volatile i64 %emsg08636, i64* %vptr15831, align 8 ; closure/env cast; i64 -> i64*
  %vptr15832 = alloca i64*, align 8 
  %envptr15830 = getelementptr inbounds i64, i64* %envptr15829, i64 3 
  store volatile i64* %envptr15830, i64** %vptr15832, align 8 ; &envptr15829[2]
 %vptr15833 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr15830, align 8 
  store volatile i64 %emsg08636, i64* %vptr15833, align 8 ; load; *envptr15830
 %vptr15836 = alloca i64, align 8 
  %envptr15834 = inttoptr i64 %env12289 to i64* 
  store volatile i64 %emsg18637, i64* %vptr15836, align 8 ; closure/env cast; i64 -> i64*
  %vptr15837 = alloca i64*, align 8 
  %envptr15835 = getelementptr inbounds i64, i64* %envptr15834, i64 2 
  store volatile i64* %envptr15835, i64** %vptr15837, align 8 ; &envptr15834[1]
 %vptr15838 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr15835, align 8 
  store volatile i64 %emsg18637, i64* %vptr15838, align 8 ; load; *envptr15835
 %vptr15839 = alloca i64, align 8 
  %cont7133 = call i64 @prim_car(i64 %rvp9033) 
  store volatile i64 %cont7133, i64* %vptr15839, align 8 ; call prim_car
 %vptr15840 = alloca i64, align 8 
  %rvp9029 = call i64 @prim_cdr(i64 %rvp9033) 
  store volatile i64 %rvp9029, i64* %vptr15840, align 8 ; call prim_cdr
 %vptr15841 = alloca i64, align 8 
  %n_639034 = call i64 @prim_null_63(i64 %rvp9029) 
  store volatile i64 %n_639034, i64* %vptr15841, align 8 ; call prim_null_63
  %cmpptr15845 = alloca i1, align 8  %cmp15842 = icmp eq i64 %n_639034, 15 store volatile i1 %cmp15842, i1* %cmpptr15845, align 8; false?
  br i1 %cmp15842, label %else15844, label %then15843                                ; if

then15843:
 %vptr15846 = alloca i64, align 8 
  %h9035 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9035, i64* %vptr15846, align 8 ; call prim_halt
  %vptr15852 = alloca i64*, align 8 
  %cloptr15847 = inttoptr i64 %h9035 to i64* 
  store volatile i64* %cloptr15847, i64** %vptr15852, align 8 ; closure/env cast; i64 -> i64*
  %vptr15853 = alloca i64*, align 8 
  %i0ptr15848 = getelementptr inbounds i64, i64* %cloptr15847, i64 1 
  store volatile i64* %i0ptr15848, i64** %vptr15853, align 8 ; &cloptr15847[1]
 %vptr15854 = alloca i64, align 8 
  %f15850 = load i64, i64* %i0ptr15848, align 8 
  store volatile i64 %f15850, i64* %vptr15854, align 8 ; load; *i0ptr15848
  %fptr15849 = inttoptr i64 %f15850 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15849(i64 %h9035, i64 %h9035)                       ; tail call
  ret void

else15844:
 %vptr15855 = alloca i64, align 8 
  %bu8$u = call i64 @prim_car(i64 %rvp9029) 
  store volatile i64 %bu8$u, i64* %vptr15855, align 8 ; call prim_car
 %vptr15856 = alloca i64, align 8 
  %na9025 = call i64 @prim_cdr(i64 %rvp9029) 
  store volatile i64 %na9025, i64* %vptr15856, align 8 ; call prim_cdr
 %vptr15857 = alloca i64, align 8 
  %n_639030 = call i64 @prim_null_63(i64 %na9025) 
  store volatile i64 %n_639030, i64* %vptr15857, align 8 ; call prim_null_63
  %cmpptr15861 = alloca i1, align 8  %cmp15858 = icmp eq i64 %n_639030, 15 store volatile i1 %cmp15858, i1* %cmpptr15861, align 8; false?
  br i1 %cmp15858, label %else15860, label %then15859                                ; if

then15859:
 %vptr15862 = alloca i64, align 8 
  %rva9028 = add i64 0, 0 
  store volatile i64 %rva9028, i64* %vptr15862, align 8 ; quoted ()
 %vptr15863 = alloca i64, align 8 
  %rva9027 = call i64 @prim_cons(i64 %bu8$u, i64 %rva9028) 
  store volatile i64 %rva9027, i64* %vptr15863, align 8 ; call prim_cons
 %vptr15864 = alloca i64, align 8 
  %rva9026 = call i64 @prim_cons(i64 %cont7133, i64 %rva9027) 
  store volatile i64 %rva9026, i64* %vptr15864, align 8 ; call prim_cons
  %vptr15870 = alloca i64*, align 8 
  %cloptr15865 = inttoptr i64 %bu8$u to i64* 
  store volatile i64* %cloptr15865, i64** %vptr15870, align 8 ; closure/env cast; i64 -> i64*
  %vptr15871 = alloca i64*, align 8 
  %i0ptr15866 = getelementptr inbounds i64, i64* %cloptr15865, i64 1 
  store volatile i64* %i0ptr15866, i64** %vptr15871, align 8 ; &cloptr15865[1]
 %vptr15872 = alloca i64, align 8 
  %f15868 = load i64, i64* %i0ptr15866, align 8 
  store volatile i64 %f15868, i64* %vptr15872, align 8 ; load; *i0ptr15866
  %fptr15867 = inttoptr i64 %f15868 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15867(i64 %bu8$u, i64 %rva9026)                     ; tail call
  ret void

else15860:
 %vptr15873 = alloca i64, align 8 
  %h9031 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9031, i64* %vptr15873, align 8 ; call prim_halt
  %vptr15879 = alloca i64*, align 8 
  %cloptr15874 = inttoptr i64 %h9031 to i64* 
  store volatile i64* %cloptr15874, i64** %vptr15879, align 8 ; closure/env cast; i64 -> i64*
  %vptr15880 = alloca i64*, align 8 
  %i0ptr15875 = getelementptr inbounds i64, i64* %cloptr15874, i64 1 
  store volatile i64* %i0ptr15875, i64** %vptr15880, align 8 ; &cloptr15874[1]
 %vptr15881 = alloca i64, align 8 
  %f15877 = load i64, i64* %i0ptr15875, align 8 
  store volatile i64 %f15877, i64* %vptr15881, align 8 ; load; *i0ptr15875
  %fptr15876 = inttoptr i64 %f15877 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15876(i64 %h9031, i64 %h9031)                       ; tail call
  ret void
}


define void @lam12285(i64 %env12286, i64 %rvp9075) {
 %vptr15884 = alloca i64, align 8 
  %envptr15882 = inttoptr i64 %env12286 to i64* 
  store volatile i64 %emsg08636, i64* %vptr15884, align 8 ; closure/env cast; i64 -> i64*
  %vptr15885 = alloca i64*, align 8 
  %envptr15883 = getelementptr inbounds i64, i64* %envptr15882, i64 6 
  store volatile i64* %envptr15883, i64** %vptr15885, align 8 ; &envptr15882[5]
 %vptr15886 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr15883, align 8 
  store volatile i64 %emsg08636, i64* %vptr15886, align 8 ; load; *envptr15883
 %vptr15889 = alloca i64, align 8 
  %envptr15887 = inttoptr i64 %env12286 to i64* 
  store volatile i64 %ReM$n, i64* %vptr15889, align 8 ; closure/env cast; i64 -> i64*
  %vptr15890 = alloca i64*, align 8 
  %envptr15888 = getelementptr inbounds i64, i64* %envptr15887, i64 5 
  store volatile i64* %envptr15888, i64** %vptr15890, align 8 ; &envptr15887[4]
 %vptr15891 = alloca i64, align 8 
  %ReM$n = load i64, i64* %envptr15888, align 8 
  store volatile i64 %ReM$n, i64* %vptr15891, align 8 ; load; *envptr15888
 %vptr15894 = alloca i64, align 8 
  %envptr15892 = inttoptr i64 %env12286 to i64* 
  store volatile i64 %cont7126, i64* %vptr15894, align 8 ; closure/env cast; i64 -> i64*
  %vptr15895 = alloca i64*, align 8 
  %envptr15893 = getelementptr inbounds i64, i64* %envptr15892, i64 4 
  store volatile i64* %envptr15893, i64** %vptr15895, align 8 ; &envptr15892[3]
 %vptr15896 = alloca i64, align 8 
  %cont7126 = load i64, i64* %envptr15893, align 8 
  store volatile i64 %cont7126, i64* %vptr15896, align 8 ; load; *envptr15893
 %vptr15899 = alloca i64, align 8 
  %envptr15897 = inttoptr i64 %env12286 to i64* 
  store volatile i64 %emsg18637, i64* %vptr15899, align 8 ; closure/env cast; i64 -> i64*
  %vptr15900 = alloca i64*, align 8 
  %envptr15898 = getelementptr inbounds i64, i64* %envptr15897, i64 3 
  store volatile i64* %envptr15898, i64** %vptr15900, align 8 ; &envptr15897[2]
 %vptr15901 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr15898, align 8 
  store volatile i64 %emsg18637, i64* %vptr15901, align 8 ; load; *envptr15898
 %vptr15904 = alloca i64, align 8 
  %envptr15902 = inttoptr i64 %env12286 to i64* 
  store volatile i64 %M8f$lst, i64* %vptr15904, align 8 ; closure/env cast; i64 -> i64*
  %vptr15905 = alloca i64*, align 8 
  %envptr15903 = getelementptr inbounds i64, i64* %envptr15902, i64 2 
  store volatile i64* %envptr15903, i64** %vptr15905, align 8 ; &envptr15902[1]
 %vptr15906 = alloca i64, align 8 
  %M8f$lst = load i64, i64* %envptr15903, align 8 
  store volatile i64 %M8f$lst, i64* %vptr15906, align 8 ; load; *envptr15903
 %vptr15907 = alloca i64, align 8 
  %_957127 = call i64 @prim_car(i64 %rvp9075) 
  store volatile i64 %_957127, i64* %vptr15907, align 8 ; call prim_car
 %vptr15908 = alloca i64, align 8 
  %rvp9071 = call i64 @prim_cdr(i64 %rvp9075) 
  store volatile i64 %rvp9071, i64* %vptr15908, align 8 ; call prim_cdr
 %vptr15909 = alloca i64, align 8 
  %n_639076 = call i64 @prim_null_63(i64 %rvp9071) 
  store volatile i64 %n_639076, i64* %vptr15909, align 8 ; call prim_null_63
  %cmpptr15913 = alloca i1, align 8  %cmp15910 = icmp eq i64 %n_639076, 15 store volatile i1 %cmp15910, i1* %cmpptr15913, align 8; false?
  br i1 %cmp15910, label %else15912, label %then15911                                ; if

then15911:
 %vptr15914 = alloca i64, align 8 
  %h9077 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9077, i64* %vptr15914, align 8 ; call prim_halt
  %vptr15920 = alloca i64*, align 8 
  %cloptr15915 = inttoptr i64 %h9077 to i64* 
  store volatile i64* %cloptr15915, i64** %vptr15920, align 8 ; closure/env cast; i64 -> i64*
  %vptr15921 = alloca i64*, align 8 
  %i0ptr15916 = getelementptr inbounds i64, i64* %cloptr15915, i64 1 
  store volatile i64* %i0ptr15916, i64** %vptr15921, align 8 ; &cloptr15915[1]
 %vptr15922 = alloca i64, align 8 
  %f15918 = load i64, i64* %i0ptr15916, align 8 
  store volatile i64 %f15918, i64* %vptr15922, align 8 ; load; *i0ptr15916
  %fptr15917 = inttoptr i64 %f15918 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15917(i64 %h9077, i64 %h9077)                       ; tail call
  ret void

else15912:
 %vptr15923 = alloca i64, align 8 
  %TCi$cc = call i64 @prim_car(i64 %rvp9071) 
  store volatile i64 %TCi$cc, i64* %vptr15923, align 8 ; call prim_car
 %vptr15924 = alloca i64, align 8 
  %na9038 = call i64 @prim_cdr(i64 %rvp9071) 
  store volatile i64 %na9038, i64* %vptr15924, align 8 ; call prim_cdr
 %vptr15925 = alloca i64, align 8 
  %n_639072 = call i64 @prim_null_63(i64 %na9038) 
  store volatile i64 %n_639072, i64* %vptr15925, align 8 ; call prim_null_63
  %cmpptr15929 = alloca i1, align 8  %cmp15926 = icmp eq i64 %n_639072, 15 store volatile i1 %cmp15926, i1* %cmpptr15929, align 8; false?
  br i1 %cmp15926, label %else15928, label %then15927                                ; if

then15927:
 %vptr15930 = alloca i64, align 8 
  %arg7590 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7590, i64* %vptr15930, align 8 ; quoted int
 %vptr15931 = alloca i64, align 8 
  %a6971 = call i64 @prim_vector_45ref(i64 %ReM$n, i64 %arg7590) 
  store volatile i64 %a6971, i64* %vptr15931, align 8 ; call prim_vector_45ref
 %vptr15932 = alloca i64, align 8 
  %arg7593 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7593, i64* %vptr15932, align 8 ; quoted int
 %vptr15933 = alloca i64, align 8 
  %a6972 = call i64 @prim__61(i64 %arg7593, i64 %a6971) 
  store volatile i64 %a6972, i64* %vptr15933, align 8 ; call prim__61
  %cmpptr15937 = alloca i1, align 8  %cmp15934 = icmp eq i64 %a6972, 15 store volatile i1 %cmp15934, i1* %cmpptr15937, align 8; false?
  br i1 %cmp15934, label %else15936, label %then15935                                ; if

then15935:
 %vptr15938 = alloca i64, align 8 
  %arg7594 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7594, i64* %vptr15938, align 8 ; quoted int
 %vptr15939 = alloca i64, align 8 
  %retprim7128 = call i64 @prim_vector_45ref(i64 %M8f$lst, i64 %arg7594) 
  store volatile i64 %retprim7128, i64* %vptr15939, align 8 ; call prim_vector_45ref
 %vptr15940 = alloca i64, align 8 
  %arg7597 = add i64 0, 0 
  store volatile i64 %arg7597, i64* %vptr15940, align 8 ; quoted ()
 %vptr15941 = alloca i64, align 8 
  %rva9041 = add i64 0, 0 
  store volatile i64 %rva9041, i64* %vptr15941, align 8 ; quoted ()
 %vptr15942 = alloca i64, align 8 
  %rva9040 = call i64 @prim_cons(i64 %retprim7128, i64 %rva9041) 
  store volatile i64 %rva9040, i64* %vptr15942, align 8 ; call prim_cons
 %vptr15943 = alloca i64, align 8 
  %rva9039 = call i64 @prim_cons(i64 %arg7597, i64 %rva9040) 
  store volatile i64 %rva9039, i64* %vptr15943, align 8 ; call prim_cons
  %vptr15949 = alloca i64*, align 8 
  %cloptr15944 = inttoptr i64 %cont7126 to i64* 
  store volatile i64* %cloptr15944, i64** %vptr15949, align 8 ; closure/env cast; i64 -> i64*
  %vptr15950 = alloca i64*, align 8 
  %i0ptr15945 = getelementptr inbounds i64, i64* %cloptr15944, i64 1 
  store volatile i64* %i0ptr15945, i64** %vptr15950, align 8 ; &cloptr15944[1]
 %vptr15951 = alloca i64, align 8 
  %f15947 = load i64, i64* %i0ptr15945, align 8 
  store volatile i64 %f15947, i64* %vptr15951, align 8 ; load; *i0ptr15945
  %fptr15946 = inttoptr i64 %f15947 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15946(i64 %cont7126, i64 %rva9039)                  ; tail call
  ret void

else15936:
 %vptr15952 = alloca i64, align 8 
  %arg7599 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7599, i64* %vptr15952, align 8 ; quoted int
 %vptr15953 = alloca i64, align 8 
  %a6973 = call i64 @prim_vector_45ref(i64 %M8f$lst, i64 %arg7599) 
  store volatile i64 %a6973, i64* %vptr15953, align 8 ; call prim_vector_45ref
 %vptr15954 = alloca i64, align 8 
  %a6974 = call i64 @prim_cdr(i64 %a6973) 
  store volatile i64 %a6974, i64* %vptr15954, align 8 ; call prim_cdr
 %vptr15955 = alloca i64, align 8 
  %arg7603 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7603, i64* %vptr15955, align 8 ; quoted int
 %vptr15956 = alloca i64, align 8 
  %retprim7132 = call i64 @prim_vector_45set_33(i64 %M8f$lst, i64 %arg7603, i64 %a6974) 
  store volatile i64 %retprim7132, i64* %vptr15956, align 8 ; call prim_vector_45set_33
  %vptr15965 = alloca i64*, align 8 
  %cloptr15957 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr15957, i64** %vptr15965, align 8 ; malloc
  %vptr15966 = alloca i64*, align 8 
  %eptr15959 = getelementptr inbounds i64, i64* %cloptr15957, i64 2 
  store volatile i64* %eptr15959, i64** %vptr15966, align 8 ; &eptr15959[1]
  %vptr15967 = alloca i64*, align 8 
  %eptr15960 = getelementptr inbounds i64, i64* %cloptr15957, i64 3 
  store volatile i64* %eptr15960, i64** %vptr15967, align 8 ; &eptr15960[2]
  %vptr15968 = alloca i64*, align 8 
  %eptr15961 = getelementptr inbounds i64, i64* %cloptr15957, i64 4 
  store volatile i64* %eptr15961, i64** %vptr15968, align 8 ; &eptr15961[3]
  %vptr15969 = alloca i64*, align 8 
  %eptr15962 = getelementptr inbounds i64, i64* %cloptr15957, i64 5 
  store volatile i64* %eptr15962, i64** %vptr15969, align 8 ; &eptr15962[4]
  %vptr15970 = alloca i64*, align 8 
  %eptr15963 = getelementptr inbounds i64, i64* %cloptr15957, i64 6 
  store volatile i64* %eptr15963, i64** %vptr15970, align 8 ; &eptr15963[5]
  store i64 %emsg18637, i64* %eptr15959                                              ; *eptr15959 = %emsg18637
  store i64 %cont7126, i64* %eptr15960                                               ; *eptr15960 = %cont7126
  store i64 %ReM$n, i64* %eptr15961                                                  ; *eptr15961 = %ReM$n
  store i64 %TCi$cc, i64* %eptr15962                                                 ; *eptr15962 = %TCi$cc
  store i64 %emsg08636, i64* %eptr15963                                              ; *eptr15963 = %emsg08636
  %vptr15971 = alloca i64*, align 8 
  %eptr15958 = getelementptr inbounds i64, i64* %cloptr15957, i64 1 
  store volatile i64* %eptr15958, i64** %vptr15971, align 8 ; &cloptr15957[1]
 %vptr15972 = alloca i64, align 8 
  %f15964 = ptrtoint void(i64,i64)* @lam12279 to i64 
  store volatile i64 %f15964, i64* %vptr15972, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f15964, i64* %eptr15958                                                 ; store fptr
 %vptr15973 = alloca i64, align 8 
  %arg7607 = ptrtoint i64* %cloptr15957 to i64 
  store volatile i64 %arg7607, i64* %vptr15973, align 8 ; closure cast; i64* -> i64
 %vptr15974 = alloca i64, align 8 
  %arg7606 = add i64 0, 0 
  store volatile i64 %arg7606, i64* %vptr15974, align 8 ; quoted ()
 %vptr15975 = alloca i64, align 8 
  %rva9070 = add i64 0, 0 
  store volatile i64 %rva9070, i64* %vptr15975, align 8 ; quoted ()
 %vptr15976 = alloca i64, align 8 
  %rva9069 = call i64 @prim_cons(i64 %retprim7132, i64 %rva9070) 
  store volatile i64 %rva9069, i64* %vptr15976, align 8 ; call prim_cons
 %vptr15977 = alloca i64, align 8 
  %rva9068 = call i64 @prim_cons(i64 %arg7606, i64 %rva9069) 
  store volatile i64 %rva9068, i64* %vptr15977, align 8 ; call prim_cons
  %vptr15983 = alloca i64*, align 8 
  %cloptr15978 = inttoptr i64 %arg7607 to i64* 
  store volatile i64* %cloptr15978, i64** %vptr15983, align 8 ; closure/env cast; i64 -> i64*
  %vptr15984 = alloca i64*, align 8 
  %i0ptr15979 = getelementptr inbounds i64, i64* %cloptr15978, i64 1 
  store volatile i64* %i0ptr15979, i64** %vptr15984, align 8 ; &cloptr15978[1]
 %vptr15985 = alloca i64, align 8 
  %f15981 = load i64, i64* %i0ptr15979, align 8 
  store volatile i64 %f15981, i64* %vptr15985, align 8 ; load; *i0ptr15979
  %fptr15980 = inttoptr i64 %f15981 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15980(i64 %arg7607, i64 %rva9068)                   ; tail call
  ret void

else15928:
 %vptr15986 = alloca i64, align 8 
  %h9073 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9073, i64* %vptr15986, align 8 ; call prim_halt
  %vptr15992 = alloca i64*, align 8 
  %cloptr15987 = inttoptr i64 %h9073 to i64* 
  store volatile i64* %cloptr15987, i64** %vptr15992, align 8 ; closure/env cast; i64 -> i64*
  %vptr15993 = alloca i64*, align 8 
  %i0ptr15988 = getelementptr inbounds i64, i64* %cloptr15987, i64 1 
  store volatile i64* %i0ptr15988, i64** %vptr15993, align 8 ; &cloptr15987[1]
 %vptr15994 = alloca i64, align 8 
  %f15990 = load i64, i64* %i0ptr15988, align 8 
  store volatile i64 %f15990, i64* %vptr15994, align 8 ; load; *i0ptr15988
  %fptr15989 = inttoptr i64 %f15990 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr15989(i64 %h9073, i64 %h9073)                       ; tail call
  ret void
}


define void @lam12279(i64 %env12280, i64 %rvp9064) {
 %vptr15997 = alloca i64, align 8 
  %envptr15995 = inttoptr i64 %env12280 to i64* 
  store volatile i64 %emsg08636, i64* %vptr15997, align 8 ; closure/env cast; i64 -> i64*
  %vptr15998 = alloca i64*, align 8 
  %envptr15996 = getelementptr inbounds i64, i64* %envptr15995, i64 6 
  store volatile i64* %envptr15996, i64** %vptr15998, align 8 ; &envptr15995[5]
 %vptr15999 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr15996, align 8 
  store volatile i64 %emsg08636, i64* %vptr15999, align 8 ; load; *envptr15996
 %vptr16002 = alloca i64, align 8 
  %envptr16000 = inttoptr i64 %env12280 to i64* 
  store volatile i64 %TCi$cc, i64* %vptr16002, align 8 ; closure/env cast; i64 -> i64*
  %vptr16003 = alloca i64*, align 8 
  %envptr16001 = getelementptr inbounds i64, i64* %envptr16000, i64 5 
  store volatile i64* %envptr16001, i64** %vptr16003, align 8 ; &envptr16000[4]
 %vptr16004 = alloca i64, align 8 
  %TCi$cc = load i64, i64* %envptr16001, align 8 
  store volatile i64 %TCi$cc, i64* %vptr16004, align 8 ; load; *envptr16001
 %vptr16007 = alloca i64, align 8 
  %envptr16005 = inttoptr i64 %env12280 to i64* 
  store volatile i64 %ReM$n, i64* %vptr16007, align 8 ; closure/env cast; i64 -> i64*
  %vptr16008 = alloca i64*, align 8 
  %envptr16006 = getelementptr inbounds i64, i64* %envptr16005, i64 4 
  store volatile i64* %envptr16006, i64** %vptr16008, align 8 ; &envptr16005[3]
 %vptr16009 = alloca i64, align 8 
  %ReM$n = load i64, i64* %envptr16006, align 8 
  store volatile i64 %ReM$n, i64* %vptr16009, align 8 ; load; *envptr16006
 %vptr16012 = alloca i64, align 8 
  %envptr16010 = inttoptr i64 %env12280 to i64* 
  store volatile i64 %cont7126, i64* %vptr16012, align 8 ; closure/env cast; i64 -> i64*
  %vptr16013 = alloca i64*, align 8 
  %envptr16011 = getelementptr inbounds i64, i64* %envptr16010, i64 3 
  store volatile i64* %envptr16011, i64** %vptr16013, align 8 ; &envptr16010[2]
 %vptr16014 = alloca i64, align 8 
  %cont7126 = load i64, i64* %envptr16011, align 8 
  store volatile i64 %cont7126, i64* %vptr16014, align 8 ; load; *envptr16011
 %vptr16017 = alloca i64, align 8 
  %envptr16015 = inttoptr i64 %env12280 to i64* 
  store volatile i64 %emsg18637, i64* %vptr16017, align 8 ; closure/env cast; i64 -> i64*
  %vptr16018 = alloca i64*, align 8 
  %envptr16016 = getelementptr inbounds i64, i64* %envptr16015, i64 2 
  store volatile i64* %envptr16016, i64** %vptr16018, align 8 ; &envptr16015[1]
 %vptr16019 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr16016, align 8 
  store volatile i64 %emsg18637, i64* %vptr16019, align 8 ; load; *envptr16016
 %vptr16020 = alloca i64, align 8 
  %_957129 = call i64 @prim_car(i64 %rvp9064) 
  store volatile i64 %_957129, i64* %vptr16020, align 8 ; call prim_car
 %vptr16021 = alloca i64, align 8 
  %rvp9060 = call i64 @prim_cdr(i64 %rvp9064) 
  store volatile i64 %rvp9060, i64* %vptr16021, align 8 ; call prim_cdr
 %vptr16022 = alloca i64, align 8 
  %n_639065 = call i64 @prim_null_63(i64 %rvp9060) 
  store volatile i64 %n_639065, i64* %vptr16022, align 8 ; call prim_null_63
  %cmpptr16026 = alloca i1, align 8  %cmp16023 = icmp eq i64 %n_639065, 15 store volatile i1 %cmp16023, i1* %cmpptr16026, align 8; false?
  br i1 %cmp16023, label %else16025, label %then16024                                ; if

then16024:
 %vptr16027 = alloca i64, align 8 
  %h9066 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9066, i64* %vptr16027, align 8 ; call prim_halt
  %vptr16033 = alloca i64*, align 8 
  %cloptr16028 = inttoptr i64 %h9066 to i64* 
  store volatile i64* %cloptr16028, i64** %vptr16033, align 8 ; closure/env cast; i64 -> i64*
  %vptr16034 = alloca i64*, align 8 
  %i0ptr16029 = getelementptr inbounds i64, i64* %cloptr16028, i64 1 
  store volatile i64* %i0ptr16029, i64** %vptr16034, align 8 ; &cloptr16028[1]
 %vptr16035 = alloca i64, align 8 
  %f16031 = load i64, i64* %i0ptr16029, align 8 
  store volatile i64 %f16031, i64* %vptr16035, align 8 ; load; *i0ptr16029
  %fptr16030 = inttoptr i64 %f16031 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16030(i64 %h9066, i64 %h9066)                       ; tail call
  ret void

else16025:
 %vptr16036 = alloca i64, align 8 
  %E2V$_950 = call i64 @prim_car(i64 %rvp9060) 
  store volatile i64 %E2V$_950, i64* %vptr16036, align 8 ; call prim_car
 %vptr16037 = alloca i64, align 8 
  %na9043 = call i64 @prim_cdr(i64 %rvp9060) 
  store volatile i64 %na9043, i64* %vptr16037, align 8 ; call prim_cdr
 %vptr16038 = alloca i64, align 8 
  %n_639061 = call i64 @prim_null_63(i64 %na9043) 
  store volatile i64 %n_639061, i64* %vptr16038, align 8 ; call prim_null_63
  %cmpptr16042 = alloca i1, align 8  %cmp16039 = icmp eq i64 %n_639061, 15 store volatile i1 %cmp16039, i1* %cmpptr16042, align 8; false?
  br i1 %cmp16039, label %else16041, label %then16040                                ; if

then16040:
 %vptr16043 = alloca i64, align 8 
  %arg7608 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7608, i64* %vptr16043, align 8 ; quoted int
 %vptr16044 = alloca i64, align 8 
  %a6975 = call i64 @prim_vector_45ref(i64 %ReM$n, i64 %arg7608) 
  store volatile i64 %a6975, i64* %vptr16044, align 8 ; call prim_vector_45ref
 %vptr16045 = alloca i64, align 8 
  %arg7610 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg7610, i64* %vptr16045, align 8 ; quoted int
 %vptr16046 = alloca i64, align 8 
  %a6976 = call i64 @prim__45(i64 %a6975, i64 %arg7610) 
  store volatile i64 %a6976, i64* %vptr16046, align 8 ; call prim__45
 %vptr16047 = alloca i64, align 8 
  %arg7613 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7613, i64* %vptr16047, align 8 ; quoted int
 %vptr16048 = alloca i64, align 8 
  %retprim7131 = call i64 @prim_vector_45set_33(i64 %ReM$n, i64 %arg7613, i64 %a6976) 
  store volatile i64 %retprim7131, i64* %vptr16048, align 8 ; call prim_vector_45set_33
  %vptr16056 = alloca i64*, align 8 
  %cloptr16049 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr16049, i64** %vptr16056, align 8 ; malloc
  %vptr16057 = alloca i64*, align 8 
  %eptr16051 = getelementptr inbounds i64, i64* %cloptr16049, i64 2 
  store volatile i64* %eptr16051, i64** %vptr16057, align 8 ; &eptr16051[1]
  %vptr16058 = alloca i64*, align 8 
  %eptr16052 = getelementptr inbounds i64, i64* %cloptr16049, i64 3 
  store volatile i64* %eptr16052, i64** %vptr16058, align 8 ; &eptr16052[2]
  %vptr16059 = alloca i64*, align 8 
  %eptr16053 = getelementptr inbounds i64, i64* %cloptr16049, i64 4 
  store volatile i64* %eptr16053, i64** %vptr16059, align 8 ; &eptr16053[3]
  %vptr16060 = alloca i64*, align 8 
  %eptr16054 = getelementptr inbounds i64, i64* %cloptr16049, i64 5 
  store volatile i64* %eptr16054, i64** %vptr16060, align 8 ; &eptr16054[4]
  store i64 %emsg18637, i64* %eptr16051                                              ; *eptr16051 = %emsg18637
  store i64 %cont7126, i64* %eptr16052                                               ; *eptr16052 = %cont7126
  store i64 %TCi$cc, i64* %eptr16053                                                 ; *eptr16053 = %TCi$cc
  store i64 %emsg08636, i64* %eptr16054                                              ; *eptr16054 = %emsg08636
  %vptr16061 = alloca i64*, align 8 
  %eptr16050 = getelementptr inbounds i64, i64* %cloptr16049, i64 1 
  store volatile i64* %eptr16050, i64** %vptr16061, align 8 ; &cloptr16049[1]
 %vptr16062 = alloca i64, align 8 
  %f16055 = ptrtoint void(i64,i64)* @lam12274 to i64 
  store volatile i64 %f16055, i64* %vptr16062, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f16055, i64* %eptr16050                                                 ; store fptr
 %vptr16063 = alloca i64, align 8 
  %arg7617 = ptrtoint i64* %cloptr16049 to i64 
  store volatile i64 %arg7617, i64* %vptr16063, align 8 ; closure cast; i64* -> i64
 %vptr16064 = alloca i64, align 8 
  %arg7616 = add i64 0, 0 
  store volatile i64 %arg7616, i64* %vptr16064, align 8 ; quoted ()
 %vptr16065 = alloca i64, align 8 
  %rva9059 = add i64 0, 0 
  store volatile i64 %rva9059, i64* %vptr16065, align 8 ; quoted ()
 %vptr16066 = alloca i64, align 8 
  %rva9058 = call i64 @prim_cons(i64 %retprim7131, i64 %rva9059) 
  store volatile i64 %rva9058, i64* %vptr16066, align 8 ; call prim_cons
 %vptr16067 = alloca i64, align 8 
  %rva9057 = call i64 @prim_cons(i64 %arg7616, i64 %rva9058) 
  store volatile i64 %rva9057, i64* %vptr16067, align 8 ; call prim_cons
  %vptr16073 = alloca i64*, align 8 
  %cloptr16068 = inttoptr i64 %arg7617 to i64* 
  store volatile i64* %cloptr16068, i64** %vptr16073, align 8 ; closure/env cast; i64 -> i64*
  %vptr16074 = alloca i64*, align 8 
  %i0ptr16069 = getelementptr inbounds i64, i64* %cloptr16068, i64 1 
  store volatile i64* %i0ptr16069, i64** %vptr16074, align 8 ; &cloptr16068[1]
 %vptr16075 = alloca i64, align 8 
  %f16071 = load i64, i64* %i0ptr16069, align 8 
  store volatile i64 %f16071, i64* %vptr16075, align 8 ; load; *i0ptr16069
  %fptr16070 = inttoptr i64 %f16071 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16070(i64 %arg7617, i64 %rva9057)                   ; tail call
  ret void

else16041:
 %vptr16076 = alloca i64, align 8 
  %h9062 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9062, i64* %vptr16076, align 8 ; call prim_halt
  %vptr16082 = alloca i64*, align 8 
  %cloptr16077 = inttoptr i64 %h9062 to i64* 
  store volatile i64* %cloptr16077, i64** %vptr16082, align 8 ; closure/env cast; i64 -> i64*
  %vptr16083 = alloca i64*, align 8 
  %i0ptr16078 = getelementptr inbounds i64, i64* %cloptr16077, i64 1 
  store volatile i64* %i0ptr16078, i64** %vptr16083, align 8 ; &cloptr16077[1]
 %vptr16084 = alloca i64, align 8 
  %f16080 = load i64, i64* %i0ptr16078, align 8 
  store volatile i64 %f16080, i64* %vptr16084, align 8 ; load; *i0ptr16078
  %fptr16079 = inttoptr i64 %f16080 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16079(i64 %h9062, i64 %h9062)                       ; tail call
  ret void
}


define void @lam12274(i64 %env12275, i64 %rvp9053) {
 %vptr16087 = alloca i64, align 8 
  %envptr16085 = inttoptr i64 %env12275 to i64* 
  store volatile i64 %emsg08636, i64* %vptr16087, align 8 ; closure/env cast; i64 -> i64*
  %vptr16088 = alloca i64*, align 8 
  %envptr16086 = getelementptr inbounds i64, i64* %envptr16085, i64 5 
  store volatile i64* %envptr16086, i64** %vptr16088, align 8 ; &envptr16085[4]
 %vptr16089 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr16086, align 8 
  store volatile i64 %emsg08636, i64* %vptr16089, align 8 ; load; *envptr16086
 %vptr16092 = alloca i64, align 8 
  %envptr16090 = inttoptr i64 %env12275 to i64* 
  store volatile i64 %TCi$cc, i64* %vptr16092, align 8 ; closure/env cast; i64 -> i64*
  %vptr16093 = alloca i64*, align 8 
  %envptr16091 = getelementptr inbounds i64, i64* %envptr16090, i64 4 
  store volatile i64* %envptr16091, i64** %vptr16093, align 8 ; &envptr16090[3]
 %vptr16094 = alloca i64, align 8 
  %TCi$cc = load i64, i64* %envptr16091, align 8 
  store volatile i64 %TCi$cc, i64* %vptr16094, align 8 ; load; *envptr16091
 %vptr16097 = alloca i64, align 8 
  %envptr16095 = inttoptr i64 %env12275 to i64* 
  store volatile i64 %cont7126, i64* %vptr16097, align 8 ; closure/env cast; i64 -> i64*
  %vptr16098 = alloca i64*, align 8 
  %envptr16096 = getelementptr inbounds i64, i64* %envptr16095, i64 3 
  store volatile i64* %envptr16096, i64** %vptr16098, align 8 ; &envptr16095[2]
 %vptr16099 = alloca i64, align 8 
  %cont7126 = load i64, i64* %envptr16096, align 8 
  store volatile i64 %cont7126, i64* %vptr16099, align 8 ; load; *envptr16096
 %vptr16102 = alloca i64, align 8 
  %envptr16100 = inttoptr i64 %env12275 to i64* 
  store volatile i64 %emsg18637, i64* %vptr16102, align 8 ; closure/env cast; i64 -> i64*
  %vptr16103 = alloca i64*, align 8 
  %envptr16101 = getelementptr inbounds i64, i64* %envptr16100, i64 2 
  store volatile i64* %envptr16101, i64** %vptr16103, align 8 ; &envptr16100[1]
 %vptr16104 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr16101, align 8 
  store volatile i64 %emsg18637, i64* %vptr16104, align 8 ; load; *envptr16101
 %vptr16105 = alloca i64, align 8 
  %_957130 = call i64 @prim_car(i64 %rvp9053) 
  store volatile i64 %_957130, i64* %vptr16105, align 8 ; call prim_car
 %vptr16106 = alloca i64, align 8 
  %rvp9049 = call i64 @prim_cdr(i64 %rvp9053) 
  store volatile i64 %rvp9049, i64* %vptr16106, align 8 ; call prim_cdr
 %vptr16107 = alloca i64, align 8 
  %n_639054 = call i64 @prim_null_63(i64 %rvp9049) 
  store volatile i64 %n_639054, i64* %vptr16107, align 8 ; call prim_null_63
  %cmpptr16111 = alloca i1, align 8  %cmp16108 = icmp eq i64 %n_639054, 15 store volatile i1 %cmp16108, i1* %cmpptr16111, align 8; false?
  br i1 %cmp16108, label %else16110, label %then16109                                ; if

then16109:
 %vptr16112 = alloca i64, align 8 
  %h9055 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9055, i64* %vptr16112, align 8 ; call prim_halt
  %vptr16118 = alloca i64*, align 8 
  %cloptr16113 = inttoptr i64 %h9055 to i64* 
  store volatile i64* %cloptr16113, i64** %vptr16118, align 8 ; closure/env cast; i64 -> i64*
  %vptr16119 = alloca i64*, align 8 
  %i0ptr16114 = getelementptr inbounds i64, i64* %cloptr16113, i64 1 
  store volatile i64* %i0ptr16114, i64** %vptr16119, align 8 ; &cloptr16113[1]
 %vptr16120 = alloca i64, align 8 
  %f16116 = load i64, i64* %i0ptr16114, align 8 
  store volatile i64 %f16116, i64* %vptr16120, align 8 ; load; *i0ptr16114
  %fptr16115 = inttoptr i64 %f16116 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16115(i64 %h9055, i64 %h9055)                       ; tail call
  ret void

else16110:
 %vptr16121 = alloca i64, align 8 
  %eGG$_951 = call i64 @prim_car(i64 %rvp9049) 
  store volatile i64 %eGG$_951, i64* %vptr16121, align 8 ; call prim_car
 %vptr16122 = alloca i64, align 8 
  %na9045 = call i64 @prim_cdr(i64 %rvp9049) 
  store volatile i64 %na9045, i64* %vptr16122, align 8 ; call prim_cdr
 %vptr16123 = alloca i64, align 8 
  %n_639050 = call i64 @prim_null_63(i64 %na9045) 
  store volatile i64 %n_639050, i64* %vptr16123, align 8 ; call prim_null_63
  %cmpptr16127 = alloca i1, align 8  %cmp16124 = icmp eq i64 %n_639050, 15 store volatile i1 %cmp16124, i1* %cmpptr16127, align 8; false?
  br i1 %cmp16124, label %else16126, label %then16125                                ; if

then16125:
 %vptr16128 = alloca i64, align 8 
  %rva9048 = add i64 0, 0 
  store volatile i64 %rva9048, i64* %vptr16128, align 8 ; quoted ()
 %vptr16129 = alloca i64, align 8 
  %rva9047 = call i64 @prim_cons(i64 %TCi$cc, i64 %rva9048) 
  store volatile i64 %rva9047, i64* %vptr16129, align 8 ; call prim_cons
 %vptr16130 = alloca i64, align 8 
  %rva9046 = call i64 @prim_cons(i64 %cont7126, i64 %rva9047) 
  store volatile i64 %rva9046, i64* %vptr16130, align 8 ; call prim_cons
  %vptr16136 = alloca i64*, align 8 
  %cloptr16131 = inttoptr i64 %TCi$cc to i64* 
  store volatile i64* %cloptr16131, i64** %vptr16136, align 8 ; closure/env cast; i64 -> i64*
  %vptr16137 = alloca i64*, align 8 
  %i0ptr16132 = getelementptr inbounds i64, i64* %cloptr16131, i64 1 
  store volatile i64* %i0ptr16132, i64** %vptr16137, align 8 ; &cloptr16131[1]
 %vptr16138 = alloca i64, align 8 
  %f16134 = load i64, i64* %i0ptr16132, align 8 
  store volatile i64 %f16134, i64* %vptr16138, align 8 ; load; *i0ptr16132
  %fptr16133 = inttoptr i64 %f16134 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16133(i64 %TCi$cc, i64 %rva9046)                    ; tail call
  ret void

else16126:
 %vptr16139 = alloca i64, align 8 
  %h9051 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9051, i64* %vptr16139, align 8 ; call prim_halt
  %vptr16145 = alloca i64*, align 8 
  %cloptr16140 = inttoptr i64 %h9051 to i64* 
  store volatile i64* %cloptr16140, i64** %vptr16145, align 8 ; closure/env cast; i64 -> i64*
  %vptr16146 = alloca i64*, align 8 
  %i0ptr16141 = getelementptr inbounds i64, i64* %cloptr16140, i64 1 
  store volatile i64* %i0ptr16141, i64** %vptr16146, align 8 ; &cloptr16140[1]
 %vptr16147 = alloca i64, align 8 
  %f16143 = load i64, i64* %i0ptr16141, align 8 
  store volatile i64 %f16143, i64* %vptr16147, align 8 ; load; *i0ptr16141
  %fptr16142 = inttoptr i64 %f16143 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16142(i64 %h9051, i64 %h9051)                       ; tail call
  ret void
}


define void @lam12264(i64 %env12265, i64 %rvp9117) {
 %vptr16150 = alloca i64, align 8 
  %envptr16148 = inttoptr i64 %env12265 to i64* 
  store volatile i64 %emsg08636, i64* %vptr16150, align 8 ; closure/env cast; i64 -> i64*
  %vptr16151 = alloca i64*, align 8 
  %envptr16149 = getelementptr inbounds i64, i64* %envptr16148, i64 6 
  store volatile i64* %envptr16149, i64** %vptr16151, align 8 ; &envptr16148[5]
 %vptr16152 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr16149, align 8 
  store volatile i64 %emsg08636, i64* %vptr16152, align 8 ; load; *envptr16149
 %vptr16155 = alloca i64, align 8 
  %envptr16153 = inttoptr i64 %env12265 to i64* 
  store volatile i64 %ReM$n, i64* %vptr16155, align 8 ; closure/env cast; i64 -> i64*
  %vptr16156 = alloca i64*, align 8 
  %envptr16154 = getelementptr inbounds i64, i64* %envptr16153, i64 5 
  store volatile i64* %envptr16154, i64** %vptr16156, align 8 ; &envptr16153[4]
 %vptr16157 = alloca i64, align 8 
  %ReM$n = load i64, i64* %envptr16154, align 8 
  store volatile i64 %ReM$n, i64* %vptr16157, align 8 ; load; *envptr16154
 %vptr16160 = alloca i64, align 8 
  %envptr16158 = inttoptr i64 %env12265 to i64* 
  store volatile i64 %cont7126, i64* %vptr16160, align 8 ; closure/env cast; i64 -> i64*
  %vptr16161 = alloca i64*, align 8 
  %envptr16159 = getelementptr inbounds i64, i64* %envptr16158, i64 4 
  store volatile i64* %envptr16159, i64** %vptr16161, align 8 ; &envptr16158[3]
 %vptr16162 = alloca i64, align 8 
  %cont7126 = load i64, i64* %envptr16159, align 8 
  store volatile i64 %cont7126, i64* %vptr16162, align 8 ; load; *envptr16159
 %vptr16165 = alloca i64, align 8 
  %envptr16163 = inttoptr i64 %env12265 to i64* 
  store volatile i64 %emsg18637, i64* %vptr16165, align 8 ; closure/env cast; i64 -> i64*
  %vptr16166 = alloca i64*, align 8 
  %envptr16164 = getelementptr inbounds i64, i64* %envptr16163, i64 3 
  store volatile i64* %envptr16164, i64** %vptr16166, align 8 ; &envptr16163[2]
 %vptr16167 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr16164, align 8 
  store volatile i64 %emsg18637, i64* %vptr16167, align 8 ; load; *envptr16164
 %vptr16170 = alloca i64, align 8 
  %envptr16168 = inttoptr i64 %env12265 to i64* 
  store volatile i64 %M8f$lst, i64* %vptr16170, align 8 ; closure/env cast; i64 -> i64*
  %vptr16171 = alloca i64*, align 8 
  %envptr16169 = getelementptr inbounds i64, i64* %envptr16168, i64 2 
  store volatile i64* %envptr16169, i64** %vptr16171, align 8 ; &envptr16168[1]
 %vptr16172 = alloca i64, align 8 
  %M8f$lst = load i64, i64* %envptr16169, align 8 
  store volatile i64 %M8f$lst, i64* %vptr16172, align 8 ; load; *envptr16169
 %vptr16173 = alloca i64, align 8 
  %_957127 = call i64 @prim_car(i64 %rvp9117) 
  store volatile i64 %_957127, i64* %vptr16173, align 8 ; call prim_car
 %vptr16174 = alloca i64, align 8 
  %rvp9113 = call i64 @prim_cdr(i64 %rvp9117) 
  store volatile i64 %rvp9113, i64* %vptr16174, align 8 ; call prim_cdr
 %vptr16175 = alloca i64, align 8 
  %n_639118 = call i64 @prim_null_63(i64 %rvp9113) 
  store volatile i64 %n_639118, i64* %vptr16175, align 8 ; call prim_null_63
  %cmpptr16179 = alloca i1, align 8  %cmp16176 = icmp eq i64 %n_639118, 15 store volatile i1 %cmp16176, i1* %cmpptr16179, align 8; false?
  br i1 %cmp16176, label %else16178, label %then16177                                ; if

then16177:
 %vptr16180 = alloca i64, align 8 
  %h9119 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9119, i64* %vptr16180, align 8 ; call prim_halt
  %vptr16186 = alloca i64*, align 8 
  %cloptr16181 = inttoptr i64 %h9119 to i64* 
  store volatile i64* %cloptr16181, i64** %vptr16186, align 8 ; closure/env cast; i64 -> i64*
  %vptr16187 = alloca i64*, align 8 
  %i0ptr16182 = getelementptr inbounds i64, i64* %cloptr16181, i64 1 
  store volatile i64* %i0ptr16182, i64** %vptr16187, align 8 ; &cloptr16181[1]
 %vptr16188 = alloca i64, align 8 
  %f16184 = load i64, i64* %i0ptr16182, align 8 
  store volatile i64 %f16184, i64* %vptr16188, align 8 ; load; *i0ptr16182
  %fptr16183 = inttoptr i64 %f16184 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16183(i64 %h9119, i64 %h9119)                       ; tail call
  ret void

else16178:
 %vptr16189 = alloca i64, align 8 
  %TCi$cc = call i64 @prim_car(i64 %rvp9113) 
  store volatile i64 %TCi$cc, i64* %vptr16189, align 8 ; call prim_car
 %vptr16190 = alloca i64, align 8 
  %na9080 = call i64 @prim_cdr(i64 %rvp9113) 
  store volatile i64 %na9080, i64* %vptr16190, align 8 ; call prim_cdr
 %vptr16191 = alloca i64, align 8 
  %n_639114 = call i64 @prim_null_63(i64 %na9080) 
  store volatile i64 %n_639114, i64* %vptr16191, align 8 ; call prim_null_63
  %cmpptr16195 = alloca i1, align 8  %cmp16192 = icmp eq i64 %n_639114, 15 store volatile i1 %cmp16192, i1* %cmpptr16195, align 8; false?
  br i1 %cmp16192, label %else16194, label %then16193                                ; if

then16193:
 %vptr16196 = alloca i64, align 8 
  %arg7621 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7621, i64* %vptr16196, align 8 ; quoted int
 %vptr16197 = alloca i64, align 8 
  %a6971 = call i64 @prim_vector_45ref(i64 %ReM$n, i64 %arg7621) 
  store volatile i64 %a6971, i64* %vptr16197, align 8 ; call prim_vector_45ref
 %vptr16198 = alloca i64, align 8 
  %arg7624 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7624, i64* %vptr16198, align 8 ; quoted int
 %vptr16199 = alloca i64, align 8 
  %a6972 = call i64 @prim__61(i64 %arg7624, i64 %a6971) 
  store volatile i64 %a6972, i64* %vptr16199, align 8 ; call prim__61
  %cmpptr16203 = alloca i1, align 8  %cmp16200 = icmp eq i64 %a6972, 15 store volatile i1 %cmp16200, i1* %cmpptr16203, align 8; false?
  br i1 %cmp16200, label %else16202, label %then16201                                ; if

then16201:
 %vptr16204 = alloca i64, align 8 
  %arg7625 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7625, i64* %vptr16204, align 8 ; quoted int
 %vptr16205 = alloca i64, align 8 
  %retprim7128 = call i64 @prim_vector_45ref(i64 %M8f$lst, i64 %arg7625) 
  store volatile i64 %retprim7128, i64* %vptr16205, align 8 ; call prim_vector_45ref
 %vptr16206 = alloca i64, align 8 
  %arg7628 = add i64 0, 0 
  store volatile i64 %arg7628, i64* %vptr16206, align 8 ; quoted ()
 %vptr16207 = alloca i64, align 8 
  %rva9083 = add i64 0, 0 
  store volatile i64 %rva9083, i64* %vptr16207, align 8 ; quoted ()
 %vptr16208 = alloca i64, align 8 
  %rva9082 = call i64 @prim_cons(i64 %retprim7128, i64 %rva9083) 
  store volatile i64 %rva9082, i64* %vptr16208, align 8 ; call prim_cons
 %vptr16209 = alloca i64, align 8 
  %rva9081 = call i64 @prim_cons(i64 %arg7628, i64 %rva9082) 
  store volatile i64 %rva9081, i64* %vptr16209, align 8 ; call prim_cons
  %vptr16215 = alloca i64*, align 8 
  %cloptr16210 = inttoptr i64 %cont7126 to i64* 
  store volatile i64* %cloptr16210, i64** %vptr16215, align 8 ; closure/env cast; i64 -> i64*
  %vptr16216 = alloca i64*, align 8 
  %i0ptr16211 = getelementptr inbounds i64, i64* %cloptr16210, i64 1 
  store volatile i64* %i0ptr16211, i64** %vptr16216, align 8 ; &cloptr16210[1]
 %vptr16217 = alloca i64, align 8 
  %f16213 = load i64, i64* %i0ptr16211, align 8 
  store volatile i64 %f16213, i64* %vptr16217, align 8 ; load; *i0ptr16211
  %fptr16212 = inttoptr i64 %f16213 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16212(i64 %cont7126, i64 %rva9081)                  ; tail call
  ret void

else16202:
 %vptr16218 = alloca i64, align 8 
  %arg7630 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7630, i64* %vptr16218, align 8 ; quoted int
 %vptr16219 = alloca i64, align 8 
  %a6973 = call i64 @prim_vector_45ref(i64 %M8f$lst, i64 %arg7630) 
  store volatile i64 %a6973, i64* %vptr16219, align 8 ; call prim_vector_45ref
 %vptr16220 = alloca i64, align 8 
  %a6974 = call i64 @prim_cdr(i64 %a6973) 
  store volatile i64 %a6974, i64* %vptr16220, align 8 ; call prim_cdr
 %vptr16221 = alloca i64, align 8 
  %arg7634 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7634, i64* %vptr16221, align 8 ; quoted int
 %vptr16222 = alloca i64, align 8 
  %retprim7132 = call i64 @prim_vector_45set_33(i64 %M8f$lst, i64 %arg7634, i64 %a6974) 
  store volatile i64 %retprim7132, i64* %vptr16222, align 8 ; call prim_vector_45set_33
  %vptr16231 = alloca i64*, align 8 
  %cloptr16223 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr16223, i64** %vptr16231, align 8 ; malloc
  %vptr16232 = alloca i64*, align 8 
  %eptr16225 = getelementptr inbounds i64, i64* %cloptr16223, i64 2 
  store volatile i64* %eptr16225, i64** %vptr16232, align 8 ; &eptr16225[1]
  %vptr16233 = alloca i64*, align 8 
  %eptr16226 = getelementptr inbounds i64, i64* %cloptr16223, i64 3 
  store volatile i64* %eptr16226, i64** %vptr16233, align 8 ; &eptr16226[2]
  %vptr16234 = alloca i64*, align 8 
  %eptr16227 = getelementptr inbounds i64, i64* %cloptr16223, i64 4 
  store volatile i64* %eptr16227, i64** %vptr16234, align 8 ; &eptr16227[3]
  %vptr16235 = alloca i64*, align 8 
  %eptr16228 = getelementptr inbounds i64, i64* %cloptr16223, i64 5 
  store volatile i64* %eptr16228, i64** %vptr16235, align 8 ; &eptr16228[4]
  %vptr16236 = alloca i64*, align 8 
  %eptr16229 = getelementptr inbounds i64, i64* %cloptr16223, i64 6 
  store volatile i64* %eptr16229, i64** %vptr16236, align 8 ; &eptr16229[5]
  store i64 %emsg18637, i64* %eptr16225                                              ; *eptr16225 = %emsg18637
  store i64 %cont7126, i64* %eptr16226                                               ; *eptr16226 = %cont7126
  store i64 %ReM$n, i64* %eptr16227                                                  ; *eptr16227 = %ReM$n
  store i64 %TCi$cc, i64* %eptr16228                                                 ; *eptr16228 = %TCi$cc
  store i64 %emsg08636, i64* %eptr16229                                              ; *eptr16229 = %emsg08636
  %vptr16237 = alloca i64*, align 8 
  %eptr16224 = getelementptr inbounds i64, i64* %cloptr16223, i64 1 
  store volatile i64* %eptr16224, i64** %vptr16237, align 8 ; &cloptr16223[1]
 %vptr16238 = alloca i64, align 8 
  %f16230 = ptrtoint void(i64,i64)* @lam12258 to i64 
  store volatile i64 %f16230, i64* %vptr16238, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f16230, i64* %eptr16224                                                 ; store fptr
 %vptr16239 = alloca i64, align 8 
  %arg7638 = ptrtoint i64* %cloptr16223 to i64 
  store volatile i64 %arg7638, i64* %vptr16239, align 8 ; closure cast; i64* -> i64
 %vptr16240 = alloca i64, align 8 
  %arg7637 = add i64 0, 0 
  store volatile i64 %arg7637, i64* %vptr16240, align 8 ; quoted ()
 %vptr16241 = alloca i64, align 8 
  %rva9112 = add i64 0, 0 
  store volatile i64 %rva9112, i64* %vptr16241, align 8 ; quoted ()
 %vptr16242 = alloca i64, align 8 
  %rva9111 = call i64 @prim_cons(i64 %retprim7132, i64 %rva9112) 
  store volatile i64 %rva9111, i64* %vptr16242, align 8 ; call prim_cons
 %vptr16243 = alloca i64, align 8 
  %rva9110 = call i64 @prim_cons(i64 %arg7637, i64 %rva9111) 
  store volatile i64 %rva9110, i64* %vptr16243, align 8 ; call prim_cons
  %vptr16249 = alloca i64*, align 8 
  %cloptr16244 = inttoptr i64 %arg7638 to i64* 
  store volatile i64* %cloptr16244, i64** %vptr16249, align 8 ; closure/env cast; i64 -> i64*
  %vptr16250 = alloca i64*, align 8 
  %i0ptr16245 = getelementptr inbounds i64, i64* %cloptr16244, i64 1 
  store volatile i64* %i0ptr16245, i64** %vptr16250, align 8 ; &cloptr16244[1]
 %vptr16251 = alloca i64, align 8 
  %f16247 = load i64, i64* %i0ptr16245, align 8 
  store volatile i64 %f16247, i64* %vptr16251, align 8 ; load; *i0ptr16245
  %fptr16246 = inttoptr i64 %f16247 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16246(i64 %arg7638, i64 %rva9110)                   ; tail call
  ret void

else16194:
 %vptr16252 = alloca i64, align 8 
  %h9115 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9115, i64* %vptr16252, align 8 ; call prim_halt
  %vptr16258 = alloca i64*, align 8 
  %cloptr16253 = inttoptr i64 %h9115 to i64* 
  store volatile i64* %cloptr16253, i64** %vptr16258, align 8 ; closure/env cast; i64 -> i64*
  %vptr16259 = alloca i64*, align 8 
  %i0ptr16254 = getelementptr inbounds i64, i64* %cloptr16253, i64 1 
  store volatile i64* %i0ptr16254, i64** %vptr16259, align 8 ; &cloptr16253[1]
 %vptr16260 = alloca i64, align 8 
  %f16256 = load i64, i64* %i0ptr16254, align 8 
  store volatile i64 %f16256, i64* %vptr16260, align 8 ; load; *i0ptr16254
  %fptr16255 = inttoptr i64 %f16256 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16255(i64 %h9115, i64 %h9115)                       ; tail call
  ret void
}


define void @lam12258(i64 %env12259, i64 %rvp9106) {
 %vptr16263 = alloca i64, align 8 
  %envptr16261 = inttoptr i64 %env12259 to i64* 
  store volatile i64 %emsg08636, i64* %vptr16263, align 8 ; closure/env cast; i64 -> i64*
  %vptr16264 = alloca i64*, align 8 
  %envptr16262 = getelementptr inbounds i64, i64* %envptr16261, i64 6 
  store volatile i64* %envptr16262, i64** %vptr16264, align 8 ; &envptr16261[5]
 %vptr16265 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr16262, align 8 
  store volatile i64 %emsg08636, i64* %vptr16265, align 8 ; load; *envptr16262
 %vptr16268 = alloca i64, align 8 
  %envptr16266 = inttoptr i64 %env12259 to i64* 
  store volatile i64 %TCi$cc, i64* %vptr16268, align 8 ; closure/env cast; i64 -> i64*
  %vptr16269 = alloca i64*, align 8 
  %envptr16267 = getelementptr inbounds i64, i64* %envptr16266, i64 5 
  store volatile i64* %envptr16267, i64** %vptr16269, align 8 ; &envptr16266[4]
 %vptr16270 = alloca i64, align 8 
  %TCi$cc = load i64, i64* %envptr16267, align 8 
  store volatile i64 %TCi$cc, i64* %vptr16270, align 8 ; load; *envptr16267
 %vptr16273 = alloca i64, align 8 
  %envptr16271 = inttoptr i64 %env12259 to i64* 
  store volatile i64 %ReM$n, i64* %vptr16273, align 8 ; closure/env cast; i64 -> i64*
  %vptr16274 = alloca i64*, align 8 
  %envptr16272 = getelementptr inbounds i64, i64* %envptr16271, i64 4 
  store volatile i64* %envptr16272, i64** %vptr16274, align 8 ; &envptr16271[3]
 %vptr16275 = alloca i64, align 8 
  %ReM$n = load i64, i64* %envptr16272, align 8 
  store volatile i64 %ReM$n, i64* %vptr16275, align 8 ; load; *envptr16272
 %vptr16278 = alloca i64, align 8 
  %envptr16276 = inttoptr i64 %env12259 to i64* 
  store volatile i64 %cont7126, i64* %vptr16278, align 8 ; closure/env cast; i64 -> i64*
  %vptr16279 = alloca i64*, align 8 
  %envptr16277 = getelementptr inbounds i64, i64* %envptr16276, i64 3 
  store volatile i64* %envptr16277, i64** %vptr16279, align 8 ; &envptr16276[2]
 %vptr16280 = alloca i64, align 8 
  %cont7126 = load i64, i64* %envptr16277, align 8 
  store volatile i64 %cont7126, i64* %vptr16280, align 8 ; load; *envptr16277
 %vptr16283 = alloca i64, align 8 
  %envptr16281 = inttoptr i64 %env12259 to i64* 
  store volatile i64 %emsg18637, i64* %vptr16283, align 8 ; closure/env cast; i64 -> i64*
  %vptr16284 = alloca i64*, align 8 
  %envptr16282 = getelementptr inbounds i64, i64* %envptr16281, i64 2 
  store volatile i64* %envptr16282, i64** %vptr16284, align 8 ; &envptr16281[1]
 %vptr16285 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr16282, align 8 
  store volatile i64 %emsg18637, i64* %vptr16285, align 8 ; load; *envptr16282
 %vptr16286 = alloca i64, align 8 
  %_957129 = call i64 @prim_car(i64 %rvp9106) 
  store volatile i64 %_957129, i64* %vptr16286, align 8 ; call prim_car
 %vptr16287 = alloca i64, align 8 
  %rvp9102 = call i64 @prim_cdr(i64 %rvp9106) 
  store volatile i64 %rvp9102, i64* %vptr16287, align 8 ; call prim_cdr
 %vptr16288 = alloca i64, align 8 
  %n_639107 = call i64 @prim_null_63(i64 %rvp9102) 
  store volatile i64 %n_639107, i64* %vptr16288, align 8 ; call prim_null_63
  %cmpptr16292 = alloca i1, align 8  %cmp16289 = icmp eq i64 %n_639107, 15 store volatile i1 %cmp16289, i1* %cmpptr16292, align 8; false?
  br i1 %cmp16289, label %else16291, label %then16290                                ; if

then16290:
 %vptr16293 = alloca i64, align 8 
  %h9108 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9108, i64* %vptr16293, align 8 ; call prim_halt
  %vptr16299 = alloca i64*, align 8 
  %cloptr16294 = inttoptr i64 %h9108 to i64* 
  store volatile i64* %cloptr16294, i64** %vptr16299, align 8 ; closure/env cast; i64 -> i64*
  %vptr16300 = alloca i64*, align 8 
  %i0ptr16295 = getelementptr inbounds i64, i64* %cloptr16294, i64 1 
  store volatile i64* %i0ptr16295, i64** %vptr16300, align 8 ; &cloptr16294[1]
 %vptr16301 = alloca i64, align 8 
  %f16297 = load i64, i64* %i0ptr16295, align 8 
  store volatile i64 %f16297, i64* %vptr16301, align 8 ; load; *i0ptr16295
  %fptr16296 = inttoptr i64 %f16297 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16296(i64 %h9108, i64 %h9108)                       ; tail call
  ret void

else16291:
 %vptr16302 = alloca i64, align 8 
  %E2V$_950 = call i64 @prim_car(i64 %rvp9102) 
  store volatile i64 %E2V$_950, i64* %vptr16302, align 8 ; call prim_car
 %vptr16303 = alloca i64, align 8 
  %na9085 = call i64 @prim_cdr(i64 %rvp9102) 
  store volatile i64 %na9085, i64* %vptr16303, align 8 ; call prim_cdr
 %vptr16304 = alloca i64, align 8 
  %n_639103 = call i64 @prim_null_63(i64 %na9085) 
  store volatile i64 %n_639103, i64* %vptr16304, align 8 ; call prim_null_63
  %cmpptr16308 = alloca i1, align 8  %cmp16305 = icmp eq i64 %n_639103, 15 store volatile i1 %cmp16305, i1* %cmpptr16308, align 8; false?
  br i1 %cmp16305, label %else16307, label %then16306                                ; if

then16306:
 %vptr16309 = alloca i64, align 8 
  %arg7639 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7639, i64* %vptr16309, align 8 ; quoted int
 %vptr16310 = alloca i64, align 8 
  %a6975 = call i64 @prim_vector_45ref(i64 %ReM$n, i64 %arg7639) 
  store volatile i64 %a6975, i64* %vptr16310, align 8 ; call prim_vector_45ref
 %vptr16311 = alloca i64, align 8 
  %arg7641 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg7641, i64* %vptr16311, align 8 ; quoted int
 %vptr16312 = alloca i64, align 8 
  %a6976 = call i64 @prim__45(i64 %a6975, i64 %arg7641) 
  store volatile i64 %a6976, i64* %vptr16312, align 8 ; call prim__45
 %vptr16313 = alloca i64, align 8 
  %arg7644 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7644, i64* %vptr16313, align 8 ; quoted int
 %vptr16314 = alloca i64, align 8 
  %retprim7131 = call i64 @prim_vector_45set_33(i64 %ReM$n, i64 %arg7644, i64 %a6976) 
  store volatile i64 %retprim7131, i64* %vptr16314, align 8 ; call prim_vector_45set_33
  %vptr16322 = alloca i64*, align 8 
  %cloptr16315 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr16315, i64** %vptr16322, align 8 ; malloc
  %vptr16323 = alloca i64*, align 8 
  %eptr16317 = getelementptr inbounds i64, i64* %cloptr16315, i64 2 
  store volatile i64* %eptr16317, i64** %vptr16323, align 8 ; &eptr16317[1]
  %vptr16324 = alloca i64*, align 8 
  %eptr16318 = getelementptr inbounds i64, i64* %cloptr16315, i64 3 
  store volatile i64* %eptr16318, i64** %vptr16324, align 8 ; &eptr16318[2]
  %vptr16325 = alloca i64*, align 8 
  %eptr16319 = getelementptr inbounds i64, i64* %cloptr16315, i64 4 
  store volatile i64* %eptr16319, i64** %vptr16325, align 8 ; &eptr16319[3]
  %vptr16326 = alloca i64*, align 8 
  %eptr16320 = getelementptr inbounds i64, i64* %cloptr16315, i64 5 
  store volatile i64* %eptr16320, i64** %vptr16326, align 8 ; &eptr16320[4]
  store i64 %emsg18637, i64* %eptr16317                                              ; *eptr16317 = %emsg18637
  store i64 %cont7126, i64* %eptr16318                                               ; *eptr16318 = %cont7126
  store i64 %TCi$cc, i64* %eptr16319                                                 ; *eptr16319 = %TCi$cc
  store i64 %emsg08636, i64* %eptr16320                                              ; *eptr16320 = %emsg08636
  %vptr16327 = alloca i64*, align 8 
  %eptr16316 = getelementptr inbounds i64, i64* %cloptr16315, i64 1 
  store volatile i64* %eptr16316, i64** %vptr16327, align 8 ; &cloptr16315[1]
 %vptr16328 = alloca i64, align 8 
  %f16321 = ptrtoint void(i64,i64)* @lam12253 to i64 
  store volatile i64 %f16321, i64* %vptr16328, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f16321, i64* %eptr16316                                                 ; store fptr
 %vptr16329 = alloca i64, align 8 
  %arg7648 = ptrtoint i64* %cloptr16315 to i64 
  store volatile i64 %arg7648, i64* %vptr16329, align 8 ; closure cast; i64* -> i64
 %vptr16330 = alloca i64, align 8 
  %arg7647 = add i64 0, 0 
  store volatile i64 %arg7647, i64* %vptr16330, align 8 ; quoted ()
 %vptr16331 = alloca i64, align 8 
  %rva9101 = add i64 0, 0 
  store volatile i64 %rva9101, i64* %vptr16331, align 8 ; quoted ()
 %vptr16332 = alloca i64, align 8 
  %rva9100 = call i64 @prim_cons(i64 %retprim7131, i64 %rva9101) 
  store volatile i64 %rva9100, i64* %vptr16332, align 8 ; call prim_cons
 %vptr16333 = alloca i64, align 8 
  %rva9099 = call i64 @prim_cons(i64 %arg7647, i64 %rva9100) 
  store volatile i64 %rva9099, i64* %vptr16333, align 8 ; call prim_cons
  %vptr16339 = alloca i64*, align 8 
  %cloptr16334 = inttoptr i64 %arg7648 to i64* 
  store volatile i64* %cloptr16334, i64** %vptr16339, align 8 ; closure/env cast; i64 -> i64*
  %vptr16340 = alloca i64*, align 8 
  %i0ptr16335 = getelementptr inbounds i64, i64* %cloptr16334, i64 1 
  store volatile i64* %i0ptr16335, i64** %vptr16340, align 8 ; &cloptr16334[1]
 %vptr16341 = alloca i64, align 8 
  %f16337 = load i64, i64* %i0ptr16335, align 8 
  store volatile i64 %f16337, i64* %vptr16341, align 8 ; load; *i0ptr16335
  %fptr16336 = inttoptr i64 %f16337 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16336(i64 %arg7648, i64 %rva9099)                   ; tail call
  ret void

else16307:
 %vptr16342 = alloca i64, align 8 
  %h9104 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9104, i64* %vptr16342, align 8 ; call prim_halt
  %vptr16348 = alloca i64*, align 8 
  %cloptr16343 = inttoptr i64 %h9104 to i64* 
  store volatile i64* %cloptr16343, i64** %vptr16348, align 8 ; closure/env cast; i64 -> i64*
  %vptr16349 = alloca i64*, align 8 
  %i0ptr16344 = getelementptr inbounds i64, i64* %cloptr16343, i64 1 
  store volatile i64* %i0ptr16344, i64** %vptr16349, align 8 ; &cloptr16343[1]
 %vptr16350 = alloca i64, align 8 
  %f16346 = load i64, i64* %i0ptr16344, align 8 
  store volatile i64 %f16346, i64* %vptr16350, align 8 ; load; *i0ptr16344
  %fptr16345 = inttoptr i64 %f16346 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16345(i64 %h9104, i64 %h9104)                       ; tail call
  ret void
}


define void @lam12253(i64 %env12254, i64 %rvp9095) {
 %vptr16353 = alloca i64, align 8 
  %envptr16351 = inttoptr i64 %env12254 to i64* 
  store volatile i64 %emsg08636, i64* %vptr16353, align 8 ; closure/env cast; i64 -> i64*
  %vptr16354 = alloca i64*, align 8 
  %envptr16352 = getelementptr inbounds i64, i64* %envptr16351, i64 5 
  store volatile i64* %envptr16352, i64** %vptr16354, align 8 ; &envptr16351[4]
 %vptr16355 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr16352, align 8 
  store volatile i64 %emsg08636, i64* %vptr16355, align 8 ; load; *envptr16352
 %vptr16358 = alloca i64, align 8 
  %envptr16356 = inttoptr i64 %env12254 to i64* 
  store volatile i64 %TCi$cc, i64* %vptr16358, align 8 ; closure/env cast; i64 -> i64*
  %vptr16359 = alloca i64*, align 8 
  %envptr16357 = getelementptr inbounds i64, i64* %envptr16356, i64 4 
  store volatile i64* %envptr16357, i64** %vptr16359, align 8 ; &envptr16356[3]
 %vptr16360 = alloca i64, align 8 
  %TCi$cc = load i64, i64* %envptr16357, align 8 
  store volatile i64 %TCi$cc, i64* %vptr16360, align 8 ; load; *envptr16357
 %vptr16363 = alloca i64, align 8 
  %envptr16361 = inttoptr i64 %env12254 to i64* 
  store volatile i64 %cont7126, i64* %vptr16363, align 8 ; closure/env cast; i64 -> i64*
  %vptr16364 = alloca i64*, align 8 
  %envptr16362 = getelementptr inbounds i64, i64* %envptr16361, i64 3 
  store volatile i64* %envptr16362, i64** %vptr16364, align 8 ; &envptr16361[2]
 %vptr16365 = alloca i64, align 8 
  %cont7126 = load i64, i64* %envptr16362, align 8 
  store volatile i64 %cont7126, i64* %vptr16365, align 8 ; load; *envptr16362
 %vptr16368 = alloca i64, align 8 
  %envptr16366 = inttoptr i64 %env12254 to i64* 
  store volatile i64 %emsg18637, i64* %vptr16368, align 8 ; closure/env cast; i64 -> i64*
  %vptr16369 = alloca i64*, align 8 
  %envptr16367 = getelementptr inbounds i64, i64* %envptr16366, i64 2 
  store volatile i64* %envptr16367, i64** %vptr16369, align 8 ; &envptr16366[1]
 %vptr16370 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr16367, align 8 
  store volatile i64 %emsg18637, i64* %vptr16370, align 8 ; load; *envptr16367
 %vptr16371 = alloca i64, align 8 
  %_957130 = call i64 @prim_car(i64 %rvp9095) 
  store volatile i64 %_957130, i64* %vptr16371, align 8 ; call prim_car
 %vptr16372 = alloca i64, align 8 
  %rvp9091 = call i64 @prim_cdr(i64 %rvp9095) 
  store volatile i64 %rvp9091, i64* %vptr16372, align 8 ; call prim_cdr
 %vptr16373 = alloca i64, align 8 
  %n_639096 = call i64 @prim_null_63(i64 %rvp9091) 
  store volatile i64 %n_639096, i64* %vptr16373, align 8 ; call prim_null_63
  %cmpptr16377 = alloca i1, align 8  %cmp16374 = icmp eq i64 %n_639096, 15 store volatile i1 %cmp16374, i1* %cmpptr16377, align 8; false?
  br i1 %cmp16374, label %else16376, label %then16375                                ; if

then16375:
 %vptr16378 = alloca i64, align 8 
  %h9097 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9097, i64* %vptr16378, align 8 ; call prim_halt
  %vptr16384 = alloca i64*, align 8 
  %cloptr16379 = inttoptr i64 %h9097 to i64* 
  store volatile i64* %cloptr16379, i64** %vptr16384, align 8 ; closure/env cast; i64 -> i64*
  %vptr16385 = alloca i64*, align 8 
  %i0ptr16380 = getelementptr inbounds i64, i64* %cloptr16379, i64 1 
  store volatile i64* %i0ptr16380, i64** %vptr16385, align 8 ; &cloptr16379[1]
 %vptr16386 = alloca i64, align 8 
  %f16382 = load i64, i64* %i0ptr16380, align 8 
  store volatile i64 %f16382, i64* %vptr16386, align 8 ; load; *i0ptr16380
  %fptr16381 = inttoptr i64 %f16382 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16381(i64 %h9097, i64 %h9097)                       ; tail call
  ret void

else16376:
 %vptr16387 = alloca i64, align 8 
  %eGG$_951 = call i64 @prim_car(i64 %rvp9091) 
  store volatile i64 %eGG$_951, i64* %vptr16387, align 8 ; call prim_car
 %vptr16388 = alloca i64, align 8 
  %na9087 = call i64 @prim_cdr(i64 %rvp9091) 
  store volatile i64 %na9087, i64* %vptr16388, align 8 ; call prim_cdr
 %vptr16389 = alloca i64, align 8 
  %n_639092 = call i64 @prim_null_63(i64 %na9087) 
  store volatile i64 %n_639092, i64* %vptr16389, align 8 ; call prim_null_63
  %cmpptr16393 = alloca i1, align 8  %cmp16390 = icmp eq i64 %n_639092, 15 store volatile i1 %cmp16390, i1* %cmpptr16393, align 8; false?
  br i1 %cmp16390, label %else16392, label %then16391                                ; if

then16391:
 %vptr16394 = alloca i64, align 8 
  %rva9090 = add i64 0, 0 
  store volatile i64 %rva9090, i64* %vptr16394, align 8 ; quoted ()
 %vptr16395 = alloca i64, align 8 
  %rva9089 = call i64 @prim_cons(i64 %TCi$cc, i64 %rva9090) 
  store volatile i64 %rva9089, i64* %vptr16395, align 8 ; call prim_cons
 %vptr16396 = alloca i64, align 8 
  %rva9088 = call i64 @prim_cons(i64 %cont7126, i64 %rva9089) 
  store volatile i64 %rva9088, i64* %vptr16396, align 8 ; call prim_cons
  %vptr16402 = alloca i64*, align 8 
  %cloptr16397 = inttoptr i64 %TCi$cc to i64* 
  store volatile i64* %cloptr16397, i64** %vptr16402, align 8 ; closure/env cast; i64 -> i64*
  %vptr16403 = alloca i64*, align 8 
  %i0ptr16398 = getelementptr inbounds i64, i64* %cloptr16397, i64 1 
  store volatile i64* %i0ptr16398, i64** %vptr16403, align 8 ; &cloptr16397[1]
 %vptr16404 = alloca i64, align 8 
  %f16400 = load i64, i64* %i0ptr16398, align 8 
  store volatile i64 %f16400, i64* %vptr16404, align 8 ; load; *i0ptr16398
  %fptr16399 = inttoptr i64 %f16400 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16399(i64 %TCi$cc, i64 %rva9088)                    ; tail call
  ret void

else16392:
 %vptr16405 = alloca i64, align 8 
  %h9093 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9093, i64* %vptr16405, align 8 ; call prim_halt
  %vptr16411 = alloca i64*, align 8 
  %cloptr16406 = inttoptr i64 %h9093 to i64* 
  store volatile i64* %cloptr16406, i64** %vptr16411, align 8 ; closure/env cast; i64 -> i64*
  %vptr16412 = alloca i64*, align 8 
  %i0ptr16407 = getelementptr inbounds i64, i64* %cloptr16406, i64 1 
  store volatile i64* %i0ptr16407, i64** %vptr16412, align 8 ; &cloptr16406[1]
 %vptr16413 = alloca i64, align 8 
  %f16409 = load i64, i64* %i0ptr16407, align 8 
  store volatile i64 %f16409, i64* %vptr16413, align 8 ; load; *i0ptr16407
  %fptr16408 = inttoptr i64 %f16409 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16408(i64 %h9093, i64 %h9093)                       ; tail call
  ret void
}


define void @lam12242(i64 %env12243, i64 %rvp9226) {
 %vptr16416 = alloca i64, align 8 
  %envptr16414 = inttoptr i64 %env12243 to i64* 
  store volatile i64 %emsg08636, i64* %vptr16416, align 8 ; closure/env cast; i64 -> i64*
  %vptr16417 = alloca i64*, align 8 
  %envptr16415 = getelementptr inbounds i64, i64* %envptr16414, i64 3 
  store volatile i64* %envptr16415, i64** %vptr16417, align 8 ; &envptr16414[2]
 %vptr16418 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr16415, align 8 
  store volatile i64 %emsg08636, i64* %vptr16418, align 8 ; load; *envptr16415
 %vptr16421 = alloca i64, align 8 
  %envptr16419 = inttoptr i64 %env12243 to i64* 
  store volatile i64 %emsg18637, i64* %vptr16421, align 8 ; closure/env cast; i64 -> i64*
  %vptr16422 = alloca i64*, align 8 
  %envptr16420 = getelementptr inbounds i64, i64* %envptr16419, i64 2 
  store volatile i64* %envptr16420, i64** %vptr16422, align 8 ; &envptr16419[1]
 %vptr16423 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr16420, align 8 
  store volatile i64 %emsg18637, i64* %vptr16423, align 8 ; load; *envptr16420
 %vptr16424 = alloca i64, align 8 
  %cont7134 = call i64 @prim_car(i64 %rvp9226) 
  store volatile i64 %cont7134, i64* %vptr16424, align 8 ; call prim_car
 %vptr16425 = alloca i64, align 8 
  %rvp9222 = call i64 @prim_cdr(i64 %rvp9226) 
  store volatile i64 %rvp9222, i64* %vptr16425, align 8 ; call prim_cdr
 %vptr16426 = alloca i64, align 8 
  %n_639227 = call i64 @prim_null_63(i64 %rvp9222) 
  store volatile i64 %n_639227, i64* %vptr16426, align 8 ; call prim_null_63
  %cmpptr16430 = alloca i1, align 8  %cmp16427 = icmp eq i64 %n_639227, 15 store volatile i1 %cmp16427, i1* %cmpptr16430, align 8; false?
  br i1 %cmp16427, label %else16429, label %then16428                                ; if

then16428:
 %vptr16431 = alloca i64, align 8 
  %h9228 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9228, i64* %vptr16431, align 8 ; call prim_halt
  %vptr16437 = alloca i64*, align 8 
  %cloptr16432 = inttoptr i64 %h9228 to i64* 
  store volatile i64* %cloptr16432, i64** %vptr16437, align 8 ; closure/env cast; i64 -> i64*
  %vptr16438 = alloca i64*, align 8 
  %i0ptr16433 = getelementptr inbounds i64, i64* %cloptr16432, i64 1 
  store volatile i64* %i0ptr16433, i64** %vptr16438, align 8 ; &cloptr16432[1]
 %vptr16439 = alloca i64, align 8 
  %f16435 = load i64, i64* %i0ptr16433, align 8 
  store volatile i64 %f16435, i64* %vptr16439, align 8 ; load; *i0ptr16433
  %fptr16434 = inttoptr i64 %f16435 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16434(i64 %h9228, i64 %h9228)                       ; tail call
  ret void

else16429:
 %vptr16440 = alloca i64, align 8 
  %gtB$v = call i64 @prim_car(i64 %rvp9222) 
  store volatile i64 %gtB$v, i64* %vptr16440, align 8 ; call prim_car
 %vptr16441 = alloca i64, align 8 
  %rvp9218 = call i64 @prim_cdr(i64 %rvp9222) 
  store volatile i64 %rvp9218, i64* %vptr16441, align 8 ; call prim_cdr
 %vptr16442 = alloca i64, align 8 
  %n_639223 = call i64 @prim_null_63(i64 %rvp9218) 
  store volatile i64 %n_639223, i64* %vptr16442, align 8 ; call prim_null_63
  %cmpptr16446 = alloca i1, align 8  %cmp16443 = icmp eq i64 %n_639223, 15 store volatile i1 %cmp16443, i1* %cmpptr16446, align 8; false?
  br i1 %cmp16443, label %else16445, label %then16444                                ; if

then16444:
 %vptr16447 = alloca i64, align 8 
  %h9224 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9224, i64* %vptr16447, align 8 ; call prim_halt
  %vptr16453 = alloca i64*, align 8 
  %cloptr16448 = inttoptr i64 %h9224 to i64* 
  store volatile i64* %cloptr16448, i64** %vptr16453, align 8 ; closure/env cast; i64 -> i64*
  %vptr16454 = alloca i64*, align 8 
  %i0ptr16449 = getelementptr inbounds i64, i64* %cloptr16448, i64 1 
  store volatile i64* %i0ptr16449, i64** %vptr16454, align 8 ; &cloptr16448[1]
 %vptr16455 = alloca i64, align 8 
  %f16451 = load i64, i64* %i0ptr16449, align 8 
  store volatile i64 %f16451, i64* %vptr16455, align 8 ; load; *i0ptr16449
  %fptr16450 = inttoptr i64 %f16451 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16450(i64 %h9224, i64 %h9224)                       ; tail call
  ret void

else16445:
 %vptr16456 = alloca i64, align 8 
  %ebO$lst = call i64 @prim_car(i64 %rvp9218) 
  store volatile i64 %ebO$lst, i64* %vptr16456, align 8 ; call prim_car
 %vptr16457 = alloca i64, align 8 
  %na9137 = call i64 @prim_cdr(i64 %rvp9218) 
  store volatile i64 %na9137, i64* %vptr16457, align 8 ; call prim_cdr
 %vptr16458 = alloca i64, align 8 
  %n_639219 = call i64 @prim_null_63(i64 %na9137) 
  store volatile i64 %n_639219, i64* %vptr16458, align 8 ; call prim_null_63
  %cmpptr16462 = alloca i1, align 8  %cmp16459 = icmp eq i64 %n_639219, 15 store volatile i1 %cmp16459, i1* %cmpptr16462, align 8; false?
  br i1 %cmp16459, label %else16461, label %then16460                                ; if

then16460:
 %vptr16463 = alloca i64, align 8 
  %arg7653 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg7653, i64* %vptr16463, align 8 ; quoted int
 %vptr16464 = alloca i64, align 8 
  %qgT$lst = call i64 @prim_make_45vector(i64 %arg7653, i64 %ebO$lst) 
  store volatile i64 %qgT$lst, i64* %vptr16464, align 8 ; call prim_make_45vector
  %vptr16470 = alloca i64*, align 8 
  %cloptr16465 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr16465, i64** %vptr16470, align 8 ; malloc
  %vptr16471 = alloca i64*, align 8 
  %eptr16467 = getelementptr inbounds i64, i64* %cloptr16465, i64 2 
  store volatile i64* %eptr16467, i64** %vptr16471, align 8 ; &eptr16467[1]
  %vptr16472 = alloca i64*, align 8 
  %eptr16468 = getelementptr inbounds i64, i64* %cloptr16465, i64 3 
  store volatile i64* %eptr16468, i64** %vptr16472, align 8 ; &eptr16468[2]
  store i64 %emsg18637, i64* %eptr16467                                              ; *eptr16467 = %emsg18637
  store i64 %emsg08636, i64* %eptr16468                                              ; *eptr16468 = %emsg08636
  %vptr16473 = alloca i64*, align 8 
  %eptr16466 = getelementptr inbounds i64, i64* %cloptr16465, i64 1 
  store volatile i64* %eptr16466, i64** %vptr16473, align 8 ; &cloptr16465[1]
 %vptr16474 = alloca i64, align 8 
  %f16469 = ptrtoint void(i64,i64)* @lam12239 to i64 
  store volatile i64 %f16469, i64* %vptr16474, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f16469, i64* %eptr16466                                                 ; store fptr
 %vptr16475 = alloca i64, align 8 
  %arg7656 = ptrtoint i64* %cloptr16465 to i64 
  store volatile i64 %arg7656, i64* %vptr16475, align 8 ; closure cast; i64* -> i64
  %vptr16484 = alloca i64*, align 8 
  %cloptr16476 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr16476, i64** %vptr16484, align 8 ; malloc
  %vptr16485 = alloca i64*, align 8 
  %eptr16478 = getelementptr inbounds i64, i64* %cloptr16476, i64 2 
  store volatile i64* %eptr16478, i64** %vptr16485, align 8 ; &eptr16478[1]
  %vptr16486 = alloca i64*, align 8 
  %eptr16479 = getelementptr inbounds i64, i64* %cloptr16476, i64 3 
  store volatile i64* %eptr16479, i64** %vptr16486, align 8 ; &eptr16479[2]
  %vptr16487 = alloca i64*, align 8 
  %eptr16480 = getelementptr inbounds i64, i64* %cloptr16476, i64 4 
  store volatile i64* %eptr16480, i64** %vptr16487, align 8 ; &eptr16480[3]
  %vptr16488 = alloca i64*, align 8 
  %eptr16481 = getelementptr inbounds i64, i64* %cloptr16476, i64 5 
  store volatile i64* %eptr16481, i64** %vptr16488, align 8 ; &eptr16481[4]
  %vptr16489 = alloca i64*, align 8 
  %eptr16482 = getelementptr inbounds i64, i64* %cloptr16476, i64 6 
  store volatile i64* %eptr16482, i64** %vptr16489, align 8 ; &eptr16482[5]
  store i64 %emsg18637, i64* %eptr16478                                              ; *eptr16478 = %emsg18637
  store i64 %qgT$lst, i64* %eptr16479                                                ; *eptr16479 = %qgT$lst
  store i64 %gtB$v, i64* %eptr16480                                                  ; *eptr16480 = %gtB$v
  store i64 %cont7134, i64* %eptr16481                                               ; *eptr16481 = %cont7134
  store i64 %emsg08636, i64* %eptr16482                                              ; *eptr16482 = %emsg08636
  %vptr16490 = alloca i64*, align 8 
  %eptr16477 = getelementptr inbounds i64, i64* %cloptr16476, i64 1 
  store volatile i64* %eptr16477, i64** %vptr16490, align 8 ; &cloptr16476[1]
 %vptr16491 = alloca i64, align 8 
  %f16483 = ptrtoint void(i64,i64)* @lam12236 to i64 
  store volatile i64 %f16483, i64* %vptr16491, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f16483, i64* %eptr16477                                                 ; store fptr
 %vptr16492 = alloca i64, align 8 
  %arg7655 = ptrtoint i64* %cloptr16476 to i64 
  store volatile i64 %arg7655, i64* %vptr16492, align 8 ; closure cast; i64* -> i64
  %vptr16501 = alloca i64*, align 8 
  %cloptr16493 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr16493, i64** %vptr16501, align 8 ; malloc
  %vptr16502 = alloca i64*, align 8 
  %eptr16495 = getelementptr inbounds i64, i64* %cloptr16493, i64 2 
  store volatile i64* %eptr16495, i64** %vptr16502, align 8 ; &eptr16495[1]
  %vptr16503 = alloca i64*, align 8 
  %eptr16496 = getelementptr inbounds i64, i64* %cloptr16493, i64 3 
  store volatile i64* %eptr16496, i64** %vptr16503, align 8 ; &eptr16496[2]
  %vptr16504 = alloca i64*, align 8 
  %eptr16497 = getelementptr inbounds i64, i64* %cloptr16493, i64 4 
  store volatile i64* %eptr16497, i64** %vptr16504, align 8 ; &eptr16497[3]
  %vptr16505 = alloca i64*, align 8 
  %eptr16498 = getelementptr inbounds i64, i64* %cloptr16493, i64 5 
  store volatile i64* %eptr16498, i64** %vptr16505, align 8 ; &eptr16498[4]
  %vptr16506 = alloca i64*, align 8 
  %eptr16499 = getelementptr inbounds i64, i64* %cloptr16493, i64 6 
  store volatile i64* %eptr16499, i64** %vptr16506, align 8 ; &eptr16499[5]
  store i64 %emsg18637, i64* %eptr16495                                              ; *eptr16495 = %emsg18637
  store i64 %qgT$lst, i64* %eptr16496                                                ; *eptr16496 = %qgT$lst
  store i64 %gtB$v, i64* %eptr16497                                                  ; *eptr16497 = %gtB$v
  store i64 %cont7134, i64* %eptr16498                                               ; *eptr16498 = %cont7134
  store i64 %emsg08636, i64* %eptr16499                                              ; *eptr16499 = %emsg08636
  %vptr16507 = alloca i64*, align 8 
  %eptr16494 = getelementptr inbounds i64, i64* %cloptr16493, i64 1 
  store volatile i64* %eptr16494, i64** %vptr16507, align 8 ; &cloptr16493[1]
 %vptr16508 = alloca i64, align 8 
  %f16500 = ptrtoint void(i64,i64)* @lam12219 to i64 
  store volatile i64 %f16500, i64* %vptr16508, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f16500, i64* %eptr16494                                                 ; store fptr
 %vptr16509 = alloca i64, align 8 
  %arg7654 = ptrtoint i64* %cloptr16493 to i64 
  store volatile i64 %arg7654, i64* %vptr16509, align 8 ; closure cast; i64* -> i64
 %vptr16510 = alloca i64, align 8 
  %rva9217 = add i64 0, 0 
  store volatile i64 %rva9217, i64* %vptr16510, align 8 ; quoted ()
 %vptr16511 = alloca i64, align 8 
  %rva9216 = call i64 @prim_cons(i64 %arg7654, i64 %rva9217) 
  store volatile i64 %rva9216, i64* %vptr16511, align 8 ; call prim_cons
 %vptr16512 = alloca i64, align 8 
  %rva9215 = call i64 @prim_cons(i64 %arg7655, i64 %rva9216) 
  store volatile i64 %rva9215, i64* %vptr16512, align 8 ; call prim_cons
  %vptr16518 = alloca i64*, align 8 
  %cloptr16513 = inttoptr i64 %arg7656 to i64* 
  store volatile i64* %cloptr16513, i64** %vptr16518, align 8 ; closure/env cast; i64 -> i64*
  %vptr16519 = alloca i64*, align 8 
  %i0ptr16514 = getelementptr inbounds i64, i64* %cloptr16513, i64 1 
  store volatile i64* %i0ptr16514, i64** %vptr16519, align 8 ; &cloptr16513[1]
 %vptr16520 = alloca i64, align 8 
  %f16516 = load i64, i64* %i0ptr16514, align 8 
  store volatile i64 %f16516, i64* %vptr16520, align 8 ; load; *i0ptr16514
  %fptr16515 = inttoptr i64 %f16516 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16515(i64 %arg7656, i64 %rva9215)                   ; tail call
  ret void

else16461:
 %vptr16521 = alloca i64, align 8 
  %h9220 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9220, i64* %vptr16521, align 8 ; call prim_halt
  %vptr16527 = alloca i64*, align 8 
  %cloptr16522 = inttoptr i64 %h9220 to i64* 
  store volatile i64* %cloptr16522, i64** %vptr16527, align 8 ; closure/env cast; i64 -> i64*
  %vptr16528 = alloca i64*, align 8 
  %i0ptr16523 = getelementptr inbounds i64, i64* %cloptr16522, i64 1 
  store volatile i64* %i0ptr16523, i64** %vptr16528, align 8 ; &cloptr16522[1]
 %vptr16529 = alloca i64, align 8 
  %f16525 = load i64, i64* %i0ptr16523, align 8 
  store volatile i64 %f16525, i64* %vptr16529, align 8 ; load; *i0ptr16523
  %fptr16524 = inttoptr i64 %f16525 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16524(i64 %h9220, i64 %h9220)                       ; tail call
  ret void
}


define void @lam12239(i64 %env12240, i64 %rvp9147) {
 %vptr16532 = alloca i64, align 8 
  %envptr16530 = inttoptr i64 %env12240 to i64* 
  store volatile i64 %emsg08636, i64* %vptr16532, align 8 ; closure/env cast; i64 -> i64*
  %vptr16533 = alloca i64*, align 8 
  %envptr16531 = getelementptr inbounds i64, i64* %envptr16530, i64 3 
  store volatile i64* %envptr16531, i64** %vptr16533, align 8 ; &envptr16530[2]
 %vptr16534 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr16531, align 8 
  store volatile i64 %emsg08636, i64* %vptr16534, align 8 ; load; *envptr16531
 %vptr16537 = alloca i64, align 8 
  %envptr16535 = inttoptr i64 %env12240 to i64* 
  store volatile i64 %emsg18637, i64* %vptr16537, align 8 ; closure/env cast; i64 -> i64*
  %vptr16538 = alloca i64*, align 8 
  %envptr16536 = getelementptr inbounds i64, i64* %envptr16535, i64 2 
  store volatile i64* %envptr16536, i64** %vptr16538, align 8 ; &envptr16535[1]
 %vptr16539 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr16536, align 8 
  store volatile i64 %emsg18637, i64* %vptr16539, align 8 ; load; *envptr16536
 %vptr16540 = alloca i64, align 8 
  %cont7139 = call i64 @prim_car(i64 %rvp9147) 
  store volatile i64 %cont7139, i64* %vptr16540, align 8 ; call prim_car
 %vptr16541 = alloca i64, align 8 
  %rvp9143 = call i64 @prim_cdr(i64 %rvp9147) 
  store volatile i64 %rvp9143, i64* %vptr16541, align 8 ; call prim_cdr
 %vptr16542 = alloca i64, align 8 
  %n_639148 = call i64 @prim_null_63(i64 %rvp9143) 
  store volatile i64 %n_639148, i64* %vptr16542, align 8 ; call prim_null_63
  %cmpptr16546 = alloca i1, align 8  %cmp16543 = icmp eq i64 %n_639148, 15 store volatile i1 %cmp16543, i1* %cmpptr16546, align 8; false?
  br i1 %cmp16543, label %else16545, label %then16544                                ; if

then16544:
 %vptr16547 = alloca i64, align 8 
  %h9149 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9149, i64* %vptr16547, align 8 ; call prim_halt
  %vptr16553 = alloca i64*, align 8 
  %cloptr16548 = inttoptr i64 %h9149 to i64* 
  store volatile i64* %cloptr16548, i64** %vptr16553, align 8 ; closure/env cast; i64 -> i64*
  %vptr16554 = alloca i64*, align 8 
  %i0ptr16549 = getelementptr inbounds i64, i64* %cloptr16548, i64 1 
  store volatile i64* %i0ptr16549, i64** %vptr16554, align 8 ; &cloptr16548[1]
 %vptr16555 = alloca i64, align 8 
  %f16551 = load i64, i64* %i0ptr16549, align 8 
  store volatile i64 %f16551, i64* %vptr16555, align 8 ; load; *i0ptr16549
  %fptr16550 = inttoptr i64 %f16551 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16550(i64 %h9149, i64 %h9149)                       ; tail call
  ret void

else16545:
 %vptr16556 = alloca i64, align 8 
  %gRZ$u = call i64 @prim_car(i64 %rvp9143) 
  store volatile i64 %gRZ$u, i64* %vptr16556, align 8 ; call prim_car
 %vptr16557 = alloca i64, align 8 
  %na9139 = call i64 @prim_cdr(i64 %rvp9143) 
  store volatile i64 %na9139, i64* %vptr16557, align 8 ; call prim_cdr
 %vptr16558 = alloca i64, align 8 
  %n_639144 = call i64 @prim_null_63(i64 %na9139) 
  store volatile i64 %n_639144, i64* %vptr16558, align 8 ; call prim_null_63
  %cmpptr16562 = alloca i1, align 8  %cmp16559 = icmp eq i64 %n_639144, 15 store volatile i1 %cmp16559, i1* %cmpptr16562, align 8; false?
  br i1 %cmp16559, label %else16561, label %then16560                                ; if

then16560:
 %vptr16563 = alloca i64, align 8 
  %rva9142 = add i64 0, 0 
  store volatile i64 %rva9142, i64* %vptr16563, align 8 ; quoted ()
 %vptr16564 = alloca i64, align 8 
  %rva9141 = call i64 @prim_cons(i64 %gRZ$u, i64 %rva9142) 
  store volatile i64 %rva9141, i64* %vptr16564, align 8 ; call prim_cons
 %vptr16565 = alloca i64, align 8 
  %rva9140 = call i64 @prim_cons(i64 %cont7139, i64 %rva9141) 
  store volatile i64 %rva9140, i64* %vptr16565, align 8 ; call prim_cons
  %vptr16571 = alloca i64*, align 8 
  %cloptr16566 = inttoptr i64 %gRZ$u to i64* 
  store volatile i64* %cloptr16566, i64** %vptr16571, align 8 ; closure/env cast; i64 -> i64*
  %vptr16572 = alloca i64*, align 8 
  %i0ptr16567 = getelementptr inbounds i64, i64* %cloptr16566, i64 1 
  store volatile i64* %i0ptr16567, i64** %vptr16572, align 8 ; &cloptr16566[1]
 %vptr16573 = alloca i64, align 8 
  %f16569 = load i64, i64* %i0ptr16567, align 8 
  store volatile i64 %f16569, i64* %vptr16573, align 8 ; load; *i0ptr16567
  %fptr16568 = inttoptr i64 %f16569 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16568(i64 %gRZ$u, i64 %rva9140)                     ; tail call
  ret void

else16561:
 %vptr16574 = alloca i64, align 8 
  %h9145 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9145, i64* %vptr16574, align 8 ; call prim_halt
  %vptr16580 = alloca i64*, align 8 
  %cloptr16575 = inttoptr i64 %h9145 to i64* 
  store volatile i64* %cloptr16575, i64** %vptr16580, align 8 ; closure/env cast; i64 -> i64*
  %vptr16581 = alloca i64*, align 8 
  %i0ptr16576 = getelementptr inbounds i64, i64* %cloptr16575, i64 1 
  store volatile i64* %i0ptr16576, i64** %vptr16581, align 8 ; &cloptr16575[1]
 %vptr16582 = alloca i64, align 8 
  %f16578 = load i64, i64* %i0ptr16576, align 8 
  store volatile i64 %f16578, i64* %vptr16582, align 8 ; load; *i0ptr16576
  %fptr16577 = inttoptr i64 %f16578 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16577(i64 %h9145, i64 %h9145)                       ; tail call
  ret void
}


define void @lam12236(i64 %env12237, i64 %rvp9179) {
 %vptr16585 = alloca i64, align 8 
  %envptr16583 = inttoptr i64 %env12237 to i64* 
  store volatile i64 %emsg08636, i64* %vptr16585, align 8 ; closure/env cast; i64 -> i64*
  %vptr16586 = alloca i64*, align 8 
  %envptr16584 = getelementptr inbounds i64, i64* %envptr16583, i64 6 
  store volatile i64* %envptr16584, i64** %vptr16586, align 8 ; &envptr16583[5]
 %vptr16587 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr16584, align 8 
  store volatile i64 %emsg08636, i64* %vptr16587, align 8 ; load; *envptr16584
 %vptr16590 = alloca i64, align 8 
  %envptr16588 = inttoptr i64 %env12237 to i64* 
  store volatile i64 %cont7134, i64* %vptr16590, align 8 ; closure/env cast; i64 -> i64*
  %vptr16591 = alloca i64*, align 8 
  %envptr16589 = getelementptr inbounds i64, i64* %envptr16588, i64 5 
  store volatile i64* %envptr16589, i64** %vptr16591, align 8 ; &envptr16588[4]
 %vptr16592 = alloca i64, align 8 
  %cont7134 = load i64, i64* %envptr16589, align 8 
  store volatile i64 %cont7134, i64* %vptr16592, align 8 ; load; *envptr16589
 %vptr16595 = alloca i64, align 8 
  %envptr16593 = inttoptr i64 %env12237 to i64* 
  store volatile i64 %gtB$v, i64* %vptr16595, align 8 ; closure/env cast; i64 -> i64*
  %vptr16596 = alloca i64*, align 8 
  %envptr16594 = getelementptr inbounds i64, i64* %envptr16593, i64 4 
  store volatile i64* %envptr16594, i64** %vptr16596, align 8 ; &envptr16593[3]
 %vptr16597 = alloca i64, align 8 
  %gtB$v = load i64, i64* %envptr16594, align 8 
  store volatile i64 %gtB$v, i64* %vptr16597, align 8 ; load; *envptr16594
 %vptr16600 = alloca i64, align 8 
  %envptr16598 = inttoptr i64 %env12237 to i64* 
  store volatile i64 %qgT$lst, i64* %vptr16600, align 8 ; closure/env cast; i64 -> i64*
  %vptr16601 = alloca i64*, align 8 
  %envptr16599 = getelementptr inbounds i64, i64* %envptr16598, i64 3 
  store volatile i64* %envptr16599, i64** %vptr16601, align 8 ; &envptr16598[2]
 %vptr16602 = alloca i64, align 8 
  %qgT$lst = load i64, i64* %envptr16599, align 8 
  store volatile i64 %qgT$lst, i64* %vptr16602, align 8 ; load; *envptr16599
 %vptr16605 = alloca i64, align 8 
  %envptr16603 = inttoptr i64 %env12237 to i64* 
  store volatile i64 %emsg18637, i64* %vptr16605, align 8 ; closure/env cast; i64 -> i64*
  %vptr16606 = alloca i64*, align 8 
  %envptr16604 = getelementptr inbounds i64, i64* %envptr16603, i64 2 
  store volatile i64* %envptr16604, i64** %vptr16606, align 8 ; &envptr16603[1]
 %vptr16607 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr16604, align 8 
  store volatile i64 %emsg18637, i64* %vptr16607, align 8 ; load; *envptr16604
 %vptr16608 = alloca i64, align 8 
  %_957135 = call i64 @prim_car(i64 %rvp9179) 
  store volatile i64 %_957135, i64* %vptr16608, align 8 ; call prim_car
 %vptr16609 = alloca i64, align 8 
  %rvp9175 = call i64 @prim_cdr(i64 %rvp9179) 
  store volatile i64 %rvp9175, i64* %vptr16609, align 8 ; call prim_cdr
 %vptr16610 = alloca i64, align 8 
  %n_639180 = call i64 @prim_null_63(i64 %rvp9175) 
  store volatile i64 %n_639180, i64* %vptr16610, align 8 ; call prim_null_63
  %cmpptr16614 = alloca i1, align 8  %cmp16611 = icmp eq i64 %n_639180, 15 store volatile i1 %cmp16611, i1* %cmpptr16614, align 8; false?
  br i1 %cmp16611, label %else16613, label %then16612                                ; if

then16612:
 %vptr16615 = alloca i64, align 8 
  %h9181 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9181, i64* %vptr16615, align 8 ; call prim_halt
  %vptr16621 = alloca i64*, align 8 
  %cloptr16616 = inttoptr i64 %h9181 to i64* 
  store volatile i64* %cloptr16616, i64** %vptr16621, align 8 ; closure/env cast; i64 -> i64*
  %vptr16622 = alloca i64*, align 8 
  %i0ptr16617 = getelementptr inbounds i64, i64* %cloptr16616, i64 1 
  store volatile i64* %i0ptr16617, i64** %vptr16622, align 8 ; &cloptr16616[1]
 %vptr16623 = alloca i64, align 8 
  %f16619 = load i64, i64* %i0ptr16617, align 8 
  store volatile i64 %f16619, i64* %vptr16623, align 8 ; load; *i0ptr16617
  %fptr16618 = inttoptr i64 %f16619 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16618(i64 %h9181, i64 %h9181)                       ; tail call
  ret void

else16613:
 %vptr16624 = alloca i64, align 8 
  %w2t$cc = call i64 @prim_car(i64 %rvp9175) 
  store volatile i64 %w2t$cc, i64* %vptr16624, align 8 ; call prim_car
 %vptr16625 = alloca i64, align 8 
  %na9152 = call i64 @prim_cdr(i64 %rvp9175) 
  store volatile i64 %na9152, i64* %vptr16625, align 8 ; call prim_cdr
 %vptr16626 = alloca i64, align 8 
  %n_639176 = call i64 @prim_null_63(i64 %na9152) 
  store volatile i64 %n_639176, i64* %vptr16626, align 8 ; call prim_null_63
  %cmpptr16630 = alloca i1, align 8  %cmp16627 = icmp eq i64 %n_639176, 15 store volatile i1 %cmp16627, i1* %cmpptr16630, align 8; false?
  br i1 %cmp16627, label %else16629, label %then16628                                ; if

then16628:
 %vptr16631 = alloca i64, align 8 
  %arg7660 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7660, i64* %vptr16631, align 8 ; quoted int
 %vptr16632 = alloca i64, align 8 
  %a6977 = call i64 @prim_vector_45ref(i64 %qgT$lst, i64 %arg7660) 
  store volatile i64 %a6977, i64* %vptr16632, align 8 ; call prim_vector_45ref
 %vptr16633 = alloca i64, align 8 
  %a6978 = call i64 @prim_null_63(i64 %a6977) 
  store volatile i64 %a6978, i64* %vptr16633, align 8 ; call prim_null_63
  %cmpptr16637 = alloca i1, align 8  %cmp16634 = icmp eq i64 %a6978, 15 store volatile i1 %cmp16634, i1* %cmpptr16637, align 8; false?
  br i1 %cmp16634, label %else16636, label %then16635                                ; if

then16635:
 %vptr16638 = alloca i64, align 8 
  %arg7664 = add i64 0, 0 
  store volatile i64 %arg7664, i64* %vptr16638, align 8 ; quoted ()
 %vptr16639 = alloca i64, align 8 
  %arg7663 = call i64 @const_init_false() 
  store volatile i64 %arg7663, i64* %vptr16639, align 8 ; quoted #f
 %vptr16640 = alloca i64, align 8 
  %rva9155 = add i64 0, 0 
  store volatile i64 %rva9155, i64* %vptr16640, align 8 ; quoted ()
 %vptr16641 = alloca i64, align 8 
  %rva9154 = call i64 @prim_cons(i64 %arg7663, i64 %rva9155) 
  store volatile i64 %rva9154, i64* %vptr16641, align 8 ; call prim_cons
 %vptr16642 = alloca i64, align 8 
  %rva9153 = call i64 @prim_cons(i64 %arg7664, i64 %rva9154) 
  store volatile i64 %rva9153, i64* %vptr16642, align 8 ; call prim_cons
  %vptr16648 = alloca i64*, align 8 
  %cloptr16643 = inttoptr i64 %cont7134 to i64* 
  store volatile i64* %cloptr16643, i64** %vptr16648, align 8 ; closure/env cast; i64 -> i64*
  %vptr16649 = alloca i64*, align 8 
  %i0ptr16644 = getelementptr inbounds i64, i64* %cloptr16643, i64 1 
  store volatile i64* %i0ptr16644, i64** %vptr16649, align 8 ; &cloptr16643[1]
 %vptr16650 = alloca i64, align 8 
  %f16646 = load i64, i64* %i0ptr16644, align 8 
  store volatile i64 %f16646, i64* %vptr16650, align 8 ; load; *i0ptr16644
  %fptr16645 = inttoptr i64 %f16646 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16645(i64 %cont7134, i64 %rva9153)                  ; tail call
  ret void

else16636:
 %vptr16651 = alloca i64, align 8 
  %arg7666 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7666, i64* %vptr16651, align 8 ; quoted int
 %vptr16652 = alloca i64, align 8 
  %a6979 = call i64 @prim_vector_45ref(i64 %qgT$lst, i64 %arg7666) 
  store volatile i64 %a6979, i64* %vptr16652, align 8 ; call prim_vector_45ref
 %vptr16653 = alloca i64, align 8 
  %a6980 = call i64 @prim_car(i64 %a6979) 
  store volatile i64 %a6980, i64* %vptr16653, align 8 ; call prim_car
 %vptr16654 = alloca i64, align 8 
  %a6981 = call i64 @prim_eqv_63(i64 %a6980, i64 %gtB$v) 
  store volatile i64 %a6981, i64* %vptr16654, align 8 ; call prim_eqv_63
  %cmpptr16658 = alloca i1, align 8  %cmp16655 = icmp eq i64 %a6981, 15 store volatile i1 %cmp16655, i1* %cmpptr16658, align 8; false?
  br i1 %cmp16655, label %else16657, label %then16656                                ; if

then16656:
 %vptr16659 = alloca i64, align 8 
  %arg7671 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7671, i64* %vptr16659, align 8 ; quoted int
 %vptr16660 = alloca i64, align 8 
  %retprim7136 = call i64 @prim_vector_45ref(i64 %qgT$lst, i64 %arg7671) 
  store volatile i64 %retprim7136, i64* %vptr16660, align 8 ; call prim_vector_45ref
 %vptr16661 = alloca i64, align 8 
  %arg7674 = add i64 0, 0 
  store volatile i64 %arg7674, i64* %vptr16661, align 8 ; quoted ()
 %vptr16662 = alloca i64, align 8 
  %rva9158 = add i64 0, 0 
  store volatile i64 %rva9158, i64* %vptr16662, align 8 ; quoted ()
 %vptr16663 = alloca i64, align 8 
  %rva9157 = call i64 @prim_cons(i64 %retprim7136, i64 %rva9158) 
  store volatile i64 %rva9157, i64* %vptr16663, align 8 ; call prim_cons
 %vptr16664 = alloca i64, align 8 
  %rva9156 = call i64 @prim_cons(i64 %arg7674, i64 %rva9157) 
  store volatile i64 %rva9156, i64* %vptr16664, align 8 ; call prim_cons
  %vptr16670 = alloca i64*, align 8 
  %cloptr16665 = inttoptr i64 %cont7134 to i64* 
  store volatile i64* %cloptr16665, i64** %vptr16670, align 8 ; closure/env cast; i64 -> i64*
  %vptr16671 = alloca i64*, align 8 
  %i0ptr16666 = getelementptr inbounds i64, i64* %cloptr16665, i64 1 
  store volatile i64* %i0ptr16666, i64** %vptr16671, align 8 ; &cloptr16665[1]
 %vptr16672 = alloca i64, align 8 
  %f16668 = load i64, i64* %i0ptr16666, align 8 
  store volatile i64 %f16668, i64* %vptr16672, align 8 ; load; *i0ptr16666
  %fptr16667 = inttoptr i64 %f16668 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16667(i64 %cont7134, i64 %rva9156)                  ; tail call
  ret void

else16657:
 %vptr16673 = alloca i64, align 8 
  %arg7676 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7676, i64* %vptr16673, align 8 ; quoted int
 %vptr16674 = alloca i64, align 8 
  %a6982 = call i64 @prim_vector_45ref(i64 %qgT$lst, i64 %arg7676) 
  store volatile i64 %a6982, i64* %vptr16674, align 8 ; call prim_vector_45ref
 %vptr16675 = alloca i64, align 8 
  %a6983 = call i64 @prim_cdr(i64 %a6982) 
  store volatile i64 %a6983, i64* %vptr16675, align 8 ; call prim_cdr
 %vptr16676 = alloca i64, align 8 
  %arg7680 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7680, i64* %vptr16676, align 8 ; quoted int
 %vptr16677 = alloca i64, align 8 
  %retprim7138 = call i64 @prim_vector_45set_33(i64 %qgT$lst, i64 %arg7680, i64 %a6983) 
  store volatile i64 %retprim7138, i64* %vptr16677, align 8 ; call prim_vector_45set_33
  %vptr16685 = alloca i64*, align 8 
  %cloptr16678 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr16678, i64** %vptr16685, align 8 ; malloc
  %vptr16686 = alloca i64*, align 8 
  %eptr16680 = getelementptr inbounds i64, i64* %cloptr16678, i64 2 
  store volatile i64* %eptr16680, i64** %vptr16686, align 8 ; &eptr16680[1]
  %vptr16687 = alloca i64*, align 8 
  %eptr16681 = getelementptr inbounds i64, i64* %cloptr16678, i64 3 
  store volatile i64* %eptr16681, i64** %vptr16687, align 8 ; &eptr16681[2]
  %vptr16688 = alloca i64*, align 8 
  %eptr16682 = getelementptr inbounds i64, i64* %cloptr16678, i64 4 
  store volatile i64* %eptr16682, i64** %vptr16688, align 8 ; &eptr16682[3]
  %vptr16689 = alloca i64*, align 8 
  %eptr16683 = getelementptr inbounds i64, i64* %cloptr16678, i64 5 
  store volatile i64* %eptr16683, i64** %vptr16689, align 8 ; &eptr16683[4]
  store i64 %w2t$cc, i64* %eptr16680                                                 ; *eptr16680 = %w2t$cc
  store i64 %emsg18637, i64* %eptr16681                                              ; *eptr16681 = %emsg18637
  store i64 %cont7134, i64* %eptr16682                                               ; *eptr16682 = %cont7134
  store i64 %emsg08636, i64* %eptr16683                                              ; *eptr16683 = %emsg08636
  %vptr16690 = alloca i64*, align 8 
  %eptr16679 = getelementptr inbounds i64, i64* %cloptr16678, i64 1 
  store volatile i64* %eptr16679, i64** %vptr16690, align 8 ; &cloptr16678[1]
 %vptr16691 = alloca i64, align 8 
  %f16684 = ptrtoint void(i64,i64)* @lam12230 to i64 
  store volatile i64 %f16684, i64* %vptr16691, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f16684, i64* %eptr16679                                                 ; store fptr
 %vptr16692 = alloca i64, align 8 
  %arg7684 = ptrtoint i64* %cloptr16678 to i64 
  store volatile i64 %arg7684, i64* %vptr16692, align 8 ; closure cast; i64* -> i64
 %vptr16693 = alloca i64, align 8 
  %arg7683 = add i64 0, 0 
  store volatile i64 %arg7683, i64* %vptr16693, align 8 ; quoted ()
 %vptr16694 = alloca i64, align 8 
  %rva9174 = add i64 0, 0 
  store volatile i64 %rva9174, i64* %vptr16694, align 8 ; quoted ()
 %vptr16695 = alloca i64, align 8 
  %rva9173 = call i64 @prim_cons(i64 %retprim7138, i64 %rva9174) 
  store volatile i64 %rva9173, i64* %vptr16695, align 8 ; call prim_cons
 %vptr16696 = alloca i64, align 8 
  %rva9172 = call i64 @prim_cons(i64 %arg7683, i64 %rva9173) 
  store volatile i64 %rva9172, i64* %vptr16696, align 8 ; call prim_cons
  %vptr16702 = alloca i64*, align 8 
  %cloptr16697 = inttoptr i64 %arg7684 to i64* 
  store volatile i64* %cloptr16697, i64** %vptr16702, align 8 ; closure/env cast; i64 -> i64*
  %vptr16703 = alloca i64*, align 8 
  %i0ptr16698 = getelementptr inbounds i64, i64* %cloptr16697, i64 1 
  store volatile i64* %i0ptr16698, i64** %vptr16703, align 8 ; &cloptr16697[1]
 %vptr16704 = alloca i64, align 8 
  %f16700 = load i64, i64* %i0ptr16698, align 8 
  store volatile i64 %f16700, i64* %vptr16704, align 8 ; load; *i0ptr16698
  %fptr16699 = inttoptr i64 %f16700 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16699(i64 %arg7684, i64 %rva9172)                   ; tail call
  ret void

else16629:
 %vptr16705 = alloca i64, align 8 
  %h9177 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9177, i64* %vptr16705, align 8 ; call prim_halt
  %vptr16711 = alloca i64*, align 8 
  %cloptr16706 = inttoptr i64 %h9177 to i64* 
  store volatile i64* %cloptr16706, i64** %vptr16711, align 8 ; closure/env cast; i64 -> i64*
  %vptr16712 = alloca i64*, align 8 
  %i0ptr16707 = getelementptr inbounds i64, i64* %cloptr16706, i64 1 
  store volatile i64* %i0ptr16707, i64** %vptr16712, align 8 ; &cloptr16706[1]
 %vptr16713 = alloca i64, align 8 
  %f16709 = load i64, i64* %i0ptr16707, align 8 
  store volatile i64 %f16709, i64* %vptr16713, align 8 ; load; *i0ptr16707
  %fptr16708 = inttoptr i64 %f16709 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16708(i64 %h9177, i64 %h9177)                       ; tail call
  ret void
}


define void @lam12230(i64 %env12231, i64 %rvp9168) {
 %vptr16716 = alloca i64, align 8 
  %envptr16714 = inttoptr i64 %env12231 to i64* 
  store volatile i64 %emsg08636, i64* %vptr16716, align 8 ; closure/env cast; i64 -> i64*
  %vptr16717 = alloca i64*, align 8 
  %envptr16715 = getelementptr inbounds i64, i64* %envptr16714, i64 5 
  store volatile i64* %envptr16715, i64** %vptr16717, align 8 ; &envptr16714[4]
 %vptr16718 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr16715, align 8 
  store volatile i64 %emsg08636, i64* %vptr16718, align 8 ; load; *envptr16715
 %vptr16721 = alloca i64, align 8 
  %envptr16719 = inttoptr i64 %env12231 to i64* 
  store volatile i64 %cont7134, i64* %vptr16721, align 8 ; closure/env cast; i64 -> i64*
  %vptr16722 = alloca i64*, align 8 
  %envptr16720 = getelementptr inbounds i64, i64* %envptr16719, i64 4 
  store volatile i64* %envptr16720, i64** %vptr16722, align 8 ; &envptr16719[3]
 %vptr16723 = alloca i64, align 8 
  %cont7134 = load i64, i64* %envptr16720, align 8 
  store volatile i64 %cont7134, i64* %vptr16723, align 8 ; load; *envptr16720
 %vptr16726 = alloca i64, align 8 
  %envptr16724 = inttoptr i64 %env12231 to i64* 
  store volatile i64 %emsg18637, i64* %vptr16726, align 8 ; closure/env cast; i64 -> i64*
  %vptr16727 = alloca i64*, align 8 
  %envptr16725 = getelementptr inbounds i64, i64* %envptr16724, i64 3 
  store volatile i64* %envptr16725, i64** %vptr16727, align 8 ; &envptr16724[2]
 %vptr16728 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr16725, align 8 
  store volatile i64 %emsg18637, i64* %vptr16728, align 8 ; load; *envptr16725
 %vptr16731 = alloca i64, align 8 
  %envptr16729 = inttoptr i64 %env12231 to i64* 
  store volatile i64 %w2t$cc, i64* %vptr16731, align 8 ; closure/env cast; i64 -> i64*
  %vptr16732 = alloca i64*, align 8 
  %envptr16730 = getelementptr inbounds i64, i64* %envptr16729, i64 2 
  store volatile i64* %envptr16730, i64** %vptr16732, align 8 ; &envptr16729[1]
 %vptr16733 = alloca i64, align 8 
  %w2t$cc = load i64, i64* %envptr16730, align 8 
  store volatile i64 %w2t$cc, i64* %vptr16733, align 8 ; load; *envptr16730
 %vptr16734 = alloca i64, align 8 
  %_957137 = call i64 @prim_car(i64 %rvp9168) 
  store volatile i64 %_957137, i64* %vptr16734, align 8 ; call prim_car
 %vptr16735 = alloca i64, align 8 
  %rvp9164 = call i64 @prim_cdr(i64 %rvp9168) 
  store volatile i64 %rvp9164, i64* %vptr16735, align 8 ; call prim_cdr
 %vptr16736 = alloca i64, align 8 
  %n_639169 = call i64 @prim_null_63(i64 %rvp9164) 
  store volatile i64 %n_639169, i64* %vptr16736, align 8 ; call prim_null_63
  %cmpptr16740 = alloca i1, align 8  %cmp16737 = icmp eq i64 %n_639169, 15 store volatile i1 %cmp16737, i1* %cmpptr16740, align 8; false?
  br i1 %cmp16737, label %else16739, label %then16738                                ; if

then16738:
 %vptr16741 = alloca i64, align 8 
  %h9170 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9170, i64* %vptr16741, align 8 ; call prim_halt
  %vptr16747 = alloca i64*, align 8 
  %cloptr16742 = inttoptr i64 %h9170 to i64* 
  store volatile i64* %cloptr16742, i64** %vptr16747, align 8 ; closure/env cast; i64 -> i64*
  %vptr16748 = alloca i64*, align 8 
  %i0ptr16743 = getelementptr inbounds i64, i64* %cloptr16742, i64 1 
  store volatile i64* %i0ptr16743, i64** %vptr16748, align 8 ; &cloptr16742[1]
 %vptr16749 = alloca i64, align 8 
  %f16745 = load i64, i64* %i0ptr16743, align 8 
  store volatile i64 %f16745, i64* %vptr16749, align 8 ; load; *i0ptr16743
  %fptr16744 = inttoptr i64 %f16745 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16744(i64 %h9170, i64 %h9170)                       ; tail call
  ret void

else16739:
 %vptr16750 = alloca i64, align 8 
  %nj5$_950 = call i64 @prim_car(i64 %rvp9164) 
  store volatile i64 %nj5$_950, i64* %vptr16750, align 8 ; call prim_car
 %vptr16751 = alloca i64, align 8 
  %na9160 = call i64 @prim_cdr(i64 %rvp9164) 
  store volatile i64 %na9160, i64* %vptr16751, align 8 ; call prim_cdr
 %vptr16752 = alloca i64, align 8 
  %n_639165 = call i64 @prim_null_63(i64 %na9160) 
  store volatile i64 %n_639165, i64* %vptr16752, align 8 ; call prim_null_63
  %cmpptr16756 = alloca i1, align 8  %cmp16753 = icmp eq i64 %n_639165, 15 store volatile i1 %cmp16753, i1* %cmpptr16756, align 8; false?
  br i1 %cmp16753, label %else16755, label %then16754                                ; if

then16754:
 %vptr16757 = alloca i64, align 8 
  %rva9163 = add i64 0, 0 
  store volatile i64 %rva9163, i64* %vptr16757, align 8 ; quoted ()
 %vptr16758 = alloca i64, align 8 
  %rva9162 = call i64 @prim_cons(i64 %w2t$cc, i64 %rva9163) 
  store volatile i64 %rva9162, i64* %vptr16758, align 8 ; call prim_cons
 %vptr16759 = alloca i64, align 8 
  %rva9161 = call i64 @prim_cons(i64 %cont7134, i64 %rva9162) 
  store volatile i64 %rva9161, i64* %vptr16759, align 8 ; call prim_cons
  %vptr16765 = alloca i64*, align 8 
  %cloptr16760 = inttoptr i64 %w2t$cc to i64* 
  store volatile i64* %cloptr16760, i64** %vptr16765, align 8 ; closure/env cast; i64 -> i64*
  %vptr16766 = alloca i64*, align 8 
  %i0ptr16761 = getelementptr inbounds i64, i64* %cloptr16760, i64 1 
  store volatile i64* %i0ptr16761, i64** %vptr16766, align 8 ; &cloptr16760[1]
 %vptr16767 = alloca i64, align 8 
  %f16763 = load i64, i64* %i0ptr16761, align 8 
  store volatile i64 %f16763, i64* %vptr16767, align 8 ; load; *i0ptr16761
  %fptr16762 = inttoptr i64 %f16763 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16762(i64 %w2t$cc, i64 %rva9161)                    ; tail call
  ret void

else16755:
 %vptr16768 = alloca i64, align 8 
  %h9166 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9166, i64* %vptr16768, align 8 ; call prim_halt
  %vptr16774 = alloca i64*, align 8 
  %cloptr16769 = inttoptr i64 %h9166 to i64* 
  store volatile i64* %cloptr16769, i64** %vptr16774, align 8 ; closure/env cast; i64 -> i64*
  %vptr16775 = alloca i64*, align 8 
  %i0ptr16770 = getelementptr inbounds i64, i64* %cloptr16769, i64 1 
  store volatile i64* %i0ptr16770, i64** %vptr16775, align 8 ; &cloptr16769[1]
 %vptr16776 = alloca i64, align 8 
  %f16772 = load i64, i64* %i0ptr16770, align 8 
  store volatile i64 %f16772, i64* %vptr16776, align 8 ; load; *i0ptr16770
  %fptr16771 = inttoptr i64 %f16772 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16771(i64 %h9166, i64 %h9166)                       ; tail call
  ret void
}


define void @lam12219(i64 %env12220, i64 %rvp9211) {
 %vptr16779 = alloca i64, align 8 
  %envptr16777 = inttoptr i64 %env12220 to i64* 
  store volatile i64 %emsg08636, i64* %vptr16779, align 8 ; closure/env cast; i64 -> i64*
  %vptr16780 = alloca i64*, align 8 
  %envptr16778 = getelementptr inbounds i64, i64* %envptr16777, i64 6 
  store volatile i64* %envptr16778, i64** %vptr16780, align 8 ; &envptr16777[5]
 %vptr16781 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr16778, align 8 
  store volatile i64 %emsg08636, i64* %vptr16781, align 8 ; load; *envptr16778
 %vptr16784 = alloca i64, align 8 
  %envptr16782 = inttoptr i64 %env12220 to i64* 
  store volatile i64 %cont7134, i64* %vptr16784, align 8 ; closure/env cast; i64 -> i64*
  %vptr16785 = alloca i64*, align 8 
  %envptr16783 = getelementptr inbounds i64, i64* %envptr16782, i64 5 
  store volatile i64* %envptr16783, i64** %vptr16785, align 8 ; &envptr16782[4]
 %vptr16786 = alloca i64, align 8 
  %cont7134 = load i64, i64* %envptr16783, align 8 
  store volatile i64 %cont7134, i64* %vptr16786, align 8 ; load; *envptr16783
 %vptr16789 = alloca i64, align 8 
  %envptr16787 = inttoptr i64 %env12220 to i64* 
  store volatile i64 %gtB$v, i64* %vptr16789, align 8 ; closure/env cast; i64 -> i64*
  %vptr16790 = alloca i64*, align 8 
  %envptr16788 = getelementptr inbounds i64, i64* %envptr16787, i64 4 
  store volatile i64* %envptr16788, i64** %vptr16790, align 8 ; &envptr16787[3]
 %vptr16791 = alloca i64, align 8 
  %gtB$v = load i64, i64* %envptr16788, align 8 
  store volatile i64 %gtB$v, i64* %vptr16791, align 8 ; load; *envptr16788
 %vptr16794 = alloca i64, align 8 
  %envptr16792 = inttoptr i64 %env12220 to i64* 
  store volatile i64 %qgT$lst, i64* %vptr16794, align 8 ; closure/env cast; i64 -> i64*
  %vptr16795 = alloca i64*, align 8 
  %envptr16793 = getelementptr inbounds i64, i64* %envptr16792, i64 3 
  store volatile i64* %envptr16793, i64** %vptr16795, align 8 ; &envptr16792[2]
 %vptr16796 = alloca i64, align 8 
  %qgT$lst = load i64, i64* %envptr16793, align 8 
  store volatile i64 %qgT$lst, i64* %vptr16796, align 8 ; load; *envptr16793
 %vptr16799 = alloca i64, align 8 
  %envptr16797 = inttoptr i64 %env12220 to i64* 
  store volatile i64 %emsg18637, i64* %vptr16799, align 8 ; closure/env cast; i64 -> i64*
  %vptr16800 = alloca i64*, align 8 
  %envptr16798 = getelementptr inbounds i64, i64* %envptr16797, i64 2 
  store volatile i64* %envptr16798, i64** %vptr16800, align 8 ; &envptr16797[1]
 %vptr16801 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr16798, align 8 
  store volatile i64 %emsg18637, i64* %vptr16801, align 8 ; load; *envptr16798
 %vptr16802 = alloca i64, align 8 
  %_957135 = call i64 @prim_car(i64 %rvp9211) 
  store volatile i64 %_957135, i64* %vptr16802, align 8 ; call prim_car
 %vptr16803 = alloca i64, align 8 
  %rvp9207 = call i64 @prim_cdr(i64 %rvp9211) 
  store volatile i64 %rvp9207, i64* %vptr16803, align 8 ; call prim_cdr
 %vptr16804 = alloca i64, align 8 
  %n_639212 = call i64 @prim_null_63(i64 %rvp9207) 
  store volatile i64 %n_639212, i64* %vptr16804, align 8 ; call prim_null_63
  %cmpptr16808 = alloca i1, align 8  %cmp16805 = icmp eq i64 %n_639212, 15 store volatile i1 %cmp16805, i1* %cmpptr16808, align 8; false?
  br i1 %cmp16805, label %else16807, label %then16806                                ; if

then16806:
 %vptr16809 = alloca i64, align 8 
  %h9213 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9213, i64* %vptr16809, align 8 ; call prim_halt
  %vptr16815 = alloca i64*, align 8 
  %cloptr16810 = inttoptr i64 %h9213 to i64* 
  store volatile i64* %cloptr16810, i64** %vptr16815, align 8 ; closure/env cast; i64 -> i64*
  %vptr16816 = alloca i64*, align 8 
  %i0ptr16811 = getelementptr inbounds i64, i64* %cloptr16810, i64 1 
  store volatile i64* %i0ptr16811, i64** %vptr16816, align 8 ; &cloptr16810[1]
 %vptr16817 = alloca i64, align 8 
  %f16813 = load i64, i64* %i0ptr16811, align 8 
  store volatile i64 %f16813, i64* %vptr16817, align 8 ; load; *i0ptr16811
  %fptr16812 = inttoptr i64 %f16813 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16812(i64 %h9213, i64 %h9213)                       ; tail call
  ret void

else16807:
 %vptr16818 = alloca i64, align 8 
  %w2t$cc = call i64 @prim_car(i64 %rvp9207) 
  store volatile i64 %w2t$cc, i64* %vptr16818, align 8 ; call prim_car
 %vptr16819 = alloca i64, align 8 
  %na9184 = call i64 @prim_cdr(i64 %rvp9207) 
  store volatile i64 %na9184, i64* %vptr16819, align 8 ; call prim_cdr
 %vptr16820 = alloca i64, align 8 
  %n_639208 = call i64 @prim_null_63(i64 %na9184) 
  store volatile i64 %n_639208, i64* %vptr16820, align 8 ; call prim_null_63
  %cmpptr16824 = alloca i1, align 8  %cmp16821 = icmp eq i64 %n_639208, 15 store volatile i1 %cmp16821, i1* %cmpptr16824, align 8; false?
  br i1 %cmp16821, label %else16823, label %then16822                                ; if

then16822:
 %vptr16825 = alloca i64, align 8 
  %arg7688 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7688, i64* %vptr16825, align 8 ; quoted int
 %vptr16826 = alloca i64, align 8 
  %a6977 = call i64 @prim_vector_45ref(i64 %qgT$lst, i64 %arg7688) 
  store volatile i64 %a6977, i64* %vptr16826, align 8 ; call prim_vector_45ref
 %vptr16827 = alloca i64, align 8 
  %a6978 = call i64 @prim_null_63(i64 %a6977) 
  store volatile i64 %a6978, i64* %vptr16827, align 8 ; call prim_null_63
  %cmpptr16831 = alloca i1, align 8  %cmp16828 = icmp eq i64 %a6978, 15 store volatile i1 %cmp16828, i1* %cmpptr16831, align 8; false?
  br i1 %cmp16828, label %else16830, label %then16829                                ; if

then16829:
 %vptr16832 = alloca i64, align 8 
  %arg7692 = add i64 0, 0 
  store volatile i64 %arg7692, i64* %vptr16832, align 8 ; quoted ()
 %vptr16833 = alloca i64, align 8 
  %arg7691 = call i64 @const_init_false() 
  store volatile i64 %arg7691, i64* %vptr16833, align 8 ; quoted #f
 %vptr16834 = alloca i64, align 8 
  %rva9187 = add i64 0, 0 
  store volatile i64 %rva9187, i64* %vptr16834, align 8 ; quoted ()
 %vptr16835 = alloca i64, align 8 
  %rva9186 = call i64 @prim_cons(i64 %arg7691, i64 %rva9187) 
  store volatile i64 %rva9186, i64* %vptr16835, align 8 ; call prim_cons
 %vptr16836 = alloca i64, align 8 
  %rva9185 = call i64 @prim_cons(i64 %arg7692, i64 %rva9186) 
  store volatile i64 %rva9185, i64* %vptr16836, align 8 ; call prim_cons
  %vptr16842 = alloca i64*, align 8 
  %cloptr16837 = inttoptr i64 %cont7134 to i64* 
  store volatile i64* %cloptr16837, i64** %vptr16842, align 8 ; closure/env cast; i64 -> i64*
  %vptr16843 = alloca i64*, align 8 
  %i0ptr16838 = getelementptr inbounds i64, i64* %cloptr16837, i64 1 
  store volatile i64* %i0ptr16838, i64** %vptr16843, align 8 ; &cloptr16837[1]
 %vptr16844 = alloca i64, align 8 
  %f16840 = load i64, i64* %i0ptr16838, align 8 
  store volatile i64 %f16840, i64* %vptr16844, align 8 ; load; *i0ptr16838
  %fptr16839 = inttoptr i64 %f16840 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16839(i64 %cont7134, i64 %rva9185)                  ; tail call
  ret void

else16830:
 %vptr16845 = alloca i64, align 8 
  %arg7694 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7694, i64* %vptr16845, align 8 ; quoted int
 %vptr16846 = alloca i64, align 8 
  %a6979 = call i64 @prim_vector_45ref(i64 %qgT$lst, i64 %arg7694) 
  store volatile i64 %a6979, i64* %vptr16846, align 8 ; call prim_vector_45ref
 %vptr16847 = alloca i64, align 8 
  %a6980 = call i64 @prim_car(i64 %a6979) 
  store volatile i64 %a6980, i64* %vptr16847, align 8 ; call prim_car
 %vptr16848 = alloca i64, align 8 
  %a6981 = call i64 @prim_eqv_63(i64 %a6980, i64 %gtB$v) 
  store volatile i64 %a6981, i64* %vptr16848, align 8 ; call prim_eqv_63
  %cmpptr16852 = alloca i1, align 8  %cmp16849 = icmp eq i64 %a6981, 15 store volatile i1 %cmp16849, i1* %cmpptr16852, align 8; false?
  br i1 %cmp16849, label %else16851, label %then16850                                ; if

then16850:
 %vptr16853 = alloca i64, align 8 
  %arg7699 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7699, i64* %vptr16853, align 8 ; quoted int
 %vptr16854 = alloca i64, align 8 
  %retprim7136 = call i64 @prim_vector_45ref(i64 %qgT$lst, i64 %arg7699) 
  store volatile i64 %retprim7136, i64* %vptr16854, align 8 ; call prim_vector_45ref
 %vptr16855 = alloca i64, align 8 
  %arg7702 = add i64 0, 0 
  store volatile i64 %arg7702, i64* %vptr16855, align 8 ; quoted ()
 %vptr16856 = alloca i64, align 8 
  %rva9190 = add i64 0, 0 
  store volatile i64 %rva9190, i64* %vptr16856, align 8 ; quoted ()
 %vptr16857 = alloca i64, align 8 
  %rva9189 = call i64 @prim_cons(i64 %retprim7136, i64 %rva9190) 
  store volatile i64 %rva9189, i64* %vptr16857, align 8 ; call prim_cons
 %vptr16858 = alloca i64, align 8 
  %rva9188 = call i64 @prim_cons(i64 %arg7702, i64 %rva9189) 
  store volatile i64 %rva9188, i64* %vptr16858, align 8 ; call prim_cons
  %vptr16864 = alloca i64*, align 8 
  %cloptr16859 = inttoptr i64 %cont7134 to i64* 
  store volatile i64* %cloptr16859, i64** %vptr16864, align 8 ; closure/env cast; i64 -> i64*
  %vptr16865 = alloca i64*, align 8 
  %i0ptr16860 = getelementptr inbounds i64, i64* %cloptr16859, i64 1 
  store volatile i64* %i0ptr16860, i64** %vptr16865, align 8 ; &cloptr16859[1]
 %vptr16866 = alloca i64, align 8 
  %f16862 = load i64, i64* %i0ptr16860, align 8 
  store volatile i64 %f16862, i64* %vptr16866, align 8 ; load; *i0ptr16860
  %fptr16861 = inttoptr i64 %f16862 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16861(i64 %cont7134, i64 %rva9188)                  ; tail call
  ret void

else16851:
 %vptr16867 = alloca i64, align 8 
  %arg7704 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7704, i64* %vptr16867, align 8 ; quoted int
 %vptr16868 = alloca i64, align 8 
  %a6982 = call i64 @prim_vector_45ref(i64 %qgT$lst, i64 %arg7704) 
  store volatile i64 %a6982, i64* %vptr16868, align 8 ; call prim_vector_45ref
 %vptr16869 = alloca i64, align 8 
  %a6983 = call i64 @prim_cdr(i64 %a6982) 
  store volatile i64 %a6983, i64* %vptr16869, align 8 ; call prim_cdr
 %vptr16870 = alloca i64, align 8 
  %arg7708 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7708, i64* %vptr16870, align 8 ; quoted int
 %vptr16871 = alloca i64, align 8 
  %retprim7138 = call i64 @prim_vector_45set_33(i64 %qgT$lst, i64 %arg7708, i64 %a6983) 
  store volatile i64 %retprim7138, i64* %vptr16871, align 8 ; call prim_vector_45set_33
  %vptr16879 = alloca i64*, align 8 
  %cloptr16872 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr16872, i64** %vptr16879, align 8 ; malloc
  %vptr16880 = alloca i64*, align 8 
  %eptr16874 = getelementptr inbounds i64, i64* %cloptr16872, i64 2 
  store volatile i64* %eptr16874, i64** %vptr16880, align 8 ; &eptr16874[1]
  %vptr16881 = alloca i64*, align 8 
  %eptr16875 = getelementptr inbounds i64, i64* %cloptr16872, i64 3 
  store volatile i64* %eptr16875, i64** %vptr16881, align 8 ; &eptr16875[2]
  %vptr16882 = alloca i64*, align 8 
  %eptr16876 = getelementptr inbounds i64, i64* %cloptr16872, i64 4 
  store volatile i64* %eptr16876, i64** %vptr16882, align 8 ; &eptr16876[3]
  %vptr16883 = alloca i64*, align 8 
  %eptr16877 = getelementptr inbounds i64, i64* %cloptr16872, i64 5 
  store volatile i64* %eptr16877, i64** %vptr16883, align 8 ; &eptr16877[4]
  store i64 %w2t$cc, i64* %eptr16874                                                 ; *eptr16874 = %w2t$cc
  store i64 %emsg18637, i64* %eptr16875                                              ; *eptr16875 = %emsg18637
  store i64 %cont7134, i64* %eptr16876                                               ; *eptr16876 = %cont7134
  store i64 %emsg08636, i64* %eptr16877                                              ; *eptr16877 = %emsg08636
  %vptr16884 = alloca i64*, align 8 
  %eptr16873 = getelementptr inbounds i64, i64* %cloptr16872, i64 1 
  store volatile i64* %eptr16873, i64** %vptr16884, align 8 ; &cloptr16872[1]
 %vptr16885 = alloca i64, align 8 
  %f16878 = ptrtoint void(i64,i64)* @lam12213 to i64 
  store volatile i64 %f16878, i64* %vptr16885, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f16878, i64* %eptr16873                                                 ; store fptr
 %vptr16886 = alloca i64, align 8 
  %arg7712 = ptrtoint i64* %cloptr16872 to i64 
  store volatile i64 %arg7712, i64* %vptr16886, align 8 ; closure cast; i64* -> i64
 %vptr16887 = alloca i64, align 8 
  %arg7711 = add i64 0, 0 
  store volatile i64 %arg7711, i64* %vptr16887, align 8 ; quoted ()
 %vptr16888 = alloca i64, align 8 
  %rva9206 = add i64 0, 0 
  store volatile i64 %rva9206, i64* %vptr16888, align 8 ; quoted ()
 %vptr16889 = alloca i64, align 8 
  %rva9205 = call i64 @prim_cons(i64 %retprim7138, i64 %rva9206) 
  store volatile i64 %rva9205, i64* %vptr16889, align 8 ; call prim_cons
 %vptr16890 = alloca i64, align 8 
  %rva9204 = call i64 @prim_cons(i64 %arg7711, i64 %rva9205) 
  store volatile i64 %rva9204, i64* %vptr16890, align 8 ; call prim_cons
  %vptr16896 = alloca i64*, align 8 
  %cloptr16891 = inttoptr i64 %arg7712 to i64* 
  store volatile i64* %cloptr16891, i64** %vptr16896, align 8 ; closure/env cast; i64 -> i64*
  %vptr16897 = alloca i64*, align 8 
  %i0ptr16892 = getelementptr inbounds i64, i64* %cloptr16891, i64 1 
  store volatile i64* %i0ptr16892, i64** %vptr16897, align 8 ; &cloptr16891[1]
 %vptr16898 = alloca i64, align 8 
  %f16894 = load i64, i64* %i0ptr16892, align 8 
  store volatile i64 %f16894, i64* %vptr16898, align 8 ; load; *i0ptr16892
  %fptr16893 = inttoptr i64 %f16894 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16893(i64 %arg7712, i64 %rva9204)                   ; tail call
  ret void

else16823:
 %vptr16899 = alloca i64, align 8 
  %h9209 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9209, i64* %vptr16899, align 8 ; call prim_halt
  %vptr16905 = alloca i64*, align 8 
  %cloptr16900 = inttoptr i64 %h9209 to i64* 
  store volatile i64* %cloptr16900, i64** %vptr16905, align 8 ; closure/env cast; i64 -> i64*
  %vptr16906 = alloca i64*, align 8 
  %i0ptr16901 = getelementptr inbounds i64, i64* %cloptr16900, i64 1 
  store volatile i64* %i0ptr16901, i64** %vptr16906, align 8 ; &cloptr16900[1]
 %vptr16907 = alloca i64, align 8 
  %f16903 = load i64, i64* %i0ptr16901, align 8 
  store volatile i64 %f16903, i64* %vptr16907, align 8 ; load; *i0ptr16901
  %fptr16902 = inttoptr i64 %f16903 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16902(i64 %h9209, i64 %h9209)                       ; tail call
  ret void
}


define void @lam12213(i64 %env12214, i64 %rvp9200) {
 %vptr16910 = alloca i64, align 8 
  %envptr16908 = inttoptr i64 %env12214 to i64* 
  store volatile i64 %emsg08636, i64* %vptr16910, align 8 ; closure/env cast; i64 -> i64*
  %vptr16911 = alloca i64*, align 8 
  %envptr16909 = getelementptr inbounds i64, i64* %envptr16908, i64 5 
  store volatile i64* %envptr16909, i64** %vptr16911, align 8 ; &envptr16908[4]
 %vptr16912 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr16909, align 8 
  store volatile i64 %emsg08636, i64* %vptr16912, align 8 ; load; *envptr16909
 %vptr16915 = alloca i64, align 8 
  %envptr16913 = inttoptr i64 %env12214 to i64* 
  store volatile i64 %cont7134, i64* %vptr16915, align 8 ; closure/env cast; i64 -> i64*
  %vptr16916 = alloca i64*, align 8 
  %envptr16914 = getelementptr inbounds i64, i64* %envptr16913, i64 4 
  store volatile i64* %envptr16914, i64** %vptr16916, align 8 ; &envptr16913[3]
 %vptr16917 = alloca i64, align 8 
  %cont7134 = load i64, i64* %envptr16914, align 8 
  store volatile i64 %cont7134, i64* %vptr16917, align 8 ; load; *envptr16914
 %vptr16920 = alloca i64, align 8 
  %envptr16918 = inttoptr i64 %env12214 to i64* 
  store volatile i64 %emsg18637, i64* %vptr16920, align 8 ; closure/env cast; i64 -> i64*
  %vptr16921 = alloca i64*, align 8 
  %envptr16919 = getelementptr inbounds i64, i64* %envptr16918, i64 3 
  store volatile i64* %envptr16919, i64** %vptr16921, align 8 ; &envptr16918[2]
 %vptr16922 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr16919, align 8 
  store volatile i64 %emsg18637, i64* %vptr16922, align 8 ; load; *envptr16919
 %vptr16925 = alloca i64, align 8 
  %envptr16923 = inttoptr i64 %env12214 to i64* 
  store volatile i64 %w2t$cc, i64* %vptr16925, align 8 ; closure/env cast; i64 -> i64*
  %vptr16926 = alloca i64*, align 8 
  %envptr16924 = getelementptr inbounds i64, i64* %envptr16923, i64 2 
  store volatile i64* %envptr16924, i64** %vptr16926, align 8 ; &envptr16923[1]
 %vptr16927 = alloca i64, align 8 
  %w2t$cc = load i64, i64* %envptr16924, align 8 
  store volatile i64 %w2t$cc, i64* %vptr16927, align 8 ; load; *envptr16924
 %vptr16928 = alloca i64, align 8 
  %_957137 = call i64 @prim_car(i64 %rvp9200) 
  store volatile i64 %_957137, i64* %vptr16928, align 8 ; call prim_car
 %vptr16929 = alloca i64, align 8 
  %rvp9196 = call i64 @prim_cdr(i64 %rvp9200) 
  store volatile i64 %rvp9196, i64* %vptr16929, align 8 ; call prim_cdr
 %vptr16930 = alloca i64, align 8 
  %n_639201 = call i64 @prim_null_63(i64 %rvp9196) 
  store volatile i64 %n_639201, i64* %vptr16930, align 8 ; call prim_null_63
  %cmpptr16934 = alloca i1, align 8  %cmp16931 = icmp eq i64 %n_639201, 15 store volatile i1 %cmp16931, i1* %cmpptr16934, align 8; false?
  br i1 %cmp16931, label %else16933, label %then16932                                ; if

then16932:
 %vptr16935 = alloca i64, align 8 
  %h9202 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9202, i64* %vptr16935, align 8 ; call prim_halt
  %vptr16941 = alloca i64*, align 8 
  %cloptr16936 = inttoptr i64 %h9202 to i64* 
  store volatile i64* %cloptr16936, i64** %vptr16941, align 8 ; closure/env cast; i64 -> i64*
  %vptr16942 = alloca i64*, align 8 
  %i0ptr16937 = getelementptr inbounds i64, i64* %cloptr16936, i64 1 
  store volatile i64* %i0ptr16937, i64** %vptr16942, align 8 ; &cloptr16936[1]
 %vptr16943 = alloca i64, align 8 
  %f16939 = load i64, i64* %i0ptr16937, align 8 
  store volatile i64 %f16939, i64* %vptr16943, align 8 ; load; *i0ptr16937
  %fptr16938 = inttoptr i64 %f16939 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16938(i64 %h9202, i64 %h9202)                       ; tail call
  ret void

else16933:
 %vptr16944 = alloca i64, align 8 
  %nj5$_950 = call i64 @prim_car(i64 %rvp9196) 
  store volatile i64 %nj5$_950, i64* %vptr16944, align 8 ; call prim_car
 %vptr16945 = alloca i64, align 8 
  %na9192 = call i64 @prim_cdr(i64 %rvp9196) 
  store volatile i64 %na9192, i64* %vptr16945, align 8 ; call prim_cdr
 %vptr16946 = alloca i64, align 8 
  %n_639197 = call i64 @prim_null_63(i64 %na9192) 
  store volatile i64 %n_639197, i64* %vptr16946, align 8 ; call prim_null_63
  %cmpptr16950 = alloca i1, align 8  %cmp16947 = icmp eq i64 %n_639197, 15 store volatile i1 %cmp16947, i1* %cmpptr16950, align 8; false?
  br i1 %cmp16947, label %else16949, label %then16948                                ; if

then16948:
 %vptr16951 = alloca i64, align 8 
  %rva9195 = add i64 0, 0 
  store volatile i64 %rva9195, i64* %vptr16951, align 8 ; quoted ()
 %vptr16952 = alloca i64, align 8 
  %rva9194 = call i64 @prim_cons(i64 %w2t$cc, i64 %rva9195) 
  store volatile i64 %rva9194, i64* %vptr16952, align 8 ; call prim_cons
 %vptr16953 = alloca i64, align 8 
  %rva9193 = call i64 @prim_cons(i64 %cont7134, i64 %rva9194) 
  store volatile i64 %rva9193, i64* %vptr16953, align 8 ; call prim_cons
  %vptr16959 = alloca i64*, align 8 
  %cloptr16954 = inttoptr i64 %w2t$cc to i64* 
  store volatile i64* %cloptr16954, i64** %vptr16959, align 8 ; closure/env cast; i64 -> i64*
  %vptr16960 = alloca i64*, align 8 
  %i0ptr16955 = getelementptr inbounds i64, i64* %cloptr16954, i64 1 
  store volatile i64* %i0ptr16955, i64** %vptr16960, align 8 ; &cloptr16954[1]
 %vptr16961 = alloca i64, align 8 
  %f16957 = load i64, i64* %i0ptr16955, align 8 
  store volatile i64 %f16957, i64* %vptr16961, align 8 ; load; *i0ptr16955
  %fptr16956 = inttoptr i64 %f16957 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16956(i64 %w2t$cc, i64 %rva9193)                    ; tail call
  ret void

else16949:
 %vptr16962 = alloca i64, align 8 
  %h9198 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9198, i64* %vptr16962, align 8 ; call prim_halt
  %vptr16968 = alloca i64*, align 8 
  %cloptr16963 = inttoptr i64 %h9198 to i64* 
  store volatile i64* %cloptr16963, i64** %vptr16968, align 8 ; closure/env cast; i64 -> i64*
  %vptr16969 = alloca i64*, align 8 
  %i0ptr16964 = getelementptr inbounds i64, i64* %cloptr16963, i64 1 
  store volatile i64* %i0ptr16964, i64** %vptr16969, align 8 ; &cloptr16963[1]
 %vptr16970 = alloca i64, align 8 
  %f16966 = load i64, i64* %i0ptr16964, align 8 
  store volatile i64 %f16966, i64* %vptr16970, align 8 ; load; *i0ptr16964
  %fptr16965 = inttoptr i64 %f16966 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr16965(i64 %h9198, i64 %h9198)                       ; tail call
  ret void
}


define void @lam12201(i64 %env12202, i64 %av8$args7141) {
 %vptr16973 = alloca i64, align 8 
  %envptr16971 = inttoptr i64 %env12202 to i64* 
  store volatile i64 %F5P$_37foldl1, i64* %vptr16973, align 8 ; closure/env cast; i64 -> i64*
  %vptr16974 = alloca i64*, align 8 
  %envptr16972 = getelementptr inbounds i64, i64* %envptr16971, i64 4 
  store volatile i64* %envptr16972, i64** %vptr16974, align 8 ; &envptr16971[3]
 %vptr16975 = alloca i64, align 8 
  %F5P$_37foldl1 = load i64, i64* %envptr16972, align 8 
  store volatile i64 %F5P$_37foldl1, i64* %vptr16975, align 8 ; load; *envptr16972
 %vptr16978 = alloca i64, align 8 
  %envptr16976 = inttoptr i64 %env12202 to i64* 
  store volatile i64 %emsg08636, i64* %vptr16978, align 8 ; closure/env cast; i64 -> i64*
  %vptr16979 = alloca i64*, align 8 
  %envptr16977 = getelementptr inbounds i64, i64* %envptr16976, i64 3 
  store volatile i64* %envptr16977, i64** %vptr16979, align 8 ; &envptr16976[2]
 %vptr16980 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr16977, align 8 
  store volatile i64 %emsg08636, i64* %vptr16980, align 8 ; load; *envptr16977
 %vptr16983 = alloca i64, align 8 
  %envptr16981 = inttoptr i64 %env12202 to i64* 
  store volatile i64 %emsg18637, i64* %vptr16983, align 8 ; closure/env cast; i64 -> i64*
  %vptr16984 = alloca i64*, align 8 
  %envptr16982 = getelementptr inbounds i64, i64* %envptr16981, i64 2 
  store volatile i64* %envptr16982, i64** %vptr16984, align 8 ; &envptr16981[1]
 %vptr16985 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr16982, align 8 
  store volatile i64 %emsg18637, i64* %vptr16985, align 8 ; load; *envptr16982
 %vptr16986 = alloca i64, align 8 
  %cont7140 = call i64 @prim_car(i64 %av8$args7141) 
  store volatile i64 %cont7140, i64* %vptr16986, align 8 ; call prim_car
 %vptr16987 = alloca i64, align 8 
  %av8$args = call i64 @prim_cdr(i64 %av8$args7141) 
  store volatile i64 %av8$args, i64* %vptr16987, align 8 ; call prim_cdr
 %vptr16988 = alloca i64, align 8 
  %a6984 = call i64 @prim_null_63(i64 %av8$args) 
  store volatile i64 %a6984, i64* %vptr16988, align 8 ; call prim_null_63
  %cmpptr16992 = alloca i1, align 8  %cmp16989 = icmp eq i64 %a6984, 15 store volatile i1 %cmp16989, i1* %cmpptr16992, align 8; false?
  br i1 %cmp16989, label %else16991, label %then16990                                ; if

then16990:
 %vptr16993 = alloca i64, align 8 
  %arg7720 = add i64 0, 0 
  store volatile i64 %arg7720, i64* %vptr16993, align 8 ; quoted ()
 %vptr16994 = alloca i64, align 8 
  %arg7719 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg7719, i64* %vptr16994, align 8 ; quoted int
 %vptr16995 = alloca i64, align 8 
  %rva9232 = add i64 0, 0 
  store volatile i64 %rva9232, i64* %vptr16995, align 8 ; quoted ()
 %vptr16996 = alloca i64, align 8 
  %rva9231 = call i64 @prim_cons(i64 %arg7719, i64 %rva9232) 
  store volatile i64 %rva9231, i64* %vptr16996, align 8 ; call prim_cons
 %vptr16997 = alloca i64, align 8 
  %rva9230 = call i64 @prim_cons(i64 %arg7720, i64 %rva9231) 
  store volatile i64 %rva9230, i64* %vptr16997, align 8 ; call prim_cons
  %vptr17003 = alloca i64*, align 8 
  %cloptr16998 = inttoptr i64 %cont7140 to i64* 
  store volatile i64* %cloptr16998, i64** %vptr17003, align 8 ; closure/env cast; i64 -> i64*
  %vptr17004 = alloca i64*, align 8 
  %i0ptr16999 = getelementptr inbounds i64, i64* %cloptr16998, i64 1 
  store volatile i64* %i0ptr16999, i64** %vptr17004, align 8 ; &cloptr16998[1]
 %vptr17005 = alloca i64, align 8 
  %f17001 = load i64, i64* %i0ptr16999, align 8 
  store volatile i64 %f17001, i64* %vptr17005, align 8 ; load; *i0ptr16999
  %fptr17000 = inttoptr i64 %f17001 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17000(i64 %cont7140, i64 %rva9230)                  ; tail call
  ret void

else16991:
 %vptr17006 = alloca i64, align 8 
  %a6985 = call i64 @prim_cdr(i64 %av8$args) 
  store volatile i64 %a6985, i64* %vptr17006, align 8 ; call prim_cdr
 %vptr17007 = alloca i64, align 8 
  %a6986 = call i64 @prim_null_63(i64 %a6985) 
  store volatile i64 %a6986, i64* %vptr17007, align 8 ; call prim_null_63
  %cmpptr17011 = alloca i1, align 8  %cmp17008 = icmp eq i64 %a6986, 15 store volatile i1 %cmp17008, i1* %cmpptr17011, align 8; false?
  br i1 %cmp17008, label %else17010, label %then17009                                ; if

then17009:
 %vptr17012 = alloca i64, align 8 
  %retprim7142 = call i64 @prim_car(i64 %av8$args) 
  store volatile i64 %retprim7142, i64* %vptr17012, align 8 ; call prim_car
 %vptr17013 = alloca i64, align 8 
  %arg7726 = add i64 0, 0 
  store volatile i64 %arg7726, i64* %vptr17013, align 8 ; quoted ()
 %vptr17014 = alloca i64, align 8 
  %rva9235 = add i64 0, 0 
  store volatile i64 %rva9235, i64* %vptr17014, align 8 ; quoted ()
 %vptr17015 = alloca i64, align 8 
  %rva9234 = call i64 @prim_cons(i64 %retprim7142, i64 %rva9235) 
  store volatile i64 %rva9234, i64* %vptr17015, align 8 ; call prim_cons
 %vptr17016 = alloca i64, align 8 
  %rva9233 = call i64 @prim_cons(i64 %arg7726, i64 %rva9234) 
  store volatile i64 %rva9233, i64* %vptr17016, align 8 ; call prim_cons
  %vptr17022 = alloca i64*, align 8 
  %cloptr17017 = inttoptr i64 %cont7140 to i64* 
  store volatile i64* %cloptr17017, i64** %vptr17022, align 8 ; closure/env cast; i64 -> i64*
  %vptr17023 = alloca i64*, align 8 
  %i0ptr17018 = getelementptr inbounds i64, i64* %cloptr17017, i64 1 
  store volatile i64* %i0ptr17018, i64** %vptr17023, align 8 ; &cloptr17017[1]
 %vptr17024 = alloca i64, align 8 
  %f17020 = load i64, i64* %i0ptr17018, align 8 
  store volatile i64 %f17020, i64* %vptr17024, align 8 ; load; *i0ptr17018
  %fptr17019 = inttoptr i64 %f17020 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17019(i64 %cont7140, i64 %rva9233)                  ; tail call
  ret void

else17010:
 %vptr17025 = alloca i64, align 8 
  %a6987 = call i64 @prim_car(i64 %av8$args) 
  store volatile i64 %a6987, i64* %vptr17025, align 8 ; call prim_car
 %vptr17026 = alloca i64, align 8 
  %a6988 = call i64 @prim_cdr(i64 %av8$args) 
  store volatile i64 %a6988, i64* %vptr17026, align 8 ; call prim_cdr
  %vptr17032 = alloca i64*, align 8 
  %cloptr17027 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr17027, i64** %vptr17032, align 8 ; malloc
  %vptr17033 = alloca i64*, align 8 
  %eptr17029 = getelementptr inbounds i64, i64* %cloptr17027, i64 2 
  store volatile i64* %eptr17029, i64** %vptr17033, align 8 ; &eptr17029[1]
  %vptr17034 = alloca i64*, align 8 
  %eptr17030 = getelementptr inbounds i64, i64* %cloptr17027, i64 3 
  store volatile i64* %eptr17030, i64** %vptr17034, align 8 ; &eptr17030[2]
  store i64 %emsg18637, i64* %eptr17029                                              ; *eptr17029 = %emsg18637
  store i64 %emsg08636, i64* %eptr17030                                              ; *eptr17030 = %emsg08636
  %vptr17035 = alloca i64*, align 8 
  %eptr17028 = getelementptr inbounds i64, i64* %cloptr17027, i64 1 
  store volatile i64* %eptr17028, i64** %vptr17035, align 8 ; &cloptr17027[1]
 %vptr17036 = alloca i64, align 8 
  %f17031 = ptrtoint void(i64,i64)* @lam12199 to i64 
  store volatile i64 %f17031, i64* %vptr17036, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f17031, i64* %eptr17028                                                 ; store fptr
 %vptr17037 = alloca i64, align 8 
  %arg7732 = ptrtoint i64* %cloptr17027 to i64 
  store volatile i64 %arg7732, i64* %vptr17037, align 8 ; closure cast; i64* -> i64
 %vptr17038 = alloca i64, align 8 
  %rva9257 = add i64 0, 0 
  store volatile i64 %rva9257, i64* %vptr17038, align 8 ; quoted ()
 %vptr17039 = alloca i64, align 8 
  %rva9256 = call i64 @prim_cons(i64 %a6988, i64 %rva9257) 
  store volatile i64 %rva9256, i64* %vptr17039, align 8 ; call prim_cons
 %vptr17040 = alloca i64, align 8 
  %rva9255 = call i64 @prim_cons(i64 %a6987, i64 %rva9256) 
  store volatile i64 %rva9255, i64* %vptr17040, align 8 ; call prim_cons
 %vptr17041 = alloca i64, align 8 
  %rva9254 = call i64 @prim_cons(i64 %arg7732, i64 %rva9255) 
  store volatile i64 %rva9254, i64* %vptr17041, align 8 ; call prim_cons
 %vptr17042 = alloca i64, align 8 
  %rva9253 = call i64 @prim_cons(i64 %cont7140, i64 %rva9254) 
  store volatile i64 %rva9253, i64* %vptr17042, align 8 ; call prim_cons
  %vptr17048 = alloca i64*, align 8 
  %cloptr17043 = inttoptr i64 %F5P$_37foldl1 to i64* 
  store volatile i64* %cloptr17043, i64** %vptr17048, align 8 ; closure/env cast; i64 -> i64*
  %vptr17049 = alloca i64*, align 8 
  %i0ptr17044 = getelementptr inbounds i64, i64* %cloptr17043, i64 1 
  store volatile i64* %i0ptr17044, i64** %vptr17049, align 8 ; &cloptr17043[1]
 %vptr17050 = alloca i64, align 8 
  %f17046 = load i64, i64* %i0ptr17044, align 8 
  store volatile i64 %f17046, i64* %vptr17050, align 8 ; load; *i0ptr17044
  %fptr17045 = inttoptr i64 %f17046 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17045(i64 %F5P$_37foldl1, i64 %rva9253)             ; tail call
  ret void
}


define void @lam12199(i64 %env12200, i64 %rvp9249) {
 %vptr17053 = alloca i64, align 8 
  %envptr17051 = inttoptr i64 %env12200 to i64* 
  store volatile i64 %emsg08636, i64* %vptr17053, align 8 ; closure/env cast; i64 -> i64*
  %vptr17054 = alloca i64*, align 8 
  %envptr17052 = getelementptr inbounds i64, i64* %envptr17051, i64 3 
  store volatile i64* %envptr17052, i64** %vptr17054, align 8 ; &envptr17051[2]
 %vptr17055 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr17052, align 8 
  store volatile i64 %emsg08636, i64* %vptr17055, align 8 ; load; *envptr17052
 %vptr17058 = alloca i64, align 8 
  %envptr17056 = inttoptr i64 %env12200 to i64* 
  store volatile i64 %emsg18637, i64* %vptr17058, align 8 ; closure/env cast; i64 -> i64*
  %vptr17059 = alloca i64*, align 8 
  %envptr17057 = getelementptr inbounds i64, i64* %envptr17056, i64 2 
  store volatile i64* %envptr17057, i64** %vptr17059, align 8 ; &envptr17056[1]
 %vptr17060 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr17057, align 8 
  store volatile i64 %emsg18637, i64* %vptr17060, align 8 ; load; *envptr17057
 %vptr17061 = alloca i64, align 8 
  %cont7143 = call i64 @prim_car(i64 %rvp9249) 
  store volatile i64 %cont7143, i64* %vptr17061, align 8 ; call prim_car
 %vptr17062 = alloca i64, align 8 
  %rvp9245 = call i64 @prim_cdr(i64 %rvp9249) 
  store volatile i64 %rvp9245, i64* %vptr17062, align 8 ; call prim_cdr
 %vptr17063 = alloca i64, align 8 
  %n_639250 = call i64 @prim_null_63(i64 %rvp9245) 
  store volatile i64 %n_639250, i64* %vptr17063, align 8 ; call prim_null_63
  %cmpptr17067 = alloca i1, align 8  %cmp17064 = icmp eq i64 %n_639250, 15 store volatile i1 %cmp17064, i1* %cmpptr17067, align 8; false?
  br i1 %cmp17064, label %else17066, label %then17065                                ; if

then17065:
 %vptr17068 = alloca i64, align 8 
  %h9251 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9251, i64* %vptr17068, align 8 ; call prim_halt
  %vptr17074 = alloca i64*, align 8 
  %cloptr17069 = inttoptr i64 %h9251 to i64* 
  store volatile i64* %cloptr17069, i64** %vptr17074, align 8 ; closure/env cast; i64 -> i64*
  %vptr17075 = alloca i64*, align 8 
  %i0ptr17070 = getelementptr inbounds i64, i64* %cloptr17069, i64 1 
  store volatile i64* %i0ptr17070, i64** %vptr17075, align 8 ; &cloptr17069[1]
 %vptr17076 = alloca i64, align 8 
  %f17072 = load i64, i64* %i0ptr17070, align 8 
  store volatile i64 %f17072, i64* %vptr17076, align 8 ; load; *i0ptr17070
  %fptr17071 = inttoptr i64 %f17072 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17071(i64 %h9251, i64 %h9251)                       ; tail call
  ret void

else17066:
 %vptr17077 = alloca i64, align 8 
  %fVu$n = call i64 @prim_car(i64 %rvp9245) 
  store volatile i64 %fVu$n, i64* %vptr17077, align 8 ; call prim_car
 %vptr17078 = alloca i64, align 8 
  %rvp9241 = call i64 @prim_cdr(i64 %rvp9245) 
  store volatile i64 %rvp9241, i64* %vptr17078, align 8 ; call prim_cdr
 %vptr17079 = alloca i64, align 8 
  %n_639246 = call i64 @prim_null_63(i64 %rvp9241) 
  store volatile i64 %n_639246, i64* %vptr17079, align 8 ; call prim_null_63
  %cmpptr17083 = alloca i1, align 8  %cmp17080 = icmp eq i64 %n_639246, 15 store volatile i1 %cmp17080, i1* %cmpptr17083, align 8; false?
  br i1 %cmp17080, label %else17082, label %then17081                                ; if

then17081:
 %vptr17084 = alloca i64, align 8 
  %h9247 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9247, i64* %vptr17084, align 8 ; call prim_halt
  %vptr17090 = alloca i64*, align 8 
  %cloptr17085 = inttoptr i64 %h9247 to i64* 
  store volatile i64* %cloptr17085, i64** %vptr17090, align 8 ; closure/env cast; i64 -> i64*
  %vptr17091 = alloca i64*, align 8 
  %i0ptr17086 = getelementptr inbounds i64, i64* %cloptr17085, i64 1 
  store volatile i64* %i0ptr17086, i64** %vptr17091, align 8 ; &cloptr17085[1]
 %vptr17092 = alloca i64, align 8 
  %f17088 = load i64, i64* %i0ptr17086, align 8 
  store volatile i64 %f17088, i64* %vptr17092, align 8 ; load; *i0ptr17086
  %fptr17087 = inttoptr i64 %f17088 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17087(i64 %h9247, i64 %h9247)                       ; tail call
  ret void

else17082:
 %vptr17093 = alloca i64, align 8 
  %LTr$v = call i64 @prim_car(i64 %rvp9241) 
  store volatile i64 %LTr$v, i64* %vptr17093, align 8 ; call prim_car
 %vptr17094 = alloca i64, align 8 
  %na9237 = call i64 @prim_cdr(i64 %rvp9241) 
  store volatile i64 %na9237, i64* %vptr17094, align 8 ; call prim_cdr
 %vptr17095 = alloca i64, align 8 
  %n_639242 = call i64 @prim_null_63(i64 %na9237) 
  store volatile i64 %n_639242, i64* %vptr17095, align 8 ; call prim_null_63
  %cmpptr17099 = alloca i1, align 8  %cmp17096 = icmp eq i64 %n_639242, 15 store volatile i1 %cmp17096, i1* %cmpptr17099, align 8; false?
  br i1 %cmp17096, label %else17098, label %then17097                                ; if

then17097:
 %vptr17100 = alloca i64, align 8 
  %retprim7144 = call i64 @prim__47(i64 %LTr$v, i64 %fVu$n) 
  store volatile i64 %retprim7144, i64* %vptr17100, align 8 ; call prim__47
 %vptr17101 = alloca i64, align 8 
  %arg7738 = add i64 0, 0 
  store volatile i64 %arg7738, i64* %vptr17101, align 8 ; quoted ()
 %vptr17102 = alloca i64, align 8 
  %rva9240 = add i64 0, 0 
  store volatile i64 %rva9240, i64* %vptr17102, align 8 ; quoted ()
 %vptr17103 = alloca i64, align 8 
  %rva9239 = call i64 @prim_cons(i64 %retprim7144, i64 %rva9240) 
  store volatile i64 %rva9239, i64* %vptr17103, align 8 ; call prim_cons
 %vptr17104 = alloca i64, align 8 
  %rva9238 = call i64 @prim_cons(i64 %arg7738, i64 %rva9239) 
  store volatile i64 %rva9238, i64* %vptr17104, align 8 ; call prim_cons
  %vptr17110 = alloca i64*, align 8 
  %cloptr17105 = inttoptr i64 %cont7143 to i64* 
  store volatile i64* %cloptr17105, i64** %vptr17110, align 8 ; closure/env cast; i64 -> i64*
  %vptr17111 = alloca i64*, align 8 
  %i0ptr17106 = getelementptr inbounds i64, i64* %cloptr17105, i64 1 
  store volatile i64* %i0ptr17106, i64** %vptr17111, align 8 ; &cloptr17105[1]
 %vptr17112 = alloca i64, align 8 
  %f17108 = load i64, i64* %i0ptr17106, align 8 
  store volatile i64 %f17108, i64* %vptr17112, align 8 ; load; *i0ptr17106
  %fptr17107 = inttoptr i64 %f17108 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17107(i64 %cont7143, i64 %rva9238)                  ; tail call
  ret void

else17098:
 %vptr17113 = alloca i64, align 8 
  %h9243 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9243, i64* %vptr17113, align 8 ; call prim_halt
  %vptr17119 = alloca i64*, align 8 
  %cloptr17114 = inttoptr i64 %h9243 to i64* 
  store volatile i64* %cloptr17114, i64** %vptr17119, align 8 ; closure/env cast; i64 -> i64*
  %vptr17120 = alloca i64*, align 8 
  %i0ptr17115 = getelementptr inbounds i64, i64* %cloptr17114, i64 1 
  store volatile i64* %i0ptr17115, i64** %vptr17120, align 8 ; &cloptr17114[1]
 %vptr17121 = alloca i64, align 8 
  %f17117 = load i64, i64* %i0ptr17115, align 8 
  store volatile i64 %f17117, i64* %vptr17121, align 8 ; load; *i0ptr17115
  %fptr17116 = inttoptr i64 %f17117 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17116(i64 %h9243, i64 %h9243)                       ; tail call
  ret void
}


define void @lam12189(i64 %env12190, i64 %rvp9267) {
 %vptr17124 = alloca i64, align 8 
  %envptr17122 = inttoptr i64 %env12190 to i64* 
  store volatile i64 %emsg08636, i64* %vptr17124, align 8 ; closure/env cast; i64 -> i64*
  %vptr17125 = alloca i64*, align 8 
  %envptr17123 = getelementptr inbounds i64, i64* %envptr17122, i64 3 
  store volatile i64* %envptr17123, i64** %vptr17125, align 8 ; &envptr17122[2]
 %vptr17126 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr17123, align 8 
  store volatile i64 %emsg08636, i64* %vptr17126, align 8 ; load; *envptr17123
 %vptr17129 = alloca i64, align 8 
  %envptr17127 = inttoptr i64 %env12190 to i64* 
  store volatile i64 %emsg18637, i64* %vptr17129, align 8 ; closure/env cast; i64 -> i64*
  %vptr17130 = alloca i64*, align 8 
  %envptr17128 = getelementptr inbounds i64, i64* %envptr17127, i64 2 
  store volatile i64* %envptr17128, i64** %vptr17130, align 8 ; &envptr17127[1]
 %vptr17131 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr17128, align 8 
  store volatile i64 %emsg18637, i64* %vptr17131, align 8 ; load; *envptr17128
 %vptr17132 = alloca i64, align 8 
  %cont7145 = call i64 @prim_car(i64 %rvp9267) 
  store volatile i64 %cont7145, i64* %vptr17132, align 8 ; call prim_car
 %vptr17133 = alloca i64, align 8 
  %rvp9263 = call i64 @prim_cdr(i64 %rvp9267) 
  store volatile i64 %rvp9263, i64* %vptr17133, align 8 ; call prim_cdr
 %vptr17134 = alloca i64, align 8 
  %n_639268 = call i64 @prim_null_63(i64 %rvp9263) 
  store volatile i64 %n_639268, i64* %vptr17134, align 8 ; call prim_null_63
  %cmpptr17138 = alloca i1, align 8  %cmp17135 = icmp eq i64 %n_639268, 15 store volatile i1 %cmp17135, i1* %cmpptr17138, align 8; false?
  br i1 %cmp17135, label %else17137, label %then17136                                ; if

then17136:
 %vptr17139 = alloca i64, align 8 
  %h9269 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9269, i64* %vptr17139, align 8 ; call prim_halt
  %vptr17145 = alloca i64*, align 8 
  %cloptr17140 = inttoptr i64 %h9269 to i64* 
  store volatile i64* %cloptr17140, i64** %vptr17145, align 8 ; closure/env cast; i64 -> i64*
  %vptr17146 = alloca i64*, align 8 
  %i0ptr17141 = getelementptr inbounds i64, i64* %cloptr17140, i64 1 
  store volatile i64* %i0ptr17141, i64** %vptr17146, align 8 ; &cloptr17140[1]
 %vptr17147 = alloca i64, align 8 
  %f17143 = load i64, i64* %i0ptr17141, align 8 
  store volatile i64 %f17143, i64* %vptr17147, align 8 ; load; *i0ptr17141
  %fptr17142 = inttoptr i64 %f17143 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17142(i64 %h9269, i64 %h9269)                       ; tail call
  ret void

else17137:
 %vptr17148 = alloca i64, align 8 
  %c8A$x = call i64 @prim_car(i64 %rvp9263) 
  store volatile i64 %c8A$x, i64* %vptr17148, align 8 ; call prim_car
 %vptr17149 = alloca i64, align 8 
  %na9259 = call i64 @prim_cdr(i64 %rvp9263) 
  store volatile i64 %na9259, i64* %vptr17149, align 8 ; call prim_cdr
 %vptr17150 = alloca i64, align 8 
  %n_639264 = call i64 @prim_null_63(i64 %na9259) 
  store volatile i64 %n_639264, i64* %vptr17150, align 8 ; call prim_null_63
  %cmpptr17154 = alloca i1, align 8  %cmp17151 = icmp eq i64 %n_639264, 15 store volatile i1 %cmp17151, i1* %cmpptr17154, align 8; false?
  br i1 %cmp17151, label %else17153, label %then17152                                ; if

then17152:
 %vptr17155 = alloca i64, align 8 
  %retprim7146 = call i64 @prim_car(i64 %c8A$x) 
  store volatile i64 %retprim7146, i64* %vptr17155, align 8 ; call prim_car
 %vptr17156 = alloca i64, align 8 
  %arg7742 = add i64 0, 0 
  store volatile i64 %arg7742, i64* %vptr17156, align 8 ; quoted ()
 %vptr17157 = alloca i64, align 8 
  %rva9262 = add i64 0, 0 
  store volatile i64 %rva9262, i64* %vptr17157, align 8 ; quoted ()
 %vptr17158 = alloca i64, align 8 
  %rva9261 = call i64 @prim_cons(i64 %retprim7146, i64 %rva9262) 
  store volatile i64 %rva9261, i64* %vptr17158, align 8 ; call prim_cons
 %vptr17159 = alloca i64, align 8 
  %rva9260 = call i64 @prim_cons(i64 %arg7742, i64 %rva9261) 
  store volatile i64 %rva9260, i64* %vptr17159, align 8 ; call prim_cons
  %vptr17165 = alloca i64*, align 8 
  %cloptr17160 = inttoptr i64 %cont7145 to i64* 
  store volatile i64* %cloptr17160, i64** %vptr17165, align 8 ; closure/env cast; i64 -> i64*
  %vptr17166 = alloca i64*, align 8 
  %i0ptr17161 = getelementptr inbounds i64, i64* %cloptr17160, i64 1 
  store volatile i64* %i0ptr17161, i64** %vptr17166, align 8 ; &cloptr17160[1]
 %vptr17167 = alloca i64, align 8 
  %f17163 = load i64, i64* %i0ptr17161, align 8 
  store volatile i64 %f17163, i64* %vptr17167, align 8 ; load; *i0ptr17161
  %fptr17162 = inttoptr i64 %f17163 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17162(i64 %cont7145, i64 %rva9260)                  ; tail call
  ret void

else17153:
 %vptr17168 = alloca i64, align 8 
  %h9265 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9265, i64* %vptr17168, align 8 ; call prim_halt
  %vptr17174 = alloca i64*, align 8 
  %cloptr17169 = inttoptr i64 %h9265 to i64* 
  store volatile i64* %cloptr17169, i64** %vptr17174, align 8 ; closure/env cast; i64 -> i64*
  %vptr17175 = alloca i64*, align 8 
  %i0ptr17170 = getelementptr inbounds i64, i64* %cloptr17169, i64 1 
  store volatile i64* %i0ptr17170, i64** %vptr17175, align 8 ; &cloptr17169[1]
 %vptr17176 = alloca i64, align 8 
  %f17172 = load i64, i64* %i0ptr17170, align 8 
  store volatile i64 %f17172, i64* %vptr17176, align 8 ; load; *i0ptr17170
  %fptr17171 = inttoptr i64 %f17172 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17171(i64 %h9265, i64 %h9265)                       ; tail call
  ret void
}


define void @lam12185(i64 %env12186, i64 %rvp9280) {
 %vptr17179 = alloca i64, align 8 
  %envptr17177 = inttoptr i64 %env12186 to i64* 
  store volatile i64 %emsg08636, i64* %vptr17179, align 8 ; closure/env cast; i64 -> i64*
  %vptr17180 = alloca i64*, align 8 
  %envptr17178 = getelementptr inbounds i64, i64* %envptr17177, i64 3 
  store volatile i64* %envptr17178, i64** %vptr17180, align 8 ; &envptr17177[2]
 %vptr17181 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr17178, align 8 
  store volatile i64 %emsg08636, i64* %vptr17181, align 8 ; load; *envptr17178
 %vptr17184 = alloca i64, align 8 
  %envptr17182 = inttoptr i64 %env12186 to i64* 
  store volatile i64 %emsg18637, i64* %vptr17184, align 8 ; closure/env cast; i64 -> i64*
  %vptr17185 = alloca i64*, align 8 
  %envptr17183 = getelementptr inbounds i64, i64* %envptr17182, i64 2 
  store volatile i64* %envptr17183, i64** %vptr17185, align 8 ; &envptr17182[1]
 %vptr17186 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr17183, align 8 
  store volatile i64 %emsg18637, i64* %vptr17186, align 8 ; load; *envptr17183
 %vptr17187 = alloca i64, align 8 
  %cont7147 = call i64 @prim_car(i64 %rvp9280) 
  store volatile i64 %cont7147, i64* %vptr17187, align 8 ; call prim_car
 %vptr17188 = alloca i64, align 8 
  %rvp9276 = call i64 @prim_cdr(i64 %rvp9280) 
  store volatile i64 %rvp9276, i64* %vptr17188, align 8 ; call prim_cdr
 %vptr17189 = alloca i64, align 8 
  %n_639281 = call i64 @prim_null_63(i64 %rvp9276) 
  store volatile i64 %n_639281, i64* %vptr17189, align 8 ; call prim_null_63
  %cmpptr17193 = alloca i1, align 8  %cmp17190 = icmp eq i64 %n_639281, 15 store volatile i1 %cmp17190, i1* %cmpptr17193, align 8; false?
  br i1 %cmp17190, label %else17192, label %then17191                                ; if

then17191:
 %vptr17194 = alloca i64, align 8 
  %h9282 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9282, i64* %vptr17194, align 8 ; call prim_halt
  %vptr17200 = alloca i64*, align 8 
  %cloptr17195 = inttoptr i64 %h9282 to i64* 
  store volatile i64* %cloptr17195, i64** %vptr17200, align 8 ; closure/env cast; i64 -> i64*
  %vptr17201 = alloca i64*, align 8 
  %i0ptr17196 = getelementptr inbounds i64, i64* %cloptr17195, i64 1 
  store volatile i64* %i0ptr17196, i64** %vptr17201, align 8 ; &cloptr17195[1]
 %vptr17202 = alloca i64, align 8 
  %f17198 = load i64, i64* %i0ptr17196, align 8 
  store volatile i64 %f17198, i64* %vptr17202, align 8 ; load; *i0ptr17196
  %fptr17197 = inttoptr i64 %f17198 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17197(i64 %h9282, i64 %h9282)                       ; tail call
  ret void

else17192:
 %vptr17203 = alloca i64, align 8 
  %MT0$x = call i64 @prim_car(i64 %rvp9276) 
  store volatile i64 %MT0$x, i64* %vptr17203, align 8 ; call prim_car
 %vptr17204 = alloca i64, align 8 
  %na9272 = call i64 @prim_cdr(i64 %rvp9276) 
  store volatile i64 %na9272, i64* %vptr17204, align 8 ; call prim_cdr
 %vptr17205 = alloca i64, align 8 
  %n_639277 = call i64 @prim_null_63(i64 %na9272) 
  store volatile i64 %n_639277, i64* %vptr17205, align 8 ; call prim_null_63
  %cmpptr17209 = alloca i1, align 8  %cmp17206 = icmp eq i64 %n_639277, 15 store volatile i1 %cmp17206, i1* %cmpptr17209, align 8; false?
  br i1 %cmp17206, label %else17208, label %then17207                                ; if

then17207:
 %vptr17210 = alloca i64, align 8 
  %a6989 = call i64 @prim_cdr(i64 %MT0$x) 
  store volatile i64 %a6989, i64* %vptr17210, align 8 ; call prim_cdr
 %vptr17211 = alloca i64, align 8 
  %retprim7148 = call i64 @prim_car(i64 %a6989) 
  store volatile i64 %retprim7148, i64* %vptr17211, align 8 ; call prim_car
 %vptr17212 = alloca i64, align 8 
  %arg7747 = add i64 0, 0 
  store volatile i64 %arg7747, i64* %vptr17212, align 8 ; quoted ()
 %vptr17213 = alloca i64, align 8 
  %rva9275 = add i64 0, 0 
  store volatile i64 %rva9275, i64* %vptr17213, align 8 ; quoted ()
 %vptr17214 = alloca i64, align 8 
  %rva9274 = call i64 @prim_cons(i64 %retprim7148, i64 %rva9275) 
  store volatile i64 %rva9274, i64* %vptr17214, align 8 ; call prim_cons
 %vptr17215 = alloca i64, align 8 
  %rva9273 = call i64 @prim_cons(i64 %arg7747, i64 %rva9274) 
  store volatile i64 %rva9273, i64* %vptr17215, align 8 ; call prim_cons
  %vptr17221 = alloca i64*, align 8 
  %cloptr17216 = inttoptr i64 %cont7147 to i64* 
  store volatile i64* %cloptr17216, i64** %vptr17221, align 8 ; closure/env cast; i64 -> i64*
  %vptr17222 = alloca i64*, align 8 
  %i0ptr17217 = getelementptr inbounds i64, i64* %cloptr17216, i64 1 
  store volatile i64* %i0ptr17217, i64** %vptr17222, align 8 ; &cloptr17216[1]
 %vptr17223 = alloca i64, align 8 
  %f17219 = load i64, i64* %i0ptr17217, align 8 
  store volatile i64 %f17219, i64* %vptr17223, align 8 ; load; *i0ptr17217
  %fptr17218 = inttoptr i64 %f17219 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17218(i64 %cont7147, i64 %rva9273)                  ; tail call
  ret void

else17208:
 %vptr17224 = alloca i64, align 8 
  %h9278 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9278, i64* %vptr17224, align 8 ; call prim_halt
  %vptr17230 = alloca i64*, align 8 
  %cloptr17225 = inttoptr i64 %h9278 to i64* 
  store volatile i64* %cloptr17225, i64** %vptr17230, align 8 ; closure/env cast; i64 -> i64*
  %vptr17231 = alloca i64*, align 8 
  %i0ptr17226 = getelementptr inbounds i64, i64* %cloptr17225, i64 1 
  store volatile i64* %i0ptr17226, i64** %vptr17231, align 8 ; &cloptr17225[1]
 %vptr17232 = alloca i64, align 8 
  %f17228 = load i64, i64* %i0ptr17226, align 8 
  store volatile i64 %f17228, i64* %vptr17232, align 8 ; load; *i0ptr17226
  %fptr17227 = inttoptr i64 %f17228 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17227(i64 %h9278, i64 %h9278)                       ; tail call
  ret void
}


define void @lam12181(i64 %env12182, i64 %rvp9293) {
 %vptr17235 = alloca i64, align 8 
  %envptr17233 = inttoptr i64 %env12182 to i64* 
  store volatile i64 %emsg08636, i64* %vptr17235, align 8 ; closure/env cast; i64 -> i64*
  %vptr17236 = alloca i64*, align 8 
  %envptr17234 = getelementptr inbounds i64, i64* %envptr17233, i64 3 
  store volatile i64* %envptr17234, i64** %vptr17236, align 8 ; &envptr17233[2]
 %vptr17237 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr17234, align 8 
  store volatile i64 %emsg08636, i64* %vptr17237, align 8 ; load; *envptr17234
 %vptr17240 = alloca i64, align 8 
  %envptr17238 = inttoptr i64 %env12182 to i64* 
  store volatile i64 %emsg18637, i64* %vptr17240, align 8 ; closure/env cast; i64 -> i64*
  %vptr17241 = alloca i64*, align 8 
  %envptr17239 = getelementptr inbounds i64, i64* %envptr17238, i64 2 
  store volatile i64* %envptr17239, i64** %vptr17241, align 8 ; &envptr17238[1]
 %vptr17242 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr17239, align 8 
  store volatile i64 %emsg18637, i64* %vptr17242, align 8 ; load; *envptr17239
 %vptr17243 = alloca i64, align 8 
  %cont7149 = call i64 @prim_car(i64 %rvp9293) 
  store volatile i64 %cont7149, i64* %vptr17243, align 8 ; call prim_car
 %vptr17244 = alloca i64, align 8 
  %rvp9289 = call i64 @prim_cdr(i64 %rvp9293) 
  store volatile i64 %rvp9289, i64* %vptr17244, align 8 ; call prim_cdr
 %vptr17245 = alloca i64, align 8 
  %n_639294 = call i64 @prim_null_63(i64 %rvp9289) 
  store volatile i64 %n_639294, i64* %vptr17245, align 8 ; call prim_null_63
  %cmpptr17249 = alloca i1, align 8  %cmp17246 = icmp eq i64 %n_639294, 15 store volatile i1 %cmp17246, i1* %cmpptr17249, align 8; false?
  br i1 %cmp17246, label %else17248, label %then17247                                ; if

then17247:
 %vptr17250 = alloca i64, align 8 
  %h9295 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9295, i64* %vptr17250, align 8 ; call prim_halt
  %vptr17256 = alloca i64*, align 8 
  %cloptr17251 = inttoptr i64 %h9295 to i64* 
  store volatile i64* %cloptr17251, i64** %vptr17256, align 8 ; closure/env cast; i64 -> i64*
  %vptr17257 = alloca i64*, align 8 
  %i0ptr17252 = getelementptr inbounds i64, i64* %cloptr17251, i64 1 
  store volatile i64* %i0ptr17252, i64** %vptr17257, align 8 ; &cloptr17251[1]
 %vptr17258 = alloca i64, align 8 
  %f17254 = load i64, i64* %i0ptr17252, align 8 
  store volatile i64 %f17254, i64* %vptr17258, align 8 ; load; *i0ptr17252
  %fptr17253 = inttoptr i64 %f17254 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17253(i64 %h9295, i64 %h9295)                       ; tail call
  ret void

else17248:
 %vptr17259 = alloca i64, align 8 
  %fW9$x = call i64 @prim_car(i64 %rvp9289) 
  store volatile i64 %fW9$x, i64* %vptr17259, align 8 ; call prim_car
 %vptr17260 = alloca i64, align 8 
  %na9285 = call i64 @prim_cdr(i64 %rvp9289) 
  store volatile i64 %na9285, i64* %vptr17260, align 8 ; call prim_cdr
 %vptr17261 = alloca i64, align 8 
  %n_639290 = call i64 @prim_null_63(i64 %na9285) 
  store volatile i64 %n_639290, i64* %vptr17261, align 8 ; call prim_null_63
  %cmpptr17265 = alloca i1, align 8  %cmp17262 = icmp eq i64 %n_639290, 15 store volatile i1 %cmp17262, i1* %cmpptr17265, align 8; false?
  br i1 %cmp17262, label %else17264, label %then17263                                ; if

then17263:
 %vptr17266 = alloca i64, align 8 
  %a6990 = call i64 @prim_cdr(i64 %fW9$x) 
  store volatile i64 %a6990, i64* %vptr17266, align 8 ; call prim_cdr
 %vptr17267 = alloca i64, align 8 
  %a6991 = call i64 @prim_cdr(i64 %a6990) 
  store volatile i64 %a6991, i64* %vptr17267, align 8 ; call prim_cdr
 %vptr17268 = alloca i64, align 8 
  %retprim7150 = call i64 @prim_car(i64 %a6991) 
  store volatile i64 %retprim7150, i64* %vptr17268, align 8 ; call prim_car
 %vptr17269 = alloca i64, align 8 
  %arg7753 = add i64 0, 0 
  store volatile i64 %arg7753, i64* %vptr17269, align 8 ; quoted ()
 %vptr17270 = alloca i64, align 8 
  %rva9288 = add i64 0, 0 
  store volatile i64 %rva9288, i64* %vptr17270, align 8 ; quoted ()
 %vptr17271 = alloca i64, align 8 
  %rva9287 = call i64 @prim_cons(i64 %retprim7150, i64 %rva9288) 
  store volatile i64 %rva9287, i64* %vptr17271, align 8 ; call prim_cons
 %vptr17272 = alloca i64, align 8 
  %rva9286 = call i64 @prim_cons(i64 %arg7753, i64 %rva9287) 
  store volatile i64 %rva9286, i64* %vptr17272, align 8 ; call prim_cons
  %vptr17278 = alloca i64*, align 8 
  %cloptr17273 = inttoptr i64 %cont7149 to i64* 
  store volatile i64* %cloptr17273, i64** %vptr17278, align 8 ; closure/env cast; i64 -> i64*
  %vptr17279 = alloca i64*, align 8 
  %i0ptr17274 = getelementptr inbounds i64, i64* %cloptr17273, i64 1 
  store volatile i64* %i0ptr17274, i64** %vptr17279, align 8 ; &cloptr17273[1]
 %vptr17280 = alloca i64, align 8 
  %f17276 = load i64, i64* %i0ptr17274, align 8 
  store volatile i64 %f17276, i64* %vptr17280, align 8 ; load; *i0ptr17274
  %fptr17275 = inttoptr i64 %f17276 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17275(i64 %cont7149, i64 %rva9286)                  ; tail call
  ret void

else17264:
 %vptr17281 = alloca i64, align 8 
  %h9291 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9291, i64* %vptr17281, align 8 ; call prim_halt
  %vptr17287 = alloca i64*, align 8 
  %cloptr17282 = inttoptr i64 %h9291 to i64* 
  store volatile i64* %cloptr17282, i64** %vptr17287, align 8 ; closure/env cast; i64 -> i64*
  %vptr17288 = alloca i64*, align 8 
  %i0ptr17283 = getelementptr inbounds i64, i64* %cloptr17282, i64 1 
  store volatile i64* %i0ptr17283, i64** %vptr17288, align 8 ; &cloptr17282[1]
 %vptr17289 = alloca i64, align 8 
  %f17285 = load i64, i64* %i0ptr17283, align 8 
  store volatile i64 %f17285, i64* %vptr17289, align 8 ; load; *i0ptr17283
  %fptr17284 = inttoptr i64 %f17285 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17284(i64 %h9291, i64 %h9291)                       ; tail call
  ret void
}


define void @lam12177(i64 %env12178, i64 %rvp9306) {
 %vptr17292 = alloca i64, align 8 
  %envptr17290 = inttoptr i64 %env12178 to i64* 
  store volatile i64 %emsg08636, i64* %vptr17292, align 8 ; closure/env cast; i64 -> i64*
  %vptr17293 = alloca i64*, align 8 
  %envptr17291 = getelementptr inbounds i64, i64* %envptr17290, i64 3 
  store volatile i64* %envptr17291, i64** %vptr17293, align 8 ; &envptr17290[2]
 %vptr17294 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr17291, align 8 
  store volatile i64 %emsg08636, i64* %vptr17294, align 8 ; load; *envptr17291
 %vptr17297 = alloca i64, align 8 
  %envptr17295 = inttoptr i64 %env12178 to i64* 
  store volatile i64 %emsg18637, i64* %vptr17297, align 8 ; closure/env cast; i64 -> i64*
  %vptr17298 = alloca i64*, align 8 
  %envptr17296 = getelementptr inbounds i64, i64* %envptr17295, i64 2 
  store volatile i64* %envptr17296, i64** %vptr17298, align 8 ; &envptr17295[1]
 %vptr17299 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr17296, align 8 
  store volatile i64 %emsg18637, i64* %vptr17299, align 8 ; load; *envptr17296
 %vptr17300 = alloca i64, align 8 
  %cont7151 = call i64 @prim_car(i64 %rvp9306) 
  store volatile i64 %cont7151, i64* %vptr17300, align 8 ; call prim_car
 %vptr17301 = alloca i64, align 8 
  %rvp9302 = call i64 @prim_cdr(i64 %rvp9306) 
  store volatile i64 %rvp9302, i64* %vptr17301, align 8 ; call prim_cdr
 %vptr17302 = alloca i64, align 8 
  %n_639307 = call i64 @prim_null_63(i64 %rvp9302) 
  store volatile i64 %n_639307, i64* %vptr17302, align 8 ; call prim_null_63
  %cmpptr17306 = alloca i1, align 8  %cmp17303 = icmp eq i64 %n_639307, 15 store volatile i1 %cmp17303, i1* %cmpptr17306, align 8; false?
  br i1 %cmp17303, label %else17305, label %then17304                                ; if

then17304:
 %vptr17307 = alloca i64, align 8 
  %h9308 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9308, i64* %vptr17307, align 8 ; call prim_halt
  %vptr17313 = alloca i64*, align 8 
  %cloptr17308 = inttoptr i64 %h9308 to i64* 
  store volatile i64* %cloptr17308, i64** %vptr17313, align 8 ; closure/env cast; i64 -> i64*
  %vptr17314 = alloca i64*, align 8 
  %i0ptr17309 = getelementptr inbounds i64, i64* %cloptr17308, i64 1 
  store volatile i64* %i0ptr17309, i64** %vptr17314, align 8 ; &cloptr17308[1]
 %vptr17315 = alloca i64, align 8 
  %f17311 = load i64, i64* %i0ptr17309, align 8 
  store volatile i64 %f17311, i64* %vptr17315, align 8 ; load; *i0ptr17309
  %fptr17310 = inttoptr i64 %f17311 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17310(i64 %h9308, i64 %h9308)                       ; tail call
  ret void

else17305:
 %vptr17316 = alloca i64, align 8 
  %FkK$x = call i64 @prim_car(i64 %rvp9302) 
  store volatile i64 %FkK$x, i64* %vptr17316, align 8 ; call prim_car
 %vptr17317 = alloca i64, align 8 
  %na9298 = call i64 @prim_cdr(i64 %rvp9302) 
  store volatile i64 %na9298, i64* %vptr17317, align 8 ; call prim_cdr
 %vptr17318 = alloca i64, align 8 
  %n_639303 = call i64 @prim_null_63(i64 %na9298) 
  store volatile i64 %n_639303, i64* %vptr17318, align 8 ; call prim_null_63
  %cmpptr17322 = alloca i1, align 8  %cmp17319 = icmp eq i64 %n_639303, 15 store volatile i1 %cmp17319, i1* %cmpptr17322, align 8; false?
  br i1 %cmp17319, label %else17321, label %then17320                                ; if

then17320:
 %vptr17323 = alloca i64, align 8 
  %a6992 = call i64 @prim_cdr(i64 %FkK$x) 
  store volatile i64 %a6992, i64* %vptr17323, align 8 ; call prim_cdr
 %vptr17324 = alloca i64, align 8 
  %a6993 = call i64 @prim_cdr(i64 %a6992) 
  store volatile i64 %a6993, i64* %vptr17324, align 8 ; call prim_cdr
 %vptr17325 = alloca i64, align 8 
  %a6994 = call i64 @prim_cdr(i64 %a6993) 
  store volatile i64 %a6994, i64* %vptr17325, align 8 ; call prim_cdr
 %vptr17326 = alloca i64, align 8 
  %retprim7152 = call i64 @prim_car(i64 %a6994) 
  store volatile i64 %retprim7152, i64* %vptr17326, align 8 ; call prim_car
 %vptr17327 = alloca i64, align 8 
  %arg7760 = add i64 0, 0 
  store volatile i64 %arg7760, i64* %vptr17327, align 8 ; quoted ()
 %vptr17328 = alloca i64, align 8 
  %rva9301 = add i64 0, 0 
  store volatile i64 %rva9301, i64* %vptr17328, align 8 ; quoted ()
 %vptr17329 = alloca i64, align 8 
  %rva9300 = call i64 @prim_cons(i64 %retprim7152, i64 %rva9301) 
  store volatile i64 %rva9300, i64* %vptr17329, align 8 ; call prim_cons
 %vptr17330 = alloca i64, align 8 
  %rva9299 = call i64 @prim_cons(i64 %arg7760, i64 %rva9300) 
  store volatile i64 %rva9299, i64* %vptr17330, align 8 ; call prim_cons
  %vptr17336 = alloca i64*, align 8 
  %cloptr17331 = inttoptr i64 %cont7151 to i64* 
  store volatile i64* %cloptr17331, i64** %vptr17336, align 8 ; closure/env cast; i64 -> i64*
  %vptr17337 = alloca i64*, align 8 
  %i0ptr17332 = getelementptr inbounds i64, i64* %cloptr17331, i64 1 
  store volatile i64* %i0ptr17332, i64** %vptr17337, align 8 ; &cloptr17331[1]
 %vptr17338 = alloca i64, align 8 
  %f17334 = load i64, i64* %i0ptr17332, align 8 
  store volatile i64 %f17334, i64* %vptr17338, align 8 ; load; *i0ptr17332
  %fptr17333 = inttoptr i64 %f17334 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17333(i64 %cont7151, i64 %rva9299)                  ; tail call
  ret void

else17321:
 %vptr17339 = alloca i64, align 8 
  %h9304 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9304, i64* %vptr17339, align 8 ; call prim_halt
  %vptr17345 = alloca i64*, align 8 
  %cloptr17340 = inttoptr i64 %h9304 to i64* 
  store volatile i64* %cloptr17340, i64** %vptr17345, align 8 ; closure/env cast; i64 -> i64*
  %vptr17346 = alloca i64*, align 8 
  %i0ptr17341 = getelementptr inbounds i64, i64* %cloptr17340, i64 1 
  store volatile i64* %i0ptr17341, i64** %vptr17346, align 8 ; &cloptr17340[1]
 %vptr17347 = alloca i64, align 8 
  %f17343 = load i64, i64* %i0ptr17341, align 8 
  store volatile i64 %f17343, i64* %vptr17347, align 8 ; load; *i0ptr17341
  %fptr17342 = inttoptr i64 %f17343 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17342(i64 %h9304, i64 %h9304)                       ; tail call
  ret void
}


define void @lam12173(i64 %env12174, i64 %rvp9332) {
 %vptr17350 = alloca i64, align 8 
  %envptr17348 = inttoptr i64 %env12174 to i64* 
  store volatile i64 %emsg08636, i64* %vptr17350, align 8 ; closure/env cast; i64 -> i64*
  %vptr17351 = alloca i64*, align 8 
  %envptr17349 = getelementptr inbounds i64, i64* %envptr17348, i64 3 
  store volatile i64* %envptr17349, i64** %vptr17351, align 8 ; &envptr17348[2]
 %vptr17352 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr17349, align 8 
  store volatile i64 %emsg08636, i64* %vptr17352, align 8 ; load; *envptr17349
 %vptr17355 = alloca i64, align 8 
  %envptr17353 = inttoptr i64 %env12174 to i64* 
  store volatile i64 %emsg18637, i64* %vptr17355, align 8 ; closure/env cast; i64 -> i64*
  %vptr17356 = alloca i64*, align 8 
  %envptr17354 = getelementptr inbounds i64, i64* %envptr17353, i64 2 
  store volatile i64* %envptr17354, i64** %vptr17356, align 8 ; &envptr17353[1]
 %vptr17357 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr17354, align 8 
  store volatile i64 %emsg18637, i64* %vptr17357, align 8 ; load; *envptr17354
 %vptr17358 = alloca i64, align 8 
  %cont7153 = call i64 @prim_car(i64 %rvp9332) 
  store volatile i64 %cont7153, i64* %vptr17358, align 8 ; call prim_car
 %vptr17359 = alloca i64, align 8 
  %rvp9328 = call i64 @prim_cdr(i64 %rvp9332) 
  store volatile i64 %rvp9328, i64* %vptr17359, align 8 ; call prim_cdr
 %vptr17360 = alloca i64, align 8 
  %n_639333 = call i64 @prim_null_63(i64 %rvp9328) 
  store volatile i64 %n_639333, i64* %vptr17360, align 8 ; call prim_null_63
  %cmpptr17364 = alloca i1, align 8  %cmp17361 = icmp eq i64 %n_639333, 15 store volatile i1 %cmp17361, i1* %cmpptr17364, align 8; false?
  br i1 %cmp17361, label %else17363, label %then17362                                ; if

then17362:
 %vptr17365 = alloca i64, align 8 
  %h9334 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9334, i64* %vptr17365, align 8 ; call prim_halt
  %vptr17371 = alloca i64*, align 8 
  %cloptr17366 = inttoptr i64 %h9334 to i64* 
  store volatile i64* %cloptr17366, i64** %vptr17371, align 8 ; closure/env cast; i64 -> i64*
  %vptr17372 = alloca i64*, align 8 
  %i0ptr17367 = getelementptr inbounds i64, i64* %cloptr17366, i64 1 
  store volatile i64* %i0ptr17367, i64** %vptr17372, align 8 ; &cloptr17366[1]
 %vptr17373 = alloca i64, align 8 
  %f17369 = load i64, i64* %i0ptr17367, align 8 
  store volatile i64 %f17369, i64* %vptr17373, align 8 ; load; *i0ptr17367
  %fptr17368 = inttoptr i64 %f17369 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17368(i64 %h9334, i64 %h9334)                       ; tail call
  ret void

else17363:
 %vptr17374 = alloca i64, align 8 
  %Zci$h = call i64 @prim_car(i64 %rvp9328) 
  store volatile i64 %Zci$h, i64* %vptr17374, align 8 ; call prim_car
 %vptr17375 = alloca i64, align 8 
  %rvp9324 = call i64 @prim_cdr(i64 %rvp9328) 
  store volatile i64 %rvp9324, i64* %vptr17375, align 8 ; call prim_cdr
 %vptr17376 = alloca i64, align 8 
  %n_639329 = call i64 @prim_null_63(i64 %rvp9324) 
  store volatile i64 %n_639329, i64* %vptr17376, align 8 ; call prim_null_63
  %cmpptr17380 = alloca i1, align 8  %cmp17377 = icmp eq i64 %n_639329, 15 store volatile i1 %cmp17377, i1* %cmpptr17380, align 8; false?
  br i1 %cmp17377, label %else17379, label %then17378                                ; if

then17378:
 %vptr17381 = alloca i64, align 8 
  %h9330 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9330, i64* %vptr17381, align 8 ; call prim_halt
  %vptr17387 = alloca i64*, align 8 
  %cloptr17382 = inttoptr i64 %h9330 to i64* 
  store volatile i64* %cloptr17382, i64** %vptr17387, align 8 ; closure/env cast; i64 -> i64*
  %vptr17388 = alloca i64*, align 8 
  %i0ptr17383 = getelementptr inbounds i64, i64* %cloptr17382, i64 1 
  store volatile i64* %i0ptr17383, i64** %vptr17388, align 8 ; &cloptr17382[1]
 %vptr17389 = alloca i64, align 8 
  %f17385 = load i64, i64* %i0ptr17383, align 8 
  store volatile i64 %f17385, i64* %vptr17389, align 8 ; load; *i0ptr17383
  %fptr17384 = inttoptr i64 %f17385 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17384(i64 %h9330, i64 %h9330)                       ; tail call
  ret void

else17379:
 %vptr17390 = alloca i64, align 8 
  %o7O$k = call i64 @prim_car(i64 %rvp9324) 
  store volatile i64 %o7O$k, i64* %vptr17390, align 8 ; call prim_car
 %vptr17391 = alloca i64, align 8 
  %rvp9320 = call i64 @prim_cdr(i64 %rvp9324) 
  store volatile i64 %rvp9320, i64* %vptr17391, align 8 ; call prim_cdr
 %vptr17392 = alloca i64, align 8 
  %n_639325 = call i64 @prim_null_63(i64 %rvp9320) 
  store volatile i64 %n_639325, i64* %vptr17392, align 8 ; call prim_null_63
  %cmpptr17396 = alloca i1, align 8  %cmp17393 = icmp eq i64 %n_639325, 15 store volatile i1 %cmp17393, i1* %cmpptr17396, align 8; false?
  br i1 %cmp17393, label %else17395, label %then17394                                ; if

then17394:
 %vptr17397 = alloca i64, align 8 
  %h9326 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9326, i64* %vptr17397, align 8 ; call prim_halt
  %vptr17403 = alloca i64*, align 8 
  %cloptr17398 = inttoptr i64 %h9326 to i64* 
  store volatile i64* %cloptr17398, i64** %vptr17403, align 8 ; closure/env cast; i64 -> i64*
  %vptr17404 = alloca i64*, align 8 
  %i0ptr17399 = getelementptr inbounds i64, i64* %cloptr17398, i64 1 
  store volatile i64* %i0ptr17399, i64** %vptr17404, align 8 ; &cloptr17398[1]
 %vptr17405 = alloca i64, align 8 
  %f17401 = load i64, i64* %i0ptr17399, align 8 
  store volatile i64 %f17401, i64* %vptr17405, align 8 ; load; *i0ptr17399
  %fptr17400 = inttoptr i64 %f17401 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17400(i64 %h9326, i64 %h9326)                       ; tail call
  ret void

else17395:
 %vptr17406 = alloca i64, align 8 
  %Dk1$thunk = call i64 @prim_car(i64 %rvp9320) 
  store volatile i64 %Dk1$thunk, i64* %vptr17406, align 8 ; call prim_car
 %vptr17407 = alloca i64, align 8 
  %na9311 = call i64 @prim_cdr(i64 %rvp9320) 
  store volatile i64 %na9311, i64* %vptr17407, align 8 ; call prim_cdr
 %vptr17408 = alloca i64, align 8 
  %n_639321 = call i64 @prim_null_63(i64 %na9311) 
  store volatile i64 %n_639321, i64* %vptr17408, align 8 ; call prim_null_63
  %cmpptr17412 = alloca i1, align 8  %cmp17409 = icmp eq i64 %n_639321, 15 store volatile i1 %cmp17409, i1* %cmpptr17412, align 8; false?
  br i1 %cmp17409, label %else17411, label %then17410                                ; if

then17410:
 %vptr17413 = alloca i64, align 8 
  %KN6$r = call i64 @prim_hash_45ref(i64 %Zci$h, i64 %o7O$k) 
  store volatile i64 %KN6$r, i64* %vptr17413, align 8 ; call prim_hash_45ref
 %vptr17414 = alloca i64, align 8 
  %arg7764 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7764, i64* %vptr17414, align 8 ; quoted int
 %vptr17415 = alloca i64, align 8 
  %a6995 = call i64 @prim_eq_63(i64 %KN6$r, i64 %arg7764) 
  store volatile i64 %a6995, i64* %vptr17415, align 8 ; call prim_eq_63
  %cmpptr17419 = alloca i1, align 8  %cmp17416 = icmp eq i64 %a6995, 15 store volatile i1 %cmp17416, i1* %cmpptr17419, align 8; false?
  br i1 %cmp17416, label %else17418, label %then17417                                ; if

then17417:
 %vptr17420 = alloca i64, align 8 
  %a6996 = call i64 @prim_null_63(i64 %Dk1$thunk) 
  store volatile i64 %a6996, i64* %vptr17420, align 8 ; call prim_null_63
  %cmpptr17424 = alloca i1, align 8  %cmp17421 = icmp eq i64 %a6996, 15 store volatile i1 %cmp17421, i1* %cmpptr17424, align 8; false?
  br i1 %cmp17421, label %else17423, label %then17422                                ; if

then17422:
 %vptr17426 = alloca i64, align 8 
  %arg7767 = call i64 @const_init_string(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @str17425, i32 0, i32 0)) 
  store volatile i64 %arg7767, i64* %vptr17426, align 8 ; quoted string
 %vptr17427 = alloca i64, align 8 
  %retprim7154 = call i64 @prim_halt(i64 %arg7767) 
  store volatile i64 %retprim7154, i64* %vptr17427, align 8 ; call prim_halt
 %vptr17428 = alloca i64, align 8 
  %arg7769 = add i64 0, 0 
  store volatile i64 %arg7769, i64* %vptr17428, align 8 ; quoted ()
 %vptr17429 = alloca i64, align 8 
  %rva9314 = add i64 0, 0 
  store volatile i64 %rva9314, i64* %vptr17429, align 8 ; quoted ()
 %vptr17430 = alloca i64, align 8 
  %rva9313 = call i64 @prim_cons(i64 %retprim7154, i64 %rva9314) 
  store volatile i64 %rva9313, i64* %vptr17430, align 8 ; call prim_cons
 %vptr17431 = alloca i64, align 8 
  %rva9312 = call i64 @prim_cons(i64 %arg7769, i64 %rva9313) 
  store volatile i64 %rva9312, i64* %vptr17431, align 8 ; call prim_cons
  %vptr17437 = alloca i64*, align 8 
  %cloptr17432 = inttoptr i64 %cont7153 to i64* 
  store volatile i64* %cloptr17432, i64** %vptr17437, align 8 ; closure/env cast; i64 -> i64*
  %vptr17438 = alloca i64*, align 8 
  %i0ptr17433 = getelementptr inbounds i64, i64* %cloptr17432, i64 1 
  store volatile i64* %i0ptr17433, i64** %vptr17438, align 8 ; &cloptr17432[1]
 %vptr17439 = alloca i64, align 8 
  %f17435 = load i64, i64* %i0ptr17433, align 8 
  store volatile i64 %f17435, i64* %vptr17439, align 8 ; load; *i0ptr17433
  %fptr17434 = inttoptr i64 %f17435 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17434(i64 %cont7153, i64 %rva9312)                  ; tail call
  ret void

else17423:
 %vptr17440 = alloca i64, align 8 
  %rva9316 = add i64 0, 0 
  store volatile i64 %rva9316, i64* %vptr17440, align 8 ; quoted ()
 %vptr17441 = alloca i64, align 8 
  %rva9315 = call i64 @prim_cons(i64 %cont7153, i64 %rva9316) 
  store volatile i64 %rva9315, i64* %vptr17441, align 8 ; call prim_cons
  %vptr17447 = alloca i64*, align 8 
  %cloptr17442 = inttoptr i64 %Dk1$thunk to i64* 
  store volatile i64* %cloptr17442, i64** %vptr17447, align 8 ; closure/env cast; i64 -> i64*
  %vptr17448 = alloca i64*, align 8 
  %i0ptr17443 = getelementptr inbounds i64, i64* %cloptr17442, i64 1 
  store volatile i64* %i0ptr17443, i64** %vptr17448, align 8 ; &cloptr17442[1]
 %vptr17449 = alloca i64, align 8 
  %f17445 = load i64, i64* %i0ptr17443, align 8 
  store volatile i64 %f17445, i64* %vptr17449, align 8 ; load; *i0ptr17443
  %fptr17444 = inttoptr i64 %f17445 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17444(i64 %Dk1$thunk, i64 %rva9315)                 ; tail call
  ret void

else17418:
 %vptr17450 = alloca i64, align 8 
  %arg7774 = add i64 0, 0 
  store volatile i64 %arg7774, i64* %vptr17450, align 8 ; quoted ()
 %vptr17451 = alloca i64, align 8 
  %rva9319 = add i64 0, 0 
  store volatile i64 %rva9319, i64* %vptr17451, align 8 ; quoted ()
 %vptr17452 = alloca i64, align 8 
  %rva9318 = call i64 @prim_cons(i64 %KN6$r, i64 %rva9319) 
  store volatile i64 %rva9318, i64* %vptr17452, align 8 ; call prim_cons
 %vptr17453 = alloca i64, align 8 
  %rva9317 = call i64 @prim_cons(i64 %arg7774, i64 %rva9318) 
  store volatile i64 %rva9317, i64* %vptr17453, align 8 ; call prim_cons
  %vptr17459 = alloca i64*, align 8 
  %cloptr17454 = inttoptr i64 %cont7153 to i64* 
  store volatile i64* %cloptr17454, i64** %vptr17459, align 8 ; closure/env cast; i64 -> i64*
  %vptr17460 = alloca i64*, align 8 
  %i0ptr17455 = getelementptr inbounds i64, i64* %cloptr17454, i64 1 
  store volatile i64* %i0ptr17455, i64** %vptr17460, align 8 ; &cloptr17454[1]
 %vptr17461 = alloca i64, align 8 
  %f17457 = load i64, i64* %i0ptr17455, align 8 
  store volatile i64 %f17457, i64* %vptr17461, align 8 ; load; *i0ptr17455
  %fptr17456 = inttoptr i64 %f17457 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17456(i64 %cont7153, i64 %rva9317)                  ; tail call
  ret void

else17411:
 %vptr17462 = alloca i64, align 8 
  %h9322 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9322, i64* %vptr17462, align 8 ; call prim_halt
  %vptr17468 = alloca i64*, align 8 
  %cloptr17463 = inttoptr i64 %h9322 to i64* 
  store volatile i64* %cloptr17463, i64** %vptr17468, align 8 ; closure/env cast; i64 -> i64*
  %vptr17469 = alloca i64*, align 8 
  %i0ptr17464 = getelementptr inbounds i64, i64* %cloptr17463, i64 1 
  store volatile i64* %i0ptr17464, i64** %vptr17469, align 8 ; &cloptr17463[1]
 %vptr17470 = alloca i64, align 8 
  %f17466 = load i64, i64* %i0ptr17464, align 8 
  store volatile i64 %f17466, i64* %vptr17470, align 8 ; load; *i0ptr17464
  %fptr17465 = inttoptr i64 %f17466 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17465(i64 %h9322, i64 %h9322)                       ; tail call
  ret void
}


define void @lam12164(i64 %env12165, i64 %rvp9348) {
 %vptr17473 = alloca i64, align 8 
  %envptr17471 = inttoptr i64 %env12165 to i64* 
  store volatile i64 %emsg08636, i64* %vptr17473, align 8 ; closure/env cast; i64 -> i64*
  %vptr17474 = alloca i64*, align 8 
  %envptr17472 = getelementptr inbounds i64, i64* %envptr17471, i64 3 
  store volatile i64* %envptr17472, i64** %vptr17474, align 8 ; &envptr17471[2]
 %vptr17475 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr17472, align 8 
  store volatile i64 %emsg08636, i64* %vptr17475, align 8 ; load; *envptr17472
 %vptr17478 = alloca i64, align 8 
  %envptr17476 = inttoptr i64 %env12165 to i64* 
  store volatile i64 %emsg18637, i64* %vptr17478, align 8 ; closure/env cast; i64 -> i64*
  %vptr17479 = alloca i64*, align 8 
  %envptr17477 = getelementptr inbounds i64, i64* %envptr17476, i64 2 
  store volatile i64* %envptr17477, i64** %vptr17479, align 8 ; &envptr17476[1]
 %vptr17480 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr17477, align 8 
  store volatile i64 %emsg18637, i64* %vptr17480, align 8 ; load; *envptr17477
 %vptr17481 = alloca i64, align 8 
  %cont7155 = call i64 @prim_car(i64 %rvp9348) 
  store volatile i64 %cont7155, i64* %vptr17481, align 8 ; call prim_car
 %vptr17482 = alloca i64, align 8 
  %rvp9344 = call i64 @prim_cdr(i64 %rvp9348) 
  store volatile i64 %rvp9344, i64* %vptr17482, align 8 ; call prim_cdr
 %vptr17483 = alloca i64, align 8 
  %n_639349 = call i64 @prim_null_63(i64 %rvp9344) 
  store volatile i64 %n_639349, i64* %vptr17483, align 8 ; call prim_null_63
  %cmpptr17487 = alloca i1, align 8  %cmp17484 = icmp eq i64 %n_639349, 15 store volatile i1 %cmp17484, i1* %cmpptr17487, align 8; false?
  br i1 %cmp17484, label %else17486, label %then17485                                ; if

then17485:
 %vptr17488 = alloca i64, align 8 
  %h9350 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9350, i64* %vptr17488, align 8 ; call prim_halt
  %vptr17494 = alloca i64*, align 8 
  %cloptr17489 = inttoptr i64 %h9350 to i64* 
  store volatile i64* %cloptr17489, i64** %vptr17494, align 8 ; closure/env cast; i64 -> i64*
  %vptr17495 = alloca i64*, align 8 
  %i0ptr17490 = getelementptr inbounds i64, i64* %cloptr17489, i64 1 
  store volatile i64* %i0ptr17490, i64** %vptr17495, align 8 ; &cloptr17489[1]
 %vptr17496 = alloca i64, align 8 
  %f17492 = load i64, i64* %i0ptr17490, align 8 
  store volatile i64 %f17492, i64* %vptr17496, align 8 ; load; *i0ptr17490
  %fptr17491 = inttoptr i64 %f17492 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17491(i64 %h9350, i64 %h9350)                       ; tail call
  ret void

else17486:
 %vptr17497 = alloca i64, align 8 
  %lkC$p = call i64 @prim_car(i64 %rvp9344) 
  store volatile i64 %lkC$p, i64* %vptr17497, align 8 ; call prim_car
 %vptr17498 = alloca i64, align 8 
  %na9337 = call i64 @prim_cdr(i64 %rvp9344) 
  store volatile i64 %na9337, i64* %vptr17498, align 8 ; call prim_cdr
 %vptr17499 = alloca i64, align 8 
  %n_639345 = call i64 @prim_null_63(i64 %na9337) 
  store volatile i64 %n_639345, i64* %vptr17499, align 8 ; call prim_null_63
  %cmpptr17503 = alloca i1, align 8  %cmp17500 = icmp eq i64 %n_639345, 15 store volatile i1 %cmp17500, i1* %cmpptr17503, align 8; false?
  br i1 %cmp17500, label %else17502, label %then17501                                ; if

then17501:
 %vptr17504 = alloca i64, align 8 
  %a6997 = call i64 @prim_cons_63(i64 %lkC$p) 
  store volatile i64 %a6997, i64* %vptr17504, align 8 ; call prim_cons_63
  %cmpptr17508 = alloca i1, align 8  %cmp17505 = icmp eq i64 %a6997, 15 store volatile i1 %cmp17505, i1* %cmpptr17508, align 8; false?
  br i1 %cmp17505, label %else17507, label %then17506                                ; if

then17506:
 %vptr17509 = alloca i64, align 8 
  %a6998 = call i64 @prim_car(i64 %lkC$p) 
  store volatile i64 %a6998, i64* %vptr17509, align 8 ; call prim_car
 %vptr17511 = alloca i64, align 8 
  %arg7778 = call i64 @const_init_symbol(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @sym17510, i32 0, i32 0)) 
  store volatile i64 %arg7778, i64* %vptr17511, align 8 ; quoted string
 %vptr17512 = alloca i64, align 8 
  %retprim7156 = call i64 @prim_eq_63(i64 %a6998, i64 %arg7778) 
  store volatile i64 %retprim7156, i64* %vptr17512, align 8 ; call prim_eq_63
 %vptr17513 = alloca i64, align 8 
  %arg7781 = add i64 0, 0 
  store volatile i64 %arg7781, i64* %vptr17513, align 8 ; quoted ()
 %vptr17514 = alloca i64, align 8 
  %rva9340 = add i64 0, 0 
  store volatile i64 %rva9340, i64* %vptr17514, align 8 ; quoted ()
 %vptr17515 = alloca i64, align 8 
  %rva9339 = call i64 @prim_cons(i64 %retprim7156, i64 %rva9340) 
  store volatile i64 %rva9339, i64* %vptr17515, align 8 ; call prim_cons
 %vptr17516 = alloca i64, align 8 
  %rva9338 = call i64 @prim_cons(i64 %arg7781, i64 %rva9339) 
  store volatile i64 %rva9338, i64* %vptr17516, align 8 ; call prim_cons
  %vptr17522 = alloca i64*, align 8 
  %cloptr17517 = inttoptr i64 %cont7155 to i64* 
  store volatile i64* %cloptr17517, i64** %vptr17522, align 8 ; closure/env cast; i64 -> i64*
  %vptr17523 = alloca i64*, align 8 
  %i0ptr17518 = getelementptr inbounds i64, i64* %cloptr17517, i64 1 
  store volatile i64* %i0ptr17518, i64** %vptr17523, align 8 ; &cloptr17517[1]
 %vptr17524 = alloca i64, align 8 
  %f17520 = load i64, i64* %i0ptr17518, align 8 
  store volatile i64 %f17520, i64* %vptr17524, align 8 ; load; *i0ptr17518
  %fptr17519 = inttoptr i64 %f17520 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17519(i64 %cont7155, i64 %rva9338)                  ; tail call
  ret void

else17507:
 %vptr17525 = alloca i64, align 8 
  %arg7784 = add i64 0, 0 
  store volatile i64 %arg7784, i64* %vptr17525, align 8 ; quoted ()
 %vptr17526 = alloca i64, align 8 
  %arg7783 = call i64 @const_init_false() 
  store volatile i64 %arg7783, i64* %vptr17526, align 8 ; quoted #f
 %vptr17527 = alloca i64, align 8 
  %rva9343 = add i64 0, 0 
  store volatile i64 %rva9343, i64* %vptr17527, align 8 ; quoted ()
 %vptr17528 = alloca i64, align 8 
  %rva9342 = call i64 @prim_cons(i64 %arg7783, i64 %rva9343) 
  store volatile i64 %rva9342, i64* %vptr17528, align 8 ; call prim_cons
 %vptr17529 = alloca i64, align 8 
  %rva9341 = call i64 @prim_cons(i64 %arg7784, i64 %rva9342) 
  store volatile i64 %rva9341, i64* %vptr17529, align 8 ; call prim_cons
  %vptr17535 = alloca i64*, align 8 
  %cloptr17530 = inttoptr i64 %cont7155 to i64* 
  store volatile i64* %cloptr17530, i64** %vptr17535, align 8 ; closure/env cast; i64 -> i64*
  %vptr17536 = alloca i64*, align 8 
  %i0ptr17531 = getelementptr inbounds i64, i64* %cloptr17530, i64 1 
  store volatile i64* %i0ptr17531, i64** %vptr17536, align 8 ; &cloptr17530[1]
 %vptr17537 = alloca i64, align 8 
  %f17533 = load i64, i64* %i0ptr17531, align 8 
  store volatile i64 %f17533, i64* %vptr17537, align 8 ; load; *i0ptr17531
  %fptr17532 = inttoptr i64 %f17533 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17532(i64 %cont7155, i64 %rva9341)                  ; tail call
  ret void

else17502:
 %vptr17538 = alloca i64, align 8 
  %h9346 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9346, i64* %vptr17538, align 8 ; call prim_halt
  %vptr17544 = alloca i64*, align 8 
  %cloptr17539 = inttoptr i64 %h9346 to i64* 
  store volatile i64* %cloptr17539, i64** %vptr17544, align 8 ; closure/env cast; i64 -> i64*
  %vptr17545 = alloca i64*, align 8 
  %i0ptr17540 = getelementptr inbounds i64, i64* %cloptr17539, i64 1 
  store volatile i64* %i0ptr17540, i64** %vptr17545, align 8 ; &cloptr17539[1]
 %vptr17546 = alloca i64, align 8 
  %f17542 = load i64, i64* %i0ptr17540, align 8 
  store volatile i64 %f17542, i64* %vptr17546, align 8 ; load; *i0ptr17540
  %fptr17541 = inttoptr i64 %f17542 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17541(i64 %h9346, i64 %h9346)                       ; tail call
  ret void
}


define void @lam12156(i64 %env12157, i64 %AWx$lst7287) {
 %vptr17547 = alloca i64, align 8 
  %cont7286 = call i64 @prim_car(i64 %AWx$lst7287) 
  store volatile i64 %cont7286, i64* %vptr17547, align 8 ; call prim_car
 %vptr17548 = alloca i64, align 8 
  %AWx$lst = call i64 @prim_cdr(i64 %AWx$lst7287) 
  store volatile i64 %AWx$lst, i64* %vptr17548, align 8 ; call prim_cdr
 %vptr17549 = alloca i64, align 8 
  %arg7791 = add i64 0, 0 
  store volatile i64 %arg7791, i64* %vptr17549, align 8 ; quoted ()
 %vptr17550 = alloca i64, align 8 
  %rva9354 = add i64 0, 0 
  store volatile i64 %rva9354, i64* %vptr17550, align 8 ; quoted ()
 %vptr17551 = alloca i64, align 8 
  %rva9353 = call i64 @prim_cons(i64 %AWx$lst, i64 %rva9354) 
  store volatile i64 %rva9353, i64* %vptr17551, align 8 ; call prim_cons
 %vptr17552 = alloca i64, align 8 
  %rva9352 = call i64 @prim_cons(i64 %arg7791, i64 %rva9353) 
  store volatile i64 %rva9352, i64* %vptr17552, align 8 ; call prim_cons
  %vptr17558 = alloca i64*, align 8 
  %cloptr17553 = inttoptr i64 %cont7286 to i64* 
  store volatile i64* %cloptr17553, i64** %vptr17558, align 8 ; closure/env cast; i64 -> i64*
  %vptr17559 = alloca i64*, align 8 
  %i0ptr17554 = getelementptr inbounds i64, i64* %cloptr17553, i64 1 
  store volatile i64* %i0ptr17554, i64** %vptr17559, align 8 ; &cloptr17553[1]
 %vptr17560 = alloca i64, align 8 
  %f17556 = load i64, i64* %i0ptr17554, align 8 
  store volatile i64 %f17556, i64* %vptr17560, align 8 ; load; *i0ptr17554
  %fptr17555 = inttoptr i64 %f17556 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17555(i64 %cont7286, i64 %rva9352)                  ; tail call
  ret void
}


define void @lam12152(i64 %env12153, i64 %rvp10728) {
 %vptr17563 = alloca i64, align 8 
  %envptr17561 = inttoptr i64 %env12153 to i64* 
  store volatile i64 %uLY$_37_62, i64* %vptr17563, align 8 ; closure/env cast; i64 -> i64*
  %vptr17564 = alloca i64*, align 8 
  %envptr17562 = getelementptr inbounds i64, i64* %envptr17561, i64 6 
  store volatile i64* %envptr17562, i64** %vptr17564, align 8 ; &envptr17561[5]
 %vptr17565 = alloca i64, align 8 
  %uLY$_37_62 = load i64, i64* %envptr17562, align 8 
  store volatile i64 %uLY$_37_62, i64* %vptr17565, align 8 ; load; *envptr17562
 %vptr17568 = alloca i64, align 8 
  %envptr17566 = inttoptr i64 %env12153 to i64* 
  store volatile i64 %emsg08636, i64* %vptr17568, align 8 ; closure/env cast; i64 -> i64*
  %vptr17569 = alloca i64*, align 8 
  %envptr17567 = getelementptr inbounds i64, i64* %envptr17566, i64 5 
  store volatile i64* %envptr17567, i64** %vptr17569, align 8 ; &envptr17566[4]
 %vptr17570 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr17567, align 8 
  store volatile i64 %emsg08636, i64* %vptr17570, align 8 ; load; *envptr17567
 %vptr17573 = alloca i64, align 8 
  %envptr17571 = inttoptr i64 %env12153 to i64* 
  store volatile i64 %zTP$_37drop, i64* %vptr17573, align 8 ; closure/env cast; i64 -> i64*
  %vptr17574 = alloca i64*, align 8 
  %envptr17572 = getelementptr inbounds i64, i64* %envptr17571, i64 4 
  store volatile i64* %envptr17572, i64** %vptr17574, align 8 ; &envptr17571[3]
 %vptr17575 = alloca i64, align 8 
  %zTP$_37drop = load i64, i64* %envptr17572, align 8 
  store volatile i64 %zTP$_37drop, i64* %vptr17575, align 8 ; load; *envptr17572
 %vptr17578 = alloca i64, align 8 
  %envptr17576 = inttoptr i64 %env12153 to i64* 
  store volatile i64 %Jup$_37length, i64* %vptr17578, align 8 ; closure/env cast; i64 -> i64*
  %vptr17579 = alloca i64*, align 8 
  %envptr17577 = getelementptr inbounds i64, i64* %envptr17576, i64 3 
  store volatile i64* %envptr17577, i64** %vptr17579, align 8 ; &envptr17576[2]
 %vptr17580 = alloca i64, align 8 
  %Jup$_37length = load i64, i64* %envptr17577, align 8 
  store volatile i64 %Jup$_37length, i64* %vptr17580, align 8 ; load; *envptr17577
 %vptr17583 = alloca i64, align 8 
  %envptr17581 = inttoptr i64 %env12153 to i64* 
  store volatile i64 %emsg18637, i64* %vptr17583, align 8 ; closure/env cast; i64 -> i64*
  %vptr17584 = alloca i64*, align 8 
  %envptr17582 = getelementptr inbounds i64, i64* %envptr17581, i64 2 
  store volatile i64* %envptr17582, i64** %vptr17584, align 8 ; &envptr17581[1]
 %vptr17585 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr17582, align 8 
  store volatile i64 %emsg18637, i64* %vptr17585, align 8 ; load; *envptr17582
 %vptr17586 = alloca i64, align 8 
  %_957157 = call i64 @prim_car(i64 %rvp10728) 
  store volatile i64 %_957157, i64* %vptr17586, align 8 ; call prim_car
 %vptr17587 = alloca i64, align 8 
  %rvp10724 = call i64 @prim_cdr(i64 %rvp10728) 
  store volatile i64 %rvp10724, i64* %vptr17587, align 8 ; call prim_cdr
 %vptr17588 = alloca i64, align 8 
  %n_6310729 = call i64 @prim_null_63(i64 %rvp10724) 
  store volatile i64 %n_6310729, i64* %vptr17588, align 8 ; call prim_null_63
  %cmpptr17592 = alloca i1, align 8  %cmp17589 = icmp eq i64 %n_6310729, 15 store volatile i1 %cmp17589, i1* %cmpptr17592, align 8; false?
  br i1 %cmp17589, label %else17591, label %then17590                                ; if

then17590:
 %vptr17593 = alloca i64, align 8 
  %h10730 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10730, i64* %vptr17593, align 8 ; call prim_halt
  %vptr17599 = alloca i64*, align 8 
  %cloptr17594 = inttoptr i64 %h10730 to i64* 
  store volatile i64* %cloptr17594, i64** %vptr17599, align 8 ; closure/env cast; i64 -> i64*
  %vptr17600 = alloca i64*, align 8 
  %i0ptr17595 = getelementptr inbounds i64, i64* %cloptr17594, i64 1 
  store volatile i64* %i0ptr17595, i64** %vptr17600, align 8 ; &cloptr17594[1]
 %vptr17601 = alloca i64, align 8 
  %f17597 = load i64, i64* %i0ptr17595, align 8 
  store volatile i64 %f17597, i64* %vptr17601, align 8 ; load; *i0ptr17595
  %fptr17596 = inttoptr i64 %f17597 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17596(i64 %h10730, i64 %h10730)                     ; tail call
  ret void

else17591:
 %vptr17602 = alloca i64, align 8 
  %gxn$_37raise_45handler = call i64 @prim_car(i64 %rvp10724) 
  store volatile i64 %gxn$_37raise_45handler, i64* %vptr17602, align 8 ; call prim_car
 %vptr17603 = alloca i64, align 8 
  %na9356 = call i64 @prim_cdr(i64 %rvp10724) 
  store volatile i64 %na9356, i64* %vptr17603, align 8 ; call prim_cdr
 %vptr17604 = alloca i64, align 8 
  %n_6310725 = call i64 @prim_null_63(i64 %na9356) 
  store volatile i64 %n_6310725, i64* %vptr17604, align 8 ; call prim_null_63
  %cmpptr17608 = alloca i1, align 8  %cmp17605 = icmp eq i64 %n_6310725, 15 store volatile i1 %cmp17605, i1* %cmpptr17608, align 8; false?
  br i1 %cmp17605, label %else17607, label %then17606                                ; if

then17606:
  %vptr17612 = alloca i64*, align 8 
  %cloptr17609 = call i64* @make_closure(i64 8) 
  store volatile i64* %cloptr17609, i64** %vptr17612, align 8 ; malloc
  %vptr17613 = alloca i64*, align 8 
  %eptr17610 = getelementptr inbounds i64, i64* %cloptr17609, i64 1 
  store volatile i64* %eptr17610, i64** %vptr17613, align 8 ; &cloptr17609[1]
 %vptr17614 = alloca i64, align 8 
  %f17611 = ptrtoint void(i64,i64)* @lam12150 to i64 
  store volatile i64 %f17611, i64* %vptr17614, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f17611, i64* %eptr17610                                                 ; store fptr
 %vptr17615 = alloca i64, align 8 
  %arg7794 = ptrtoint i64* %cloptr17609 to i64 
  store volatile i64 %arg7794, i64* %vptr17615, align 8 ; closure cast; i64* -> i64
  %vptr17624 = alloca i64*, align 8 
  %cloptr17616 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr17616, i64** %vptr17624, align 8 ; malloc
  %vptr17625 = alloca i64*, align 8 
  %eptr17618 = getelementptr inbounds i64, i64* %cloptr17616, i64 2 
  store volatile i64* %eptr17618, i64** %vptr17625, align 8 ; &eptr17618[1]
  %vptr17626 = alloca i64*, align 8 
  %eptr17619 = getelementptr inbounds i64, i64* %cloptr17616, i64 3 
  store volatile i64* %eptr17619, i64** %vptr17626, align 8 ; &eptr17619[2]
  %vptr17627 = alloca i64*, align 8 
  %eptr17620 = getelementptr inbounds i64, i64* %cloptr17616, i64 4 
  store volatile i64* %eptr17620, i64** %vptr17627, align 8 ; &eptr17620[3]
  %vptr17628 = alloca i64*, align 8 
  %eptr17621 = getelementptr inbounds i64, i64* %cloptr17616, i64 5 
  store volatile i64* %eptr17621, i64** %vptr17628, align 8 ; &eptr17621[4]
  %vptr17629 = alloca i64*, align 8 
  %eptr17622 = getelementptr inbounds i64, i64* %cloptr17616, i64 6 
  store volatile i64* %eptr17622, i64** %vptr17629, align 8 ; &eptr17622[5]
  store i64 %emsg18637, i64* %eptr17618                                              ; *eptr17618 = %emsg18637
  store i64 %Jup$_37length, i64* %eptr17619                                          ; *eptr17619 = %Jup$_37length
  store i64 %zTP$_37drop, i64* %eptr17620                                            ; *eptr17620 = %zTP$_37drop
  store i64 %emsg08636, i64* %eptr17621                                              ; *eptr17621 = %emsg08636
  store i64 %uLY$_37_62, i64* %eptr17622                                             ; *eptr17622 = %uLY$_37_62
  %vptr17630 = alloca i64*, align 8 
  %eptr17617 = getelementptr inbounds i64, i64* %cloptr17616, i64 1 
  store volatile i64* %eptr17617, i64** %vptr17630, align 8 ; &cloptr17616[1]
 %vptr17631 = alloca i64, align 8 
  %f17623 = ptrtoint void(i64,i64)* @lam12146 to i64 
  store volatile i64 %f17623, i64* %vptr17631, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f17623, i64* %eptr17617                                                 ; store fptr
 %vptr17632 = alloca i64, align 8 
  %arg7793 = ptrtoint i64* %cloptr17616 to i64 
  store volatile i64 %arg7793, i64* %vptr17632, align 8 ; closure cast; i64* -> i64
 %vptr17633 = alloca i64, align 8 
  %rva10723 = add i64 0, 0 
  store volatile i64 %rva10723, i64* %vptr17633, align 8 ; quoted ()
 %vptr17634 = alloca i64, align 8 
  %rva10722 = call i64 @prim_cons(i64 %arg7793, i64 %rva10723) 
  store volatile i64 %rva10722, i64* %vptr17634, align 8 ; call prim_cons
  %vptr17640 = alloca i64*, align 8 
  %cloptr17635 = inttoptr i64 %arg7794 to i64* 
  store volatile i64* %cloptr17635, i64** %vptr17640, align 8 ; closure/env cast; i64 -> i64*
  %vptr17641 = alloca i64*, align 8 
  %i0ptr17636 = getelementptr inbounds i64, i64* %cloptr17635, i64 1 
  store volatile i64* %i0ptr17636, i64** %vptr17641, align 8 ; &cloptr17635[1]
 %vptr17642 = alloca i64, align 8 
  %f17638 = load i64, i64* %i0ptr17636, align 8 
  store volatile i64 %f17638, i64* %vptr17642, align 8 ; load; *i0ptr17636
  %fptr17637 = inttoptr i64 %f17638 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17637(i64 %arg7794, i64 %rva10722)                  ; tail call
  ret void

else17607:
 %vptr17643 = alloca i64, align 8 
  %h10726 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10726, i64* %vptr17643, align 8 ; call prim_halt
  %vptr17649 = alloca i64*, align 8 
  %cloptr17644 = inttoptr i64 %h10726 to i64* 
  store volatile i64* %cloptr17644, i64** %vptr17649, align 8 ; closure/env cast; i64 -> i64*
  %vptr17650 = alloca i64*, align 8 
  %i0ptr17645 = getelementptr inbounds i64, i64* %cloptr17644, i64 1 
  store volatile i64* %i0ptr17645, i64** %vptr17650, align 8 ; &cloptr17644[1]
 %vptr17651 = alloca i64, align 8 
  %f17647 = load i64, i64* %i0ptr17645, align 8 
  store volatile i64 %f17647, i64* %vptr17651, align 8 ; load; *i0ptr17645
  %fptr17646 = inttoptr i64 %f17647 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17646(i64 %h10726, i64 %h10726)                     ; tail call
  ret void
}


define void @lam12150(i64 %env12151, i64 %NOg$lst7285) {
 %vptr17652 = alloca i64, align 8 
  %cont7284 = call i64 @prim_car(i64 %NOg$lst7285) 
  store volatile i64 %cont7284, i64* %vptr17652, align 8 ; call prim_car
 %vptr17653 = alloca i64, align 8 
  %NOg$lst = call i64 @prim_cdr(i64 %NOg$lst7285) 
  store volatile i64 %NOg$lst, i64* %vptr17653, align 8 ; call prim_cdr
 %vptr17654 = alloca i64, align 8 
  %arg7798 = add i64 0, 0 
  store volatile i64 %arg7798, i64* %vptr17654, align 8 ; quoted ()
 %vptr17655 = alloca i64, align 8 
  %rva9359 = add i64 0, 0 
  store volatile i64 %rva9359, i64* %vptr17655, align 8 ; quoted ()
 %vptr17656 = alloca i64, align 8 
  %rva9358 = call i64 @prim_cons(i64 %NOg$lst, i64 %rva9359) 
  store volatile i64 %rva9358, i64* %vptr17656, align 8 ; call prim_cons
 %vptr17657 = alloca i64, align 8 
  %rva9357 = call i64 @prim_cons(i64 %arg7798, i64 %rva9358) 
  store volatile i64 %rva9357, i64* %vptr17657, align 8 ; call prim_cons
  %vptr17663 = alloca i64*, align 8 
  %cloptr17658 = inttoptr i64 %cont7284 to i64* 
  store volatile i64* %cloptr17658, i64** %vptr17663, align 8 ; closure/env cast; i64 -> i64*
  %vptr17664 = alloca i64*, align 8 
  %i0ptr17659 = getelementptr inbounds i64, i64* %cloptr17658, i64 1 
  store volatile i64* %i0ptr17659, i64** %vptr17664, align 8 ; &cloptr17658[1]
 %vptr17665 = alloca i64, align 8 
  %f17661 = load i64, i64* %i0ptr17659, align 8 
  store volatile i64 %f17661, i64* %vptr17665, align 8 ; load; *i0ptr17659
  %fptr17660 = inttoptr i64 %f17661 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17660(i64 %cont7284, i64 %rva9357)                  ; tail call
  ret void
}


define void @lam12146(i64 %env12147, i64 %rvp10718) {
 %vptr17668 = alloca i64, align 8 
  %envptr17666 = inttoptr i64 %env12147 to i64* 
  store volatile i64 %uLY$_37_62, i64* %vptr17668, align 8 ; closure/env cast; i64 -> i64*
  %vptr17669 = alloca i64*, align 8 
  %envptr17667 = getelementptr inbounds i64, i64* %envptr17666, i64 6 
  store volatile i64* %envptr17667, i64** %vptr17669, align 8 ; &envptr17666[5]
 %vptr17670 = alloca i64, align 8 
  %uLY$_37_62 = load i64, i64* %envptr17667, align 8 
  store volatile i64 %uLY$_37_62, i64* %vptr17670, align 8 ; load; *envptr17667
 %vptr17673 = alloca i64, align 8 
  %envptr17671 = inttoptr i64 %env12147 to i64* 
  store volatile i64 %emsg08636, i64* %vptr17673, align 8 ; closure/env cast; i64 -> i64*
  %vptr17674 = alloca i64*, align 8 
  %envptr17672 = getelementptr inbounds i64, i64* %envptr17671, i64 5 
  store volatile i64* %envptr17672, i64** %vptr17674, align 8 ; &envptr17671[4]
 %vptr17675 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr17672, align 8 
  store volatile i64 %emsg08636, i64* %vptr17675, align 8 ; load; *envptr17672
 %vptr17678 = alloca i64, align 8 
  %envptr17676 = inttoptr i64 %env12147 to i64* 
  store volatile i64 %zTP$_37drop, i64* %vptr17678, align 8 ; closure/env cast; i64 -> i64*
  %vptr17679 = alloca i64*, align 8 
  %envptr17677 = getelementptr inbounds i64, i64* %envptr17676, i64 4 
  store volatile i64* %envptr17677, i64** %vptr17679, align 8 ; &envptr17676[3]
 %vptr17680 = alloca i64, align 8 
  %zTP$_37drop = load i64, i64* %envptr17677, align 8 
  store volatile i64 %zTP$_37drop, i64* %vptr17680, align 8 ; load; *envptr17677
 %vptr17683 = alloca i64, align 8 
  %envptr17681 = inttoptr i64 %env12147 to i64* 
  store volatile i64 %Jup$_37length, i64* %vptr17683, align 8 ; closure/env cast; i64 -> i64*
  %vptr17684 = alloca i64*, align 8 
  %envptr17682 = getelementptr inbounds i64, i64* %envptr17681, i64 3 
  store volatile i64* %envptr17682, i64** %vptr17684, align 8 ; &envptr17681[2]
 %vptr17685 = alloca i64, align 8 
  %Jup$_37length = load i64, i64* %envptr17682, align 8 
  store volatile i64 %Jup$_37length, i64* %vptr17685, align 8 ; load; *envptr17682
 %vptr17688 = alloca i64, align 8 
  %envptr17686 = inttoptr i64 %env12147 to i64* 
  store volatile i64 %emsg18637, i64* %vptr17688, align 8 ; closure/env cast; i64 -> i64*
  %vptr17689 = alloca i64*, align 8 
  %envptr17687 = getelementptr inbounds i64, i64* %envptr17686, i64 2 
  store volatile i64* %envptr17687, i64** %vptr17689, align 8 ; &envptr17686[1]
 %vptr17690 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr17687, align 8 
  store volatile i64 %emsg18637, i64* %vptr17690, align 8 ; load; *envptr17687
 %vptr17691 = alloca i64, align 8 
  %_957282 = call i64 @prim_car(i64 %rvp10718) 
  store volatile i64 %_957282, i64* %vptr17691, align 8 ; call prim_car
 %vptr17692 = alloca i64, align 8 
  %rvp10714 = call i64 @prim_cdr(i64 %rvp10718) 
  store volatile i64 %rvp10714, i64* %vptr17692, align 8 ; call prim_cdr
 %vptr17693 = alloca i64, align 8 
  %n_6310719 = call i64 @prim_null_63(i64 %rvp10714) 
  store volatile i64 %n_6310719, i64* %vptr17693, align 8 ; call prim_null_63
  %cmpptr17697 = alloca i1, align 8  %cmp17694 = icmp eq i64 %n_6310719, 15 store volatile i1 %cmp17694, i1* %cmpptr17697, align 8; false?
  br i1 %cmp17694, label %else17696, label %then17695                                ; if

then17695:
 %vptr17698 = alloca i64, align 8 
  %h10720 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10720, i64* %vptr17698, align 8 ; call prim_halt
  %vptr17704 = alloca i64*, align 8 
  %cloptr17699 = inttoptr i64 %h10720 to i64* 
  store volatile i64* %cloptr17699, i64** %vptr17704, align 8 ; closure/env cast; i64 -> i64*
  %vptr17705 = alloca i64*, align 8 
  %i0ptr17700 = getelementptr inbounds i64, i64* %cloptr17699, i64 1 
  store volatile i64* %i0ptr17700, i64** %vptr17705, align 8 ; &cloptr17699[1]
 %vptr17706 = alloca i64, align 8 
  %f17702 = load i64, i64* %i0ptr17700, align 8 
  store volatile i64 %f17702, i64* %vptr17706, align 8 ; load; *i0ptr17700
  %fptr17701 = inttoptr i64 %f17702 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17701(i64 %h10720, i64 %h10720)                     ; tail call
  ret void

else17696:
 %vptr17707 = alloca i64, align 8 
  %a6999 = call i64 @prim_car(i64 %rvp10714) 
  store volatile i64 %a6999, i64* %vptr17707, align 8 ; call prim_car
 %vptr17708 = alloca i64, align 8 
  %na9361 = call i64 @prim_cdr(i64 %rvp10714) 
  store volatile i64 %na9361, i64* %vptr17708, align 8 ; call prim_cdr
 %vptr17709 = alloca i64, align 8 
  %n_6310715 = call i64 @prim_null_63(i64 %na9361) 
  store volatile i64 %n_6310715, i64* %vptr17709, align 8 ; call prim_null_63
  %cmpptr17713 = alloca i1, align 8  %cmp17710 = icmp eq i64 %n_6310715, 15 store volatile i1 %cmp17710, i1* %cmpptr17713, align 8; false?
  br i1 %cmp17710, label %else17712, label %then17711                                ; if

then17711:
 %vptr17714 = alloca i64, align 8 
  %arg7801 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg7801, i64* %vptr17714, align 8 ; quoted int
 %vptr17715 = alloca i64, align 8 
  %retprim7283 = call i64 @prim_make_45vector(i64 %arg7801, i64 %a6999) 
  store volatile i64 %retprim7283, i64* %vptr17715, align 8 ; call prim_make_45vector
  %vptr17724 = alloca i64*, align 8 
  %cloptr17716 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr17716, i64** %vptr17724, align 8 ; malloc
  %vptr17725 = alloca i64*, align 8 
  %eptr17718 = getelementptr inbounds i64, i64* %cloptr17716, i64 2 
  store volatile i64* %eptr17718, i64** %vptr17725, align 8 ; &eptr17718[1]
  %vptr17726 = alloca i64*, align 8 
  %eptr17719 = getelementptr inbounds i64, i64* %cloptr17716, i64 3 
  store volatile i64* %eptr17719, i64** %vptr17726, align 8 ; &eptr17719[2]
  %vptr17727 = alloca i64*, align 8 
  %eptr17720 = getelementptr inbounds i64, i64* %cloptr17716, i64 4 
  store volatile i64* %eptr17720, i64** %vptr17727, align 8 ; &eptr17720[3]
  %vptr17728 = alloca i64*, align 8 
  %eptr17721 = getelementptr inbounds i64, i64* %cloptr17716, i64 5 
  store volatile i64* %eptr17721, i64** %vptr17728, align 8 ; &eptr17721[4]
  %vptr17729 = alloca i64*, align 8 
  %eptr17722 = getelementptr inbounds i64, i64* %cloptr17716, i64 6 
  store volatile i64* %eptr17722, i64** %vptr17729, align 8 ; &eptr17722[5]
  store i64 %emsg18637, i64* %eptr17718                                              ; *eptr17718 = %emsg18637
  store i64 %Jup$_37length, i64* %eptr17719                                          ; *eptr17719 = %Jup$_37length
  store i64 %zTP$_37drop, i64* %eptr17720                                            ; *eptr17720 = %zTP$_37drop
  store i64 %emsg08636, i64* %eptr17721                                              ; *eptr17721 = %emsg08636
  store i64 %uLY$_37_62, i64* %eptr17722                                             ; *eptr17722 = %uLY$_37_62
  %vptr17730 = alloca i64*, align 8 
  %eptr17717 = getelementptr inbounds i64, i64* %cloptr17716, i64 1 
  store volatile i64* %eptr17717, i64** %vptr17730, align 8 ; &cloptr17716[1]
 %vptr17731 = alloca i64, align 8 
  %f17723 = ptrtoint void(i64,i64)* @lam12143 to i64 
  store volatile i64 %f17723, i64* %vptr17731, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f17723, i64* %eptr17717                                                 ; store fptr
 %vptr17732 = alloca i64, align 8 
  %arg7804 = ptrtoint i64* %cloptr17716 to i64 
  store volatile i64 %arg7804, i64* %vptr17732, align 8 ; closure cast; i64* -> i64
 %vptr17733 = alloca i64, align 8 
  %arg7803 = add i64 0, 0 
  store volatile i64 %arg7803, i64* %vptr17733, align 8 ; quoted ()
 %vptr17734 = alloca i64, align 8 
  %rva10713 = add i64 0, 0 
  store volatile i64 %rva10713, i64* %vptr17734, align 8 ; quoted ()
 %vptr17735 = alloca i64, align 8 
  %rva10712 = call i64 @prim_cons(i64 %retprim7283, i64 %rva10713) 
  store volatile i64 %rva10712, i64* %vptr17735, align 8 ; call prim_cons
 %vptr17736 = alloca i64, align 8 
  %rva10711 = call i64 @prim_cons(i64 %arg7803, i64 %rva10712) 
  store volatile i64 %rva10711, i64* %vptr17736, align 8 ; call prim_cons
  %vptr17742 = alloca i64*, align 8 
  %cloptr17737 = inttoptr i64 %arg7804 to i64* 
  store volatile i64* %cloptr17737, i64** %vptr17742, align 8 ; closure/env cast; i64 -> i64*
  %vptr17743 = alloca i64*, align 8 
  %i0ptr17738 = getelementptr inbounds i64, i64* %cloptr17737, i64 1 
  store volatile i64* %i0ptr17738, i64** %vptr17743, align 8 ; &cloptr17737[1]
 %vptr17744 = alloca i64, align 8 
  %f17740 = load i64, i64* %i0ptr17738, align 8 
  store volatile i64 %f17740, i64* %vptr17744, align 8 ; load; *i0ptr17738
  %fptr17739 = inttoptr i64 %f17740 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17739(i64 %arg7804, i64 %rva10711)                  ; tail call
  ret void

else17712:
 %vptr17745 = alloca i64, align 8 
  %h10716 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10716, i64* %vptr17745, align 8 ; call prim_halt
  %vptr17751 = alloca i64*, align 8 
  %cloptr17746 = inttoptr i64 %h10716 to i64* 
  store volatile i64* %cloptr17746, i64** %vptr17751, align 8 ; closure/env cast; i64 -> i64*
  %vptr17752 = alloca i64*, align 8 
  %i0ptr17747 = getelementptr inbounds i64, i64* %cloptr17746, i64 1 
  store volatile i64* %i0ptr17747, i64** %vptr17752, align 8 ; &cloptr17746[1]
 %vptr17753 = alloca i64, align 8 
  %f17749 = load i64, i64* %i0ptr17747, align 8 
  store volatile i64 %f17749, i64* %vptr17753, align 8 ; load; *i0ptr17747
  %fptr17748 = inttoptr i64 %f17749 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17748(i64 %h10716, i64 %h10716)                     ; tail call
  ret void
}


define void @lam12143(i64 %env12144, i64 %rvp10707) {
 %vptr17756 = alloca i64, align 8 
  %envptr17754 = inttoptr i64 %env12144 to i64* 
  store volatile i64 %uLY$_37_62, i64* %vptr17756, align 8 ; closure/env cast; i64 -> i64*
  %vptr17757 = alloca i64*, align 8 
  %envptr17755 = getelementptr inbounds i64, i64* %envptr17754, i64 6 
  store volatile i64* %envptr17755, i64** %vptr17757, align 8 ; &envptr17754[5]
 %vptr17758 = alloca i64, align 8 
  %uLY$_37_62 = load i64, i64* %envptr17755, align 8 
  store volatile i64 %uLY$_37_62, i64* %vptr17758, align 8 ; load; *envptr17755
 %vptr17761 = alloca i64, align 8 
  %envptr17759 = inttoptr i64 %env12144 to i64* 
  store volatile i64 %emsg08636, i64* %vptr17761, align 8 ; closure/env cast; i64 -> i64*
  %vptr17762 = alloca i64*, align 8 
  %envptr17760 = getelementptr inbounds i64, i64* %envptr17759, i64 5 
  store volatile i64* %envptr17760, i64** %vptr17762, align 8 ; &envptr17759[4]
 %vptr17763 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr17760, align 8 
  store volatile i64 %emsg08636, i64* %vptr17763, align 8 ; load; *envptr17760
 %vptr17766 = alloca i64, align 8 
  %envptr17764 = inttoptr i64 %env12144 to i64* 
  store volatile i64 %zTP$_37drop, i64* %vptr17766, align 8 ; closure/env cast; i64 -> i64*
  %vptr17767 = alloca i64*, align 8 
  %envptr17765 = getelementptr inbounds i64, i64* %envptr17764, i64 4 
  store volatile i64* %envptr17765, i64** %vptr17767, align 8 ; &envptr17764[3]
 %vptr17768 = alloca i64, align 8 
  %zTP$_37drop = load i64, i64* %envptr17765, align 8 
  store volatile i64 %zTP$_37drop, i64* %vptr17768, align 8 ; load; *envptr17765
 %vptr17771 = alloca i64, align 8 
  %envptr17769 = inttoptr i64 %env12144 to i64* 
  store volatile i64 %Jup$_37length, i64* %vptr17771, align 8 ; closure/env cast; i64 -> i64*
  %vptr17772 = alloca i64*, align 8 
  %envptr17770 = getelementptr inbounds i64, i64* %envptr17769, i64 3 
  store volatile i64* %envptr17770, i64** %vptr17772, align 8 ; &envptr17769[2]
 %vptr17773 = alloca i64, align 8 
  %Jup$_37length = load i64, i64* %envptr17770, align 8 
  store volatile i64 %Jup$_37length, i64* %vptr17773, align 8 ; load; *envptr17770
 %vptr17776 = alloca i64, align 8 
  %envptr17774 = inttoptr i64 %env12144 to i64* 
  store volatile i64 %emsg18637, i64* %vptr17776, align 8 ; closure/env cast; i64 -> i64*
  %vptr17777 = alloca i64*, align 8 
  %envptr17775 = getelementptr inbounds i64, i64* %envptr17774, i64 2 
  store volatile i64* %envptr17775, i64** %vptr17777, align 8 ; &envptr17774[1]
 %vptr17778 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr17775, align 8 
  store volatile i64 %emsg18637, i64* %vptr17778, align 8 ; load; *envptr17775
 %vptr17779 = alloca i64, align 8 
  %_957158 = call i64 @prim_car(i64 %rvp10707) 
  store volatile i64 %_957158, i64* %vptr17779, align 8 ; call prim_car
 %vptr17780 = alloca i64, align 8 
  %rvp10703 = call i64 @prim_cdr(i64 %rvp10707) 
  store volatile i64 %rvp10703, i64* %vptr17780, align 8 ; call prim_cdr
 %vptr17781 = alloca i64, align 8 
  %n_6310708 = call i64 @prim_null_63(i64 %rvp10703) 
  store volatile i64 %n_6310708, i64* %vptr17781, align 8 ; call prim_null_63
  %cmpptr17785 = alloca i1, align 8  %cmp17782 = icmp eq i64 %n_6310708, 15 store volatile i1 %cmp17782, i1* %cmpptr17785, align 8; false?
  br i1 %cmp17782, label %else17784, label %then17783                                ; if

then17783:
 %vptr17786 = alloca i64, align 8 
  %h10709 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10709, i64* %vptr17786, align 8 ; call prim_halt
  %vptr17792 = alloca i64*, align 8 
  %cloptr17787 = inttoptr i64 %h10709 to i64* 
  store volatile i64* %cloptr17787, i64** %vptr17792, align 8 ; closure/env cast; i64 -> i64*
  %vptr17793 = alloca i64*, align 8 
  %i0ptr17788 = getelementptr inbounds i64, i64* %cloptr17787, i64 1 
  store volatile i64* %i0ptr17788, i64** %vptr17793, align 8 ; &cloptr17787[1]
 %vptr17794 = alloca i64, align 8 
  %f17790 = load i64, i64* %i0ptr17788, align 8 
  store volatile i64 %f17790, i64* %vptr17794, align 8 ; load; *i0ptr17788
  %fptr17789 = inttoptr i64 %f17790 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17789(i64 %h10709, i64 %h10709)                     ; tail call
  ret void

else17784:
 %vptr17795 = alloca i64, align 8 
  %SdC$_37wind_45stack = call i64 @prim_car(i64 %rvp10703) 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr17795, align 8 ; call prim_car
 %vptr17796 = alloca i64, align 8 
  %na9363 = call i64 @prim_cdr(i64 %rvp10703) 
  store volatile i64 %na9363, i64* %vptr17796, align 8 ; call prim_cdr
 %vptr17797 = alloca i64, align 8 
  %n_6310704 = call i64 @prim_null_63(i64 %na9363) 
  store volatile i64 %n_6310704, i64* %vptr17797, align 8 ; call prim_null_63
  %cmpptr17801 = alloca i1, align 8  %cmp17798 = icmp eq i64 %n_6310704, 15 store volatile i1 %cmp17798, i1* %cmpptr17801, align 8; false?
  br i1 %cmp17798, label %else17800, label %then17799                                ; if

then17799:
  %vptr17810 = alloca i64*, align 8 
  %cloptr17802 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr17802, i64** %vptr17810, align 8 ; malloc
  %vptr17811 = alloca i64*, align 8 
  %eptr17804 = getelementptr inbounds i64, i64* %cloptr17802, i64 2 
  store volatile i64* %eptr17804, i64** %vptr17811, align 8 ; &eptr17804[1]
  %vptr17812 = alloca i64*, align 8 
  %eptr17805 = getelementptr inbounds i64, i64* %cloptr17802, i64 3 
  store volatile i64* %eptr17805, i64** %vptr17812, align 8 ; &eptr17805[2]
  %vptr17813 = alloca i64*, align 8 
  %eptr17806 = getelementptr inbounds i64, i64* %cloptr17802, i64 4 
  store volatile i64* %eptr17806, i64** %vptr17813, align 8 ; &eptr17806[3]
  %vptr17814 = alloca i64*, align 8 
  %eptr17807 = getelementptr inbounds i64, i64* %cloptr17802, i64 5 
  store volatile i64* %eptr17807, i64** %vptr17814, align 8 ; &eptr17807[4]
  %vptr17815 = alloca i64*, align 8 
  %eptr17808 = getelementptr inbounds i64, i64* %cloptr17802, i64 6 
  store volatile i64* %eptr17808, i64** %vptr17815, align 8 ; &eptr17808[5]
  store i64 %emsg18637, i64* %eptr17804                                              ; *eptr17804 = %emsg18637
  store i64 %Jup$_37length, i64* %eptr17805                                          ; *eptr17805 = %Jup$_37length
  store i64 %zTP$_37drop, i64* %eptr17806                                            ; *eptr17806 = %zTP$_37drop
  store i64 %emsg08636, i64* %eptr17807                                              ; *eptr17807 = %emsg08636
  store i64 %uLY$_37_62, i64* %eptr17808                                             ; *eptr17808 = %uLY$_37_62
  %vptr17816 = alloca i64*, align 8 
  %eptr17803 = getelementptr inbounds i64, i64* %cloptr17802, i64 1 
  store volatile i64* %eptr17803, i64** %vptr17816, align 8 ; &cloptr17802[1]
 %vptr17817 = alloca i64, align 8 
  %f17809 = ptrtoint void(i64,i64)* @lam12141 to i64 
  store volatile i64 %f17809, i64* %vptr17817, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f17809, i64* %eptr17803                                                 ; store fptr
 %vptr17818 = alloca i64, align 8 
  %fDa$_37common_45tail = ptrtoint i64* %cloptr17802 to i64 
  store volatile i64 %fDa$_37common_45tail, i64* %vptr17818, align 8 ; closure cast; i64* -> i64
  %vptr17826 = alloca i64*, align 8 
  %cloptr17819 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr17819, i64** %vptr17826, align 8 ; malloc
  %vptr17827 = alloca i64*, align 8 
  %eptr17821 = getelementptr inbounds i64, i64* %cloptr17819, i64 2 
  store volatile i64* %eptr17821, i64** %vptr17827, align 8 ; &eptr17821[1]
  %vptr17828 = alloca i64*, align 8 
  %eptr17822 = getelementptr inbounds i64, i64* %cloptr17819, i64 3 
  store volatile i64* %eptr17822, i64** %vptr17828, align 8 ; &eptr17822[2]
  %vptr17829 = alloca i64*, align 8 
  %eptr17823 = getelementptr inbounds i64, i64* %cloptr17819, i64 4 
  store volatile i64* %eptr17823, i64** %vptr17829, align 8 ; &eptr17823[3]
  %vptr17830 = alloca i64*, align 8 
  %eptr17824 = getelementptr inbounds i64, i64* %cloptr17819, i64 5 
  store volatile i64* %eptr17824, i64** %vptr17830, align 8 ; &eptr17824[4]
  store i64 %fDa$_37common_45tail, i64* %eptr17821                                   ; *eptr17821 = %fDa$_37common_45tail
  store i64 %emsg18637, i64* %eptr17822                                              ; *eptr17822 = %emsg18637
  store i64 %SdC$_37wind_45stack, i64* %eptr17823                                    ; *eptr17823 = %SdC$_37wind_45stack
  store i64 %emsg08636, i64* %eptr17824                                              ; *eptr17824 = %emsg08636
  %vptr17831 = alloca i64*, align 8 
  %eptr17820 = getelementptr inbounds i64, i64* %cloptr17819, i64 1 
  store volatile i64* %eptr17820, i64** %vptr17831, align 8 ; &cloptr17819[1]
 %vptr17832 = alloca i64, align 8 
  %f17825 = ptrtoint void(i64,i64)* @lam12079 to i64 
  store volatile i64 %f17825, i64* %vptr17832, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f17825, i64* %eptr17820                                                 ; store fptr
 %vptr17833 = alloca i64, align 8 
  %U8g$_37do_45wind = ptrtoint i64* %cloptr17819 to i64 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr17833, align 8 ; closure cast; i64* -> i64
  %vptr17837 = alloca i64*, align 8 
  %cloptr17834 = call i64* @make_closure(i64 8) 
  store volatile i64* %cloptr17834, i64** %vptr17837, align 8 ; malloc
  %vptr17838 = alloca i64*, align 8 
  %eptr17835 = getelementptr inbounds i64, i64* %cloptr17834, i64 1 
  store volatile i64* %eptr17835, i64** %vptr17838, align 8 ; &cloptr17834[1]
 %vptr17839 = alloca i64, align 8 
  %f17836 = ptrtoint void(i64,i64)* @lam12012 to i64 
  store volatile i64 %f17836, i64* %vptr17839, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f17836, i64* %eptr17835                                                 ; store fptr
 %vptr17840 = alloca i64, align 8 
  %arg7990 = ptrtoint i64* %cloptr17834 to i64 
  store volatile i64 %arg7990, i64* %vptr17840, align 8 ; closure cast; i64* -> i64
  %vptr17848 = alloca i64*, align 8 
  %cloptr17841 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr17841, i64** %vptr17848, align 8 ; malloc
  %vptr17849 = alloca i64*, align 8 
  %eptr17843 = getelementptr inbounds i64, i64* %cloptr17841, i64 2 
  store volatile i64* %eptr17843, i64** %vptr17849, align 8 ; &eptr17843[1]
  %vptr17850 = alloca i64*, align 8 
  %eptr17844 = getelementptr inbounds i64, i64* %cloptr17841, i64 3 
  store volatile i64* %eptr17844, i64** %vptr17850, align 8 ; &eptr17844[2]
  %vptr17851 = alloca i64*, align 8 
  %eptr17845 = getelementptr inbounds i64, i64* %cloptr17841, i64 4 
  store volatile i64* %eptr17845, i64** %vptr17851, align 8 ; &eptr17845[3]
  %vptr17852 = alloca i64*, align 8 
  %eptr17846 = getelementptr inbounds i64, i64* %cloptr17841, i64 5 
  store volatile i64* %eptr17846, i64** %vptr17852, align 8 ; &eptr17846[4]
  store i64 %emsg18637, i64* %eptr17843                                              ; *eptr17843 = %emsg18637
  store i64 %SdC$_37wind_45stack, i64* %eptr17844                                    ; *eptr17844 = %SdC$_37wind_45stack
  store i64 %emsg08636, i64* %eptr17845                                              ; *eptr17845 = %emsg08636
  store i64 %U8g$_37do_45wind, i64* %eptr17846                                       ; *eptr17846 = %U8g$_37do_45wind
  %vptr17853 = alloca i64*, align 8 
  %eptr17842 = getelementptr inbounds i64, i64* %cloptr17841, i64 1 
  store volatile i64* %eptr17842, i64** %vptr17853, align 8 ; &cloptr17841[1]
 %vptr17854 = alloca i64, align 8 
  %f17847 = ptrtoint void(i64,i64)* @lam12008 to i64 
  store volatile i64 %f17847, i64* %vptr17854, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f17847, i64* %eptr17842                                                 ; store fptr
 %vptr17855 = alloca i64, align 8 
  %arg7989 = ptrtoint i64* %cloptr17841 to i64 
  store volatile i64 %arg7989, i64* %vptr17855, align 8 ; closure cast; i64* -> i64
 %vptr17856 = alloca i64, align 8 
  %rva10702 = add i64 0, 0 
  store volatile i64 %rva10702, i64* %vptr17856, align 8 ; quoted ()
 %vptr17857 = alloca i64, align 8 
  %rva10701 = call i64 @prim_cons(i64 %arg7989, i64 %rva10702) 
  store volatile i64 %rva10701, i64* %vptr17857, align 8 ; call prim_cons
  %vptr17863 = alloca i64*, align 8 
  %cloptr17858 = inttoptr i64 %arg7990 to i64* 
  store volatile i64* %cloptr17858, i64** %vptr17863, align 8 ; closure/env cast; i64 -> i64*
  %vptr17864 = alloca i64*, align 8 
  %i0ptr17859 = getelementptr inbounds i64, i64* %cloptr17858, i64 1 
  store volatile i64* %i0ptr17859, i64** %vptr17864, align 8 ; &cloptr17858[1]
 %vptr17865 = alloca i64, align 8 
  %f17861 = load i64, i64* %i0ptr17859, align 8 
  store volatile i64 %f17861, i64* %vptr17865, align 8 ; load; *i0ptr17859
  %fptr17860 = inttoptr i64 %f17861 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17860(i64 %arg7990, i64 %rva10701)                  ; tail call
  ret void

else17800:
 %vptr17866 = alloca i64, align 8 
  %h10705 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10705, i64* %vptr17866, align 8 ; call prim_halt
  %vptr17872 = alloca i64*, align 8 
  %cloptr17867 = inttoptr i64 %h10705 to i64* 
  store volatile i64* %cloptr17867, i64** %vptr17872, align 8 ; closure/env cast; i64 -> i64*
  %vptr17873 = alloca i64*, align 8 
  %i0ptr17868 = getelementptr inbounds i64, i64* %cloptr17867, i64 1 
  store volatile i64* %i0ptr17868, i64** %vptr17873, align 8 ; &cloptr17867[1]
 %vptr17874 = alloca i64, align 8 
  %f17870 = load i64, i64* %i0ptr17868, align 8 
  store volatile i64 %f17870, i64* %vptr17874, align 8 ; load; *i0ptr17868
  %fptr17869 = inttoptr i64 %f17870 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17869(i64 %h10705, i64 %h10705)                     ; tail call
  ret void
}


define void @lam12141(i64 %env12142, i64 %rvp9588) {
 %vptr17877 = alloca i64, align 8 
  %envptr17875 = inttoptr i64 %env12142 to i64* 
  store volatile i64 %uLY$_37_62, i64* %vptr17877, align 8 ; closure/env cast; i64 -> i64*
  %vptr17878 = alloca i64*, align 8 
  %envptr17876 = getelementptr inbounds i64, i64* %envptr17875, i64 6 
  store volatile i64* %envptr17876, i64** %vptr17878, align 8 ; &envptr17875[5]
 %vptr17879 = alloca i64, align 8 
  %uLY$_37_62 = load i64, i64* %envptr17876, align 8 
  store volatile i64 %uLY$_37_62, i64* %vptr17879, align 8 ; load; *envptr17876
 %vptr17882 = alloca i64, align 8 
  %envptr17880 = inttoptr i64 %env12142 to i64* 
  store volatile i64 %emsg08636, i64* %vptr17882, align 8 ; closure/env cast; i64 -> i64*
  %vptr17883 = alloca i64*, align 8 
  %envptr17881 = getelementptr inbounds i64, i64* %envptr17880, i64 5 
  store volatile i64* %envptr17881, i64** %vptr17883, align 8 ; &envptr17880[4]
 %vptr17884 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr17881, align 8 
  store volatile i64 %emsg08636, i64* %vptr17884, align 8 ; load; *envptr17881
 %vptr17887 = alloca i64, align 8 
  %envptr17885 = inttoptr i64 %env12142 to i64* 
  store volatile i64 %zTP$_37drop, i64* %vptr17887, align 8 ; closure/env cast; i64 -> i64*
  %vptr17888 = alloca i64*, align 8 
  %envptr17886 = getelementptr inbounds i64, i64* %envptr17885, i64 4 
  store volatile i64* %envptr17886, i64** %vptr17888, align 8 ; &envptr17885[3]
 %vptr17889 = alloca i64, align 8 
  %zTP$_37drop = load i64, i64* %envptr17886, align 8 
  store volatile i64 %zTP$_37drop, i64* %vptr17889, align 8 ; load; *envptr17886
 %vptr17892 = alloca i64, align 8 
  %envptr17890 = inttoptr i64 %env12142 to i64* 
  store volatile i64 %Jup$_37length, i64* %vptr17892, align 8 ; closure/env cast; i64 -> i64*
  %vptr17893 = alloca i64*, align 8 
  %envptr17891 = getelementptr inbounds i64, i64* %envptr17890, i64 3 
  store volatile i64* %envptr17891, i64** %vptr17893, align 8 ; &envptr17890[2]
 %vptr17894 = alloca i64, align 8 
  %Jup$_37length = load i64, i64* %envptr17891, align 8 
  store volatile i64 %Jup$_37length, i64* %vptr17894, align 8 ; load; *envptr17891
 %vptr17897 = alloca i64, align 8 
  %envptr17895 = inttoptr i64 %env12142 to i64* 
  store volatile i64 %emsg18637, i64* %vptr17897, align 8 ; closure/env cast; i64 -> i64*
  %vptr17898 = alloca i64*, align 8 
  %envptr17896 = getelementptr inbounds i64, i64* %envptr17895, i64 2 
  store volatile i64* %envptr17896, i64** %vptr17898, align 8 ; &envptr17895[1]
 %vptr17899 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr17896, align 8 
  store volatile i64 %emsg18637, i64* %vptr17899, align 8 ; load; *envptr17896
 %vptr17900 = alloca i64, align 8 
  %cont7159 = call i64 @prim_car(i64 %rvp9588) 
  store volatile i64 %cont7159, i64* %vptr17900, align 8 ; call prim_car
 %vptr17901 = alloca i64, align 8 
  %rvp9584 = call i64 @prim_cdr(i64 %rvp9588) 
  store volatile i64 %rvp9584, i64* %vptr17901, align 8 ; call prim_cdr
 %vptr17902 = alloca i64, align 8 
  %n_639589 = call i64 @prim_null_63(i64 %rvp9584) 
  store volatile i64 %n_639589, i64* %vptr17902, align 8 ; call prim_null_63
  %cmpptr17906 = alloca i1, align 8  %cmp17903 = icmp eq i64 %n_639589, 15 store volatile i1 %cmp17903, i1* %cmpptr17906, align 8; false?
  br i1 %cmp17903, label %else17905, label %then17904                                ; if

then17904:
 %vptr17907 = alloca i64, align 8 
  %h9590 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9590, i64* %vptr17907, align 8 ; call prim_halt
  %vptr17913 = alloca i64*, align 8 
  %cloptr17908 = inttoptr i64 %h9590 to i64* 
  store volatile i64* %cloptr17908, i64** %vptr17913, align 8 ; closure/env cast; i64 -> i64*
  %vptr17914 = alloca i64*, align 8 
  %i0ptr17909 = getelementptr inbounds i64, i64* %cloptr17908, i64 1 
  store volatile i64* %i0ptr17909, i64** %vptr17914, align 8 ; &cloptr17908[1]
 %vptr17915 = alloca i64, align 8 
  %f17911 = load i64, i64* %i0ptr17909, align 8 
  store volatile i64 %f17911, i64* %vptr17915, align 8 ; load; *i0ptr17909
  %fptr17910 = inttoptr i64 %f17911 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17910(i64 %h9590, i64 %h9590)                       ; tail call
  ret void

else17905:
 %vptr17916 = alloca i64, align 8 
  %FhZ$x = call i64 @prim_car(i64 %rvp9584) 
  store volatile i64 %FhZ$x, i64* %vptr17916, align 8 ; call prim_car
 %vptr17917 = alloca i64, align 8 
  %rvp9580 = call i64 @prim_cdr(i64 %rvp9584) 
  store volatile i64 %rvp9580, i64* %vptr17917, align 8 ; call prim_cdr
 %vptr17918 = alloca i64, align 8 
  %n_639585 = call i64 @prim_null_63(i64 %rvp9580) 
  store volatile i64 %n_639585, i64* %vptr17918, align 8 ; call prim_null_63
  %cmpptr17922 = alloca i1, align 8  %cmp17919 = icmp eq i64 %n_639585, 15 store volatile i1 %cmp17919, i1* %cmpptr17922, align 8; false?
  br i1 %cmp17919, label %else17921, label %then17920                                ; if

then17920:
 %vptr17923 = alloca i64, align 8 
  %h9586 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9586, i64* %vptr17923, align 8 ; call prim_halt
  %vptr17929 = alloca i64*, align 8 
  %cloptr17924 = inttoptr i64 %h9586 to i64* 
  store volatile i64* %cloptr17924, i64** %vptr17929, align 8 ; closure/env cast; i64 -> i64*
  %vptr17930 = alloca i64*, align 8 
  %i0ptr17925 = getelementptr inbounds i64, i64* %cloptr17924, i64 1 
  store volatile i64* %i0ptr17925, i64** %vptr17930, align 8 ; &cloptr17924[1]
 %vptr17931 = alloca i64, align 8 
  %f17927 = load i64, i64* %i0ptr17925, align 8 
  store volatile i64 %f17927, i64* %vptr17931, align 8 ; load; *i0ptr17925
  %fptr17926 = inttoptr i64 %f17927 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17926(i64 %h9586, i64 %h9586)                       ; tail call
  ret void

else17921:
 %vptr17932 = alloca i64, align 8 
  %v42$y = call i64 @prim_car(i64 %rvp9580) 
  store volatile i64 %v42$y, i64* %vptr17932, align 8 ; call prim_car
 %vptr17933 = alloca i64, align 8 
  %na9365 = call i64 @prim_cdr(i64 %rvp9580) 
  store volatile i64 %na9365, i64* %vptr17933, align 8 ; call prim_cdr
 %vptr17934 = alloca i64, align 8 
  %n_639581 = call i64 @prim_null_63(i64 %na9365) 
  store volatile i64 %n_639581, i64* %vptr17934, align 8 ; call prim_null_63
  %cmpptr17938 = alloca i1, align 8  %cmp17935 = icmp eq i64 %n_639581, 15 store volatile i1 %cmp17935, i1* %cmpptr17938, align 8; false?
  br i1 %cmp17935, label %else17937, label %then17936                                ; if

then17936:
  %vptr17950 = alloca i64*, align 8 
  %cloptr17939 = call i64* @make_closure(i64 72) 
  store volatile i64* %cloptr17939, i64** %vptr17950, align 8 ; malloc
  %vptr17951 = alloca i64*, align 8 
  %eptr17941 = getelementptr inbounds i64, i64* %cloptr17939, i64 2 
  store volatile i64* %eptr17941, i64** %vptr17951, align 8 ; &eptr17941[1]
  %vptr17952 = alloca i64*, align 8 
  %eptr17942 = getelementptr inbounds i64, i64* %cloptr17939, i64 3 
  store volatile i64* %eptr17942, i64** %vptr17952, align 8 ; &eptr17942[2]
  %vptr17953 = alloca i64*, align 8 
  %eptr17943 = getelementptr inbounds i64, i64* %cloptr17939, i64 4 
  store volatile i64* %eptr17943, i64** %vptr17953, align 8 ; &eptr17943[3]
  %vptr17954 = alloca i64*, align 8 
  %eptr17944 = getelementptr inbounds i64, i64* %cloptr17939, i64 5 
  store volatile i64* %eptr17944, i64** %vptr17954, align 8 ; &eptr17944[4]
  %vptr17955 = alloca i64*, align 8 
  %eptr17945 = getelementptr inbounds i64, i64* %cloptr17939, i64 6 
  store volatile i64* %eptr17945, i64** %vptr17955, align 8 ; &eptr17945[5]
  %vptr17956 = alloca i64*, align 8 
  %eptr17946 = getelementptr inbounds i64, i64* %cloptr17939, i64 7 
  store volatile i64* %eptr17946, i64** %vptr17956, align 8 ; &eptr17946[6]
  %vptr17957 = alloca i64*, align 8 
  %eptr17947 = getelementptr inbounds i64, i64* %cloptr17939, i64 8 
  store volatile i64* %eptr17947, i64** %vptr17957, align 8 ; &eptr17947[7]
  %vptr17958 = alloca i64*, align 8 
  %eptr17948 = getelementptr inbounds i64, i64* %cloptr17939, i64 9 
  store volatile i64* %eptr17948, i64** %vptr17958, align 8 ; &eptr17948[8]
  store i64 %FhZ$x, i64* %eptr17941                                                  ; *eptr17941 = %FhZ$x
  store i64 %emsg18637, i64* %eptr17942                                              ; *eptr17942 = %emsg18637
  store i64 %cont7159, i64* %eptr17943                                               ; *eptr17943 = %cont7159
  store i64 %v42$y, i64* %eptr17944                                                  ; *eptr17944 = %v42$y
  store i64 %Jup$_37length, i64* %eptr17945                                          ; *eptr17945 = %Jup$_37length
  store i64 %zTP$_37drop, i64* %eptr17946                                            ; *eptr17946 = %zTP$_37drop
  store i64 %emsg08636, i64* %eptr17947                                              ; *eptr17947 = %emsg08636
  store i64 %uLY$_37_62, i64* %eptr17948                                             ; *eptr17948 = %uLY$_37_62
  %vptr17959 = alloca i64*, align 8 
  %eptr17940 = getelementptr inbounds i64, i64* %cloptr17939, i64 1 
  store volatile i64* %eptr17940, i64** %vptr17959, align 8 ; &cloptr17939[1]
 %vptr17960 = alloca i64, align 8 
  %f17949 = ptrtoint void(i64,i64)* @lam12139 to i64 
  store volatile i64 %f17949, i64* %vptr17960, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f17949, i64* %eptr17940                                                 ; store fptr
 %vptr17961 = alloca i64, align 8 
  %arg7806 = ptrtoint i64* %cloptr17939 to i64 
  store volatile i64 %arg7806, i64* %vptr17961, align 8 ; closure cast; i64* -> i64
 %vptr17962 = alloca i64, align 8 
  %rva9579 = add i64 0, 0 
  store volatile i64 %rva9579, i64* %vptr17962, align 8 ; quoted ()
 %vptr17963 = alloca i64, align 8 
  %rva9578 = call i64 @prim_cons(i64 %FhZ$x, i64 %rva9579) 
  store volatile i64 %rva9578, i64* %vptr17963, align 8 ; call prim_cons
 %vptr17964 = alloca i64, align 8 
  %rva9577 = call i64 @prim_cons(i64 %arg7806, i64 %rva9578) 
  store volatile i64 %rva9577, i64* %vptr17964, align 8 ; call prim_cons
  %vptr17970 = alloca i64*, align 8 
  %cloptr17965 = inttoptr i64 %Jup$_37length to i64* 
  store volatile i64* %cloptr17965, i64** %vptr17970, align 8 ; closure/env cast; i64 -> i64*
  %vptr17971 = alloca i64*, align 8 
  %i0ptr17966 = getelementptr inbounds i64, i64* %cloptr17965, i64 1 
  store volatile i64* %i0ptr17966, i64** %vptr17971, align 8 ; &cloptr17965[1]
 %vptr17972 = alloca i64, align 8 
  %f17968 = load i64, i64* %i0ptr17966, align 8 
  store volatile i64 %f17968, i64* %vptr17972, align 8 ; load; *i0ptr17966
  %fptr17967 = inttoptr i64 %f17968 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17967(i64 %Jup$_37length, i64 %rva9577)             ; tail call
  ret void

else17937:
 %vptr17973 = alloca i64, align 8 
  %h9582 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9582, i64* %vptr17973, align 8 ; call prim_halt
  %vptr17979 = alloca i64*, align 8 
  %cloptr17974 = inttoptr i64 %h9582 to i64* 
  store volatile i64* %cloptr17974, i64** %vptr17979, align 8 ; closure/env cast; i64 -> i64*
  %vptr17980 = alloca i64*, align 8 
  %i0ptr17975 = getelementptr inbounds i64, i64* %cloptr17974, i64 1 
  store volatile i64* %i0ptr17975, i64** %vptr17980, align 8 ; &cloptr17974[1]
 %vptr17981 = alloca i64, align 8 
  %f17977 = load i64, i64* %i0ptr17975, align 8 
  store volatile i64 %f17977, i64* %vptr17981, align 8 ; load; *i0ptr17975
  %fptr17976 = inttoptr i64 %f17977 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr17976(i64 %h9582, i64 %h9582)                       ; tail call
  ret void
}


define void @lam12139(i64 %env12140, i64 %rvp9573) {
 %vptr17984 = alloca i64, align 8 
  %envptr17982 = inttoptr i64 %env12140 to i64* 
  store volatile i64 %uLY$_37_62, i64* %vptr17984, align 8 ; closure/env cast; i64 -> i64*
  %vptr17985 = alloca i64*, align 8 
  %envptr17983 = getelementptr inbounds i64, i64* %envptr17982, i64 9 
  store volatile i64* %envptr17983, i64** %vptr17985, align 8 ; &envptr17982[8]
 %vptr17986 = alloca i64, align 8 
  %uLY$_37_62 = load i64, i64* %envptr17983, align 8 
  store volatile i64 %uLY$_37_62, i64* %vptr17986, align 8 ; load; *envptr17983
 %vptr17989 = alloca i64, align 8 
  %envptr17987 = inttoptr i64 %env12140 to i64* 
  store volatile i64 %emsg08636, i64* %vptr17989, align 8 ; closure/env cast; i64 -> i64*
  %vptr17990 = alloca i64*, align 8 
  %envptr17988 = getelementptr inbounds i64, i64* %envptr17987, i64 8 
  store volatile i64* %envptr17988, i64** %vptr17990, align 8 ; &envptr17987[7]
 %vptr17991 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr17988, align 8 
  store volatile i64 %emsg08636, i64* %vptr17991, align 8 ; load; *envptr17988
 %vptr17994 = alloca i64, align 8 
  %envptr17992 = inttoptr i64 %env12140 to i64* 
  store volatile i64 %zTP$_37drop, i64* %vptr17994, align 8 ; closure/env cast; i64 -> i64*
  %vptr17995 = alloca i64*, align 8 
  %envptr17993 = getelementptr inbounds i64, i64* %envptr17992, i64 7 
  store volatile i64* %envptr17993, i64** %vptr17995, align 8 ; &envptr17992[6]
 %vptr17996 = alloca i64, align 8 
  %zTP$_37drop = load i64, i64* %envptr17993, align 8 
  store volatile i64 %zTP$_37drop, i64* %vptr17996, align 8 ; load; *envptr17993
 %vptr17999 = alloca i64, align 8 
  %envptr17997 = inttoptr i64 %env12140 to i64* 
  store volatile i64 %Jup$_37length, i64* %vptr17999, align 8 ; closure/env cast; i64 -> i64*
  %vptr18000 = alloca i64*, align 8 
  %envptr17998 = getelementptr inbounds i64, i64* %envptr17997, i64 6 
  store volatile i64* %envptr17998, i64** %vptr18000, align 8 ; &envptr17997[5]
 %vptr18001 = alloca i64, align 8 
  %Jup$_37length = load i64, i64* %envptr17998, align 8 
  store volatile i64 %Jup$_37length, i64* %vptr18001, align 8 ; load; *envptr17998
 %vptr18004 = alloca i64, align 8 
  %envptr18002 = inttoptr i64 %env12140 to i64* 
  store volatile i64 %v42$y, i64* %vptr18004, align 8 ; closure/env cast; i64 -> i64*
  %vptr18005 = alloca i64*, align 8 
  %envptr18003 = getelementptr inbounds i64, i64* %envptr18002, i64 5 
  store volatile i64* %envptr18003, i64** %vptr18005, align 8 ; &envptr18002[4]
 %vptr18006 = alloca i64, align 8 
  %v42$y = load i64, i64* %envptr18003, align 8 
  store volatile i64 %v42$y, i64* %vptr18006, align 8 ; load; *envptr18003
 %vptr18009 = alloca i64, align 8 
  %envptr18007 = inttoptr i64 %env12140 to i64* 
  store volatile i64 %cont7159, i64* %vptr18009, align 8 ; closure/env cast; i64 -> i64*
  %vptr18010 = alloca i64*, align 8 
  %envptr18008 = getelementptr inbounds i64, i64* %envptr18007, i64 4 
  store volatile i64* %envptr18008, i64** %vptr18010, align 8 ; &envptr18007[3]
 %vptr18011 = alloca i64, align 8 
  %cont7159 = load i64, i64* %envptr18008, align 8 
  store volatile i64 %cont7159, i64* %vptr18011, align 8 ; load; *envptr18008
 %vptr18014 = alloca i64, align 8 
  %envptr18012 = inttoptr i64 %env12140 to i64* 
  store volatile i64 %emsg18637, i64* %vptr18014, align 8 ; closure/env cast; i64 -> i64*
  %vptr18015 = alloca i64*, align 8 
  %envptr18013 = getelementptr inbounds i64, i64* %envptr18012, i64 3 
  store volatile i64* %envptr18013, i64** %vptr18015, align 8 ; &envptr18012[2]
 %vptr18016 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr18013, align 8 
  store volatile i64 %emsg18637, i64* %vptr18016, align 8 ; load; *envptr18013
 %vptr18019 = alloca i64, align 8 
  %envptr18017 = inttoptr i64 %env12140 to i64* 
  store volatile i64 %FhZ$x, i64* %vptr18019, align 8 ; closure/env cast; i64 -> i64*
  %vptr18020 = alloca i64*, align 8 
  %envptr18018 = getelementptr inbounds i64, i64* %envptr18017, i64 2 
  store volatile i64* %envptr18018, i64** %vptr18020, align 8 ; &envptr18017[1]
 %vptr18021 = alloca i64, align 8 
  %FhZ$x = load i64, i64* %envptr18018, align 8 
  store volatile i64 %FhZ$x, i64* %vptr18021, align 8 ; load; *envptr18018
 %vptr18022 = alloca i64, align 8 
  %_957160 = call i64 @prim_car(i64 %rvp9573) 
  store volatile i64 %_957160, i64* %vptr18022, align 8 ; call prim_car
 %vptr18023 = alloca i64, align 8 
  %rvp9569 = call i64 @prim_cdr(i64 %rvp9573) 
  store volatile i64 %rvp9569, i64* %vptr18023, align 8 ; call prim_cdr
 %vptr18024 = alloca i64, align 8 
  %n_639574 = call i64 @prim_null_63(i64 %rvp9569) 
  store volatile i64 %n_639574, i64* %vptr18024, align 8 ; call prim_null_63
  %cmpptr18028 = alloca i1, align 8  %cmp18025 = icmp eq i64 %n_639574, 15 store volatile i1 %cmp18025, i1* %cmpptr18028, align 8; false?
  br i1 %cmp18025, label %else18027, label %then18026                                ; if

then18026:
 %vptr18029 = alloca i64, align 8 
  %h9575 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9575, i64* %vptr18029, align 8 ; call prim_halt
  %vptr18035 = alloca i64*, align 8 
  %cloptr18030 = inttoptr i64 %h9575 to i64* 
  store volatile i64* %cloptr18030, i64** %vptr18035, align 8 ; closure/env cast; i64 -> i64*
  %vptr18036 = alloca i64*, align 8 
  %i0ptr18031 = getelementptr inbounds i64, i64* %cloptr18030, i64 1 
  store volatile i64* %i0ptr18031, i64** %vptr18036, align 8 ; &cloptr18030[1]
 %vptr18037 = alloca i64, align 8 
  %f18033 = load i64, i64* %i0ptr18031, align 8 
  store volatile i64 %f18033, i64* %vptr18037, align 8 ; load; *i0ptr18031
  %fptr18032 = inttoptr i64 %f18033 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18032(i64 %h9575, i64 %h9575)                       ; tail call
  ret void

else18027:
 %vptr18038 = alloca i64, align 8 
  %DwU$lx = call i64 @prim_car(i64 %rvp9569) 
  store volatile i64 %DwU$lx, i64* %vptr18038, align 8 ; call prim_car
 %vptr18039 = alloca i64, align 8 
  %na9367 = call i64 @prim_cdr(i64 %rvp9569) 
  store volatile i64 %na9367, i64* %vptr18039, align 8 ; call prim_cdr
 %vptr18040 = alloca i64, align 8 
  %n_639570 = call i64 @prim_null_63(i64 %na9367) 
  store volatile i64 %n_639570, i64* %vptr18040, align 8 ; call prim_null_63
  %cmpptr18044 = alloca i1, align 8  %cmp18041 = icmp eq i64 %n_639570, 15 store volatile i1 %cmp18041, i1* %cmpptr18044, align 8; false?
  br i1 %cmp18041, label %else18043, label %then18042                                ; if

then18042:
  %vptr18056 = alloca i64*, align 8 
  %cloptr18045 = call i64* @make_closure(i64 72) 
  store volatile i64* %cloptr18045, i64** %vptr18056, align 8 ; malloc
  %vptr18057 = alloca i64*, align 8 
  %eptr18047 = getelementptr inbounds i64, i64* %cloptr18045, i64 2 
  store volatile i64* %eptr18047, i64** %vptr18057, align 8 ; &eptr18047[1]
  %vptr18058 = alloca i64*, align 8 
  %eptr18048 = getelementptr inbounds i64, i64* %cloptr18045, i64 3 
  store volatile i64* %eptr18048, i64** %vptr18058, align 8 ; &eptr18048[2]
  %vptr18059 = alloca i64*, align 8 
  %eptr18049 = getelementptr inbounds i64, i64* %cloptr18045, i64 4 
  store volatile i64* %eptr18049, i64** %vptr18059, align 8 ; &eptr18049[3]
  %vptr18060 = alloca i64*, align 8 
  %eptr18050 = getelementptr inbounds i64, i64* %cloptr18045, i64 5 
  store volatile i64* %eptr18050, i64** %vptr18060, align 8 ; &eptr18050[4]
  %vptr18061 = alloca i64*, align 8 
  %eptr18051 = getelementptr inbounds i64, i64* %cloptr18045, i64 6 
  store volatile i64* %eptr18051, i64** %vptr18061, align 8 ; &eptr18051[5]
  %vptr18062 = alloca i64*, align 8 
  %eptr18052 = getelementptr inbounds i64, i64* %cloptr18045, i64 7 
  store volatile i64* %eptr18052, i64** %vptr18062, align 8 ; &eptr18052[6]
  %vptr18063 = alloca i64*, align 8 
  %eptr18053 = getelementptr inbounds i64, i64* %cloptr18045, i64 8 
  store volatile i64* %eptr18053, i64** %vptr18063, align 8 ; &eptr18053[7]
  %vptr18064 = alloca i64*, align 8 
  %eptr18054 = getelementptr inbounds i64, i64* %cloptr18045, i64 9 
  store volatile i64* %eptr18054, i64** %vptr18064, align 8 ; &eptr18054[8]
  store i64 %FhZ$x, i64* %eptr18047                                                  ; *eptr18047 = %FhZ$x
  store i64 %emsg18637, i64* %eptr18048                                              ; *eptr18048 = %emsg18637
  store i64 %cont7159, i64* %eptr18049                                               ; *eptr18049 = %cont7159
  store i64 %v42$y, i64* %eptr18050                                                  ; *eptr18050 = %v42$y
  store i64 %zTP$_37drop, i64* %eptr18051                                            ; *eptr18051 = %zTP$_37drop
  store i64 %DwU$lx, i64* %eptr18052                                                 ; *eptr18052 = %DwU$lx
  store i64 %emsg08636, i64* %eptr18053                                              ; *eptr18053 = %emsg08636
  store i64 %uLY$_37_62, i64* %eptr18054                                             ; *eptr18054 = %uLY$_37_62
  %vptr18065 = alloca i64*, align 8 
  %eptr18046 = getelementptr inbounds i64, i64* %cloptr18045, i64 1 
  store volatile i64* %eptr18046, i64** %vptr18065, align 8 ; &cloptr18045[1]
 %vptr18066 = alloca i64, align 8 
  %f18055 = ptrtoint void(i64,i64)* @lam12137 to i64 
  store volatile i64 %f18055, i64* %vptr18066, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f18055, i64* %eptr18046                                                 ; store fptr
 %vptr18067 = alloca i64, align 8 
  %arg7809 = ptrtoint i64* %cloptr18045 to i64 
  store volatile i64 %arg7809, i64* %vptr18067, align 8 ; closure cast; i64* -> i64
 %vptr18068 = alloca i64, align 8 
  %rva9568 = add i64 0, 0 
  store volatile i64 %rva9568, i64* %vptr18068, align 8 ; quoted ()
 %vptr18069 = alloca i64, align 8 
  %rva9567 = call i64 @prim_cons(i64 %v42$y, i64 %rva9568) 
  store volatile i64 %rva9567, i64* %vptr18069, align 8 ; call prim_cons
 %vptr18070 = alloca i64, align 8 
  %rva9566 = call i64 @prim_cons(i64 %arg7809, i64 %rva9567) 
  store volatile i64 %rva9566, i64* %vptr18070, align 8 ; call prim_cons
  %vptr18076 = alloca i64*, align 8 
  %cloptr18071 = inttoptr i64 %Jup$_37length to i64* 
  store volatile i64* %cloptr18071, i64** %vptr18076, align 8 ; closure/env cast; i64 -> i64*
  %vptr18077 = alloca i64*, align 8 
  %i0ptr18072 = getelementptr inbounds i64, i64* %cloptr18071, i64 1 
  store volatile i64* %i0ptr18072, i64** %vptr18077, align 8 ; &cloptr18071[1]
 %vptr18078 = alloca i64, align 8 
  %f18074 = load i64, i64* %i0ptr18072, align 8 
  store volatile i64 %f18074, i64* %vptr18078, align 8 ; load; *i0ptr18072
  %fptr18073 = inttoptr i64 %f18074 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18073(i64 %Jup$_37length, i64 %rva9566)             ; tail call
  ret void

else18043:
 %vptr18079 = alloca i64, align 8 
  %h9571 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9571, i64* %vptr18079, align 8 ; call prim_halt
  %vptr18085 = alloca i64*, align 8 
  %cloptr18080 = inttoptr i64 %h9571 to i64* 
  store volatile i64* %cloptr18080, i64** %vptr18085, align 8 ; closure/env cast; i64 -> i64*
  %vptr18086 = alloca i64*, align 8 
  %i0ptr18081 = getelementptr inbounds i64, i64* %cloptr18080, i64 1 
  store volatile i64* %i0ptr18081, i64** %vptr18086, align 8 ; &cloptr18080[1]
 %vptr18087 = alloca i64, align 8 
  %f18083 = load i64, i64* %i0ptr18081, align 8 
  store volatile i64 %f18083, i64* %vptr18087, align 8 ; load; *i0ptr18081
  %fptr18082 = inttoptr i64 %f18083 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18082(i64 %h9571, i64 %h9571)                       ; tail call
  ret void
}


define void @lam12137(i64 %env12138, i64 %rvp9562) {
 %vptr18090 = alloca i64, align 8 
  %envptr18088 = inttoptr i64 %env12138 to i64* 
  store volatile i64 %uLY$_37_62, i64* %vptr18090, align 8 ; closure/env cast; i64 -> i64*
  %vptr18091 = alloca i64*, align 8 
  %envptr18089 = getelementptr inbounds i64, i64* %envptr18088, i64 9 
  store volatile i64* %envptr18089, i64** %vptr18091, align 8 ; &envptr18088[8]
 %vptr18092 = alloca i64, align 8 
  %uLY$_37_62 = load i64, i64* %envptr18089, align 8 
  store volatile i64 %uLY$_37_62, i64* %vptr18092, align 8 ; load; *envptr18089
 %vptr18095 = alloca i64, align 8 
  %envptr18093 = inttoptr i64 %env12138 to i64* 
  store volatile i64 %emsg08636, i64* %vptr18095, align 8 ; closure/env cast; i64 -> i64*
  %vptr18096 = alloca i64*, align 8 
  %envptr18094 = getelementptr inbounds i64, i64* %envptr18093, i64 8 
  store volatile i64* %envptr18094, i64** %vptr18096, align 8 ; &envptr18093[7]
 %vptr18097 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr18094, align 8 
  store volatile i64 %emsg08636, i64* %vptr18097, align 8 ; load; *envptr18094
 %vptr18100 = alloca i64, align 8 
  %envptr18098 = inttoptr i64 %env12138 to i64* 
  store volatile i64 %DwU$lx, i64* %vptr18100, align 8 ; closure/env cast; i64 -> i64*
  %vptr18101 = alloca i64*, align 8 
  %envptr18099 = getelementptr inbounds i64, i64* %envptr18098, i64 7 
  store volatile i64* %envptr18099, i64** %vptr18101, align 8 ; &envptr18098[6]
 %vptr18102 = alloca i64, align 8 
  %DwU$lx = load i64, i64* %envptr18099, align 8 
  store volatile i64 %DwU$lx, i64* %vptr18102, align 8 ; load; *envptr18099
 %vptr18105 = alloca i64, align 8 
  %envptr18103 = inttoptr i64 %env12138 to i64* 
  store volatile i64 %zTP$_37drop, i64* %vptr18105, align 8 ; closure/env cast; i64 -> i64*
  %vptr18106 = alloca i64*, align 8 
  %envptr18104 = getelementptr inbounds i64, i64* %envptr18103, i64 6 
  store volatile i64* %envptr18104, i64** %vptr18106, align 8 ; &envptr18103[5]
 %vptr18107 = alloca i64, align 8 
  %zTP$_37drop = load i64, i64* %envptr18104, align 8 
  store volatile i64 %zTP$_37drop, i64* %vptr18107, align 8 ; load; *envptr18104
 %vptr18110 = alloca i64, align 8 
  %envptr18108 = inttoptr i64 %env12138 to i64* 
  store volatile i64 %v42$y, i64* %vptr18110, align 8 ; closure/env cast; i64 -> i64*
  %vptr18111 = alloca i64*, align 8 
  %envptr18109 = getelementptr inbounds i64, i64* %envptr18108, i64 5 
  store volatile i64* %envptr18109, i64** %vptr18111, align 8 ; &envptr18108[4]
 %vptr18112 = alloca i64, align 8 
  %v42$y = load i64, i64* %envptr18109, align 8 
  store volatile i64 %v42$y, i64* %vptr18112, align 8 ; load; *envptr18109
 %vptr18115 = alloca i64, align 8 
  %envptr18113 = inttoptr i64 %env12138 to i64* 
  store volatile i64 %cont7159, i64* %vptr18115, align 8 ; closure/env cast; i64 -> i64*
  %vptr18116 = alloca i64*, align 8 
  %envptr18114 = getelementptr inbounds i64, i64* %envptr18113, i64 4 
  store volatile i64* %envptr18114, i64** %vptr18116, align 8 ; &envptr18113[3]
 %vptr18117 = alloca i64, align 8 
  %cont7159 = load i64, i64* %envptr18114, align 8 
  store volatile i64 %cont7159, i64* %vptr18117, align 8 ; load; *envptr18114
 %vptr18120 = alloca i64, align 8 
  %envptr18118 = inttoptr i64 %env12138 to i64* 
  store volatile i64 %emsg18637, i64* %vptr18120, align 8 ; closure/env cast; i64 -> i64*
  %vptr18121 = alloca i64*, align 8 
  %envptr18119 = getelementptr inbounds i64, i64* %envptr18118, i64 3 
  store volatile i64* %envptr18119, i64** %vptr18121, align 8 ; &envptr18118[2]
 %vptr18122 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr18119, align 8 
  store volatile i64 %emsg18637, i64* %vptr18122, align 8 ; load; *envptr18119
 %vptr18125 = alloca i64, align 8 
  %envptr18123 = inttoptr i64 %env12138 to i64* 
  store volatile i64 %FhZ$x, i64* %vptr18125, align 8 ; closure/env cast; i64 -> i64*
  %vptr18126 = alloca i64*, align 8 
  %envptr18124 = getelementptr inbounds i64, i64* %envptr18123, i64 2 
  store volatile i64* %envptr18124, i64** %vptr18126, align 8 ; &envptr18123[1]
 %vptr18127 = alloca i64, align 8 
  %FhZ$x = load i64, i64* %envptr18124, align 8 
  store volatile i64 %FhZ$x, i64* %vptr18127, align 8 ; load; *envptr18124
 %vptr18128 = alloca i64, align 8 
  %_957161 = call i64 @prim_car(i64 %rvp9562) 
  store volatile i64 %_957161, i64* %vptr18128, align 8 ; call prim_car
 %vptr18129 = alloca i64, align 8 
  %rvp9558 = call i64 @prim_cdr(i64 %rvp9562) 
  store volatile i64 %rvp9558, i64* %vptr18129, align 8 ; call prim_cdr
 %vptr18130 = alloca i64, align 8 
  %n_639563 = call i64 @prim_null_63(i64 %rvp9558) 
  store volatile i64 %n_639563, i64* %vptr18130, align 8 ; call prim_null_63
  %cmpptr18134 = alloca i1, align 8  %cmp18131 = icmp eq i64 %n_639563, 15 store volatile i1 %cmp18131, i1* %cmpptr18134, align 8; false?
  br i1 %cmp18131, label %else18133, label %then18132                                ; if

then18132:
 %vptr18135 = alloca i64, align 8 
  %h9564 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9564, i64* %vptr18135, align 8 ; call prim_halt
  %vptr18141 = alloca i64*, align 8 
  %cloptr18136 = inttoptr i64 %h9564 to i64* 
  store volatile i64* %cloptr18136, i64** %vptr18141, align 8 ; closure/env cast; i64 -> i64*
  %vptr18142 = alloca i64*, align 8 
  %i0ptr18137 = getelementptr inbounds i64, i64* %cloptr18136, i64 1 
  store volatile i64* %i0ptr18137, i64** %vptr18142, align 8 ; &cloptr18136[1]
 %vptr18143 = alloca i64, align 8 
  %f18139 = load i64, i64* %i0ptr18137, align 8 
  store volatile i64 %f18139, i64* %vptr18143, align 8 ; load; *i0ptr18137
  %fptr18138 = inttoptr i64 %f18139 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18138(i64 %h9564, i64 %h9564)                       ; tail call
  ret void

else18133:
 %vptr18144 = alloca i64, align 8 
  %bcc$ly = call i64 @prim_car(i64 %rvp9558) 
  store volatile i64 %bcc$ly, i64* %vptr18144, align 8 ; call prim_car
 %vptr18145 = alloca i64, align 8 
  %na9369 = call i64 @prim_cdr(i64 %rvp9558) 
  store volatile i64 %na9369, i64* %vptr18145, align 8 ; call prim_cdr
 %vptr18146 = alloca i64, align 8 
  %n_639559 = call i64 @prim_null_63(i64 %na9369) 
  store volatile i64 %n_639559, i64* %vptr18146, align 8 ; call prim_null_63
  %cmpptr18150 = alloca i1, align 8  %cmp18147 = icmp eq i64 %n_639559, 15 store volatile i1 %cmp18147, i1* %cmpptr18150, align 8; false?
  br i1 %cmp18147, label %else18149, label %then18148                                ; if

then18148:
  %vptr18154 = alloca i64*, align 8 
  %cloptr18151 = call i64* @make_closure(i64 8) 
  store volatile i64* %cloptr18151, i64** %vptr18154, align 8 ; malloc
  %vptr18155 = alloca i64*, align 8 
  %eptr18152 = getelementptr inbounds i64, i64* %cloptr18151, i64 1 
  store volatile i64* %eptr18152, i64** %vptr18155, align 8 ; &cloptr18151[1]
 %vptr18156 = alloca i64, align 8 
  %f18153 = ptrtoint void(i64,i64)* @lam12135 to i64 
  store volatile i64 %f18153, i64* %vptr18156, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f18153, i64* %eptr18152                                                 ; store fptr
 %vptr18157 = alloca i64, align 8 
  %arg7812 = ptrtoint i64* %cloptr18151 to i64 
  store volatile i64 %arg7812, i64* %vptr18157, align 8 ; closure cast; i64* -> i64
  %vptr18170 = alloca i64*, align 8 
  %cloptr18158 = call i64* @make_closure(i64 80) 
  store volatile i64* %cloptr18158, i64** %vptr18170, align 8 ; malloc
  %vptr18171 = alloca i64*, align 8 
  %eptr18160 = getelementptr inbounds i64, i64* %cloptr18158, i64 2 
  store volatile i64* %eptr18160, i64** %vptr18171, align 8 ; &eptr18160[1]
  %vptr18172 = alloca i64*, align 8 
  %eptr18161 = getelementptr inbounds i64, i64* %cloptr18158, i64 3 
  store volatile i64* %eptr18161, i64** %vptr18172, align 8 ; &eptr18161[2]
  %vptr18173 = alloca i64*, align 8 
  %eptr18162 = getelementptr inbounds i64, i64* %cloptr18158, i64 4 
  store volatile i64* %eptr18162, i64** %vptr18173, align 8 ; &eptr18162[3]
  %vptr18174 = alloca i64*, align 8 
  %eptr18163 = getelementptr inbounds i64, i64* %cloptr18158, i64 5 
  store volatile i64* %eptr18163, i64** %vptr18174, align 8 ; &eptr18163[4]
  %vptr18175 = alloca i64*, align 8 
  %eptr18164 = getelementptr inbounds i64, i64* %cloptr18158, i64 6 
  store volatile i64* %eptr18164, i64** %vptr18175, align 8 ; &eptr18164[5]
  %vptr18176 = alloca i64*, align 8 
  %eptr18165 = getelementptr inbounds i64, i64* %cloptr18158, i64 7 
  store volatile i64* %eptr18165, i64** %vptr18176, align 8 ; &eptr18165[6]
  %vptr18177 = alloca i64*, align 8 
  %eptr18166 = getelementptr inbounds i64, i64* %cloptr18158, i64 8 
  store volatile i64* %eptr18166, i64** %vptr18177, align 8 ; &eptr18166[7]
  %vptr18178 = alloca i64*, align 8 
  %eptr18167 = getelementptr inbounds i64, i64* %cloptr18158, i64 9 
  store volatile i64* %eptr18167, i64** %vptr18178, align 8 ; &eptr18167[8]
  %vptr18179 = alloca i64*, align 8 
  %eptr18168 = getelementptr inbounds i64, i64* %cloptr18158, i64 10 
  store volatile i64* %eptr18168, i64** %vptr18179, align 8 ; &eptr18168[9]
  store i64 %FhZ$x, i64* %eptr18160                                                  ; *eptr18160 = %FhZ$x
  store i64 %bcc$ly, i64* %eptr18161                                                 ; *eptr18161 = %bcc$ly
  store i64 %emsg18637, i64* %eptr18162                                              ; *eptr18162 = %emsg18637
  store i64 %cont7159, i64* %eptr18163                                               ; *eptr18163 = %cont7159
  store i64 %v42$y, i64* %eptr18164                                                  ; *eptr18164 = %v42$y
  store i64 %zTP$_37drop, i64* %eptr18165                                            ; *eptr18165 = %zTP$_37drop
  store i64 %DwU$lx, i64* %eptr18166                                                 ; *eptr18166 = %DwU$lx
  store i64 %emsg08636, i64* %eptr18167                                              ; *eptr18167 = %emsg08636
  store i64 %uLY$_37_62, i64* %eptr18168                                             ; *eptr18168 = %uLY$_37_62
  %vptr18180 = alloca i64*, align 8 
  %eptr18159 = getelementptr inbounds i64, i64* %cloptr18158, i64 1 
  store volatile i64* %eptr18159, i64** %vptr18180, align 8 ; &cloptr18158[1]
 %vptr18181 = alloca i64, align 8 
  %f18169 = ptrtoint void(i64,i64)* @lam12131 to i64 
  store volatile i64 %f18169, i64* %vptr18181, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f18169, i64* %eptr18159                                                 ; store fptr
 %vptr18182 = alloca i64, align 8 
  %arg7811 = ptrtoint i64* %cloptr18158 to i64 
  store volatile i64 %arg7811, i64* %vptr18182, align 8 ; closure cast; i64* -> i64
 %vptr18183 = alloca i64, align 8 
  %rva9557 = add i64 0, 0 
  store volatile i64 %rva9557, i64* %vptr18183, align 8 ; quoted ()
 %vptr18184 = alloca i64, align 8 
  %rva9556 = call i64 @prim_cons(i64 %arg7811, i64 %rva9557) 
  store volatile i64 %rva9556, i64* %vptr18184, align 8 ; call prim_cons
  %vptr18190 = alloca i64*, align 8 
  %cloptr18185 = inttoptr i64 %arg7812 to i64* 
  store volatile i64* %cloptr18185, i64** %vptr18190, align 8 ; closure/env cast; i64 -> i64*
  %vptr18191 = alloca i64*, align 8 
  %i0ptr18186 = getelementptr inbounds i64, i64* %cloptr18185, i64 1 
  store volatile i64* %i0ptr18186, i64** %vptr18191, align 8 ; &cloptr18185[1]
 %vptr18192 = alloca i64, align 8 
  %f18188 = load i64, i64* %i0ptr18186, align 8 
  store volatile i64 %f18188, i64* %vptr18192, align 8 ; load; *i0ptr18186
  %fptr18187 = inttoptr i64 %f18188 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18187(i64 %arg7812, i64 %rva9556)                   ; tail call
  ret void

else18149:
 %vptr18193 = alloca i64, align 8 
  %h9560 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9560, i64* %vptr18193, align 8 ; call prim_halt
  %vptr18199 = alloca i64*, align 8 
  %cloptr18194 = inttoptr i64 %h9560 to i64* 
  store volatile i64* %cloptr18194, i64** %vptr18199, align 8 ; closure/env cast; i64 -> i64*
  %vptr18200 = alloca i64*, align 8 
  %i0ptr18195 = getelementptr inbounds i64, i64* %cloptr18194, i64 1 
  store volatile i64* %i0ptr18195, i64** %vptr18200, align 8 ; &cloptr18194[1]
 %vptr18201 = alloca i64, align 8 
  %f18197 = load i64, i64* %i0ptr18195, align 8 
  store volatile i64 %f18197, i64* %vptr18201, align 8 ; load; *i0ptr18195
  %fptr18196 = inttoptr i64 %f18197 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18196(i64 %h9560, i64 %h9560)                       ; tail call
  ret void
}


define void @lam12135(i64 %env12136, i64 %lZj$lst7171) {
 %vptr18202 = alloca i64, align 8 
  %cont7170 = call i64 @prim_car(i64 %lZj$lst7171) 
  store volatile i64 %cont7170, i64* %vptr18202, align 8 ; call prim_car
 %vptr18203 = alloca i64, align 8 
  %lZj$lst = call i64 @prim_cdr(i64 %lZj$lst7171) 
  store volatile i64 %lZj$lst, i64* %vptr18203, align 8 ; call prim_cdr
 %vptr18204 = alloca i64, align 8 
  %arg7816 = add i64 0, 0 
  store volatile i64 %arg7816, i64* %vptr18204, align 8 ; quoted ()
 %vptr18205 = alloca i64, align 8 
  %rva9372 = add i64 0, 0 
  store volatile i64 %rva9372, i64* %vptr18205, align 8 ; quoted ()
 %vptr18206 = alloca i64, align 8 
  %rva9371 = call i64 @prim_cons(i64 %lZj$lst, i64 %rva9372) 
  store volatile i64 %rva9371, i64* %vptr18206, align 8 ; call prim_cons
 %vptr18207 = alloca i64, align 8 
  %rva9370 = call i64 @prim_cons(i64 %arg7816, i64 %rva9371) 
  store volatile i64 %rva9370, i64* %vptr18207, align 8 ; call prim_cons
  %vptr18213 = alloca i64*, align 8 
  %cloptr18208 = inttoptr i64 %cont7170 to i64* 
  store volatile i64* %cloptr18208, i64** %vptr18213, align 8 ; closure/env cast; i64 -> i64*
  %vptr18214 = alloca i64*, align 8 
  %i0ptr18209 = getelementptr inbounds i64, i64* %cloptr18208, i64 1 
  store volatile i64* %i0ptr18209, i64** %vptr18214, align 8 ; &cloptr18208[1]
 %vptr18215 = alloca i64, align 8 
  %f18211 = load i64, i64* %i0ptr18209, align 8 
  store volatile i64 %f18211, i64* %vptr18215, align 8 ; load; *i0ptr18209
  %fptr18210 = inttoptr i64 %f18211 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18210(i64 %cont7170, i64 %rva9370)                  ; tail call
  ret void
}


define void @lam12131(i64 %env12132, i64 %rvp9552) {
 %vptr18218 = alloca i64, align 8 
  %envptr18216 = inttoptr i64 %env12132 to i64* 
  store volatile i64 %uLY$_37_62, i64* %vptr18218, align 8 ; closure/env cast; i64 -> i64*
  %vptr18219 = alloca i64*, align 8 
  %envptr18217 = getelementptr inbounds i64, i64* %envptr18216, i64 10 
  store volatile i64* %envptr18217, i64** %vptr18219, align 8 ; &envptr18216[9]
 %vptr18220 = alloca i64, align 8 
  %uLY$_37_62 = load i64, i64* %envptr18217, align 8 
  store volatile i64 %uLY$_37_62, i64* %vptr18220, align 8 ; load; *envptr18217
 %vptr18223 = alloca i64, align 8 
  %envptr18221 = inttoptr i64 %env12132 to i64* 
  store volatile i64 %emsg08636, i64* %vptr18223, align 8 ; closure/env cast; i64 -> i64*
  %vptr18224 = alloca i64*, align 8 
  %envptr18222 = getelementptr inbounds i64, i64* %envptr18221, i64 9 
  store volatile i64* %envptr18222, i64** %vptr18224, align 8 ; &envptr18221[8]
 %vptr18225 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr18222, align 8 
  store volatile i64 %emsg08636, i64* %vptr18225, align 8 ; load; *envptr18222
 %vptr18228 = alloca i64, align 8 
  %envptr18226 = inttoptr i64 %env12132 to i64* 
  store volatile i64 %DwU$lx, i64* %vptr18228, align 8 ; closure/env cast; i64 -> i64*
  %vptr18229 = alloca i64*, align 8 
  %envptr18227 = getelementptr inbounds i64, i64* %envptr18226, i64 8 
  store volatile i64* %envptr18227, i64** %vptr18229, align 8 ; &envptr18226[7]
 %vptr18230 = alloca i64, align 8 
  %DwU$lx = load i64, i64* %envptr18227, align 8 
  store volatile i64 %DwU$lx, i64* %vptr18230, align 8 ; load; *envptr18227
 %vptr18233 = alloca i64, align 8 
  %envptr18231 = inttoptr i64 %env12132 to i64* 
  store volatile i64 %zTP$_37drop, i64* %vptr18233, align 8 ; closure/env cast; i64 -> i64*
  %vptr18234 = alloca i64*, align 8 
  %envptr18232 = getelementptr inbounds i64, i64* %envptr18231, i64 7 
  store volatile i64* %envptr18232, i64** %vptr18234, align 8 ; &envptr18231[6]
 %vptr18235 = alloca i64, align 8 
  %zTP$_37drop = load i64, i64* %envptr18232, align 8 
  store volatile i64 %zTP$_37drop, i64* %vptr18235, align 8 ; load; *envptr18232
 %vptr18238 = alloca i64, align 8 
  %envptr18236 = inttoptr i64 %env12132 to i64* 
  store volatile i64 %v42$y, i64* %vptr18238, align 8 ; closure/env cast; i64 -> i64*
  %vptr18239 = alloca i64*, align 8 
  %envptr18237 = getelementptr inbounds i64, i64* %envptr18236, i64 6 
  store volatile i64* %envptr18237, i64** %vptr18239, align 8 ; &envptr18236[5]
 %vptr18240 = alloca i64, align 8 
  %v42$y = load i64, i64* %envptr18237, align 8 
  store volatile i64 %v42$y, i64* %vptr18240, align 8 ; load; *envptr18237
 %vptr18243 = alloca i64, align 8 
  %envptr18241 = inttoptr i64 %env12132 to i64* 
  store volatile i64 %cont7159, i64* %vptr18243, align 8 ; closure/env cast; i64 -> i64*
  %vptr18244 = alloca i64*, align 8 
  %envptr18242 = getelementptr inbounds i64, i64* %envptr18241, i64 5 
  store volatile i64* %envptr18242, i64** %vptr18244, align 8 ; &envptr18241[4]
 %vptr18245 = alloca i64, align 8 
  %cont7159 = load i64, i64* %envptr18242, align 8 
  store volatile i64 %cont7159, i64* %vptr18245, align 8 ; load; *envptr18242
 %vptr18248 = alloca i64, align 8 
  %envptr18246 = inttoptr i64 %env12132 to i64* 
  store volatile i64 %emsg18637, i64* %vptr18248, align 8 ; closure/env cast; i64 -> i64*
  %vptr18249 = alloca i64*, align 8 
  %envptr18247 = getelementptr inbounds i64, i64* %envptr18246, i64 4 
  store volatile i64* %envptr18247, i64** %vptr18249, align 8 ; &envptr18246[3]
 %vptr18250 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr18247, align 8 
  store volatile i64 %emsg18637, i64* %vptr18250, align 8 ; load; *envptr18247
 %vptr18253 = alloca i64, align 8 
  %envptr18251 = inttoptr i64 %env12132 to i64* 
  store volatile i64 %bcc$ly, i64* %vptr18253, align 8 ; closure/env cast; i64 -> i64*
  %vptr18254 = alloca i64*, align 8 
  %envptr18252 = getelementptr inbounds i64, i64* %envptr18251, i64 3 
  store volatile i64* %envptr18252, i64** %vptr18254, align 8 ; &envptr18251[2]
 %vptr18255 = alloca i64, align 8 
  %bcc$ly = load i64, i64* %envptr18252, align 8 
  store volatile i64 %bcc$ly, i64* %vptr18255, align 8 ; load; *envptr18252
 %vptr18258 = alloca i64, align 8 
  %envptr18256 = inttoptr i64 %env12132 to i64* 
  store volatile i64 %FhZ$x, i64* %vptr18258, align 8 ; closure/env cast; i64 -> i64*
  %vptr18259 = alloca i64*, align 8 
  %envptr18257 = getelementptr inbounds i64, i64* %envptr18256, i64 2 
  store volatile i64* %envptr18257, i64** %vptr18259, align 8 ; &envptr18256[1]
 %vptr18260 = alloca i64, align 8 
  %FhZ$x = load i64, i64* %envptr18257, align 8 
  store volatile i64 %FhZ$x, i64* %vptr18260, align 8 ; load; *envptr18257
 %vptr18261 = alloca i64, align 8 
  %_957168 = call i64 @prim_car(i64 %rvp9552) 
  store volatile i64 %_957168, i64* %vptr18261, align 8 ; call prim_car
 %vptr18262 = alloca i64, align 8 
  %rvp9548 = call i64 @prim_cdr(i64 %rvp9552) 
  store volatile i64 %rvp9548, i64* %vptr18262, align 8 ; call prim_cdr
 %vptr18263 = alloca i64, align 8 
  %n_639553 = call i64 @prim_null_63(i64 %rvp9548) 
  store volatile i64 %n_639553, i64* %vptr18263, align 8 ; call prim_null_63
  %cmpptr18267 = alloca i1, align 8  %cmp18264 = icmp eq i64 %n_639553, 15 store volatile i1 %cmp18264, i1* %cmpptr18267, align 8; false?
  br i1 %cmp18264, label %else18266, label %then18265                                ; if

then18265:
 %vptr18268 = alloca i64, align 8 
  %h9554 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9554, i64* %vptr18268, align 8 ; call prim_halt
  %vptr18274 = alloca i64*, align 8 
  %cloptr18269 = inttoptr i64 %h9554 to i64* 
  store volatile i64* %cloptr18269, i64** %vptr18274, align 8 ; closure/env cast; i64 -> i64*
  %vptr18275 = alloca i64*, align 8 
  %i0ptr18270 = getelementptr inbounds i64, i64* %cloptr18269, i64 1 
  store volatile i64* %i0ptr18270, i64** %vptr18275, align 8 ; &cloptr18269[1]
 %vptr18276 = alloca i64, align 8 
  %f18272 = load i64, i64* %i0ptr18270, align 8 
  store volatile i64 %f18272, i64* %vptr18276, align 8 ; load; *i0ptr18270
  %fptr18271 = inttoptr i64 %f18272 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18271(i64 %h9554, i64 %h9554)                       ; tail call
  ret void

else18266:
 %vptr18277 = alloca i64, align 8 
  %a7000 = call i64 @prim_car(i64 %rvp9548) 
  store volatile i64 %a7000, i64* %vptr18277, align 8 ; call prim_car
 %vptr18278 = alloca i64, align 8 
  %na9374 = call i64 @prim_cdr(i64 %rvp9548) 
  store volatile i64 %na9374, i64* %vptr18278, align 8 ; call prim_cdr
 %vptr18279 = alloca i64, align 8 
  %n_639549 = call i64 @prim_null_63(i64 %na9374) 
  store volatile i64 %n_639549, i64* %vptr18279, align 8 ; call prim_null_63
  %cmpptr18283 = alloca i1, align 8  %cmp18280 = icmp eq i64 %n_639549, 15 store volatile i1 %cmp18280, i1* %cmpptr18283, align 8; false?
  br i1 %cmp18280, label %else18282, label %then18281                                ; if

then18281:
 %vptr18284 = alloca i64, align 8 
  %arg7819 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg7819, i64* %vptr18284, align 8 ; quoted int
 %vptr18285 = alloca i64, align 8 
  %retprim7169 = call i64 @prim_make_45vector(i64 %arg7819, i64 %a7000) 
  store volatile i64 %retprim7169, i64* %vptr18285, align 8 ; call prim_make_45vector
  %vptr18298 = alloca i64*, align 8 
  %cloptr18286 = call i64* @make_closure(i64 80) 
  store volatile i64* %cloptr18286, i64** %vptr18298, align 8 ; malloc
  %vptr18299 = alloca i64*, align 8 
  %eptr18288 = getelementptr inbounds i64, i64* %cloptr18286, i64 2 
  store volatile i64* %eptr18288, i64** %vptr18299, align 8 ; &eptr18288[1]
  %vptr18300 = alloca i64*, align 8 
  %eptr18289 = getelementptr inbounds i64, i64* %cloptr18286, i64 3 
  store volatile i64* %eptr18289, i64** %vptr18300, align 8 ; &eptr18289[2]
  %vptr18301 = alloca i64*, align 8 
  %eptr18290 = getelementptr inbounds i64, i64* %cloptr18286, i64 4 
  store volatile i64* %eptr18290, i64** %vptr18301, align 8 ; &eptr18290[3]
  %vptr18302 = alloca i64*, align 8 
  %eptr18291 = getelementptr inbounds i64, i64* %cloptr18286, i64 5 
  store volatile i64* %eptr18291, i64** %vptr18302, align 8 ; &eptr18291[4]
  %vptr18303 = alloca i64*, align 8 
  %eptr18292 = getelementptr inbounds i64, i64* %cloptr18286, i64 6 
  store volatile i64* %eptr18292, i64** %vptr18303, align 8 ; &eptr18292[5]
  %vptr18304 = alloca i64*, align 8 
  %eptr18293 = getelementptr inbounds i64, i64* %cloptr18286, i64 7 
  store volatile i64* %eptr18293, i64** %vptr18304, align 8 ; &eptr18293[6]
  %vptr18305 = alloca i64*, align 8 
  %eptr18294 = getelementptr inbounds i64, i64* %cloptr18286, i64 8 
  store volatile i64* %eptr18294, i64** %vptr18305, align 8 ; &eptr18294[7]
  %vptr18306 = alloca i64*, align 8 
  %eptr18295 = getelementptr inbounds i64, i64* %cloptr18286, i64 9 
  store volatile i64* %eptr18295, i64** %vptr18306, align 8 ; &eptr18295[8]
  %vptr18307 = alloca i64*, align 8 
  %eptr18296 = getelementptr inbounds i64, i64* %cloptr18286, i64 10 
  store volatile i64* %eptr18296, i64** %vptr18307, align 8 ; &eptr18296[9]
  store i64 %FhZ$x, i64* %eptr18288                                                  ; *eptr18288 = %FhZ$x
  store i64 %bcc$ly, i64* %eptr18289                                                 ; *eptr18289 = %bcc$ly
  store i64 %emsg18637, i64* %eptr18290                                              ; *eptr18290 = %emsg18637
  store i64 %cont7159, i64* %eptr18291                                               ; *eptr18291 = %cont7159
  store i64 %v42$y, i64* %eptr18292                                                  ; *eptr18292 = %v42$y
  store i64 %zTP$_37drop, i64* %eptr18293                                            ; *eptr18293 = %zTP$_37drop
  store i64 %DwU$lx, i64* %eptr18294                                                 ; *eptr18294 = %DwU$lx
  store i64 %emsg08636, i64* %eptr18295                                              ; *eptr18295 = %emsg08636
  store i64 %uLY$_37_62, i64* %eptr18296                                             ; *eptr18296 = %uLY$_37_62
  %vptr18308 = alloca i64*, align 8 
  %eptr18287 = getelementptr inbounds i64, i64* %cloptr18286, i64 1 
  store volatile i64* %eptr18287, i64** %vptr18308, align 8 ; &cloptr18286[1]
 %vptr18309 = alloca i64, align 8 
  %f18297 = ptrtoint void(i64,i64)* @lam12128 to i64 
  store volatile i64 %f18297, i64* %vptr18309, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f18297, i64* %eptr18287                                                 ; store fptr
 %vptr18310 = alloca i64, align 8 
  %arg7822 = ptrtoint i64* %cloptr18286 to i64 
  store volatile i64 %arg7822, i64* %vptr18310, align 8 ; closure cast; i64* -> i64
 %vptr18311 = alloca i64, align 8 
  %arg7821 = add i64 0, 0 
  store volatile i64 %arg7821, i64* %vptr18311, align 8 ; quoted ()
 %vptr18312 = alloca i64, align 8 
  %rva9547 = add i64 0, 0 
  store volatile i64 %rva9547, i64* %vptr18312, align 8 ; quoted ()
 %vptr18313 = alloca i64, align 8 
  %rva9546 = call i64 @prim_cons(i64 %retprim7169, i64 %rva9547) 
  store volatile i64 %rva9546, i64* %vptr18313, align 8 ; call prim_cons
 %vptr18314 = alloca i64, align 8 
  %rva9545 = call i64 @prim_cons(i64 %arg7821, i64 %rva9546) 
  store volatile i64 %rva9545, i64* %vptr18314, align 8 ; call prim_cons
  %vptr18320 = alloca i64*, align 8 
  %cloptr18315 = inttoptr i64 %arg7822 to i64* 
  store volatile i64* %cloptr18315, i64** %vptr18320, align 8 ; closure/env cast; i64 -> i64*
  %vptr18321 = alloca i64*, align 8 
  %i0ptr18316 = getelementptr inbounds i64, i64* %cloptr18315, i64 1 
  store volatile i64* %i0ptr18316, i64** %vptr18321, align 8 ; &cloptr18315[1]
 %vptr18322 = alloca i64, align 8 
  %f18318 = load i64, i64* %i0ptr18316, align 8 
  store volatile i64 %f18318, i64* %vptr18322, align 8 ; load; *i0ptr18316
  %fptr18317 = inttoptr i64 %f18318 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18317(i64 %arg7822, i64 %rva9545)                   ; tail call
  ret void

else18282:
 %vptr18323 = alloca i64, align 8 
  %h9550 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9550, i64* %vptr18323, align 8 ; call prim_halt
  %vptr18329 = alloca i64*, align 8 
  %cloptr18324 = inttoptr i64 %h9550 to i64* 
  store volatile i64* %cloptr18324, i64** %vptr18329, align 8 ; closure/env cast; i64 -> i64*
  %vptr18330 = alloca i64*, align 8 
  %i0ptr18325 = getelementptr inbounds i64, i64* %cloptr18324, i64 1 
  store volatile i64* %i0ptr18325, i64** %vptr18330, align 8 ; &cloptr18324[1]
 %vptr18331 = alloca i64, align 8 
  %f18327 = load i64, i64* %i0ptr18325, align 8 
  store volatile i64 %f18327, i64* %vptr18331, align 8 ; load; *i0ptr18325
  %fptr18326 = inttoptr i64 %f18327 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18326(i64 %h9550, i64 %h9550)                       ; tail call
  ret void
}


define void @lam12128(i64 %env12129, i64 %rvp9541) {
 %vptr18334 = alloca i64, align 8 
  %envptr18332 = inttoptr i64 %env12129 to i64* 
  store volatile i64 %uLY$_37_62, i64* %vptr18334, align 8 ; closure/env cast; i64 -> i64*
  %vptr18335 = alloca i64*, align 8 
  %envptr18333 = getelementptr inbounds i64, i64* %envptr18332, i64 10 
  store volatile i64* %envptr18333, i64** %vptr18335, align 8 ; &envptr18332[9]
 %vptr18336 = alloca i64, align 8 
  %uLY$_37_62 = load i64, i64* %envptr18333, align 8 
  store volatile i64 %uLY$_37_62, i64* %vptr18336, align 8 ; load; *envptr18333
 %vptr18339 = alloca i64, align 8 
  %envptr18337 = inttoptr i64 %env12129 to i64* 
  store volatile i64 %emsg08636, i64* %vptr18339, align 8 ; closure/env cast; i64 -> i64*
  %vptr18340 = alloca i64*, align 8 
  %envptr18338 = getelementptr inbounds i64, i64* %envptr18337, i64 9 
  store volatile i64* %envptr18338, i64** %vptr18340, align 8 ; &envptr18337[8]
 %vptr18341 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr18338, align 8 
  store volatile i64 %emsg08636, i64* %vptr18341, align 8 ; load; *envptr18338
 %vptr18344 = alloca i64, align 8 
  %envptr18342 = inttoptr i64 %env12129 to i64* 
  store volatile i64 %DwU$lx, i64* %vptr18344, align 8 ; closure/env cast; i64 -> i64*
  %vptr18345 = alloca i64*, align 8 
  %envptr18343 = getelementptr inbounds i64, i64* %envptr18342, i64 8 
  store volatile i64* %envptr18343, i64** %vptr18345, align 8 ; &envptr18342[7]
 %vptr18346 = alloca i64, align 8 
  %DwU$lx = load i64, i64* %envptr18343, align 8 
  store volatile i64 %DwU$lx, i64* %vptr18346, align 8 ; load; *envptr18343
 %vptr18349 = alloca i64, align 8 
  %envptr18347 = inttoptr i64 %env12129 to i64* 
  store volatile i64 %zTP$_37drop, i64* %vptr18349, align 8 ; closure/env cast; i64 -> i64*
  %vptr18350 = alloca i64*, align 8 
  %envptr18348 = getelementptr inbounds i64, i64* %envptr18347, i64 7 
  store volatile i64* %envptr18348, i64** %vptr18350, align 8 ; &envptr18347[6]
 %vptr18351 = alloca i64, align 8 
  %zTP$_37drop = load i64, i64* %envptr18348, align 8 
  store volatile i64 %zTP$_37drop, i64* %vptr18351, align 8 ; load; *envptr18348
 %vptr18354 = alloca i64, align 8 
  %envptr18352 = inttoptr i64 %env12129 to i64* 
  store volatile i64 %v42$y, i64* %vptr18354, align 8 ; closure/env cast; i64 -> i64*
  %vptr18355 = alloca i64*, align 8 
  %envptr18353 = getelementptr inbounds i64, i64* %envptr18352, i64 6 
  store volatile i64* %envptr18353, i64** %vptr18355, align 8 ; &envptr18352[5]
 %vptr18356 = alloca i64, align 8 
  %v42$y = load i64, i64* %envptr18353, align 8 
  store volatile i64 %v42$y, i64* %vptr18356, align 8 ; load; *envptr18353
 %vptr18359 = alloca i64, align 8 
  %envptr18357 = inttoptr i64 %env12129 to i64* 
  store volatile i64 %cont7159, i64* %vptr18359, align 8 ; closure/env cast; i64 -> i64*
  %vptr18360 = alloca i64*, align 8 
  %envptr18358 = getelementptr inbounds i64, i64* %envptr18357, i64 5 
  store volatile i64* %envptr18358, i64** %vptr18360, align 8 ; &envptr18357[4]
 %vptr18361 = alloca i64, align 8 
  %cont7159 = load i64, i64* %envptr18358, align 8 
  store volatile i64 %cont7159, i64* %vptr18361, align 8 ; load; *envptr18358
 %vptr18364 = alloca i64, align 8 
  %envptr18362 = inttoptr i64 %env12129 to i64* 
  store volatile i64 %emsg18637, i64* %vptr18364, align 8 ; closure/env cast; i64 -> i64*
  %vptr18365 = alloca i64*, align 8 
  %envptr18363 = getelementptr inbounds i64, i64* %envptr18362, i64 4 
  store volatile i64* %envptr18363, i64** %vptr18365, align 8 ; &envptr18362[3]
 %vptr18366 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr18363, align 8 
  store volatile i64 %emsg18637, i64* %vptr18366, align 8 ; load; *envptr18363
 %vptr18369 = alloca i64, align 8 
  %envptr18367 = inttoptr i64 %env12129 to i64* 
  store volatile i64 %bcc$ly, i64* %vptr18369, align 8 ; closure/env cast; i64 -> i64*
  %vptr18370 = alloca i64*, align 8 
  %envptr18368 = getelementptr inbounds i64, i64* %envptr18367, i64 3 
  store volatile i64* %envptr18368, i64** %vptr18370, align 8 ; &envptr18367[2]
 %vptr18371 = alloca i64, align 8 
  %bcc$ly = load i64, i64* %envptr18368, align 8 
  store volatile i64 %bcc$ly, i64* %vptr18371, align 8 ; load; *envptr18368
 %vptr18374 = alloca i64, align 8 
  %envptr18372 = inttoptr i64 %env12129 to i64* 
  store volatile i64 %FhZ$x, i64* %vptr18374, align 8 ; closure/env cast; i64 -> i64*
  %vptr18375 = alloca i64*, align 8 
  %envptr18373 = getelementptr inbounds i64, i64* %envptr18372, i64 2 
  store volatile i64* %envptr18373, i64** %vptr18375, align 8 ; &envptr18372[1]
 %vptr18376 = alloca i64, align 8 
  %FhZ$x = load i64, i64* %envptr18373, align 8 
  store volatile i64 %FhZ$x, i64* %vptr18376, align 8 ; load; *envptr18373
 %vptr18377 = alloca i64, align 8 
  %_957162 = call i64 @prim_car(i64 %rvp9541) 
  store volatile i64 %_957162, i64* %vptr18377, align 8 ; call prim_car
 %vptr18378 = alloca i64, align 8 
  %rvp9537 = call i64 @prim_cdr(i64 %rvp9541) 
  store volatile i64 %rvp9537, i64* %vptr18378, align 8 ; call prim_cdr
 %vptr18379 = alloca i64, align 8 
  %n_639542 = call i64 @prim_null_63(i64 %rvp9537) 
  store volatile i64 %n_639542, i64* %vptr18379, align 8 ; call prim_null_63
  %cmpptr18383 = alloca i1, align 8  %cmp18380 = icmp eq i64 %n_639542, 15 store volatile i1 %cmp18380, i1* %cmpptr18383, align 8; false?
  br i1 %cmp18380, label %else18382, label %then18381                                ; if

then18381:
 %vptr18384 = alloca i64, align 8 
  %h9543 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9543, i64* %vptr18384, align 8 ; call prim_halt
  %vptr18390 = alloca i64*, align 8 
  %cloptr18385 = inttoptr i64 %h9543 to i64* 
  store volatile i64* %cloptr18385, i64** %vptr18390, align 8 ; closure/env cast; i64 -> i64*
  %vptr18391 = alloca i64*, align 8 
  %i0ptr18386 = getelementptr inbounds i64, i64* %cloptr18385, i64 1 
  store volatile i64* %i0ptr18386, i64** %vptr18391, align 8 ; &cloptr18385[1]
 %vptr18392 = alloca i64, align 8 
  %f18388 = load i64, i64* %i0ptr18386, align 8 
  store volatile i64 %f18388, i64* %vptr18392, align 8 ; load; *i0ptr18386
  %fptr18387 = inttoptr i64 %f18388 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18387(i64 %h9543, i64 %h9543)                       ; tail call
  ret void

else18382:
 %vptr18393 = alloca i64, align 8 
  %L0p$loop = call i64 @prim_car(i64 %rvp9537) 
  store volatile i64 %L0p$loop, i64* %vptr18393, align 8 ; call prim_car
 %vptr18394 = alloca i64, align 8 
  %na9376 = call i64 @prim_cdr(i64 %rvp9537) 
  store volatile i64 %na9376, i64* %vptr18394, align 8 ; call prim_cdr
 %vptr18395 = alloca i64, align 8 
  %n_639538 = call i64 @prim_null_63(i64 %na9376) 
  store volatile i64 %n_639538, i64* %vptr18395, align 8 ; call prim_null_63
  %cmpptr18399 = alloca i1, align 8  %cmp18396 = icmp eq i64 %n_639538, 15 store volatile i1 %cmp18396, i1* %cmpptr18399, align 8; false?
  br i1 %cmp18396, label %else18398, label %then18397                                ; if

then18397:
 %vptr18400 = alloca i64, align 8 
  %arg7824 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7824, i64* %vptr18400, align 8 ; quoted int
  %vptr18407 = alloca i64*, align 8 
  %cloptr18401 = call i64* @make_closure(i64 32) 
  store volatile i64* %cloptr18401, i64** %vptr18407, align 8 ; malloc
  %vptr18408 = alloca i64*, align 8 
  %eptr18403 = getelementptr inbounds i64, i64* %cloptr18401, i64 2 
  store volatile i64* %eptr18403, i64** %vptr18408, align 8 ; &eptr18403[1]
  %vptr18409 = alloca i64*, align 8 
  %eptr18404 = getelementptr inbounds i64, i64* %cloptr18401, i64 3 
  store volatile i64* %eptr18404, i64** %vptr18409, align 8 ; &eptr18404[2]
  %vptr18410 = alloca i64*, align 8 
  %eptr18405 = getelementptr inbounds i64, i64* %cloptr18401, i64 4 
  store volatile i64* %eptr18405, i64** %vptr18410, align 8 ; &eptr18405[3]
  store i64 %emsg18637, i64* %eptr18403                                              ; *eptr18403 = %emsg18637
  store i64 %L0p$loop, i64* %eptr18404                                               ; *eptr18404 = %L0p$loop
  store i64 %emsg08636, i64* %eptr18405                                              ; *eptr18405 = %emsg08636
  %vptr18411 = alloca i64*, align 8 
  %eptr18402 = getelementptr inbounds i64, i64* %cloptr18401, i64 1 
  store volatile i64* %eptr18402, i64** %vptr18411, align 8 ; &cloptr18401[1]
 %vptr18412 = alloca i64, align 8 
  %f18406 = ptrtoint void(i64,i64)* @lam12125 to i64 
  store volatile i64 %f18406, i64* %vptr18412, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f18406, i64* %eptr18402                                                 ; store fptr
 %vptr18413 = alloca i64, align 8 
  %arg7823 = ptrtoint i64* %cloptr18401 to i64 
  store volatile i64 %arg7823, i64* %vptr18413, align 8 ; closure cast; i64* -> i64
 %vptr18414 = alloca i64, align 8 
  %b8D$_956883 = call i64 @prim_vector_45set_33(i64 %L0p$loop, i64 %arg7824, i64 %arg7823) 
  store volatile i64 %b8D$_956883, i64* %vptr18414, align 8 ; call prim_vector_45set_33
 %vptr18415 = alloca i64, align 8 
  %arg7839 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7839, i64* %vptr18415, align 8 ; quoted int
 %vptr18416 = alloca i64, align 8 
  %a7005 = call i64 @prim_vector_45ref(i64 %L0p$loop, i64 %arg7839) 
  store volatile i64 %a7005, i64* %vptr18416, align 8 ; call prim_vector_45ref
  %vptr18430 = alloca i64*, align 8 
  %cloptr18417 = call i64* @make_closure(i64 88) 
  store volatile i64* %cloptr18417, i64** %vptr18430, align 8 ; malloc
  %vptr18431 = alloca i64*, align 8 
  %eptr18419 = getelementptr inbounds i64, i64* %cloptr18417, i64 2 
  store volatile i64* %eptr18419, i64** %vptr18431, align 8 ; &eptr18419[1]
  %vptr18432 = alloca i64*, align 8 
  %eptr18420 = getelementptr inbounds i64, i64* %cloptr18417, i64 3 
  store volatile i64* %eptr18420, i64** %vptr18432, align 8 ; &eptr18420[2]
  %vptr18433 = alloca i64*, align 8 
  %eptr18421 = getelementptr inbounds i64, i64* %cloptr18417, i64 4 
  store volatile i64* %eptr18421, i64** %vptr18433, align 8 ; &eptr18421[3]
  %vptr18434 = alloca i64*, align 8 
  %eptr18422 = getelementptr inbounds i64, i64* %cloptr18417, i64 5 
  store volatile i64* %eptr18422, i64** %vptr18434, align 8 ; &eptr18422[4]
  %vptr18435 = alloca i64*, align 8 
  %eptr18423 = getelementptr inbounds i64, i64* %cloptr18417, i64 6 
  store volatile i64* %eptr18423, i64** %vptr18435, align 8 ; &eptr18423[5]
  %vptr18436 = alloca i64*, align 8 
  %eptr18424 = getelementptr inbounds i64, i64* %cloptr18417, i64 7 
  store volatile i64* %eptr18424, i64** %vptr18436, align 8 ; &eptr18424[6]
  %vptr18437 = alloca i64*, align 8 
  %eptr18425 = getelementptr inbounds i64, i64* %cloptr18417, i64 8 
  store volatile i64* %eptr18425, i64** %vptr18437, align 8 ; &eptr18425[7]
  %vptr18438 = alloca i64*, align 8 
  %eptr18426 = getelementptr inbounds i64, i64* %cloptr18417, i64 9 
  store volatile i64* %eptr18426, i64** %vptr18438, align 8 ; &eptr18426[8]
  %vptr18439 = alloca i64*, align 8 
  %eptr18427 = getelementptr inbounds i64, i64* %cloptr18417, i64 10 
  store volatile i64* %eptr18427, i64** %vptr18439, align 8 ; &eptr18427[9]
  %vptr18440 = alloca i64*, align 8 
  %eptr18428 = getelementptr inbounds i64, i64* %cloptr18417, i64 11 
  store volatile i64* %eptr18428, i64** %vptr18440, align 8 ; &eptr18428[10]
  store i64 %FhZ$x, i64* %eptr18419                                                  ; *eptr18419 = %FhZ$x
  store i64 %bcc$ly, i64* %eptr18420                                                 ; *eptr18420 = %bcc$ly
  store i64 %emsg18637, i64* %eptr18421                                              ; *eptr18421 = %emsg18637
  store i64 %cont7159, i64* %eptr18422                                               ; *eptr18422 = %cont7159
  store i64 %v42$y, i64* %eptr18423                                                  ; *eptr18423 = %v42$y
  store i64 %zTP$_37drop, i64* %eptr18424                                            ; *eptr18424 = %zTP$_37drop
  store i64 %DwU$lx, i64* %eptr18425                                                 ; *eptr18425 = %DwU$lx
  store i64 %emsg08636, i64* %eptr18426                                              ; *eptr18426 = %emsg08636
  store i64 %uLY$_37_62, i64* %eptr18427                                             ; *eptr18427 = %uLY$_37_62
  store i64 %a7005, i64* %eptr18428                                                  ; *eptr18428 = %a7005
  %vptr18441 = alloca i64*, align 8 
  %eptr18418 = getelementptr inbounds i64, i64* %cloptr18417, i64 1 
  store volatile i64* %eptr18418, i64** %vptr18441, align 8 ; &cloptr18417[1]
 %vptr18442 = alloca i64, align 8 
  %f18429 = ptrtoint void(i64,i64)* @lam12118 to i64 
  store volatile i64 %f18429, i64* %vptr18442, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f18429, i64* %eptr18418                                                 ; store fptr
 %vptr18443 = alloca i64, align 8 
  %arg7843 = ptrtoint i64* %cloptr18417 to i64 
  store volatile i64 %arg7843, i64* %vptr18443, align 8 ; closure cast; i64* -> i64
 %vptr18444 = alloca i64, align 8 
  %rva9536 = add i64 0, 0 
  store volatile i64 %rva9536, i64* %vptr18444, align 8 ; quoted ()
 %vptr18445 = alloca i64, align 8 
  %rva9535 = call i64 @prim_cons(i64 %bcc$ly, i64 %rva9536) 
  store volatile i64 %rva9535, i64* %vptr18445, align 8 ; call prim_cons
 %vptr18446 = alloca i64, align 8 
  %rva9534 = call i64 @prim_cons(i64 %DwU$lx, i64 %rva9535) 
  store volatile i64 %rva9534, i64* %vptr18446, align 8 ; call prim_cons
 %vptr18447 = alloca i64, align 8 
  %rva9533 = call i64 @prim_cons(i64 %arg7843, i64 %rva9534) 
  store volatile i64 %rva9533, i64* %vptr18447, align 8 ; call prim_cons
  %vptr18453 = alloca i64*, align 8 
  %cloptr18448 = inttoptr i64 %uLY$_37_62 to i64* 
  store volatile i64* %cloptr18448, i64** %vptr18453, align 8 ; closure/env cast; i64 -> i64*
  %vptr18454 = alloca i64*, align 8 
  %i0ptr18449 = getelementptr inbounds i64, i64* %cloptr18448, i64 1 
  store volatile i64* %i0ptr18449, i64** %vptr18454, align 8 ; &cloptr18448[1]
 %vptr18455 = alloca i64, align 8 
  %f18451 = load i64, i64* %i0ptr18449, align 8 
  store volatile i64 %f18451, i64* %vptr18455, align 8 ; load; *i0ptr18449
  %fptr18450 = inttoptr i64 %f18451 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18450(i64 %uLY$_37_62, i64 %rva9533)                ; tail call
  ret void

else18398:
 %vptr18456 = alloca i64, align 8 
  %h9539 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9539, i64* %vptr18456, align 8 ; call prim_halt
  %vptr18462 = alloca i64*, align 8 
  %cloptr18457 = inttoptr i64 %h9539 to i64* 
  store volatile i64* %cloptr18457, i64** %vptr18462, align 8 ; closure/env cast; i64 -> i64*
  %vptr18463 = alloca i64*, align 8 
  %i0ptr18458 = getelementptr inbounds i64, i64* %cloptr18457, i64 1 
  store volatile i64* %i0ptr18458, i64** %vptr18463, align 8 ; &cloptr18457[1]
 %vptr18464 = alloca i64, align 8 
  %f18460 = load i64, i64* %i0ptr18458, align 8 
  store volatile i64 %f18460, i64* %vptr18464, align 8 ; load; *i0ptr18458
  %fptr18459 = inttoptr i64 %f18460 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18459(i64 %h9539, i64 %h9539)                       ; tail call
  ret void
}


define void @lam12125(i64 %env12126, i64 %rvp9394) {
 %vptr18467 = alloca i64, align 8 
  %envptr18465 = inttoptr i64 %env12126 to i64* 
  store volatile i64 %emsg08636, i64* %vptr18467, align 8 ; closure/env cast; i64 -> i64*
  %vptr18468 = alloca i64*, align 8 
  %envptr18466 = getelementptr inbounds i64, i64* %envptr18465, i64 4 
  store volatile i64* %envptr18466, i64** %vptr18468, align 8 ; &envptr18465[3]
 %vptr18469 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr18466, align 8 
  store volatile i64 %emsg08636, i64* %vptr18469, align 8 ; load; *envptr18466
 %vptr18472 = alloca i64, align 8 
  %envptr18470 = inttoptr i64 %env12126 to i64* 
  store volatile i64 %L0p$loop, i64* %vptr18472, align 8 ; closure/env cast; i64 -> i64*
  %vptr18473 = alloca i64*, align 8 
  %envptr18471 = getelementptr inbounds i64, i64* %envptr18470, i64 3 
  store volatile i64* %envptr18471, i64** %vptr18473, align 8 ; &envptr18470[2]
 %vptr18474 = alloca i64, align 8 
  %L0p$loop = load i64, i64* %envptr18471, align 8 
  store volatile i64 %L0p$loop, i64* %vptr18474, align 8 ; load; *envptr18471
 %vptr18477 = alloca i64, align 8 
  %envptr18475 = inttoptr i64 %env12126 to i64* 
  store volatile i64 %emsg18637, i64* %vptr18477, align 8 ; closure/env cast; i64 -> i64*
  %vptr18478 = alloca i64*, align 8 
  %envptr18476 = getelementptr inbounds i64, i64* %envptr18475, i64 2 
  store volatile i64* %envptr18476, i64** %vptr18478, align 8 ; &envptr18475[1]
 %vptr18479 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr18476, align 8 
  store volatile i64 %emsg18637, i64* %vptr18479, align 8 ; load; *envptr18476
 %vptr18480 = alloca i64, align 8 
  %cont7163 = call i64 @prim_car(i64 %rvp9394) 
  store volatile i64 %cont7163, i64* %vptr18480, align 8 ; call prim_car
 %vptr18481 = alloca i64, align 8 
  %rvp9390 = call i64 @prim_cdr(i64 %rvp9394) 
  store volatile i64 %rvp9390, i64* %vptr18481, align 8 ; call prim_cdr
 %vptr18482 = alloca i64, align 8 
  %n_639395 = call i64 @prim_null_63(i64 %rvp9390) 
  store volatile i64 %n_639395, i64* %vptr18482, align 8 ; call prim_null_63
  %cmpptr18486 = alloca i1, align 8  %cmp18483 = icmp eq i64 %n_639395, 15 store volatile i1 %cmp18483, i1* %cmpptr18486, align 8; false?
  br i1 %cmp18483, label %else18485, label %then18484                                ; if

then18484:
 %vptr18487 = alloca i64, align 8 
  %h9396 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9396, i64* %vptr18487, align 8 ; call prim_halt
  %vptr18493 = alloca i64*, align 8 
  %cloptr18488 = inttoptr i64 %h9396 to i64* 
  store volatile i64* %cloptr18488, i64** %vptr18493, align 8 ; closure/env cast; i64 -> i64*
  %vptr18494 = alloca i64*, align 8 
  %i0ptr18489 = getelementptr inbounds i64, i64* %cloptr18488, i64 1 
  store volatile i64* %i0ptr18489, i64** %vptr18494, align 8 ; &cloptr18488[1]
 %vptr18495 = alloca i64, align 8 
  %f18491 = load i64, i64* %i0ptr18489, align 8 
  store volatile i64 %f18491, i64* %vptr18495, align 8 ; load; *i0ptr18489
  %fptr18490 = inttoptr i64 %f18491 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18490(i64 %h9396, i64 %h9396)                       ; tail call
  ret void

else18485:
 %vptr18496 = alloca i64, align 8 
  %fgV$x = call i64 @prim_car(i64 %rvp9390) 
  store volatile i64 %fgV$x, i64* %vptr18496, align 8 ; call prim_car
 %vptr18497 = alloca i64, align 8 
  %rvp9386 = call i64 @prim_cdr(i64 %rvp9390) 
  store volatile i64 %rvp9386, i64* %vptr18497, align 8 ; call prim_cdr
 %vptr18498 = alloca i64, align 8 
  %n_639391 = call i64 @prim_null_63(i64 %rvp9386) 
  store volatile i64 %n_639391, i64* %vptr18498, align 8 ; call prim_null_63
  %cmpptr18502 = alloca i1, align 8  %cmp18499 = icmp eq i64 %n_639391, 15 store volatile i1 %cmp18499, i1* %cmpptr18502, align 8; false?
  br i1 %cmp18499, label %else18501, label %then18500                                ; if

then18500:
 %vptr18503 = alloca i64, align 8 
  %h9392 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9392, i64* %vptr18503, align 8 ; call prim_halt
  %vptr18509 = alloca i64*, align 8 
  %cloptr18504 = inttoptr i64 %h9392 to i64* 
  store volatile i64* %cloptr18504, i64** %vptr18509, align 8 ; closure/env cast; i64 -> i64*
  %vptr18510 = alloca i64*, align 8 
  %i0ptr18505 = getelementptr inbounds i64, i64* %cloptr18504, i64 1 
  store volatile i64* %i0ptr18505, i64** %vptr18510, align 8 ; &cloptr18504[1]
 %vptr18511 = alloca i64, align 8 
  %f18507 = load i64, i64* %i0ptr18505, align 8 
  store volatile i64 %f18507, i64* %vptr18511, align 8 ; load; *i0ptr18505
  %fptr18506 = inttoptr i64 %f18507 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18506(i64 %h9392, i64 %h9392)                       ; tail call
  ret void

else18501:
 %vptr18512 = alloca i64, align 8 
  %Mml$y = call i64 @prim_car(i64 %rvp9386) 
  store volatile i64 %Mml$y, i64* %vptr18512, align 8 ; call prim_car
 %vptr18513 = alloca i64, align 8 
  %na9378 = call i64 @prim_cdr(i64 %rvp9386) 
  store volatile i64 %na9378, i64* %vptr18513, align 8 ; call prim_cdr
 %vptr18514 = alloca i64, align 8 
  %n_639387 = call i64 @prim_null_63(i64 %na9378) 
  store volatile i64 %n_639387, i64* %vptr18514, align 8 ; call prim_null_63
  %cmpptr18518 = alloca i1, align 8  %cmp18515 = icmp eq i64 %n_639387, 15 store volatile i1 %cmp18515, i1* %cmpptr18518, align 8; false?
  br i1 %cmp18515, label %else18517, label %then18516                                ; if

then18516:
 %vptr18519 = alloca i64, align 8 
  %a7001 = call i64 @prim_eq_63(i64 %fgV$x, i64 %Mml$y) 
  store volatile i64 %a7001, i64* %vptr18519, align 8 ; call prim_eq_63
  %cmpptr18523 = alloca i1, align 8  %cmp18520 = icmp eq i64 %a7001, 15 store volatile i1 %cmp18520, i1* %cmpptr18523, align 8; false?
  br i1 %cmp18520, label %else18522, label %then18521                                ; if

then18521:
 %vptr18524 = alloca i64, align 8 
  %arg7829 = add i64 0, 0 
  store volatile i64 %arg7829, i64* %vptr18524, align 8 ; quoted ()
 %vptr18525 = alloca i64, align 8 
  %rva9381 = add i64 0, 0 
  store volatile i64 %rva9381, i64* %vptr18525, align 8 ; quoted ()
 %vptr18526 = alloca i64, align 8 
  %rva9380 = call i64 @prim_cons(i64 %fgV$x, i64 %rva9381) 
  store volatile i64 %rva9380, i64* %vptr18526, align 8 ; call prim_cons
 %vptr18527 = alloca i64, align 8 
  %rva9379 = call i64 @prim_cons(i64 %arg7829, i64 %rva9380) 
  store volatile i64 %rva9379, i64* %vptr18527, align 8 ; call prim_cons
  %vptr18533 = alloca i64*, align 8 
  %cloptr18528 = inttoptr i64 %cont7163 to i64* 
  store volatile i64* %cloptr18528, i64** %vptr18533, align 8 ; closure/env cast; i64 -> i64*
  %vptr18534 = alloca i64*, align 8 
  %i0ptr18529 = getelementptr inbounds i64, i64* %cloptr18528, i64 1 
  store volatile i64* %i0ptr18529, i64** %vptr18534, align 8 ; &cloptr18528[1]
 %vptr18535 = alloca i64, align 8 
  %f18531 = load i64, i64* %i0ptr18529, align 8 
  store volatile i64 %f18531, i64* %vptr18535, align 8 ; load; *i0ptr18529
  %fptr18530 = inttoptr i64 %f18531 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18530(i64 %cont7163, i64 %rva9379)                  ; tail call
  ret void

else18522:
 %vptr18536 = alloca i64, align 8 
  %arg7831 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7831, i64* %vptr18536, align 8 ; quoted int
 %vptr18537 = alloca i64, align 8 
  %a7002 = call i64 @prim_vector_45ref(i64 %L0p$loop, i64 %arg7831) 
  store volatile i64 %a7002, i64* %vptr18537, align 8 ; call prim_vector_45ref
 %vptr18538 = alloca i64, align 8 
  %a7003 = call i64 @prim_cdr(i64 %fgV$x) 
  store volatile i64 %a7003, i64* %vptr18538, align 8 ; call prim_cdr
 %vptr18539 = alloca i64, align 8 
  %a7004 = call i64 @prim_cdr(i64 %Mml$y) 
  store volatile i64 %a7004, i64* %vptr18539, align 8 ; call prim_cdr
 %vptr18540 = alloca i64, align 8 
  %rva9385 = add i64 0, 0 
  store volatile i64 %rva9385, i64* %vptr18540, align 8 ; quoted ()
 %vptr18541 = alloca i64, align 8 
  %rva9384 = call i64 @prim_cons(i64 %a7004, i64 %rva9385) 
  store volatile i64 %rva9384, i64* %vptr18541, align 8 ; call prim_cons
 %vptr18542 = alloca i64, align 8 
  %rva9383 = call i64 @prim_cons(i64 %a7003, i64 %rva9384) 
  store volatile i64 %rva9383, i64* %vptr18542, align 8 ; call prim_cons
 %vptr18543 = alloca i64, align 8 
  %rva9382 = call i64 @prim_cons(i64 %cont7163, i64 %rva9383) 
  store volatile i64 %rva9382, i64* %vptr18543, align 8 ; call prim_cons
  %vptr18549 = alloca i64*, align 8 
  %cloptr18544 = inttoptr i64 %a7002 to i64* 
  store volatile i64* %cloptr18544, i64** %vptr18549, align 8 ; closure/env cast; i64 -> i64*
  %vptr18550 = alloca i64*, align 8 
  %i0ptr18545 = getelementptr inbounds i64, i64* %cloptr18544, i64 1 
  store volatile i64* %i0ptr18545, i64** %vptr18550, align 8 ; &cloptr18544[1]
 %vptr18551 = alloca i64, align 8 
  %f18547 = load i64, i64* %i0ptr18545, align 8 
  store volatile i64 %f18547, i64* %vptr18551, align 8 ; load; *i0ptr18545
  %fptr18546 = inttoptr i64 %f18547 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18546(i64 %a7002, i64 %rva9382)                     ; tail call
  ret void

else18517:
 %vptr18552 = alloca i64, align 8 
  %h9388 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9388, i64* %vptr18552, align 8 ; call prim_halt
  %vptr18558 = alloca i64*, align 8 
  %cloptr18553 = inttoptr i64 %h9388 to i64* 
  store volatile i64* %cloptr18553, i64** %vptr18558, align 8 ; closure/env cast; i64 -> i64*
  %vptr18559 = alloca i64*, align 8 
  %i0ptr18554 = getelementptr inbounds i64, i64* %cloptr18553, i64 1 
  store volatile i64* %i0ptr18554, i64** %vptr18559, align 8 ; &cloptr18553[1]
 %vptr18560 = alloca i64, align 8 
  %f18556 = load i64, i64* %i0ptr18554, align 8 
  store volatile i64 %f18556, i64* %vptr18560, align 8 ; load; *i0ptr18554
  %fptr18555 = inttoptr i64 %f18556 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18555(i64 %h9388, i64 %h9388)                       ; tail call
  ret void
}


define void @lam12118(i64 %env12119, i64 %rvp9529) {
 %vptr18563 = alloca i64, align 8 
  %envptr18561 = inttoptr i64 %env12119 to i64* 
  store volatile i64 %a7005, i64* %vptr18563, align 8 ; closure/env cast; i64 -> i64*
  %vptr18564 = alloca i64*, align 8 
  %envptr18562 = getelementptr inbounds i64, i64* %envptr18561, i64 11 
  store volatile i64* %envptr18562, i64** %vptr18564, align 8 ; &envptr18561[10]
 %vptr18565 = alloca i64, align 8 
  %a7005 = load i64, i64* %envptr18562, align 8 
  store volatile i64 %a7005, i64* %vptr18565, align 8 ; load; *envptr18562
 %vptr18568 = alloca i64, align 8 
  %envptr18566 = inttoptr i64 %env12119 to i64* 
  store volatile i64 %uLY$_37_62, i64* %vptr18568, align 8 ; closure/env cast; i64 -> i64*
  %vptr18569 = alloca i64*, align 8 
  %envptr18567 = getelementptr inbounds i64, i64* %envptr18566, i64 10 
  store volatile i64* %envptr18567, i64** %vptr18569, align 8 ; &envptr18566[9]
 %vptr18570 = alloca i64, align 8 
  %uLY$_37_62 = load i64, i64* %envptr18567, align 8 
  store volatile i64 %uLY$_37_62, i64* %vptr18570, align 8 ; load; *envptr18567
 %vptr18573 = alloca i64, align 8 
  %envptr18571 = inttoptr i64 %env12119 to i64* 
  store volatile i64 %emsg08636, i64* %vptr18573, align 8 ; closure/env cast; i64 -> i64*
  %vptr18574 = alloca i64*, align 8 
  %envptr18572 = getelementptr inbounds i64, i64* %envptr18571, i64 9 
  store volatile i64* %envptr18572, i64** %vptr18574, align 8 ; &envptr18571[8]
 %vptr18575 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr18572, align 8 
  store volatile i64 %emsg08636, i64* %vptr18575, align 8 ; load; *envptr18572
 %vptr18578 = alloca i64, align 8 
  %envptr18576 = inttoptr i64 %env12119 to i64* 
  store volatile i64 %DwU$lx, i64* %vptr18578, align 8 ; closure/env cast; i64 -> i64*
  %vptr18579 = alloca i64*, align 8 
  %envptr18577 = getelementptr inbounds i64, i64* %envptr18576, i64 8 
  store volatile i64* %envptr18577, i64** %vptr18579, align 8 ; &envptr18576[7]
 %vptr18580 = alloca i64, align 8 
  %DwU$lx = load i64, i64* %envptr18577, align 8 
  store volatile i64 %DwU$lx, i64* %vptr18580, align 8 ; load; *envptr18577
 %vptr18583 = alloca i64, align 8 
  %envptr18581 = inttoptr i64 %env12119 to i64* 
  store volatile i64 %zTP$_37drop, i64* %vptr18583, align 8 ; closure/env cast; i64 -> i64*
  %vptr18584 = alloca i64*, align 8 
  %envptr18582 = getelementptr inbounds i64, i64* %envptr18581, i64 7 
  store volatile i64* %envptr18582, i64** %vptr18584, align 8 ; &envptr18581[6]
 %vptr18585 = alloca i64, align 8 
  %zTP$_37drop = load i64, i64* %envptr18582, align 8 
  store volatile i64 %zTP$_37drop, i64* %vptr18585, align 8 ; load; *envptr18582
 %vptr18588 = alloca i64, align 8 
  %envptr18586 = inttoptr i64 %env12119 to i64* 
  store volatile i64 %v42$y, i64* %vptr18588, align 8 ; closure/env cast; i64 -> i64*
  %vptr18589 = alloca i64*, align 8 
  %envptr18587 = getelementptr inbounds i64, i64* %envptr18586, i64 6 
  store volatile i64* %envptr18587, i64** %vptr18589, align 8 ; &envptr18586[5]
 %vptr18590 = alloca i64, align 8 
  %v42$y = load i64, i64* %envptr18587, align 8 
  store volatile i64 %v42$y, i64* %vptr18590, align 8 ; load; *envptr18587
 %vptr18593 = alloca i64, align 8 
  %envptr18591 = inttoptr i64 %env12119 to i64* 
  store volatile i64 %cont7159, i64* %vptr18593, align 8 ; closure/env cast; i64 -> i64*
  %vptr18594 = alloca i64*, align 8 
  %envptr18592 = getelementptr inbounds i64, i64* %envptr18591, i64 5 
  store volatile i64* %envptr18592, i64** %vptr18594, align 8 ; &envptr18591[4]
 %vptr18595 = alloca i64, align 8 
  %cont7159 = load i64, i64* %envptr18592, align 8 
  store volatile i64 %cont7159, i64* %vptr18595, align 8 ; load; *envptr18592
 %vptr18598 = alloca i64, align 8 
  %envptr18596 = inttoptr i64 %env12119 to i64* 
  store volatile i64 %emsg18637, i64* %vptr18598, align 8 ; closure/env cast; i64 -> i64*
  %vptr18599 = alloca i64*, align 8 
  %envptr18597 = getelementptr inbounds i64, i64* %envptr18596, i64 4 
  store volatile i64* %envptr18597, i64** %vptr18599, align 8 ; &envptr18596[3]
 %vptr18600 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr18597, align 8 
  store volatile i64 %emsg18637, i64* %vptr18600, align 8 ; load; *envptr18597
 %vptr18603 = alloca i64, align 8 
  %envptr18601 = inttoptr i64 %env12119 to i64* 
  store volatile i64 %bcc$ly, i64* %vptr18603, align 8 ; closure/env cast; i64 -> i64*
  %vptr18604 = alloca i64*, align 8 
  %envptr18602 = getelementptr inbounds i64, i64* %envptr18601, i64 3 
  store volatile i64* %envptr18602, i64** %vptr18604, align 8 ; &envptr18601[2]
 %vptr18605 = alloca i64, align 8 
  %bcc$ly = load i64, i64* %envptr18602, align 8 
  store volatile i64 %bcc$ly, i64* %vptr18605, align 8 ; load; *envptr18602
 %vptr18608 = alloca i64, align 8 
  %envptr18606 = inttoptr i64 %env12119 to i64* 
  store volatile i64 %FhZ$x, i64* %vptr18608, align 8 ; closure/env cast; i64 -> i64*
  %vptr18609 = alloca i64*, align 8 
  %envptr18607 = getelementptr inbounds i64, i64* %envptr18606, i64 2 
  store volatile i64* %envptr18607, i64** %vptr18609, align 8 ; &envptr18606[1]
 %vptr18610 = alloca i64, align 8 
  %FhZ$x = load i64, i64* %envptr18607, align 8 
  store volatile i64 %FhZ$x, i64* %vptr18610, align 8 ; load; *envptr18607
 %vptr18611 = alloca i64, align 8 
  %_957164 = call i64 @prim_car(i64 %rvp9529) 
  store volatile i64 %_957164, i64* %vptr18611, align 8 ; call prim_car
 %vptr18612 = alloca i64, align 8 
  %rvp9525 = call i64 @prim_cdr(i64 %rvp9529) 
  store volatile i64 %rvp9525, i64* %vptr18612, align 8 ; call prim_cdr
 %vptr18613 = alloca i64, align 8 
  %n_639530 = call i64 @prim_null_63(i64 %rvp9525) 
  store volatile i64 %n_639530, i64* %vptr18613, align 8 ; call prim_null_63
  %cmpptr18617 = alloca i1, align 8  %cmp18614 = icmp eq i64 %n_639530, 15 store volatile i1 %cmp18614, i1* %cmpptr18617, align 8; false?
  br i1 %cmp18614, label %else18616, label %then18615                                ; if

then18615:
 %vptr18618 = alloca i64, align 8 
  %h9531 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9531, i64* %vptr18618, align 8 ; call prim_halt
  %vptr18624 = alloca i64*, align 8 
  %cloptr18619 = inttoptr i64 %h9531 to i64* 
  store volatile i64* %cloptr18619, i64** %vptr18624, align 8 ; closure/env cast; i64 -> i64*
  %vptr18625 = alloca i64*, align 8 
  %i0ptr18620 = getelementptr inbounds i64, i64* %cloptr18619, i64 1 
  store volatile i64* %i0ptr18620, i64** %vptr18625, align 8 ; &cloptr18619[1]
 %vptr18626 = alloca i64, align 8 
  %f18622 = load i64, i64* %i0ptr18620, align 8 
  store volatile i64 %f18622, i64* %vptr18626, align 8 ; load; *i0ptr18620
  %fptr18621 = inttoptr i64 %f18622 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18621(i64 %h9531, i64 %h9531)                       ; tail call
  ret void

else18616:
 %vptr18627 = alloca i64, align 8 
  %a7006 = call i64 @prim_car(i64 %rvp9525) 
  store volatile i64 %a7006, i64* %vptr18627, align 8 ; call prim_car
 %vptr18628 = alloca i64, align 8 
  %na9399 = call i64 @prim_cdr(i64 %rvp9525) 
  store volatile i64 %na9399, i64* %vptr18628, align 8 ; call prim_cdr
 %vptr18629 = alloca i64, align 8 
  %n_639526 = call i64 @prim_null_63(i64 %na9399) 
  store volatile i64 %n_639526, i64* %vptr18629, align 8 ; call prim_null_63
  %cmpptr18633 = alloca i1, align 8  %cmp18630 = icmp eq i64 %n_639526, 15 store volatile i1 %cmp18630, i1* %cmpptr18633, align 8; false?
  br i1 %cmp18630, label %else18632, label %then18631                                ; if

then18631:
  %cmpptr18637 = alloca i1, align 8  %cmp18634 = icmp eq i64 %a7006, 15 store volatile i1 %cmp18634, i1* %cmpptr18637, align 8; false?
  br i1 %cmp18634, label %else18636, label %then18635                                ; if

then18635:
 %vptr18638 = alloca i64, align 8 
  %a7007 = call i64 @prim__45(i64 %DwU$lx, i64 %bcc$ly) 
  store volatile i64 %a7007, i64* %vptr18638, align 8 ; call prim__45
  %vptr18651 = alloca i64*, align 8 
  %cloptr18639 = call i64* @make_closure(i64 80) 
  store volatile i64* %cloptr18639, i64** %vptr18651, align 8 ; malloc
  %vptr18652 = alloca i64*, align 8 
  %eptr18641 = getelementptr inbounds i64, i64* %cloptr18639, i64 2 
  store volatile i64* %eptr18641, i64** %vptr18652, align 8 ; &eptr18641[1]
  %vptr18653 = alloca i64*, align 8 
  %eptr18642 = getelementptr inbounds i64, i64* %cloptr18639, i64 3 
  store volatile i64* %eptr18642, i64** %vptr18653, align 8 ; &eptr18642[2]
  %vptr18654 = alloca i64*, align 8 
  %eptr18643 = getelementptr inbounds i64, i64* %cloptr18639, i64 4 
  store volatile i64* %eptr18643, i64** %vptr18654, align 8 ; &eptr18643[3]
  %vptr18655 = alloca i64*, align 8 
  %eptr18644 = getelementptr inbounds i64, i64* %cloptr18639, i64 5 
  store volatile i64* %eptr18644, i64** %vptr18655, align 8 ; &eptr18644[4]
  %vptr18656 = alloca i64*, align 8 
  %eptr18645 = getelementptr inbounds i64, i64* %cloptr18639, i64 6 
  store volatile i64* %eptr18645, i64** %vptr18656, align 8 ; &eptr18645[5]
  %vptr18657 = alloca i64*, align 8 
  %eptr18646 = getelementptr inbounds i64, i64* %cloptr18639, i64 7 
  store volatile i64* %eptr18646, i64** %vptr18657, align 8 ; &eptr18646[6]
  %vptr18658 = alloca i64*, align 8 
  %eptr18647 = getelementptr inbounds i64, i64* %cloptr18639, i64 8 
  store volatile i64* %eptr18647, i64** %vptr18658, align 8 ; &eptr18647[7]
  %vptr18659 = alloca i64*, align 8 
  %eptr18648 = getelementptr inbounds i64, i64* %cloptr18639, i64 9 
  store volatile i64* %eptr18648, i64** %vptr18659, align 8 ; &eptr18648[8]
  %vptr18660 = alloca i64*, align 8 
  %eptr18649 = getelementptr inbounds i64, i64* %cloptr18639, i64 10 
  store volatile i64* %eptr18649, i64** %vptr18660, align 8 ; &eptr18649[9]
  store i64 %bcc$ly, i64* %eptr18641                                                 ; *eptr18641 = %bcc$ly
  store i64 %emsg18637, i64* %eptr18642                                              ; *eptr18642 = %emsg18637
  store i64 %cont7159, i64* %eptr18643                                               ; *eptr18643 = %cont7159
  store i64 %v42$y, i64* %eptr18644                                                  ; *eptr18644 = %v42$y
  store i64 %zTP$_37drop, i64* %eptr18645                                            ; *eptr18645 = %zTP$_37drop
  store i64 %DwU$lx, i64* %eptr18646                                                 ; *eptr18646 = %DwU$lx
  store i64 %emsg08636, i64* %eptr18647                                              ; *eptr18647 = %emsg08636
  store i64 %uLY$_37_62, i64* %eptr18648                                             ; *eptr18648 = %uLY$_37_62
  store i64 %a7005, i64* %eptr18649                                                  ; *eptr18649 = %a7005
  %vptr18661 = alloca i64*, align 8 
  %eptr18640 = getelementptr inbounds i64, i64* %cloptr18639, i64 1 
  store volatile i64* %eptr18640, i64** %vptr18661, align 8 ; &cloptr18639[1]
 %vptr18662 = alloca i64, align 8 
  %f18650 = ptrtoint void(i64,i64)* @lam12100 to i64 
  store volatile i64 %f18650, i64* %vptr18662, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f18650, i64* %eptr18640                                                 ; store fptr
 %vptr18663 = alloca i64, align 8 
  %arg7849 = ptrtoint i64* %cloptr18639 to i64 
  store volatile i64 %arg7849, i64* %vptr18663, align 8 ; closure cast; i64* -> i64
 %vptr18664 = alloca i64, align 8 
  %rva9462 = add i64 0, 0 
  store volatile i64 %rva9462, i64* %vptr18664, align 8 ; quoted ()
 %vptr18665 = alloca i64, align 8 
  %rva9461 = call i64 @prim_cons(i64 %a7007, i64 %rva9462) 
  store volatile i64 %rva9461, i64* %vptr18665, align 8 ; call prim_cons
 %vptr18666 = alloca i64, align 8 
  %rva9460 = call i64 @prim_cons(i64 %FhZ$x, i64 %rva9461) 
  store volatile i64 %rva9460, i64* %vptr18666, align 8 ; call prim_cons
 %vptr18667 = alloca i64, align 8 
  %rva9459 = call i64 @prim_cons(i64 %arg7849, i64 %rva9460) 
  store volatile i64 %rva9459, i64* %vptr18667, align 8 ; call prim_cons
  %vptr18673 = alloca i64*, align 8 
  %cloptr18668 = inttoptr i64 %zTP$_37drop to i64* 
  store volatile i64* %cloptr18668, i64** %vptr18673, align 8 ; closure/env cast; i64 -> i64*
  %vptr18674 = alloca i64*, align 8 
  %i0ptr18669 = getelementptr inbounds i64, i64* %cloptr18668, i64 1 
  store volatile i64* %i0ptr18669, i64** %vptr18674, align 8 ; &cloptr18668[1]
 %vptr18675 = alloca i64, align 8 
  %f18671 = load i64, i64* %i0ptr18669, align 8 
  store volatile i64 %f18671, i64* %vptr18675, align 8 ; load; *i0ptr18669
  %fptr18670 = inttoptr i64 %f18671 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18670(i64 %zTP$_37drop, i64 %rva9459)               ; tail call
  ret void

else18636:
  %vptr18688 = alloca i64*, align 8 
  %cloptr18676 = call i64* @make_closure(i64 80) 
  store volatile i64* %cloptr18676, i64** %vptr18688, align 8 ; malloc
  %vptr18689 = alloca i64*, align 8 
  %eptr18678 = getelementptr inbounds i64, i64* %cloptr18676, i64 2 
  store volatile i64* %eptr18678, i64** %vptr18689, align 8 ; &eptr18678[1]
  %vptr18690 = alloca i64*, align 8 
  %eptr18679 = getelementptr inbounds i64, i64* %cloptr18676, i64 3 
  store volatile i64* %eptr18679, i64** %vptr18690, align 8 ; &eptr18679[2]
  %vptr18691 = alloca i64*, align 8 
  %eptr18680 = getelementptr inbounds i64, i64* %cloptr18676, i64 4 
  store volatile i64* %eptr18680, i64** %vptr18691, align 8 ; &eptr18680[3]
  %vptr18692 = alloca i64*, align 8 
  %eptr18681 = getelementptr inbounds i64, i64* %cloptr18676, i64 5 
  store volatile i64* %eptr18681, i64** %vptr18692, align 8 ; &eptr18681[4]
  %vptr18693 = alloca i64*, align 8 
  %eptr18682 = getelementptr inbounds i64, i64* %cloptr18676, i64 6 
  store volatile i64* %eptr18682, i64** %vptr18693, align 8 ; &eptr18682[5]
  %vptr18694 = alloca i64*, align 8 
  %eptr18683 = getelementptr inbounds i64, i64* %cloptr18676, i64 7 
  store volatile i64* %eptr18683, i64** %vptr18694, align 8 ; &eptr18683[6]
  %vptr18695 = alloca i64*, align 8 
  %eptr18684 = getelementptr inbounds i64, i64* %cloptr18676, i64 8 
  store volatile i64* %eptr18684, i64** %vptr18695, align 8 ; &eptr18684[7]
  %vptr18696 = alloca i64*, align 8 
  %eptr18685 = getelementptr inbounds i64, i64* %cloptr18676, i64 9 
  store volatile i64* %eptr18685, i64** %vptr18696, align 8 ; &eptr18685[8]
  %vptr18697 = alloca i64*, align 8 
  %eptr18686 = getelementptr inbounds i64, i64* %cloptr18676, i64 10 
  store volatile i64* %eptr18686, i64** %vptr18697, align 8 ; &eptr18686[9]
  store i64 %bcc$ly, i64* %eptr18678                                                 ; *eptr18678 = %bcc$ly
  store i64 %emsg18637, i64* %eptr18679                                              ; *eptr18679 = %emsg18637
  store i64 %cont7159, i64* %eptr18680                                               ; *eptr18680 = %cont7159
  store i64 %v42$y, i64* %eptr18681                                                  ; *eptr18681 = %v42$y
  store i64 %zTP$_37drop, i64* %eptr18682                                            ; *eptr18682 = %zTP$_37drop
  store i64 %DwU$lx, i64* %eptr18683                                                 ; *eptr18683 = %DwU$lx
  store i64 %emsg08636, i64* %eptr18684                                              ; *eptr18684 = %emsg08636
  store i64 %uLY$_37_62, i64* %eptr18685                                             ; *eptr18685 = %uLY$_37_62
  store i64 %a7005, i64* %eptr18686                                                  ; *eptr18686 = %a7005
  %vptr18698 = alloca i64*, align 8 
  %eptr18677 = getelementptr inbounds i64, i64* %cloptr18676, i64 1 
  store volatile i64* %eptr18677, i64** %vptr18698, align 8 ; &cloptr18676[1]
 %vptr18699 = alloca i64, align 8 
  %f18687 = ptrtoint void(i64,i64)* @lam12116 to i64 
  store volatile i64 %f18687, i64* %vptr18699, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f18687, i64* %eptr18677                                                 ; store fptr
 %vptr18700 = alloca i64, align 8 
  %arg7874 = ptrtoint i64* %cloptr18676 to i64 
  store volatile i64 %arg7874, i64* %vptr18700, align 8 ; closure cast; i64* -> i64
 %vptr18701 = alloca i64, align 8 
  %arg7873 = add i64 0, 0 
  store volatile i64 %arg7873, i64* %vptr18701, align 8 ; quoted ()
 %vptr18702 = alloca i64, align 8 
  %rva9524 = add i64 0, 0 
  store volatile i64 %rva9524, i64* %vptr18702, align 8 ; quoted ()
 %vptr18703 = alloca i64, align 8 
  %rva9523 = call i64 @prim_cons(i64 %FhZ$x, i64 %rva9524) 
  store volatile i64 %rva9523, i64* %vptr18703, align 8 ; call prim_cons
 %vptr18704 = alloca i64, align 8 
  %rva9522 = call i64 @prim_cons(i64 %arg7873, i64 %rva9523) 
  store volatile i64 %rva9522, i64* %vptr18704, align 8 ; call prim_cons
  %vptr18710 = alloca i64*, align 8 
  %cloptr18705 = inttoptr i64 %arg7874 to i64* 
  store volatile i64* %cloptr18705, i64** %vptr18710, align 8 ; closure/env cast; i64 -> i64*
  %vptr18711 = alloca i64*, align 8 
  %i0ptr18706 = getelementptr inbounds i64, i64* %cloptr18705, i64 1 
  store volatile i64* %i0ptr18706, i64** %vptr18711, align 8 ; &cloptr18705[1]
 %vptr18712 = alloca i64, align 8 
  %f18708 = load i64, i64* %i0ptr18706, align 8 
  store volatile i64 %f18708, i64* %vptr18712, align 8 ; load; *i0ptr18706
  %fptr18707 = inttoptr i64 %f18708 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18707(i64 %arg7874, i64 %rva9522)                   ; tail call
  ret void

else18632:
 %vptr18713 = alloca i64, align 8 
  %h9527 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9527, i64* %vptr18713, align 8 ; call prim_halt
  %vptr18719 = alloca i64*, align 8 
  %cloptr18714 = inttoptr i64 %h9527 to i64* 
  store volatile i64* %cloptr18714, i64** %vptr18719, align 8 ; closure/env cast; i64 -> i64*
  %vptr18720 = alloca i64*, align 8 
  %i0ptr18715 = getelementptr inbounds i64, i64* %cloptr18714, i64 1 
  store volatile i64* %i0ptr18715, i64** %vptr18720, align 8 ; &cloptr18714[1]
 %vptr18721 = alloca i64, align 8 
  %f18717 = load i64, i64* %i0ptr18715, align 8 
  store volatile i64 %f18717, i64* %vptr18721, align 8 ; load; *i0ptr18715
  %fptr18716 = inttoptr i64 %f18717 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18716(i64 %h9527, i64 %h9527)                       ; tail call
  ret void
}


define void @lam12116(i64 %env12117, i64 %rvp9518) {
 %vptr18724 = alloca i64, align 8 
  %envptr18722 = inttoptr i64 %env12117 to i64* 
  store volatile i64 %a7005, i64* %vptr18724, align 8 ; closure/env cast; i64 -> i64*
  %vptr18725 = alloca i64*, align 8 
  %envptr18723 = getelementptr inbounds i64, i64* %envptr18722, i64 10 
  store volatile i64* %envptr18723, i64** %vptr18725, align 8 ; &envptr18722[9]
 %vptr18726 = alloca i64, align 8 
  %a7005 = load i64, i64* %envptr18723, align 8 
  store volatile i64 %a7005, i64* %vptr18726, align 8 ; load; *envptr18723
 %vptr18729 = alloca i64, align 8 
  %envptr18727 = inttoptr i64 %env12117 to i64* 
  store volatile i64 %uLY$_37_62, i64* %vptr18729, align 8 ; closure/env cast; i64 -> i64*
  %vptr18730 = alloca i64*, align 8 
  %envptr18728 = getelementptr inbounds i64, i64* %envptr18727, i64 9 
  store volatile i64* %envptr18728, i64** %vptr18730, align 8 ; &envptr18727[8]
 %vptr18731 = alloca i64, align 8 
  %uLY$_37_62 = load i64, i64* %envptr18728, align 8 
  store volatile i64 %uLY$_37_62, i64* %vptr18731, align 8 ; load; *envptr18728
 %vptr18734 = alloca i64, align 8 
  %envptr18732 = inttoptr i64 %env12117 to i64* 
  store volatile i64 %emsg08636, i64* %vptr18734, align 8 ; closure/env cast; i64 -> i64*
  %vptr18735 = alloca i64*, align 8 
  %envptr18733 = getelementptr inbounds i64, i64* %envptr18732, i64 8 
  store volatile i64* %envptr18733, i64** %vptr18735, align 8 ; &envptr18732[7]
 %vptr18736 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr18733, align 8 
  store volatile i64 %emsg08636, i64* %vptr18736, align 8 ; load; *envptr18733
 %vptr18739 = alloca i64, align 8 
  %envptr18737 = inttoptr i64 %env12117 to i64* 
  store volatile i64 %DwU$lx, i64* %vptr18739, align 8 ; closure/env cast; i64 -> i64*
  %vptr18740 = alloca i64*, align 8 
  %envptr18738 = getelementptr inbounds i64, i64* %envptr18737, i64 7 
  store volatile i64* %envptr18738, i64** %vptr18740, align 8 ; &envptr18737[6]
 %vptr18741 = alloca i64, align 8 
  %DwU$lx = load i64, i64* %envptr18738, align 8 
  store volatile i64 %DwU$lx, i64* %vptr18741, align 8 ; load; *envptr18738
 %vptr18744 = alloca i64, align 8 
  %envptr18742 = inttoptr i64 %env12117 to i64* 
  store volatile i64 %zTP$_37drop, i64* %vptr18744, align 8 ; closure/env cast; i64 -> i64*
  %vptr18745 = alloca i64*, align 8 
  %envptr18743 = getelementptr inbounds i64, i64* %envptr18742, i64 6 
  store volatile i64* %envptr18743, i64** %vptr18745, align 8 ; &envptr18742[5]
 %vptr18746 = alloca i64, align 8 
  %zTP$_37drop = load i64, i64* %envptr18743, align 8 
  store volatile i64 %zTP$_37drop, i64* %vptr18746, align 8 ; load; *envptr18743
 %vptr18749 = alloca i64, align 8 
  %envptr18747 = inttoptr i64 %env12117 to i64* 
  store volatile i64 %v42$y, i64* %vptr18749, align 8 ; closure/env cast; i64 -> i64*
  %vptr18750 = alloca i64*, align 8 
  %envptr18748 = getelementptr inbounds i64, i64* %envptr18747, i64 5 
  store volatile i64* %envptr18748, i64** %vptr18750, align 8 ; &envptr18747[4]
 %vptr18751 = alloca i64, align 8 
  %v42$y = load i64, i64* %envptr18748, align 8 
  store volatile i64 %v42$y, i64* %vptr18751, align 8 ; load; *envptr18748
 %vptr18754 = alloca i64, align 8 
  %envptr18752 = inttoptr i64 %env12117 to i64* 
  store volatile i64 %cont7159, i64* %vptr18754, align 8 ; closure/env cast; i64 -> i64*
  %vptr18755 = alloca i64*, align 8 
  %envptr18753 = getelementptr inbounds i64, i64* %envptr18752, i64 4 
  store volatile i64* %envptr18753, i64** %vptr18755, align 8 ; &envptr18752[3]
 %vptr18756 = alloca i64, align 8 
  %cont7159 = load i64, i64* %envptr18753, align 8 
  store volatile i64 %cont7159, i64* %vptr18756, align 8 ; load; *envptr18753
 %vptr18759 = alloca i64, align 8 
  %envptr18757 = inttoptr i64 %env12117 to i64* 
  store volatile i64 %emsg18637, i64* %vptr18759, align 8 ; closure/env cast; i64 -> i64*
  %vptr18760 = alloca i64*, align 8 
  %envptr18758 = getelementptr inbounds i64, i64* %envptr18757, i64 3 
  store volatile i64* %envptr18758, i64** %vptr18760, align 8 ; &envptr18757[2]
 %vptr18761 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr18758, align 8 
  store volatile i64 %emsg18637, i64* %vptr18761, align 8 ; load; *envptr18758
 %vptr18764 = alloca i64, align 8 
  %envptr18762 = inttoptr i64 %env12117 to i64* 
  store volatile i64 %bcc$ly, i64* %vptr18764, align 8 ; closure/env cast; i64 -> i64*
  %vptr18765 = alloca i64*, align 8 
  %envptr18763 = getelementptr inbounds i64, i64* %envptr18762, i64 2 
  store volatile i64* %envptr18763, i64** %vptr18765, align 8 ; &envptr18762[1]
 %vptr18766 = alloca i64, align 8 
  %bcc$ly = load i64, i64* %envptr18763, align 8 
  store volatile i64 %bcc$ly, i64* %vptr18766, align 8 ; load; *envptr18763
 %vptr18767 = alloca i64, align 8 
  %_957165 = call i64 @prim_car(i64 %rvp9518) 
  store volatile i64 %_957165, i64* %vptr18767, align 8 ; call prim_car
 %vptr18768 = alloca i64, align 8 
  %rvp9514 = call i64 @prim_cdr(i64 %rvp9518) 
  store volatile i64 %rvp9514, i64* %vptr18768, align 8 ; call prim_cdr
 %vptr18769 = alloca i64, align 8 
  %n_639519 = call i64 @prim_null_63(i64 %rvp9514) 
  store volatile i64 %n_639519, i64* %vptr18769, align 8 ; call prim_null_63
  %cmpptr18773 = alloca i1, align 8  %cmp18770 = icmp eq i64 %n_639519, 15 store volatile i1 %cmp18770, i1* %cmpptr18773, align 8; false?
  br i1 %cmp18770, label %else18772, label %then18771                                ; if

then18771:
 %vptr18774 = alloca i64, align 8 
  %h9520 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9520, i64* %vptr18774, align 8 ; call prim_halt
  %vptr18780 = alloca i64*, align 8 
  %cloptr18775 = inttoptr i64 %h9520 to i64* 
  store volatile i64* %cloptr18775, i64** %vptr18780, align 8 ; closure/env cast; i64 -> i64*
  %vptr18781 = alloca i64*, align 8 
  %i0ptr18776 = getelementptr inbounds i64, i64* %cloptr18775, i64 1 
  store volatile i64* %i0ptr18776, i64** %vptr18781, align 8 ; &cloptr18775[1]
 %vptr18782 = alloca i64, align 8 
  %f18778 = load i64, i64* %i0ptr18776, align 8 
  store volatile i64 %f18778, i64* %vptr18782, align 8 ; load; *i0ptr18776
  %fptr18777 = inttoptr i64 %f18778 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18777(i64 %h9520, i64 %h9520)                       ; tail call
  ret void

else18772:
 %vptr18783 = alloca i64, align 8 
  %a7008 = call i64 @prim_car(i64 %rvp9514) 
  store volatile i64 %a7008, i64* %vptr18783, align 8 ; call prim_car
 %vptr18784 = alloca i64, align 8 
  %na9464 = call i64 @prim_cdr(i64 %rvp9514) 
  store volatile i64 %na9464, i64* %vptr18784, align 8 ; call prim_cdr
 %vptr18785 = alloca i64, align 8 
  %n_639515 = call i64 @prim_null_63(i64 %na9464) 
  store volatile i64 %n_639515, i64* %vptr18785, align 8 ; call prim_null_63
  %cmpptr18789 = alloca i1, align 8  %cmp18786 = icmp eq i64 %n_639515, 15 store volatile i1 %cmp18786, i1* %cmpptr18789, align 8; false?
  br i1 %cmp18786, label %else18788, label %then18787                                ; if

then18787:
  %vptr18802 = alloca i64*, align 8 
  %cloptr18790 = call i64* @make_closure(i64 80) 
  store volatile i64* %cloptr18790, i64** %vptr18802, align 8 ; malloc
  %vptr18803 = alloca i64*, align 8 
  %eptr18792 = getelementptr inbounds i64, i64* %cloptr18790, i64 2 
  store volatile i64* %eptr18792, i64** %vptr18803, align 8 ; &eptr18792[1]
  %vptr18804 = alloca i64*, align 8 
  %eptr18793 = getelementptr inbounds i64, i64* %cloptr18790, i64 3 
  store volatile i64* %eptr18793, i64** %vptr18804, align 8 ; &eptr18793[2]
  %vptr18805 = alloca i64*, align 8 
  %eptr18794 = getelementptr inbounds i64, i64* %cloptr18790, i64 4 
  store volatile i64* %eptr18794, i64** %vptr18805, align 8 ; &eptr18794[3]
  %vptr18806 = alloca i64*, align 8 
  %eptr18795 = getelementptr inbounds i64, i64* %cloptr18790, i64 5 
  store volatile i64* %eptr18795, i64** %vptr18806, align 8 ; &eptr18795[4]
  %vptr18807 = alloca i64*, align 8 
  %eptr18796 = getelementptr inbounds i64, i64* %cloptr18790, i64 6 
  store volatile i64* %eptr18796, i64** %vptr18807, align 8 ; &eptr18796[5]
  %vptr18808 = alloca i64*, align 8 
  %eptr18797 = getelementptr inbounds i64, i64* %cloptr18790, i64 7 
  store volatile i64* %eptr18797, i64** %vptr18808, align 8 ; &eptr18797[6]
  %vptr18809 = alloca i64*, align 8 
  %eptr18798 = getelementptr inbounds i64, i64* %cloptr18790, i64 8 
  store volatile i64* %eptr18798, i64** %vptr18809, align 8 ; &eptr18798[7]
  %vptr18810 = alloca i64*, align 8 
  %eptr18799 = getelementptr inbounds i64, i64* %cloptr18790, i64 9 
  store volatile i64* %eptr18799, i64** %vptr18810, align 8 ; &eptr18799[8]
  %vptr18811 = alloca i64*, align 8 
  %eptr18800 = getelementptr inbounds i64, i64* %cloptr18790, i64 10 
  store volatile i64* %eptr18800, i64** %vptr18811, align 8 ; &eptr18800[9]
  store i64 %bcc$ly, i64* %eptr18792                                                 ; *eptr18792 = %bcc$ly
  store i64 %emsg18637, i64* %eptr18793                                              ; *eptr18793 = %emsg18637
  store i64 %a7008, i64* %eptr18794                                                  ; *eptr18794 = %a7008
  store i64 %cont7159, i64* %eptr18795                                               ; *eptr18795 = %cont7159
  store i64 %v42$y, i64* %eptr18796                                                  ; *eptr18796 = %v42$y
  store i64 %zTP$_37drop, i64* %eptr18797                                            ; *eptr18797 = %zTP$_37drop
  store i64 %DwU$lx, i64* %eptr18798                                                 ; *eptr18798 = %DwU$lx
  store i64 %emsg08636, i64* %eptr18799                                              ; *eptr18799 = %emsg08636
  store i64 %a7005, i64* %eptr18800                                                  ; *eptr18800 = %a7005
  %vptr18812 = alloca i64*, align 8 
  %eptr18791 = getelementptr inbounds i64, i64* %cloptr18790, i64 1 
  store volatile i64* %eptr18791, i64** %vptr18812, align 8 ; &cloptr18790[1]
 %vptr18813 = alloca i64, align 8 
  %f18801 = ptrtoint void(i64,i64)* @lam12114 to i64 
  store volatile i64 %f18801, i64* %vptr18813, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f18801, i64* %eptr18791                                                 ; store fptr
 %vptr18814 = alloca i64, align 8 
  %arg7877 = ptrtoint i64* %cloptr18790 to i64 
  store volatile i64 %arg7877, i64* %vptr18814, align 8 ; closure cast; i64* -> i64
 %vptr18815 = alloca i64, align 8 
  %rva9513 = add i64 0, 0 
  store volatile i64 %rva9513, i64* %vptr18815, align 8 ; quoted ()
 %vptr18816 = alloca i64, align 8 
  %rva9512 = call i64 @prim_cons(i64 %DwU$lx, i64 %rva9513) 
  store volatile i64 %rva9512, i64* %vptr18816, align 8 ; call prim_cons
 %vptr18817 = alloca i64, align 8 
  %rva9511 = call i64 @prim_cons(i64 %bcc$ly, i64 %rva9512) 
  store volatile i64 %rva9511, i64* %vptr18817, align 8 ; call prim_cons
 %vptr18818 = alloca i64, align 8 
  %rva9510 = call i64 @prim_cons(i64 %arg7877, i64 %rva9511) 
  store volatile i64 %rva9510, i64* %vptr18818, align 8 ; call prim_cons
  %vptr18824 = alloca i64*, align 8 
  %cloptr18819 = inttoptr i64 %uLY$_37_62 to i64* 
  store volatile i64* %cloptr18819, i64** %vptr18824, align 8 ; closure/env cast; i64 -> i64*
  %vptr18825 = alloca i64*, align 8 
  %i0ptr18820 = getelementptr inbounds i64, i64* %cloptr18819, i64 1 
  store volatile i64* %i0ptr18820, i64** %vptr18825, align 8 ; &cloptr18819[1]
 %vptr18826 = alloca i64, align 8 
  %f18822 = load i64, i64* %i0ptr18820, align 8 
  store volatile i64 %f18822, i64* %vptr18826, align 8 ; load; *i0ptr18820
  %fptr18821 = inttoptr i64 %f18822 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18821(i64 %uLY$_37_62, i64 %rva9510)                ; tail call
  ret void

else18788:
 %vptr18827 = alloca i64, align 8 
  %h9516 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9516, i64* %vptr18827, align 8 ; call prim_halt
  %vptr18833 = alloca i64*, align 8 
  %cloptr18828 = inttoptr i64 %h9516 to i64* 
  store volatile i64* %cloptr18828, i64** %vptr18833, align 8 ; closure/env cast; i64 -> i64*
  %vptr18834 = alloca i64*, align 8 
  %i0ptr18829 = getelementptr inbounds i64, i64* %cloptr18828, i64 1 
  store volatile i64* %i0ptr18829, i64** %vptr18834, align 8 ; &cloptr18828[1]
 %vptr18835 = alloca i64, align 8 
  %f18831 = load i64, i64* %i0ptr18829, align 8 
  store volatile i64 %f18831, i64* %vptr18835, align 8 ; load; *i0ptr18829
  %fptr18830 = inttoptr i64 %f18831 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18830(i64 %h9516, i64 %h9516)                       ; tail call
  ret void
}


define void @lam12114(i64 %env12115, i64 %rvp9506) {
 %vptr18838 = alloca i64, align 8 
  %envptr18836 = inttoptr i64 %env12115 to i64* 
  store volatile i64 %a7005, i64* %vptr18838, align 8 ; closure/env cast; i64 -> i64*
  %vptr18839 = alloca i64*, align 8 
  %envptr18837 = getelementptr inbounds i64, i64* %envptr18836, i64 10 
  store volatile i64* %envptr18837, i64** %vptr18839, align 8 ; &envptr18836[9]
 %vptr18840 = alloca i64, align 8 
  %a7005 = load i64, i64* %envptr18837, align 8 
  store volatile i64 %a7005, i64* %vptr18840, align 8 ; load; *envptr18837
 %vptr18843 = alloca i64, align 8 
  %envptr18841 = inttoptr i64 %env12115 to i64* 
  store volatile i64 %emsg08636, i64* %vptr18843, align 8 ; closure/env cast; i64 -> i64*
  %vptr18844 = alloca i64*, align 8 
  %envptr18842 = getelementptr inbounds i64, i64* %envptr18841, i64 9 
  store volatile i64* %envptr18842, i64** %vptr18844, align 8 ; &envptr18841[8]
 %vptr18845 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr18842, align 8 
  store volatile i64 %emsg08636, i64* %vptr18845, align 8 ; load; *envptr18842
 %vptr18848 = alloca i64, align 8 
  %envptr18846 = inttoptr i64 %env12115 to i64* 
  store volatile i64 %DwU$lx, i64* %vptr18848, align 8 ; closure/env cast; i64 -> i64*
  %vptr18849 = alloca i64*, align 8 
  %envptr18847 = getelementptr inbounds i64, i64* %envptr18846, i64 8 
  store volatile i64* %envptr18847, i64** %vptr18849, align 8 ; &envptr18846[7]
 %vptr18850 = alloca i64, align 8 
  %DwU$lx = load i64, i64* %envptr18847, align 8 
  store volatile i64 %DwU$lx, i64* %vptr18850, align 8 ; load; *envptr18847
 %vptr18853 = alloca i64, align 8 
  %envptr18851 = inttoptr i64 %env12115 to i64* 
  store volatile i64 %zTP$_37drop, i64* %vptr18853, align 8 ; closure/env cast; i64 -> i64*
  %vptr18854 = alloca i64*, align 8 
  %envptr18852 = getelementptr inbounds i64, i64* %envptr18851, i64 7 
  store volatile i64* %envptr18852, i64** %vptr18854, align 8 ; &envptr18851[6]
 %vptr18855 = alloca i64, align 8 
  %zTP$_37drop = load i64, i64* %envptr18852, align 8 
  store volatile i64 %zTP$_37drop, i64* %vptr18855, align 8 ; load; *envptr18852
 %vptr18858 = alloca i64, align 8 
  %envptr18856 = inttoptr i64 %env12115 to i64* 
  store volatile i64 %v42$y, i64* %vptr18858, align 8 ; closure/env cast; i64 -> i64*
  %vptr18859 = alloca i64*, align 8 
  %envptr18857 = getelementptr inbounds i64, i64* %envptr18856, i64 6 
  store volatile i64* %envptr18857, i64** %vptr18859, align 8 ; &envptr18856[5]
 %vptr18860 = alloca i64, align 8 
  %v42$y = load i64, i64* %envptr18857, align 8 
  store volatile i64 %v42$y, i64* %vptr18860, align 8 ; load; *envptr18857
 %vptr18863 = alloca i64, align 8 
  %envptr18861 = inttoptr i64 %env12115 to i64* 
  store volatile i64 %cont7159, i64* %vptr18863, align 8 ; closure/env cast; i64 -> i64*
  %vptr18864 = alloca i64*, align 8 
  %envptr18862 = getelementptr inbounds i64, i64* %envptr18861, i64 5 
  store volatile i64* %envptr18862, i64** %vptr18864, align 8 ; &envptr18861[4]
 %vptr18865 = alloca i64, align 8 
  %cont7159 = load i64, i64* %envptr18862, align 8 
  store volatile i64 %cont7159, i64* %vptr18865, align 8 ; load; *envptr18862
 %vptr18868 = alloca i64, align 8 
  %envptr18866 = inttoptr i64 %env12115 to i64* 
  store volatile i64 %a7008, i64* %vptr18868, align 8 ; closure/env cast; i64 -> i64*
  %vptr18869 = alloca i64*, align 8 
  %envptr18867 = getelementptr inbounds i64, i64* %envptr18866, i64 4 
  store volatile i64* %envptr18867, i64** %vptr18869, align 8 ; &envptr18866[3]
 %vptr18870 = alloca i64, align 8 
  %a7008 = load i64, i64* %envptr18867, align 8 
  store volatile i64 %a7008, i64* %vptr18870, align 8 ; load; *envptr18867
 %vptr18873 = alloca i64, align 8 
  %envptr18871 = inttoptr i64 %env12115 to i64* 
  store volatile i64 %emsg18637, i64* %vptr18873, align 8 ; closure/env cast; i64 -> i64*
  %vptr18874 = alloca i64*, align 8 
  %envptr18872 = getelementptr inbounds i64, i64* %envptr18871, i64 3 
  store volatile i64* %envptr18872, i64** %vptr18874, align 8 ; &envptr18871[2]
 %vptr18875 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr18872, align 8 
  store volatile i64 %emsg18637, i64* %vptr18875, align 8 ; load; *envptr18872
 %vptr18878 = alloca i64, align 8 
  %envptr18876 = inttoptr i64 %env12115 to i64* 
  store volatile i64 %bcc$ly, i64* %vptr18878, align 8 ; closure/env cast; i64 -> i64*
  %vptr18879 = alloca i64*, align 8 
  %envptr18877 = getelementptr inbounds i64, i64* %envptr18876, i64 2 
  store volatile i64* %envptr18877, i64** %vptr18879, align 8 ; &envptr18876[1]
 %vptr18880 = alloca i64, align 8 
  %bcc$ly = load i64, i64* %envptr18877, align 8 
  store volatile i64 %bcc$ly, i64* %vptr18880, align 8 ; load; *envptr18877
 %vptr18881 = alloca i64, align 8 
  %_957166 = call i64 @prim_car(i64 %rvp9506) 
  store volatile i64 %_957166, i64* %vptr18881, align 8 ; call prim_car
 %vptr18882 = alloca i64, align 8 
  %rvp9502 = call i64 @prim_cdr(i64 %rvp9506) 
  store volatile i64 %rvp9502, i64* %vptr18882, align 8 ; call prim_cdr
 %vptr18883 = alloca i64, align 8 
  %n_639507 = call i64 @prim_null_63(i64 %rvp9502) 
  store volatile i64 %n_639507, i64* %vptr18883, align 8 ; call prim_null_63
  %cmpptr18887 = alloca i1, align 8  %cmp18884 = icmp eq i64 %n_639507, 15 store volatile i1 %cmp18884, i1* %cmpptr18887, align 8; false?
  br i1 %cmp18884, label %else18886, label %then18885                                ; if

then18885:
 %vptr18888 = alloca i64, align 8 
  %h9508 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9508, i64* %vptr18888, align 8 ; call prim_halt
  %vptr18894 = alloca i64*, align 8 
  %cloptr18889 = inttoptr i64 %h9508 to i64* 
  store volatile i64* %cloptr18889, i64** %vptr18894, align 8 ; closure/env cast; i64 -> i64*
  %vptr18895 = alloca i64*, align 8 
  %i0ptr18890 = getelementptr inbounds i64, i64* %cloptr18889, i64 1 
  store volatile i64* %i0ptr18890, i64** %vptr18895, align 8 ; &cloptr18889[1]
 %vptr18896 = alloca i64, align 8 
  %f18892 = load i64, i64* %i0ptr18890, align 8 
  store volatile i64 %f18892, i64* %vptr18896, align 8 ; load; *i0ptr18890
  %fptr18891 = inttoptr i64 %f18892 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18891(i64 %h9508, i64 %h9508)                       ; tail call
  ret void

else18886:
 %vptr18897 = alloca i64, align 8 
  %a7009 = call i64 @prim_car(i64 %rvp9502) 
  store volatile i64 %a7009, i64* %vptr18897, align 8 ; call prim_car
 %vptr18898 = alloca i64, align 8 
  %na9466 = call i64 @prim_cdr(i64 %rvp9502) 
  store volatile i64 %na9466, i64* %vptr18898, align 8 ; call prim_cdr
 %vptr18899 = alloca i64, align 8 
  %n_639503 = call i64 @prim_null_63(i64 %na9466) 
  store volatile i64 %n_639503, i64* %vptr18899, align 8 ; call prim_null_63
  %cmpptr18903 = alloca i1, align 8  %cmp18900 = icmp eq i64 %n_639503, 15 store volatile i1 %cmp18900, i1* %cmpptr18903, align 8; false?
  br i1 %cmp18900, label %else18902, label %then18901                                ; if

then18901:
  %cmpptr18907 = alloca i1, align 8  %cmp18904 = icmp eq i64 %a7009, 15 store volatile i1 %cmp18904, i1* %cmpptr18907, align 8; false?
  br i1 %cmp18904, label %else18906, label %then18905                                ; if

then18905:
 %vptr18908 = alloca i64, align 8 
  %a7010 = call i64 @prim__45(i64 %bcc$ly, i64 %DwU$lx) 
  store volatile i64 %a7010, i64* %vptr18908, align 8 ; call prim__45
  %vptr18917 = alloca i64*, align 8 
  %cloptr18909 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr18909, i64** %vptr18917, align 8 ; malloc
  %vptr18918 = alloca i64*, align 8 
  %eptr18911 = getelementptr inbounds i64, i64* %cloptr18909, i64 2 
  store volatile i64* %eptr18911, i64** %vptr18918, align 8 ; &eptr18911[1]
  %vptr18919 = alloca i64*, align 8 
  %eptr18912 = getelementptr inbounds i64, i64* %cloptr18909, i64 3 
  store volatile i64* %eptr18912, i64** %vptr18919, align 8 ; &eptr18912[2]
  %vptr18920 = alloca i64*, align 8 
  %eptr18913 = getelementptr inbounds i64, i64* %cloptr18909, i64 4 
  store volatile i64* %eptr18913, i64** %vptr18920, align 8 ; &eptr18913[3]
  %vptr18921 = alloca i64*, align 8 
  %eptr18914 = getelementptr inbounds i64, i64* %cloptr18909, i64 5 
  store volatile i64* %eptr18914, i64** %vptr18921, align 8 ; &eptr18914[4]
  %vptr18922 = alloca i64*, align 8 
  %eptr18915 = getelementptr inbounds i64, i64* %cloptr18909, i64 6 
  store volatile i64* %eptr18915, i64** %vptr18922, align 8 ; &eptr18915[5]
  store i64 %emsg18637, i64* %eptr18911                                              ; *eptr18911 = %emsg18637
  store i64 %a7008, i64* %eptr18912                                                  ; *eptr18912 = %a7008
  store i64 %cont7159, i64* %eptr18913                                               ; *eptr18913 = %cont7159
  store i64 %emsg08636, i64* %eptr18914                                              ; *eptr18914 = %emsg08636
  store i64 %a7005, i64* %eptr18915                                                  ; *eptr18915 = %a7005
  %vptr18923 = alloca i64*, align 8 
  %eptr18910 = getelementptr inbounds i64, i64* %cloptr18909, i64 1 
  store volatile i64* %eptr18910, i64** %vptr18923, align 8 ; &cloptr18909[1]
 %vptr18924 = alloca i64, align 8 
  %f18916 = ptrtoint void(i64,i64)* @lam12107 to i64 
  store volatile i64 %f18916, i64* %vptr18924, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f18916, i64* %eptr18910                                                 ; store fptr
 %vptr18925 = alloca i64, align 8 
  %arg7883 = ptrtoint i64* %cloptr18909 to i64 
  store volatile i64 %arg7883, i64* %vptr18925, align 8 ; closure cast; i64* -> i64
 %vptr18926 = alloca i64, align 8 
  %rva9484 = add i64 0, 0 
  store volatile i64 %rva9484, i64* %vptr18926, align 8 ; quoted ()
 %vptr18927 = alloca i64, align 8 
  %rva9483 = call i64 @prim_cons(i64 %a7010, i64 %rva9484) 
  store volatile i64 %rva9483, i64* %vptr18927, align 8 ; call prim_cons
 %vptr18928 = alloca i64, align 8 
  %rva9482 = call i64 @prim_cons(i64 %v42$y, i64 %rva9483) 
  store volatile i64 %rva9482, i64* %vptr18928, align 8 ; call prim_cons
 %vptr18929 = alloca i64, align 8 
  %rva9481 = call i64 @prim_cons(i64 %arg7883, i64 %rva9482) 
  store volatile i64 %rva9481, i64* %vptr18929, align 8 ; call prim_cons
  %vptr18935 = alloca i64*, align 8 
  %cloptr18930 = inttoptr i64 %zTP$_37drop to i64* 
  store volatile i64* %cloptr18930, i64** %vptr18935, align 8 ; closure/env cast; i64 -> i64*
  %vptr18936 = alloca i64*, align 8 
  %i0ptr18931 = getelementptr inbounds i64, i64* %cloptr18930, i64 1 
  store volatile i64* %i0ptr18931, i64** %vptr18936, align 8 ; &cloptr18930[1]
 %vptr18937 = alloca i64, align 8 
  %f18933 = load i64, i64* %i0ptr18931, align 8 
  store volatile i64 %f18933, i64* %vptr18937, align 8 ; load; *i0ptr18931
  %fptr18932 = inttoptr i64 %f18933 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18932(i64 %zTP$_37drop, i64 %rva9481)               ; tail call
  ret void

else18906:
  %vptr18946 = alloca i64*, align 8 
  %cloptr18938 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr18938, i64** %vptr18946, align 8 ; malloc
  %vptr18947 = alloca i64*, align 8 
  %eptr18940 = getelementptr inbounds i64, i64* %cloptr18938, i64 2 
  store volatile i64* %eptr18940, i64** %vptr18947, align 8 ; &eptr18940[1]
  %vptr18948 = alloca i64*, align 8 
  %eptr18941 = getelementptr inbounds i64, i64* %cloptr18938, i64 3 
  store volatile i64* %eptr18941, i64** %vptr18948, align 8 ; &eptr18941[2]
  %vptr18949 = alloca i64*, align 8 
  %eptr18942 = getelementptr inbounds i64, i64* %cloptr18938, i64 4 
  store volatile i64* %eptr18942, i64** %vptr18949, align 8 ; &eptr18942[3]
  %vptr18950 = alloca i64*, align 8 
  %eptr18943 = getelementptr inbounds i64, i64* %cloptr18938, i64 5 
  store volatile i64* %eptr18943, i64** %vptr18950, align 8 ; &eptr18943[4]
  %vptr18951 = alloca i64*, align 8 
  %eptr18944 = getelementptr inbounds i64, i64* %cloptr18938, i64 6 
  store volatile i64* %eptr18944, i64** %vptr18951, align 8 ; &eptr18944[5]
  store i64 %emsg18637, i64* %eptr18940                                              ; *eptr18940 = %emsg18637
  store i64 %a7008, i64* %eptr18941                                                  ; *eptr18941 = %a7008
  store i64 %cont7159, i64* %eptr18942                                               ; *eptr18942 = %cont7159
  store i64 %emsg08636, i64* %eptr18943                                              ; *eptr18943 = %emsg08636
  store i64 %a7005, i64* %eptr18944                                                  ; *eptr18944 = %a7005
  %vptr18952 = alloca i64*, align 8 
  %eptr18939 = getelementptr inbounds i64, i64* %cloptr18938, i64 1 
  store volatile i64* %eptr18939, i64** %vptr18952, align 8 ; &cloptr18938[1]
 %vptr18953 = alloca i64, align 8 
  %f18945 = ptrtoint void(i64,i64)* @lam12112 to i64 
  store volatile i64 %f18945, i64* %vptr18953, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f18945, i64* %eptr18939                                                 ; store fptr
 %vptr18954 = alloca i64, align 8 
  %arg7891 = ptrtoint i64* %cloptr18938 to i64 
  store volatile i64 %arg7891, i64* %vptr18954, align 8 ; closure cast; i64* -> i64
 %vptr18955 = alloca i64, align 8 
  %arg7890 = add i64 0, 0 
  store volatile i64 %arg7890, i64* %vptr18955, align 8 ; quoted ()
 %vptr18956 = alloca i64, align 8 
  %rva9501 = add i64 0, 0 
  store volatile i64 %rva9501, i64* %vptr18956, align 8 ; quoted ()
 %vptr18957 = alloca i64, align 8 
  %rva9500 = call i64 @prim_cons(i64 %v42$y, i64 %rva9501) 
  store volatile i64 %rva9500, i64* %vptr18957, align 8 ; call prim_cons
 %vptr18958 = alloca i64, align 8 
  %rva9499 = call i64 @prim_cons(i64 %arg7890, i64 %rva9500) 
  store volatile i64 %rva9499, i64* %vptr18958, align 8 ; call prim_cons
  %vptr18964 = alloca i64*, align 8 
  %cloptr18959 = inttoptr i64 %arg7891 to i64* 
  store volatile i64* %cloptr18959, i64** %vptr18964, align 8 ; closure/env cast; i64 -> i64*
  %vptr18965 = alloca i64*, align 8 
  %i0ptr18960 = getelementptr inbounds i64, i64* %cloptr18959, i64 1 
  store volatile i64* %i0ptr18960, i64** %vptr18965, align 8 ; &cloptr18959[1]
 %vptr18966 = alloca i64, align 8 
  %f18962 = load i64, i64* %i0ptr18960, align 8 
  store volatile i64 %f18962, i64* %vptr18966, align 8 ; load; *i0ptr18960
  %fptr18961 = inttoptr i64 %f18962 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18961(i64 %arg7891, i64 %rva9499)                   ; tail call
  ret void

else18902:
 %vptr18967 = alloca i64, align 8 
  %h9504 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9504, i64* %vptr18967, align 8 ; call prim_halt
  %vptr18973 = alloca i64*, align 8 
  %cloptr18968 = inttoptr i64 %h9504 to i64* 
  store volatile i64* %cloptr18968, i64** %vptr18973, align 8 ; closure/env cast; i64 -> i64*
  %vptr18974 = alloca i64*, align 8 
  %i0ptr18969 = getelementptr inbounds i64, i64* %cloptr18968, i64 1 
  store volatile i64* %i0ptr18969, i64** %vptr18974, align 8 ; &cloptr18968[1]
 %vptr18975 = alloca i64, align 8 
  %f18971 = load i64, i64* %i0ptr18969, align 8 
  store volatile i64 %f18971, i64* %vptr18975, align 8 ; load; *i0ptr18969
  %fptr18970 = inttoptr i64 %f18971 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr18970(i64 %h9504, i64 %h9504)                       ; tail call
  ret void
}


define void @lam12112(i64 %env12113, i64 %rvp9495) {
 %vptr18978 = alloca i64, align 8 
  %envptr18976 = inttoptr i64 %env12113 to i64* 
  store volatile i64 %a7005, i64* %vptr18978, align 8 ; closure/env cast; i64 -> i64*
  %vptr18979 = alloca i64*, align 8 
  %envptr18977 = getelementptr inbounds i64, i64* %envptr18976, i64 6 
  store volatile i64* %envptr18977, i64** %vptr18979, align 8 ; &envptr18976[5]
 %vptr18980 = alloca i64, align 8 
  %a7005 = load i64, i64* %envptr18977, align 8 
  store volatile i64 %a7005, i64* %vptr18980, align 8 ; load; *envptr18977
 %vptr18983 = alloca i64, align 8 
  %envptr18981 = inttoptr i64 %env12113 to i64* 
  store volatile i64 %emsg08636, i64* %vptr18983, align 8 ; closure/env cast; i64 -> i64*
  %vptr18984 = alloca i64*, align 8 
  %envptr18982 = getelementptr inbounds i64, i64* %envptr18981, i64 5 
  store volatile i64* %envptr18982, i64** %vptr18984, align 8 ; &envptr18981[4]
 %vptr18985 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr18982, align 8 
  store volatile i64 %emsg08636, i64* %vptr18985, align 8 ; load; *envptr18982
 %vptr18988 = alloca i64, align 8 
  %envptr18986 = inttoptr i64 %env12113 to i64* 
  store volatile i64 %cont7159, i64* %vptr18988, align 8 ; closure/env cast; i64 -> i64*
  %vptr18989 = alloca i64*, align 8 
  %envptr18987 = getelementptr inbounds i64, i64* %envptr18986, i64 4 
  store volatile i64* %envptr18987, i64** %vptr18989, align 8 ; &envptr18986[3]
 %vptr18990 = alloca i64, align 8 
  %cont7159 = load i64, i64* %envptr18987, align 8 
  store volatile i64 %cont7159, i64* %vptr18990, align 8 ; load; *envptr18987
 %vptr18993 = alloca i64, align 8 
  %envptr18991 = inttoptr i64 %env12113 to i64* 
  store volatile i64 %a7008, i64* %vptr18993, align 8 ; closure/env cast; i64 -> i64*
  %vptr18994 = alloca i64*, align 8 
  %envptr18992 = getelementptr inbounds i64, i64* %envptr18991, i64 3 
  store volatile i64* %envptr18992, i64** %vptr18994, align 8 ; &envptr18991[2]
 %vptr18995 = alloca i64, align 8 
  %a7008 = load i64, i64* %envptr18992, align 8 
  store volatile i64 %a7008, i64* %vptr18995, align 8 ; load; *envptr18992
 %vptr18998 = alloca i64, align 8 
  %envptr18996 = inttoptr i64 %env12113 to i64* 
  store volatile i64 %emsg18637, i64* %vptr18998, align 8 ; closure/env cast; i64 -> i64*
  %vptr18999 = alloca i64*, align 8 
  %envptr18997 = getelementptr inbounds i64, i64* %envptr18996, i64 2 
  store volatile i64* %envptr18997, i64** %vptr18999, align 8 ; &envptr18996[1]
 %vptr19000 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr18997, align 8 
  store volatile i64 %emsg18637, i64* %vptr19000, align 8 ; load; *envptr18997
 %vptr19001 = alloca i64, align 8 
  %_957167 = call i64 @prim_car(i64 %rvp9495) 
  store volatile i64 %_957167, i64* %vptr19001, align 8 ; call prim_car
 %vptr19002 = alloca i64, align 8 
  %rvp9491 = call i64 @prim_cdr(i64 %rvp9495) 
  store volatile i64 %rvp9491, i64* %vptr19002, align 8 ; call prim_cdr
 %vptr19003 = alloca i64, align 8 
  %n_639496 = call i64 @prim_null_63(i64 %rvp9491) 
  store volatile i64 %n_639496, i64* %vptr19003, align 8 ; call prim_null_63
  %cmpptr19007 = alloca i1, align 8  %cmp19004 = icmp eq i64 %n_639496, 15 store volatile i1 %cmp19004, i1* %cmpptr19007, align 8; false?
  br i1 %cmp19004, label %else19006, label %then19005                                ; if

then19005:
 %vptr19008 = alloca i64, align 8 
  %h9497 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9497, i64* %vptr19008, align 8 ; call prim_halt
  %vptr19014 = alloca i64*, align 8 
  %cloptr19009 = inttoptr i64 %h9497 to i64* 
  store volatile i64* %cloptr19009, i64** %vptr19014, align 8 ; closure/env cast; i64 -> i64*
  %vptr19015 = alloca i64*, align 8 
  %i0ptr19010 = getelementptr inbounds i64, i64* %cloptr19009, i64 1 
  store volatile i64* %i0ptr19010, i64** %vptr19015, align 8 ; &cloptr19009[1]
 %vptr19016 = alloca i64, align 8 
  %f19012 = load i64, i64* %i0ptr19010, align 8 
  store volatile i64 %f19012, i64* %vptr19016, align 8 ; load; *i0ptr19010
  %fptr19011 = inttoptr i64 %f19012 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19011(i64 %h9497, i64 %h9497)                       ; tail call
  ret void

else19006:
 %vptr19017 = alloca i64, align 8 
  %a7011 = call i64 @prim_car(i64 %rvp9491) 
  store volatile i64 %a7011, i64* %vptr19017, align 8 ; call prim_car
 %vptr19018 = alloca i64, align 8 
  %na9486 = call i64 @prim_cdr(i64 %rvp9491) 
  store volatile i64 %na9486, i64* %vptr19018, align 8 ; call prim_cdr
 %vptr19019 = alloca i64, align 8 
  %n_639492 = call i64 @prim_null_63(i64 %na9486) 
  store volatile i64 %n_639492, i64* %vptr19019, align 8 ; call prim_null_63
  %cmpptr19023 = alloca i1, align 8  %cmp19020 = icmp eq i64 %n_639492, 15 store volatile i1 %cmp19020, i1* %cmpptr19023, align 8; false?
  br i1 %cmp19020, label %else19022, label %then19021                                ; if

then19021:
 %vptr19024 = alloca i64, align 8 
  %rva9490 = add i64 0, 0 
  store volatile i64 %rva9490, i64* %vptr19024, align 8 ; quoted ()
 %vptr19025 = alloca i64, align 8 
  %rva9489 = call i64 @prim_cons(i64 %a7011, i64 %rva9490) 
  store volatile i64 %rva9489, i64* %vptr19025, align 8 ; call prim_cons
 %vptr19026 = alloca i64, align 8 
  %rva9488 = call i64 @prim_cons(i64 %a7008, i64 %rva9489) 
  store volatile i64 %rva9488, i64* %vptr19026, align 8 ; call prim_cons
 %vptr19027 = alloca i64, align 8 
  %rva9487 = call i64 @prim_cons(i64 %cont7159, i64 %rva9488) 
  store volatile i64 %rva9487, i64* %vptr19027, align 8 ; call prim_cons
  %vptr19033 = alloca i64*, align 8 
  %cloptr19028 = inttoptr i64 %a7005 to i64* 
  store volatile i64* %cloptr19028, i64** %vptr19033, align 8 ; closure/env cast; i64 -> i64*
  %vptr19034 = alloca i64*, align 8 
  %i0ptr19029 = getelementptr inbounds i64, i64* %cloptr19028, i64 1 
  store volatile i64* %i0ptr19029, i64** %vptr19034, align 8 ; &cloptr19028[1]
 %vptr19035 = alloca i64, align 8 
  %f19031 = load i64, i64* %i0ptr19029, align 8 
  store volatile i64 %f19031, i64* %vptr19035, align 8 ; load; *i0ptr19029
  %fptr19030 = inttoptr i64 %f19031 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19030(i64 %a7005, i64 %rva9487)                     ; tail call
  ret void

else19022:
 %vptr19036 = alloca i64, align 8 
  %h9493 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9493, i64* %vptr19036, align 8 ; call prim_halt
  %vptr19042 = alloca i64*, align 8 
  %cloptr19037 = inttoptr i64 %h9493 to i64* 
  store volatile i64* %cloptr19037, i64** %vptr19042, align 8 ; closure/env cast; i64 -> i64*
  %vptr19043 = alloca i64*, align 8 
  %i0ptr19038 = getelementptr inbounds i64, i64* %cloptr19037, i64 1 
  store volatile i64* %i0ptr19038, i64** %vptr19043, align 8 ; &cloptr19037[1]
 %vptr19044 = alloca i64, align 8 
  %f19040 = load i64, i64* %i0ptr19038, align 8 
  store volatile i64 %f19040, i64* %vptr19044, align 8 ; load; *i0ptr19038
  %fptr19039 = inttoptr i64 %f19040 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19039(i64 %h9493, i64 %h9493)                       ; tail call
  ret void
}


define void @lam12107(i64 %env12108, i64 %rvp9477) {
 %vptr19047 = alloca i64, align 8 
  %envptr19045 = inttoptr i64 %env12108 to i64* 
  store volatile i64 %a7005, i64* %vptr19047, align 8 ; closure/env cast; i64 -> i64*
  %vptr19048 = alloca i64*, align 8 
  %envptr19046 = getelementptr inbounds i64, i64* %envptr19045, i64 6 
  store volatile i64* %envptr19046, i64** %vptr19048, align 8 ; &envptr19045[5]
 %vptr19049 = alloca i64, align 8 
  %a7005 = load i64, i64* %envptr19046, align 8 
  store volatile i64 %a7005, i64* %vptr19049, align 8 ; load; *envptr19046
 %vptr19052 = alloca i64, align 8 
  %envptr19050 = inttoptr i64 %env12108 to i64* 
  store volatile i64 %emsg08636, i64* %vptr19052, align 8 ; closure/env cast; i64 -> i64*
  %vptr19053 = alloca i64*, align 8 
  %envptr19051 = getelementptr inbounds i64, i64* %envptr19050, i64 5 
  store volatile i64* %envptr19051, i64** %vptr19053, align 8 ; &envptr19050[4]
 %vptr19054 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr19051, align 8 
  store volatile i64 %emsg08636, i64* %vptr19054, align 8 ; load; *envptr19051
 %vptr19057 = alloca i64, align 8 
  %envptr19055 = inttoptr i64 %env12108 to i64* 
  store volatile i64 %cont7159, i64* %vptr19057, align 8 ; closure/env cast; i64 -> i64*
  %vptr19058 = alloca i64*, align 8 
  %envptr19056 = getelementptr inbounds i64, i64* %envptr19055, i64 4 
  store volatile i64* %envptr19056, i64** %vptr19058, align 8 ; &envptr19055[3]
 %vptr19059 = alloca i64, align 8 
  %cont7159 = load i64, i64* %envptr19056, align 8 
  store volatile i64 %cont7159, i64* %vptr19059, align 8 ; load; *envptr19056
 %vptr19062 = alloca i64, align 8 
  %envptr19060 = inttoptr i64 %env12108 to i64* 
  store volatile i64 %a7008, i64* %vptr19062, align 8 ; closure/env cast; i64 -> i64*
  %vptr19063 = alloca i64*, align 8 
  %envptr19061 = getelementptr inbounds i64, i64* %envptr19060, i64 3 
  store volatile i64* %envptr19061, i64** %vptr19063, align 8 ; &envptr19060[2]
 %vptr19064 = alloca i64, align 8 
  %a7008 = load i64, i64* %envptr19061, align 8 
  store volatile i64 %a7008, i64* %vptr19064, align 8 ; load; *envptr19061
 %vptr19067 = alloca i64, align 8 
  %envptr19065 = inttoptr i64 %env12108 to i64* 
  store volatile i64 %emsg18637, i64* %vptr19067, align 8 ; closure/env cast; i64 -> i64*
  %vptr19068 = alloca i64*, align 8 
  %envptr19066 = getelementptr inbounds i64, i64* %envptr19065, i64 2 
  store volatile i64* %envptr19066, i64** %vptr19068, align 8 ; &envptr19065[1]
 %vptr19069 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr19066, align 8 
  store volatile i64 %emsg18637, i64* %vptr19069, align 8 ; load; *envptr19066
 %vptr19070 = alloca i64, align 8 
  %_957167 = call i64 @prim_car(i64 %rvp9477) 
  store volatile i64 %_957167, i64* %vptr19070, align 8 ; call prim_car
 %vptr19071 = alloca i64, align 8 
  %rvp9473 = call i64 @prim_cdr(i64 %rvp9477) 
  store volatile i64 %rvp9473, i64* %vptr19071, align 8 ; call prim_cdr
 %vptr19072 = alloca i64, align 8 
  %n_639478 = call i64 @prim_null_63(i64 %rvp9473) 
  store volatile i64 %n_639478, i64* %vptr19072, align 8 ; call prim_null_63
  %cmpptr19076 = alloca i1, align 8  %cmp19073 = icmp eq i64 %n_639478, 15 store volatile i1 %cmp19073, i1* %cmpptr19076, align 8; false?
  br i1 %cmp19073, label %else19075, label %then19074                                ; if

then19074:
 %vptr19077 = alloca i64, align 8 
  %h9479 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9479, i64* %vptr19077, align 8 ; call prim_halt
  %vptr19083 = alloca i64*, align 8 
  %cloptr19078 = inttoptr i64 %h9479 to i64* 
  store volatile i64* %cloptr19078, i64** %vptr19083, align 8 ; closure/env cast; i64 -> i64*
  %vptr19084 = alloca i64*, align 8 
  %i0ptr19079 = getelementptr inbounds i64, i64* %cloptr19078, i64 1 
  store volatile i64* %i0ptr19079, i64** %vptr19084, align 8 ; &cloptr19078[1]
 %vptr19085 = alloca i64, align 8 
  %f19081 = load i64, i64* %i0ptr19079, align 8 
  store volatile i64 %f19081, i64* %vptr19085, align 8 ; load; *i0ptr19079
  %fptr19080 = inttoptr i64 %f19081 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19080(i64 %h9479, i64 %h9479)                       ; tail call
  ret void

else19075:
 %vptr19086 = alloca i64, align 8 
  %a7011 = call i64 @prim_car(i64 %rvp9473) 
  store volatile i64 %a7011, i64* %vptr19086, align 8 ; call prim_car
 %vptr19087 = alloca i64, align 8 
  %na9468 = call i64 @prim_cdr(i64 %rvp9473) 
  store volatile i64 %na9468, i64* %vptr19087, align 8 ; call prim_cdr
 %vptr19088 = alloca i64, align 8 
  %n_639474 = call i64 @prim_null_63(i64 %na9468) 
  store volatile i64 %n_639474, i64* %vptr19088, align 8 ; call prim_null_63
  %cmpptr19092 = alloca i1, align 8  %cmp19089 = icmp eq i64 %n_639474, 15 store volatile i1 %cmp19089, i1* %cmpptr19092, align 8; false?
  br i1 %cmp19089, label %else19091, label %then19090                                ; if

then19090:
 %vptr19093 = alloca i64, align 8 
  %rva9472 = add i64 0, 0 
  store volatile i64 %rva9472, i64* %vptr19093, align 8 ; quoted ()
 %vptr19094 = alloca i64, align 8 
  %rva9471 = call i64 @prim_cons(i64 %a7011, i64 %rva9472) 
  store volatile i64 %rva9471, i64* %vptr19094, align 8 ; call prim_cons
 %vptr19095 = alloca i64, align 8 
  %rva9470 = call i64 @prim_cons(i64 %a7008, i64 %rva9471) 
  store volatile i64 %rva9470, i64* %vptr19095, align 8 ; call prim_cons
 %vptr19096 = alloca i64, align 8 
  %rva9469 = call i64 @prim_cons(i64 %cont7159, i64 %rva9470) 
  store volatile i64 %rva9469, i64* %vptr19096, align 8 ; call prim_cons
  %vptr19102 = alloca i64*, align 8 
  %cloptr19097 = inttoptr i64 %a7005 to i64* 
  store volatile i64* %cloptr19097, i64** %vptr19102, align 8 ; closure/env cast; i64 -> i64*
  %vptr19103 = alloca i64*, align 8 
  %i0ptr19098 = getelementptr inbounds i64, i64* %cloptr19097, i64 1 
  store volatile i64* %i0ptr19098, i64** %vptr19103, align 8 ; &cloptr19097[1]
 %vptr19104 = alloca i64, align 8 
  %f19100 = load i64, i64* %i0ptr19098, align 8 
  store volatile i64 %f19100, i64* %vptr19104, align 8 ; load; *i0ptr19098
  %fptr19099 = inttoptr i64 %f19100 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19099(i64 %a7005, i64 %rva9469)                     ; tail call
  ret void

else19091:
 %vptr19105 = alloca i64, align 8 
  %h9475 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9475, i64* %vptr19105, align 8 ; call prim_halt
  %vptr19111 = alloca i64*, align 8 
  %cloptr19106 = inttoptr i64 %h9475 to i64* 
  store volatile i64* %cloptr19106, i64** %vptr19111, align 8 ; closure/env cast; i64 -> i64*
  %vptr19112 = alloca i64*, align 8 
  %i0ptr19107 = getelementptr inbounds i64, i64* %cloptr19106, i64 1 
  store volatile i64* %i0ptr19107, i64** %vptr19112, align 8 ; &cloptr19106[1]
 %vptr19113 = alloca i64, align 8 
  %f19109 = load i64, i64* %i0ptr19107, align 8 
  store volatile i64 %f19109, i64* %vptr19113, align 8 ; load; *i0ptr19107
  %fptr19108 = inttoptr i64 %f19109 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19108(i64 %h9475, i64 %h9475)                       ; tail call
  ret void
}


define void @lam12100(i64 %env12101, i64 %rvp9455) {
 %vptr19116 = alloca i64, align 8 
  %envptr19114 = inttoptr i64 %env12101 to i64* 
  store volatile i64 %a7005, i64* %vptr19116, align 8 ; closure/env cast; i64 -> i64*
  %vptr19117 = alloca i64*, align 8 
  %envptr19115 = getelementptr inbounds i64, i64* %envptr19114, i64 10 
  store volatile i64* %envptr19115, i64** %vptr19117, align 8 ; &envptr19114[9]
 %vptr19118 = alloca i64, align 8 
  %a7005 = load i64, i64* %envptr19115, align 8 
  store volatile i64 %a7005, i64* %vptr19118, align 8 ; load; *envptr19115
 %vptr19121 = alloca i64, align 8 
  %envptr19119 = inttoptr i64 %env12101 to i64* 
  store volatile i64 %uLY$_37_62, i64* %vptr19121, align 8 ; closure/env cast; i64 -> i64*
  %vptr19122 = alloca i64*, align 8 
  %envptr19120 = getelementptr inbounds i64, i64* %envptr19119, i64 9 
  store volatile i64* %envptr19120, i64** %vptr19122, align 8 ; &envptr19119[8]
 %vptr19123 = alloca i64, align 8 
  %uLY$_37_62 = load i64, i64* %envptr19120, align 8 
  store volatile i64 %uLY$_37_62, i64* %vptr19123, align 8 ; load; *envptr19120
 %vptr19126 = alloca i64, align 8 
  %envptr19124 = inttoptr i64 %env12101 to i64* 
  store volatile i64 %emsg08636, i64* %vptr19126, align 8 ; closure/env cast; i64 -> i64*
  %vptr19127 = alloca i64*, align 8 
  %envptr19125 = getelementptr inbounds i64, i64* %envptr19124, i64 8 
  store volatile i64* %envptr19125, i64** %vptr19127, align 8 ; &envptr19124[7]
 %vptr19128 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr19125, align 8 
  store volatile i64 %emsg08636, i64* %vptr19128, align 8 ; load; *envptr19125
 %vptr19131 = alloca i64, align 8 
  %envptr19129 = inttoptr i64 %env12101 to i64* 
  store volatile i64 %DwU$lx, i64* %vptr19131, align 8 ; closure/env cast; i64 -> i64*
  %vptr19132 = alloca i64*, align 8 
  %envptr19130 = getelementptr inbounds i64, i64* %envptr19129, i64 7 
  store volatile i64* %envptr19130, i64** %vptr19132, align 8 ; &envptr19129[6]
 %vptr19133 = alloca i64, align 8 
  %DwU$lx = load i64, i64* %envptr19130, align 8 
  store volatile i64 %DwU$lx, i64* %vptr19133, align 8 ; load; *envptr19130
 %vptr19136 = alloca i64, align 8 
  %envptr19134 = inttoptr i64 %env12101 to i64* 
  store volatile i64 %zTP$_37drop, i64* %vptr19136, align 8 ; closure/env cast; i64 -> i64*
  %vptr19137 = alloca i64*, align 8 
  %envptr19135 = getelementptr inbounds i64, i64* %envptr19134, i64 6 
  store volatile i64* %envptr19135, i64** %vptr19137, align 8 ; &envptr19134[5]
 %vptr19138 = alloca i64, align 8 
  %zTP$_37drop = load i64, i64* %envptr19135, align 8 
  store volatile i64 %zTP$_37drop, i64* %vptr19138, align 8 ; load; *envptr19135
 %vptr19141 = alloca i64, align 8 
  %envptr19139 = inttoptr i64 %env12101 to i64* 
  store volatile i64 %v42$y, i64* %vptr19141, align 8 ; closure/env cast; i64 -> i64*
  %vptr19142 = alloca i64*, align 8 
  %envptr19140 = getelementptr inbounds i64, i64* %envptr19139, i64 5 
  store volatile i64* %envptr19140, i64** %vptr19142, align 8 ; &envptr19139[4]
 %vptr19143 = alloca i64, align 8 
  %v42$y = load i64, i64* %envptr19140, align 8 
  store volatile i64 %v42$y, i64* %vptr19143, align 8 ; load; *envptr19140
 %vptr19146 = alloca i64, align 8 
  %envptr19144 = inttoptr i64 %env12101 to i64* 
  store volatile i64 %cont7159, i64* %vptr19146, align 8 ; closure/env cast; i64 -> i64*
  %vptr19147 = alloca i64*, align 8 
  %envptr19145 = getelementptr inbounds i64, i64* %envptr19144, i64 4 
  store volatile i64* %envptr19145, i64** %vptr19147, align 8 ; &envptr19144[3]
 %vptr19148 = alloca i64, align 8 
  %cont7159 = load i64, i64* %envptr19145, align 8 
  store volatile i64 %cont7159, i64* %vptr19148, align 8 ; load; *envptr19145
 %vptr19151 = alloca i64, align 8 
  %envptr19149 = inttoptr i64 %env12101 to i64* 
  store volatile i64 %emsg18637, i64* %vptr19151, align 8 ; closure/env cast; i64 -> i64*
  %vptr19152 = alloca i64*, align 8 
  %envptr19150 = getelementptr inbounds i64, i64* %envptr19149, i64 3 
  store volatile i64* %envptr19150, i64** %vptr19152, align 8 ; &envptr19149[2]
 %vptr19153 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr19150, align 8 
  store volatile i64 %emsg18637, i64* %vptr19153, align 8 ; load; *envptr19150
 %vptr19156 = alloca i64, align 8 
  %envptr19154 = inttoptr i64 %env12101 to i64* 
  store volatile i64 %bcc$ly, i64* %vptr19156, align 8 ; closure/env cast; i64 -> i64*
  %vptr19157 = alloca i64*, align 8 
  %envptr19155 = getelementptr inbounds i64, i64* %envptr19154, i64 2 
  store volatile i64* %envptr19155, i64** %vptr19157, align 8 ; &envptr19154[1]
 %vptr19158 = alloca i64, align 8 
  %bcc$ly = load i64, i64* %envptr19155, align 8 
  store volatile i64 %bcc$ly, i64* %vptr19158, align 8 ; load; *envptr19155
 %vptr19159 = alloca i64, align 8 
  %_957165 = call i64 @prim_car(i64 %rvp9455) 
  store volatile i64 %_957165, i64* %vptr19159, align 8 ; call prim_car
 %vptr19160 = alloca i64, align 8 
  %rvp9451 = call i64 @prim_cdr(i64 %rvp9455) 
  store volatile i64 %rvp9451, i64* %vptr19160, align 8 ; call prim_cdr
 %vptr19161 = alloca i64, align 8 
  %n_639456 = call i64 @prim_null_63(i64 %rvp9451) 
  store volatile i64 %n_639456, i64* %vptr19161, align 8 ; call prim_null_63
  %cmpptr19165 = alloca i1, align 8  %cmp19162 = icmp eq i64 %n_639456, 15 store volatile i1 %cmp19162, i1* %cmpptr19165, align 8; false?
  br i1 %cmp19162, label %else19164, label %then19163                                ; if

then19163:
 %vptr19166 = alloca i64, align 8 
  %h9457 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9457, i64* %vptr19166, align 8 ; call prim_halt
  %vptr19172 = alloca i64*, align 8 
  %cloptr19167 = inttoptr i64 %h9457 to i64* 
  store volatile i64* %cloptr19167, i64** %vptr19172, align 8 ; closure/env cast; i64 -> i64*
  %vptr19173 = alloca i64*, align 8 
  %i0ptr19168 = getelementptr inbounds i64, i64* %cloptr19167, i64 1 
  store volatile i64* %i0ptr19168, i64** %vptr19173, align 8 ; &cloptr19167[1]
 %vptr19174 = alloca i64, align 8 
  %f19170 = load i64, i64* %i0ptr19168, align 8 
  store volatile i64 %f19170, i64* %vptr19174, align 8 ; load; *i0ptr19168
  %fptr19169 = inttoptr i64 %f19170 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19169(i64 %h9457, i64 %h9457)                       ; tail call
  ret void

else19164:
 %vptr19175 = alloca i64, align 8 
  %a7008 = call i64 @prim_car(i64 %rvp9451) 
  store volatile i64 %a7008, i64* %vptr19175, align 8 ; call prim_car
 %vptr19176 = alloca i64, align 8 
  %na9401 = call i64 @prim_cdr(i64 %rvp9451) 
  store volatile i64 %na9401, i64* %vptr19176, align 8 ; call prim_cdr
 %vptr19177 = alloca i64, align 8 
  %n_639452 = call i64 @prim_null_63(i64 %na9401) 
  store volatile i64 %n_639452, i64* %vptr19177, align 8 ; call prim_null_63
  %cmpptr19181 = alloca i1, align 8  %cmp19178 = icmp eq i64 %n_639452, 15 store volatile i1 %cmp19178, i1* %cmpptr19181, align 8; false?
  br i1 %cmp19178, label %else19180, label %then19179                                ; if

then19179:
  %vptr19194 = alloca i64*, align 8 
  %cloptr19182 = call i64* @make_closure(i64 80) 
  store volatile i64* %cloptr19182, i64** %vptr19194, align 8 ; malloc
  %vptr19195 = alloca i64*, align 8 
  %eptr19184 = getelementptr inbounds i64, i64* %cloptr19182, i64 2 
  store volatile i64* %eptr19184, i64** %vptr19195, align 8 ; &eptr19184[1]
  %vptr19196 = alloca i64*, align 8 
  %eptr19185 = getelementptr inbounds i64, i64* %cloptr19182, i64 3 
  store volatile i64* %eptr19185, i64** %vptr19196, align 8 ; &eptr19185[2]
  %vptr19197 = alloca i64*, align 8 
  %eptr19186 = getelementptr inbounds i64, i64* %cloptr19182, i64 4 
  store volatile i64* %eptr19186, i64** %vptr19197, align 8 ; &eptr19186[3]
  %vptr19198 = alloca i64*, align 8 
  %eptr19187 = getelementptr inbounds i64, i64* %cloptr19182, i64 5 
  store volatile i64* %eptr19187, i64** %vptr19198, align 8 ; &eptr19187[4]
  %vptr19199 = alloca i64*, align 8 
  %eptr19188 = getelementptr inbounds i64, i64* %cloptr19182, i64 6 
  store volatile i64* %eptr19188, i64** %vptr19199, align 8 ; &eptr19188[5]
  %vptr19200 = alloca i64*, align 8 
  %eptr19189 = getelementptr inbounds i64, i64* %cloptr19182, i64 7 
  store volatile i64* %eptr19189, i64** %vptr19200, align 8 ; &eptr19189[6]
  %vptr19201 = alloca i64*, align 8 
  %eptr19190 = getelementptr inbounds i64, i64* %cloptr19182, i64 8 
  store volatile i64* %eptr19190, i64** %vptr19201, align 8 ; &eptr19190[7]
  %vptr19202 = alloca i64*, align 8 
  %eptr19191 = getelementptr inbounds i64, i64* %cloptr19182, i64 9 
  store volatile i64* %eptr19191, i64** %vptr19202, align 8 ; &eptr19191[8]
  %vptr19203 = alloca i64*, align 8 
  %eptr19192 = getelementptr inbounds i64, i64* %cloptr19182, i64 10 
  store volatile i64* %eptr19192, i64** %vptr19203, align 8 ; &eptr19192[9]
  store i64 %bcc$ly, i64* %eptr19184                                                 ; *eptr19184 = %bcc$ly
  store i64 %emsg18637, i64* %eptr19185                                              ; *eptr19185 = %emsg18637
  store i64 %a7008, i64* %eptr19186                                                  ; *eptr19186 = %a7008
  store i64 %cont7159, i64* %eptr19187                                               ; *eptr19187 = %cont7159
  store i64 %v42$y, i64* %eptr19188                                                  ; *eptr19188 = %v42$y
  store i64 %zTP$_37drop, i64* %eptr19189                                            ; *eptr19189 = %zTP$_37drop
  store i64 %DwU$lx, i64* %eptr19190                                                 ; *eptr19190 = %DwU$lx
  store i64 %emsg08636, i64* %eptr19191                                              ; *eptr19191 = %emsg08636
  store i64 %a7005, i64* %eptr19192                                                  ; *eptr19192 = %a7005
  %vptr19204 = alloca i64*, align 8 
  %eptr19183 = getelementptr inbounds i64, i64* %cloptr19182, i64 1 
  store volatile i64* %eptr19183, i64** %vptr19204, align 8 ; &cloptr19182[1]
 %vptr19205 = alloca i64, align 8 
  %f19193 = ptrtoint void(i64,i64)* @lam12098 to i64 
  store volatile i64 %f19193, i64* %vptr19205, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f19193, i64* %eptr19183                                                 ; store fptr
 %vptr19206 = alloca i64, align 8 
  %arg7853 = ptrtoint i64* %cloptr19182 to i64 
  store volatile i64 %arg7853, i64* %vptr19206, align 8 ; closure cast; i64* -> i64
 %vptr19207 = alloca i64, align 8 
  %rva9450 = add i64 0, 0 
  store volatile i64 %rva9450, i64* %vptr19207, align 8 ; quoted ()
 %vptr19208 = alloca i64, align 8 
  %rva9449 = call i64 @prim_cons(i64 %DwU$lx, i64 %rva9450) 
  store volatile i64 %rva9449, i64* %vptr19208, align 8 ; call prim_cons
 %vptr19209 = alloca i64, align 8 
  %rva9448 = call i64 @prim_cons(i64 %bcc$ly, i64 %rva9449) 
  store volatile i64 %rva9448, i64* %vptr19209, align 8 ; call prim_cons
 %vptr19210 = alloca i64, align 8 
  %rva9447 = call i64 @prim_cons(i64 %arg7853, i64 %rva9448) 
  store volatile i64 %rva9447, i64* %vptr19210, align 8 ; call prim_cons
  %vptr19216 = alloca i64*, align 8 
  %cloptr19211 = inttoptr i64 %uLY$_37_62 to i64* 
  store volatile i64* %cloptr19211, i64** %vptr19216, align 8 ; closure/env cast; i64 -> i64*
  %vptr19217 = alloca i64*, align 8 
  %i0ptr19212 = getelementptr inbounds i64, i64* %cloptr19211, i64 1 
  store volatile i64* %i0ptr19212, i64** %vptr19217, align 8 ; &cloptr19211[1]
 %vptr19218 = alloca i64, align 8 
  %f19214 = load i64, i64* %i0ptr19212, align 8 
  store volatile i64 %f19214, i64* %vptr19218, align 8 ; load; *i0ptr19212
  %fptr19213 = inttoptr i64 %f19214 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19213(i64 %uLY$_37_62, i64 %rva9447)                ; tail call
  ret void

else19180:
 %vptr19219 = alloca i64, align 8 
  %h9453 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9453, i64* %vptr19219, align 8 ; call prim_halt
  %vptr19225 = alloca i64*, align 8 
  %cloptr19220 = inttoptr i64 %h9453 to i64* 
  store volatile i64* %cloptr19220, i64** %vptr19225, align 8 ; closure/env cast; i64 -> i64*
  %vptr19226 = alloca i64*, align 8 
  %i0ptr19221 = getelementptr inbounds i64, i64* %cloptr19220, i64 1 
  store volatile i64* %i0ptr19221, i64** %vptr19226, align 8 ; &cloptr19220[1]
 %vptr19227 = alloca i64, align 8 
  %f19223 = load i64, i64* %i0ptr19221, align 8 
  store volatile i64 %f19223, i64* %vptr19227, align 8 ; load; *i0ptr19221
  %fptr19222 = inttoptr i64 %f19223 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19222(i64 %h9453, i64 %h9453)                       ; tail call
  ret void
}


define void @lam12098(i64 %env12099, i64 %rvp9443) {
 %vptr19230 = alloca i64, align 8 
  %envptr19228 = inttoptr i64 %env12099 to i64* 
  store volatile i64 %a7005, i64* %vptr19230, align 8 ; closure/env cast; i64 -> i64*
  %vptr19231 = alloca i64*, align 8 
  %envptr19229 = getelementptr inbounds i64, i64* %envptr19228, i64 10 
  store volatile i64* %envptr19229, i64** %vptr19231, align 8 ; &envptr19228[9]
 %vptr19232 = alloca i64, align 8 
  %a7005 = load i64, i64* %envptr19229, align 8 
  store volatile i64 %a7005, i64* %vptr19232, align 8 ; load; *envptr19229
 %vptr19235 = alloca i64, align 8 
  %envptr19233 = inttoptr i64 %env12099 to i64* 
  store volatile i64 %emsg08636, i64* %vptr19235, align 8 ; closure/env cast; i64 -> i64*
  %vptr19236 = alloca i64*, align 8 
  %envptr19234 = getelementptr inbounds i64, i64* %envptr19233, i64 9 
  store volatile i64* %envptr19234, i64** %vptr19236, align 8 ; &envptr19233[8]
 %vptr19237 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr19234, align 8 
  store volatile i64 %emsg08636, i64* %vptr19237, align 8 ; load; *envptr19234
 %vptr19240 = alloca i64, align 8 
  %envptr19238 = inttoptr i64 %env12099 to i64* 
  store volatile i64 %DwU$lx, i64* %vptr19240, align 8 ; closure/env cast; i64 -> i64*
  %vptr19241 = alloca i64*, align 8 
  %envptr19239 = getelementptr inbounds i64, i64* %envptr19238, i64 8 
  store volatile i64* %envptr19239, i64** %vptr19241, align 8 ; &envptr19238[7]
 %vptr19242 = alloca i64, align 8 
  %DwU$lx = load i64, i64* %envptr19239, align 8 
  store volatile i64 %DwU$lx, i64* %vptr19242, align 8 ; load; *envptr19239
 %vptr19245 = alloca i64, align 8 
  %envptr19243 = inttoptr i64 %env12099 to i64* 
  store volatile i64 %zTP$_37drop, i64* %vptr19245, align 8 ; closure/env cast; i64 -> i64*
  %vptr19246 = alloca i64*, align 8 
  %envptr19244 = getelementptr inbounds i64, i64* %envptr19243, i64 7 
  store volatile i64* %envptr19244, i64** %vptr19246, align 8 ; &envptr19243[6]
 %vptr19247 = alloca i64, align 8 
  %zTP$_37drop = load i64, i64* %envptr19244, align 8 
  store volatile i64 %zTP$_37drop, i64* %vptr19247, align 8 ; load; *envptr19244
 %vptr19250 = alloca i64, align 8 
  %envptr19248 = inttoptr i64 %env12099 to i64* 
  store volatile i64 %v42$y, i64* %vptr19250, align 8 ; closure/env cast; i64 -> i64*
  %vptr19251 = alloca i64*, align 8 
  %envptr19249 = getelementptr inbounds i64, i64* %envptr19248, i64 6 
  store volatile i64* %envptr19249, i64** %vptr19251, align 8 ; &envptr19248[5]
 %vptr19252 = alloca i64, align 8 
  %v42$y = load i64, i64* %envptr19249, align 8 
  store volatile i64 %v42$y, i64* %vptr19252, align 8 ; load; *envptr19249
 %vptr19255 = alloca i64, align 8 
  %envptr19253 = inttoptr i64 %env12099 to i64* 
  store volatile i64 %cont7159, i64* %vptr19255, align 8 ; closure/env cast; i64 -> i64*
  %vptr19256 = alloca i64*, align 8 
  %envptr19254 = getelementptr inbounds i64, i64* %envptr19253, i64 5 
  store volatile i64* %envptr19254, i64** %vptr19256, align 8 ; &envptr19253[4]
 %vptr19257 = alloca i64, align 8 
  %cont7159 = load i64, i64* %envptr19254, align 8 
  store volatile i64 %cont7159, i64* %vptr19257, align 8 ; load; *envptr19254
 %vptr19260 = alloca i64, align 8 
  %envptr19258 = inttoptr i64 %env12099 to i64* 
  store volatile i64 %a7008, i64* %vptr19260, align 8 ; closure/env cast; i64 -> i64*
  %vptr19261 = alloca i64*, align 8 
  %envptr19259 = getelementptr inbounds i64, i64* %envptr19258, i64 4 
  store volatile i64* %envptr19259, i64** %vptr19261, align 8 ; &envptr19258[3]
 %vptr19262 = alloca i64, align 8 
  %a7008 = load i64, i64* %envptr19259, align 8 
  store volatile i64 %a7008, i64* %vptr19262, align 8 ; load; *envptr19259
 %vptr19265 = alloca i64, align 8 
  %envptr19263 = inttoptr i64 %env12099 to i64* 
  store volatile i64 %emsg18637, i64* %vptr19265, align 8 ; closure/env cast; i64 -> i64*
  %vptr19266 = alloca i64*, align 8 
  %envptr19264 = getelementptr inbounds i64, i64* %envptr19263, i64 3 
  store volatile i64* %envptr19264, i64** %vptr19266, align 8 ; &envptr19263[2]
 %vptr19267 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr19264, align 8 
  store volatile i64 %emsg18637, i64* %vptr19267, align 8 ; load; *envptr19264
 %vptr19270 = alloca i64, align 8 
  %envptr19268 = inttoptr i64 %env12099 to i64* 
  store volatile i64 %bcc$ly, i64* %vptr19270, align 8 ; closure/env cast; i64 -> i64*
  %vptr19271 = alloca i64*, align 8 
  %envptr19269 = getelementptr inbounds i64, i64* %envptr19268, i64 2 
  store volatile i64* %envptr19269, i64** %vptr19271, align 8 ; &envptr19268[1]
 %vptr19272 = alloca i64, align 8 
  %bcc$ly = load i64, i64* %envptr19269, align 8 
  store volatile i64 %bcc$ly, i64* %vptr19272, align 8 ; load; *envptr19269
 %vptr19273 = alloca i64, align 8 
  %_957166 = call i64 @prim_car(i64 %rvp9443) 
  store volatile i64 %_957166, i64* %vptr19273, align 8 ; call prim_car
 %vptr19274 = alloca i64, align 8 
  %rvp9439 = call i64 @prim_cdr(i64 %rvp9443) 
  store volatile i64 %rvp9439, i64* %vptr19274, align 8 ; call prim_cdr
 %vptr19275 = alloca i64, align 8 
  %n_639444 = call i64 @prim_null_63(i64 %rvp9439) 
  store volatile i64 %n_639444, i64* %vptr19275, align 8 ; call prim_null_63
  %cmpptr19279 = alloca i1, align 8  %cmp19276 = icmp eq i64 %n_639444, 15 store volatile i1 %cmp19276, i1* %cmpptr19279, align 8; false?
  br i1 %cmp19276, label %else19278, label %then19277                                ; if

then19277:
 %vptr19280 = alloca i64, align 8 
  %h9445 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9445, i64* %vptr19280, align 8 ; call prim_halt
  %vptr19286 = alloca i64*, align 8 
  %cloptr19281 = inttoptr i64 %h9445 to i64* 
  store volatile i64* %cloptr19281, i64** %vptr19286, align 8 ; closure/env cast; i64 -> i64*
  %vptr19287 = alloca i64*, align 8 
  %i0ptr19282 = getelementptr inbounds i64, i64* %cloptr19281, i64 1 
  store volatile i64* %i0ptr19282, i64** %vptr19287, align 8 ; &cloptr19281[1]
 %vptr19288 = alloca i64, align 8 
  %f19284 = load i64, i64* %i0ptr19282, align 8 
  store volatile i64 %f19284, i64* %vptr19288, align 8 ; load; *i0ptr19282
  %fptr19283 = inttoptr i64 %f19284 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19283(i64 %h9445, i64 %h9445)                       ; tail call
  ret void

else19278:
 %vptr19289 = alloca i64, align 8 
  %a7009 = call i64 @prim_car(i64 %rvp9439) 
  store volatile i64 %a7009, i64* %vptr19289, align 8 ; call prim_car
 %vptr19290 = alloca i64, align 8 
  %na9403 = call i64 @prim_cdr(i64 %rvp9439) 
  store volatile i64 %na9403, i64* %vptr19290, align 8 ; call prim_cdr
 %vptr19291 = alloca i64, align 8 
  %n_639440 = call i64 @prim_null_63(i64 %na9403) 
  store volatile i64 %n_639440, i64* %vptr19291, align 8 ; call prim_null_63
  %cmpptr19295 = alloca i1, align 8  %cmp19292 = icmp eq i64 %n_639440, 15 store volatile i1 %cmp19292, i1* %cmpptr19295, align 8; false?
  br i1 %cmp19292, label %else19294, label %then19293                                ; if

then19293:
  %cmpptr19299 = alloca i1, align 8  %cmp19296 = icmp eq i64 %a7009, 15 store volatile i1 %cmp19296, i1* %cmpptr19299, align 8; false?
  br i1 %cmp19296, label %else19298, label %then19297                                ; if

then19297:
 %vptr19300 = alloca i64, align 8 
  %a7010 = call i64 @prim__45(i64 %bcc$ly, i64 %DwU$lx) 
  store volatile i64 %a7010, i64* %vptr19300, align 8 ; call prim__45
  %vptr19309 = alloca i64*, align 8 
  %cloptr19301 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr19301, i64** %vptr19309, align 8 ; malloc
  %vptr19310 = alloca i64*, align 8 
  %eptr19303 = getelementptr inbounds i64, i64* %cloptr19301, i64 2 
  store volatile i64* %eptr19303, i64** %vptr19310, align 8 ; &eptr19303[1]
  %vptr19311 = alloca i64*, align 8 
  %eptr19304 = getelementptr inbounds i64, i64* %cloptr19301, i64 3 
  store volatile i64* %eptr19304, i64** %vptr19311, align 8 ; &eptr19304[2]
  %vptr19312 = alloca i64*, align 8 
  %eptr19305 = getelementptr inbounds i64, i64* %cloptr19301, i64 4 
  store volatile i64* %eptr19305, i64** %vptr19312, align 8 ; &eptr19305[3]
  %vptr19313 = alloca i64*, align 8 
  %eptr19306 = getelementptr inbounds i64, i64* %cloptr19301, i64 5 
  store volatile i64* %eptr19306, i64** %vptr19313, align 8 ; &eptr19306[4]
  %vptr19314 = alloca i64*, align 8 
  %eptr19307 = getelementptr inbounds i64, i64* %cloptr19301, i64 6 
  store volatile i64* %eptr19307, i64** %vptr19314, align 8 ; &eptr19307[5]
  store i64 %emsg18637, i64* %eptr19303                                              ; *eptr19303 = %emsg18637
  store i64 %a7008, i64* %eptr19304                                                  ; *eptr19304 = %a7008
  store i64 %cont7159, i64* %eptr19305                                               ; *eptr19305 = %cont7159
  store i64 %emsg08636, i64* %eptr19306                                              ; *eptr19306 = %emsg08636
  store i64 %a7005, i64* %eptr19307                                                  ; *eptr19307 = %a7005
  %vptr19315 = alloca i64*, align 8 
  %eptr19302 = getelementptr inbounds i64, i64* %cloptr19301, i64 1 
  store volatile i64* %eptr19302, i64** %vptr19315, align 8 ; &cloptr19301[1]
 %vptr19316 = alloca i64, align 8 
  %f19308 = ptrtoint void(i64,i64)* @lam12091 to i64 
  store volatile i64 %f19308, i64* %vptr19316, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f19308, i64* %eptr19302                                                 ; store fptr
 %vptr19317 = alloca i64, align 8 
  %arg7859 = ptrtoint i64* %cloptr19301 to i64 
  store volatile i64 %arg7859, i64* %vptr19317, align 8 ; closure cast; i64* -> i64
 %vptr19318 = alloca i64, align 8 
  %rva9421 = add i64 0, 0 
  store volatile i64 %rva9421, i64* %vptr19318, align 8 ; quoted ()
 %vptr19319 = alloca i64, align 8 
  %rva9420 = call i64 @prim_cons(i64 %a7010, i64 %rva9421) 
  store volatile i64 %rva9420, i64* %vptr19319, align 8 ; call prim_cons
 %vptr19320 = alloca i64, align 8 
  %rva9419 = call i64 @prim_cons(i64 %v42$y, i64 %rva9420) 
  store volatile i64 %rva9419, i64* %vptr19320, align 8 ; call prim_cons
 %vptr19321 = alloca i64, align 8 
  %rva9418 = call i64 @prim_cons(i64 %arg7859, i64 %rva9419) 
  store volatile i64 %rva9418, i64* %vptr19321, align 8 ; call prim_cons
  %vptr19327 = alloca i64*, align 8 
  %cloptr19322 = inttoptr i64 %zTP$_37drop to i64* 
  store volatile i64* %cloptr19322, i64** %vptr19327, align 8 ; closure/env cast; i64 -> i64*
  %vptr19328 = alloca i64*, align 8 
  %i0ptr19323 = getelementptr inbounds i64, i64* %cloptr19322, i64 1 
  store volatile i64* %i0ptr19323, i64** %vptr19328, align 8 ; &cloptr19322[1]
 %vptr19329 = alloca i64, align 8 
  %f19325 = load i64, i64* %i0ptr19323, align 8 
  store volatile i64 %f19325, i64* %vptr19329, align 8 ; load; *i0ptr19323
  %fptr19324 = inttoptr i64 %f19325 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19324(i64 %zTP$_37drop, i64 %rva9418)               ; tail call
  ret void

else19298:
  %vptr19338 = alloca i64*, align 8 
  %cloptr19330 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr19330, i64** %vptr19338, align 8 ; malloc
  %vptr19339 = alloca i64*, align 8 
  %eptr19332 = getelementptr inbounds i64, i64* %cloptr19330, i64 2 
  store volatile i64* %eptr19332, i64** %vptr19339, align 8 ; &eptr19332[1]
  %vptr19340 = alloca i64*, align 8 
  %eptr19333 = getelementptr inbounds i64, i64* %cloptr19330, i64 3 
  store volatile i64* %eptr19333, i64** %vptr19340, align 8 ; &eptr19333[2]
  %vptr19341 = alloca i64*, align 8 
  %eptr19334 = getelementptr inbounds i64, i64* %cloptr19330, i64 4 
  store volatile i64* %eptr19334, i64** %vptr19341, align 8 ; &eptr19334[3]
  %vptr19342 = alloca i64*, align 8 
  %eptr19335 = getelementptr inbounds i64, i64* %cloptr19330, i64 5 
  store volatile i64* %eptr19335, i64** %vptr19342, align 8 ; &eptr19335[4]
  %vptr19343 = alloca i64*, align 8 
  %eptr19336 = getelementptr inbounds i64, i64* %cloptr19330, i64 6 
  store volatile i64* %eptr19336, i64** %vptr19343, align 8 ; &eptr19336[5]
  store i64 %emsg18637, i64* %eptr19332                                              ; *eptr19332 = %emsg18637
  store i64 %a7008, i64* %eptr19333                                                  ; *eptr19333 = %a7008
  store i64 %cont7159, i64* %eptr19334                                               ; *eptr19334 = %cont7159
  store i64 %emsg08636, i64* %eptr19335                                              ; *eptr19335 = %emsg08636
  store i64 %a7005, i64* %eptr19336                                                  ; *eptr19336 = %a7005
  %vptr19344 = alloca i64*, align 8 
  %eptr19331 = getelementptr inbounds i64, i64* %cloptr19330, i64 1 
  store volatile i64* %eptr19331, i64** %vptr19344, align 8 ; &cloptr19330[1]
 %vptr19345 = alloca i64, align 8 
  %f19337 = ptrtoint void(i64,i64)* @lam12096 to i64 
  store volatile i64 %f19337, i64* %vptr19345, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f19337, i64* %eptr19331                                                 ; store fptr
 %vptr19346 = alloca i64, align 8 
  %arg7867 = ptrtoint i64* %cloptr19330 to i64 
  store volatile i64 %arg7867, i64* %vptr19346, align 8 ; closure cast; i64* -> i64
 %vptr19347 = alloca i64, align 8 
  %arg7866 = add i64 0, 0 
  store volatile i64 %arg7866, i64* %vptr19347, align 8 ; quoted ()
 %vptr19348 = alloca i64, align 8 
  %rva9438 = add i64 0, 0 
  store volatile i64 %rva9438, i64* %vptr19348, align 8 ; quoted ()
 %vptr19349 = alloca i64, align 8 
  %rva9437 = call i64 @prim_cons(i64 %v42$y, i64 %rva9438) 
  store volatile i64 %rva9437, i64* %vptr19349, align 8 ; call prim_cons
 %vptr19350 = alloca i64, align 8 
  %rva9436 = call i64 @prim_cons(i64 %arg7866, i64 %rva9437) 
  store volatile i64 %rva9436, i64* %vptr19350, align 8 ; call prim_cons
  %vptr19356 = alloca i64*, align 8 
  %cloptr19351 = inttoptr i64 %arg7867 to i64* 
  store volatile i64* %cloptr19351, i64** %vptr19356, align 8 ; closure/env cast; i64 -> i64*
  %vptr19357 = alloca i64*, align 8 
  %i0ptr19352 = getelementptr inbounds i64, i64* %cloptr19351, i64 1 
  store volatile i64* %i0ptr19352, i64** %vptr19357, align 8 ; &cloptr19351[1]
 %vptr19358 = alloca i64, align 8 
  %f19354 = load i64, i64* %i0ptr19352, align 8 
  store volatile i64 %f19354, i64* %vptr19358, align 8 ; load; *i0ptr19352
  %fptr19353 = inttoptr i64 %f19354 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19353(i64 %arg7867, i64 %rva9436)                   ; tail call
  ret void

else19294:
 %vptr19359 = alloca i64, align 8 
  %h9441 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9441, i64* %vptr19359, align 8 ; call prim_halt
  %vptr19365 = alloca i64*, align 8 
  %cloptr19360 = inttoptr i64 %h9441 to i64* 
  store volatile i64* %cloptr19360, i64** %vptr19365, align 8 ; closure/env cast; i64 -> i64*
  %vptr19366 = alloca i64*, align 8 
  %i0ptr19361 = getelementptr inbounds i64, i64* %cloptr19360, i64 1 
  store volatile i64* %i0ptr19361, i64** %vptr19366, align 8 ; &cloptr19360[1]
 %vptr19367 = alloca i64, align 8 
  %f19363 = load i64, i64* %i0ptr19361, align 8 
  store volatile i64 %f19363, i64* %vptr19367, align 8 ; load; *i0ptr19361
  %fptr19362 = inttoptr i64 %f19363 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19362(i64 %h9441, i64 %h9441)                       ; tail call
  ret void
}


define void @lam12096(i64 %env12097, i64 %rvp9432) {
 %vptr19370 = alloca i64, align 8 
  %envptr19368 = inttoptr i64 %env12097 to i64* 
  store volatile i64 %a7005, i64* %vptr19370, align 8 ; closure/env cast; i64 -> i64*
  %vptr19371 = alloca i64*, align 8 
  %envptr19369 = getelementptr inbounds i64, i64* %envptr19368, i64 6 
  store volatile i64* %envptr19369, i64** %vptr19371, align 8 ; &envptr19368[5]
 %vptr19372 = alloca i64, align 8 
  %a7005 = load i64, i64* %envptr19369, align 8 
  store volatile i64 %a7005, i64* %vptr19372, align 8 ; load; *envptr19369
 %vptr19375 = alloca i64, align 8 
  %envptr19373 = inttoptr i64 %env12097 to i64* 
  store volatile i64 %emsg08636, i64* %vptr19375, align 8 ; closure/env cast; i64 -> i64*
  %vptr19376 = alloca i64*, align 8 
  %envptr19374 = getelementptr inbounds i64, i64* %envptr19373, i64 5 
  store volatile i64* %envptr19374, i64** %vptr19376, align 8 ; &envptr19373[4]
 %vptr19377 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr19374, align 8 
  store volatile i64 %emsg08636, i64* %vptr19377, align 8 ; load; *envptr19374
 %vptr19380 = alloca i64, align 8 
  %envptr19378 = inttoptr i64 %env12097 to i64* 
  store volatile i64 %cont7159, i64* %vptr19380, align 8 ; closure/env cast; i64 -> i64*
  %vptr19381 = alloca i64*, align 8 
  %envptr19379 = getelementptr inbounds i64, i64* %envptr19378, i64 4 
  store volatile i64* %envptr19379, i64** %vptr19381, align 8 ; &envptr19378[3]
 %vptr19382 = alloca i64, align 8 
  %cont7159 = load i64, i64* %envptr19379, align 8 
  store volatile i64 %cont7159, i64* %vptr19382, align 8 ; load; *envptr19379
 %vptr19385 = alloca i64, align 8 
  %envptr19383 = inttoptr i64 %env12097 to i64* 
  store volatile i64 %a7008, i64* %vptr19385, align 8 ; closure/env cast; i64 -> i64*
  %vptr19386 = alloca i64*, align 8 
  %envptr19384 = getelementptr inbounds i64, i64* %envptr19383, i64 3 
  store volatile i64* %envptr19384, i64** %vptr19386, align 8 ; &envptr19383[2]
 %vptr19387 = alloca i64, align 8 
  %a7008 = load i64, i64* %envptr19384, align 8 
  store volatile i64 %a7008, i64* %vptr19387, align 8 ; load; *envptr19384
 %vptr19390 = alloca i64, align 8 
  %envptr19388 = inttoptr i64 %env12097 to i64* 
  store volatile i64 %emsg18637, i64* %vptr19390, align 8 ; closure/env cast; i64 -> i64*
  %vptr19391 = alloca i64*, align 8 
  %envptr19389 = getelementptr inbounds i64, i64* %envptr19388, i64 2 
  store volatile i64* %envptr19389, i64** %vptr19391, align 8 ; &envptr19388[1]
 %vptr19392 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr19389, align 8 
  store volatile i64 %emsg18637, i64* %vptr19392, align 8 ; load; *envptr19389
 %vptr19393 = alloca i64, align 8 
  %_957167 = call i64 @prim_car(i64 %rvp9432) 
  store volatile i64 %_957167, i64* %vptr19393, align 8 ; call prim_car
 %vptr19394 = alloca i64, align 8 
  %rvp9428 = call i64 @prim_cdr(i64 %rvp9432) 
  store volatile i64 %rvp9428, i64* %vptr19394, align 8 ; call prim_cdr
 %vptr19395 = alloca i64, align 8 
  %n_639433 = call i64 @prim_null_63(i64 %rvp9428) 
  store volatile i64 %n_639433, i64* %vptr19395, align 8 ; call prim_null_63
  %cmpptr19399 = alloca i1, align 8  %cmp19396 = icmp eq i64 %n_639433, 15 store volatile i1 %cmp19396, i1* %cmpptr19399, align 8; false?
  br i1 %cmp19396, label %else19398, label %then19397                                ; if

then19397:
 %vptr19400 = alloca i64, align 8 
  %h9434 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9434, i64* %vptr19400, align 8 ; call prim_halt
  %vptr19406 = alloca i64*, align 8 
  %cloptr19401 = inttoptr i64 %h9434 to i64* 
  store volatile i64* %cloptr19401, i64** %vptr19406, align 8 ; closure/env cast; i64 -> i64*
  %vptr19407 = alloca i64*, align 8 
  %i0ptr19402 = getelementptr inbounds i64, i64* %cloptr19401, i64 1 
  store volatile i64* %i0ptr19402, i64** %vptr19407, align 8 ; &cloptr19401[1]
 %vptr19408 = alloca i64, align 8 
  %f19404 = load i64, i64* %i0ptr19402, align 8 
  store volatile i64 %f19404, i64* %vptr19408, align 8 ; load; *i0ptr19402
  %fptr19403 = inttoptr i64 %f19404 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19403(i64 %h9434, i64 %h9434)                       ; tail call
  ret void

else19398:
 %vptr19409 = alloca i64, align 8 
  %a7011 = call i64 @prim_car(i64 %rvp9428) 
  store volatile i64 %a7011, i64* %vptr19409, align 8 ; call prim_car
 %vptr19410 = alloca i64, align 8 
  %na9423 = call i64 @prim_cdr(i64 %rvp9428) 
  store volatile i64 %na9423, i64* %vptr19410, align 8 ; call prim_cdr
 %vptr19411 = alloca i64, align 8 
  %n_639429 = call i64 @prim_null_63(i64 %na9423) 
  store volatile i64 %n_639429, i64* %vptr19411, align 8 ; call prim_null_63
  %cmpptr19415 = alloca i1, align 8  %cmp19412 = icmp eq i64 %n_639429, 15 store volatile i1 %cmp19412, i1* %cmpptr19415, align 8; false?
  br i1 %cmp19412, label %else19414, label %then19413                                ; if

then19413:
 %vptr19416 = alloca i64, align 8 
  %rva9427 = add i64 0, 0 
  store volatile i64 %rva9427, i64* %vptr19416, align 8 ; quoted ()
 %vptr19417 = alloca i64, align 8 
  %rva9426 = call i64 @prim_cons(i64 %a7011, i64 %rva9427) 
  store volatile i64 %rva9426, i64* %vptr19417, align 8 ; call prim_cons
 %vptr19418 = alloca i64, align 8 
  %rva9425 = call i64 @prim_cons(i64 %a7008, i64 %rva9426) 
  store volatile i64 %rva9425, i64* %vptr19418, align 8 ; call prim_cons
 %vptr19419 = alloca i64, align 8 
  %rva9424 = call i64 @prim_cons(i64 %cont7159, i64 %rva9425) 
  store volatile i64 %rva9424, i64* %vptr19419, align 8 ; call prim_cons
  %vptr19425 = alloca i64*, align 8 
  %cloptr19420 = inttoptr i64 %a7005 to i64* 
  store volatile i64* %cloptr19420, i64** %vptr19425, align 8 ; closure/env cast; i64 -> i64*
  %vptr19426 = alloca i64*, align 8 
  %i0ptr19421 = getelementptr inbounds i64, i64* %cloptr19420, i64 1 
  store volatile i64* %i0ptr19421, i64** %vptr19426, align 8 ; &cloptr19420[1]
 %vptr19427 = alloca i64, align 8 
  %f19423 = load i64, i64* %i0ptr19421, align 8 
  store volatile i64 %f19423, i64* %vptr19427, align 8 ; load; *i0ptr19421
  %fptr19422 = inttoptr i64 %f19423 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19422(i64 %a7005, i64 %rva9424)                     ; tail call
  ret void

else19414:
 %vptr19428 = alloca i64, align 8 
  %h9430 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9430, i64* %vptr19428, align 8 ; call prim_halt
  %vptr19434 = alloca i64*, align 8 
  %cloptr19429 = inttoptr i64 %h9430 to i64* 
  store volatile i64* %cloptr19429, i64** %vptr19434, align 8 ; closure/env cast; i64 -> i64*
  %vptr19435 = alloca i64*, align 8 
  %i0ptr19430 = getelementptr inbounds i64, i64* %cloptr19429, i64 1 
  store volatile i64* %i0ptr19430, i64** %vptr19435, align 8 ; &cloptr19429[1]
 %vptr19436 = alloca i64, align 8 
  %f19432 = load i64, i64* %i0ptr19430, align 8 
  store volatile i64 %f19432, i64* %vptr19436, align 8 ; load; *i0ptr19430
  %fptr19431 = inttoptr i64 %f19432 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19431(i64 %h9430, i64 %h9430)                       ; tail call
  ret void
}


define void @lam12091(i64 %env12092, i64 %rvp9414) {
 %vptr19439 = alloca i64, align 8 
  %envptr19437 = inttoptr i64 %env12092 to i64* 
  store volatile i64 %a7005, i64* %vptr19439, align 8 ; closure/env cast; i64 -> i64*
  %vptr19440 = alloca i64*, align 8 
  %envptr19438 = getelementptr inbounds i64, i64* %envptr19437, i64 6 
  store volatile i64* %envptr19438, i64** %vptr19440, align 8 ; &envptr19437[5]
 %vptr19441 = alloca i64, align 8 
  %a7005 = load i64, i64* %envptr19438, align 8 
  store volatile i64 %a7005, i64* %vptr19441, align 8 ; load; *envptr19438
 %vptr19444 = alloca i64, align 8 
  %envptr19442 = inttoptr i64 %env12092 to i64* 
  store volatile i64 %emsg08636, i64* %vptr19444, align 8 ; closure/env cast; i64 -> i64*
  %vptr19445 = alloca i64*, align 8 
  %envptr19443 = getelementptr inbounds i64, i64* %envptr19442, i64 5 
  store volatile i64* %envptr19443, i64** %vptr19445, align 8 ; &envptr19442[4]
 %vptr19446 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr19443, align 8 
  store volatile i64 %emsg08636, i64* %vptr19446, align 8 ; load; *envptr19443
 %vptr19449 = alloca i64, align 8 
  %envptr19447 = inttoptr i64 %env12092 to i64* 
  store volatile i64 %cont7159, i64* %vptr19449, align 8 ; closure/env cast; i64 -> i64*
  %vptr19450 = alloca i64*, align 8 
  %envptr19448 = getelementptr inbounds i64, i64* %envptr19447, i64 4 
  store volatile i64* %envptr19448, i64** %vptr19450, align 8 ; &envptr19447[3]
 %vptr19451 = alloca i64, align 8 
  %cont7159 = load i64, i64* %envptr19448, align 8 
  store volatile i64 %cont7159, i64* %vptr19451, align 8 ; load; *envptr19448
 %vptr19454 = alloca i64, align 8 
  %envptr19452 = inttoptr i64 %env12092 to i64* 
  store volatile i64 %a7008, i64* %vptr19454, align 8 ; closure/env cast; i64 -> i64*
  %vptr19455 = alloca i64*, align 8 
  %envptr19453 = getelementptr inbounds i64, i64* %envptr19452, i64 3 
  store volatile i64* %envptr19453, i64** %vptr19455, align 8 ; &envptr19452[2]
 %vptr19456 = alloca i64, align 8 
  %a7008 = load i64, i64* %envptr19453, align 8 
  store volatile i64 %a7008, i64* %vptr19456, align 8 ; load; *envptr19453
 %vptr19459 = alloca i64, align 8 
  %envptr19457 = inttoptr i64 %env12092 to i64* 
  store volatile i64 %emsg18637, i64* %vptr19459, align 8 ; closure/env cast; i64 -> i64*
  %vptr19460 = alloca i64*, align 8 
  %envptr19458 = getelementptr inbounds i64, i64* %envptr19457, i64 2 
  store volatile i64* %envptr19458, i64** %vptr19460, align 8 ; &envptr19457[1]
 %vptr19461 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr19458, align 8 
  store volatile i64 %emsg18637, i64* %vptr19461, align 8 ; load; *envptr19458
 %vptr19462 = alloca i64, align 8 
  %_957167 = call i64 @prim_car(i64 %rvp9414) 
  store volatile i64 %_957167, i64* %vptr19462, align 8 ; call prim_car
 %vptr19463 = alloca i64, align 8 
  %rvp9410 = call i64 @prim_cdr(i64 %rvp9414) 
  store volatile i64 %rvp9410, i64* %vptr19463, align 8 ; call prim_cdr
 %vptr19464 = alloca i64, align 8 
  %n_639415 = call i64 @prim_null_63(i64 %rvp9410) 
  store volatile i64 %n_639415, i64* %vptr19464, align 8 ; call prim_null_63
  %cmpptr19468 = alloca i1, align 8  %cmp19465 = icmp eq i64 %n_639415, 15 store volatile i1 %cmp19465, i1* %cmpptr19468, align 8; false?
  br i1 %cmp19465, label %else19467, label %then19466                                ; if

then19466:
 %vptr19469 = alloca i64, align 8 
  %h9416 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9416, i64* %vptr19469, align 8 ; call prim_halt
  %vptr19475 = alloca i64*, align 8 
  %cloptr19470 = inttoptr i64 %h9416 to i64* 
  store volatile i64* %cloptr19470, i64** %vptr19475, align 8 ; closure/env cast; i64 -> i64*
  %vptr19476 = alloca i64*, align 8 
  %i0ptr19471 = getelementptr inbounds i64, i64* %cloptr19470, i64 1 
  store volatile i64* %i0ptr19471, i64** %vptr19476, align 8 ; &cloptr19470[1]
 %vptr19477 = alloca i64, align 8 
  %f19473 = load i64, i64* %i0ptr19471, align 8 
  store volatile i64 %f19473, i64* %vptr19477, align 8 ; load; *i0ptr19471
  %fptr19472 = inttoptr i64 %f19473 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19472(i64 %h9416, i64 %h9416)                       ; tail call
  ret void

else19467:
 %vptr19478 = alloca i64, align 8 
  %a7011 = call i64 @prim_car(i64 %rvp9410) 
  store volatile i64 %a7011, i64* %vptr19478, align 8 ; call prim_car
 %vptr19479 = alloca i64, align 8 
  %na9405 = call i64 @prim_cdr(i64 %rvp9410) 
  store volatile i64 %na9405, i64* %vptr19479, align 8 ; call prim_cdr
 %vptr19480 = alloca i64, align 8 
  %n_639411 = call i64 @prim_null_63(i64 %na9405) 
  store volatile i64 %n_639411, i64* %vptr19480, align 8 ; call prim_null_63
  %cmpptr19484 = alloca i1, align 8  %cmp19481 = icmp eq i64 %n_639411, 15 store volatile i1 %cmp19481, i1* %cmpptr19484, align 8; false?
  br i1 %cmp19481, label %else19483, label %then19482                                ; if

then19482:
 %vptr19485 = alloca i64, align 8 
  %rva9409 = add i64 0, 0 
  store volatile i64 %rva9409, i64* %vptr19485, align 8 ; quoted ()
 %vptr19486 = alloca i64, align 8 
  %rva9408 = call i64 @prim_cons(i64 %a7011, i64 %rva9409) 
  store volatile i64 %rva9408, i64* %vptr19486, align 8 ; call prim_cons
 %vptr19487 = alloca i64, align 8 
  %rva9407 = call i64 @prim_cons(i64 %a7008, i64 %rva9408) 
  store volatile i64 %rva9407, i64* %vptr19487, align 8 ; call prim_cons
 %vptr19488 = alloca i64, align 8 
  %rva9406 = call i64 @prim_cons(i64 %cont7159, i64 %rva9407) 
  store volatile i64 %rva9406, i64* %vptr19488, align 8 ; call prim_cons
  %vptr19494 = alloca i64*, align 8 
  %cloptr19489 = inttoptr i64 %a7005 to i64* 
  store volatile i64* %cloptr19489, i64** %vptr19494, align 8 ; closure/env cast; i64 -> i64*
  %vptr19495 = alloca i64*, align 8 
  %i0ptr19490 = getelementptr inbounds i64, i64* %cloptr19489, i64 1 
  store volatile i64* %i0ptr19490, i64** %vptr19495, align 8 ; &cloptr19489[1]
 %vptr19496 = alloca i64, align 8 
  %f19492 = load i64, i64* %i0ptr19490, align 8 
  store volatile i64 %f19492, i64* %vptr19496, align 8 ; load; *i0ptr19490
  %fptr19491 = inttoptr i64 %f19492 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19491(i64 %a7005, i64 %rva9406)                     ; tail call
  ret void

else19483:
 %vptr19497 = alloca i64, align 8 
  %h9412 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9412, i64* %vptr19497, align 8 ; call prim_halt
  %vptr19503 = alloca i64*, align 8 
  %cloptr19498 = inttoptr i64 %h9412 to i64* 
  store volatile i64* %cloptr19498, i64** %vptr19503, align 8 ; closure/env cast; i64 -> i64*
  %vptr19504 = alloca i64*, align 8 
  %i0ptr19499 = getelementptr inbounds i64, i64* %cloptr19498, i64 1 
  store volatile i64* %i0ptr19499, i64** %vptr19504, align 8 ; &cloptr19498[1]
 %vptr19505 = alloca i64, align 8 
  %f19501 = load i64, i64* %i0ptr19499, align 8 
  store volatile i64 %f19501, i64* %vptr19505, align 8 ; load; *i0ptr19499
  %fptr19500 = inttoptr i64 %f19501 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19500(i64 %h9412, i64 %h9412)                       ; tail call
  ret void
}


define void @lam12079(i64 %env12080, i64 %rvp9766) {
 %vptr19508 = alloca i64, align 8 
  %envptr19506 = inttoptr i64 %env12080 to i64* 
  store volatile i64 %emsg08636, i64* %vptr19508, align 8 ; closure/env cast; i64 -> i64*
  %vptr19509 = alloca i64*, align 8 
  %envptr19507 = getelementptr inbounds i64, i64* %envptr19506, i64 5 
  store volatile i64* %envptr19507, i64** %vptr19509, align 8 ; &envptr19506[4]
 %vptr19510 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr19507, align 8 
  store volatile i64 %emsg08636, i64* %vptr19510, align 8 ; load; *envptr19507
 %vptr19513 = alloca i64, align 8 
  %envptr19511 = inttoptr i64 %env12080 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr19513, align 8 ; closure/env cast; i64 -> i64*
  %vptr19514 = alloca i64*, align 8 
  %envptr19512 = getelementptr inbounds i64, i64* %envptr19511, i64 4 
  store volatile i64* %envptr19512, i64** %vptr19514, align 8 ; &envptr19511[3]
 %vptr19515 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr19512, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr19515, align 8 ; load; *envptr19512
 %vptr19518 = alloca i64, align 8 
  %envptr19516 = inttoptr i64 %env12080 to i64* 
  store volatile i64 %emsg18637, i64* %vptr19518, align 8 ; closure/env cast; i64 -> i64*
  %vptr19519 = alloca i64*, align 8 
  %envptr19517 = getelementptr inbounds i64, i64* %envptr19516, i64 3 
  store volatile i64* %envptr19517, i64** %vptr19519, align 8 ; &envptr19516[2]
 %vptr19520 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr19517, align 8 
  store volatile i64 %emsg18637, i64* %vptr19520, align 8 ; load; *envptr19517
 %vptr19523 = alloca i64, align 8 
  %envptr19521 = inttoptr i64 %env12080 to i64* 
  store volatile i64 %fDa$_37common_45tail, i64* %vptr19523, align 8 ; closure/env cast; i64 -> i64*
  %vptr19524 = alloca i64*, align 8 
  %envptr19522 = getelementptr inbounds i64, i64* %envptr19521, i64 2 
  store volatile i64* %envptr19522, i64** %vptr19524, align 8 ; &envptr19521[1]
 %vptr19525 = alloca i64, align 8 
  %fDa$_37common_45tail = load i64, i64* %envptr19522, align 8 
  store volatile i64 %fDa$_37common_45tail, i64* %vptr19525, align 8 ; load; *envptr19522
 %vptr19526 = alloca i64, align 8 
  %cont7172 = call i64 @prim_car(i64 %rvp9766) 
  store volatile i64 %cont7172, i64* %vptr19526, align 8 ; call prim_car
 %vptr19527 = alloca i64, align 8 
  %rvp9762 = call i64 @prim_cdr(i64 %rvp9766) 
  store volatile i64 %rvp9762, i64* %vptr19527, align 8 ; call prim_cdr
 %vptr19528 = alloca i64, align 8 
  %n_639767 = call i64 @prim_null_63(i64 %rvp9762) 
  store volatile i64 %n_639767, i64* %vptr19528, align 8 ; call prim_null_63
  %cmpptr19532 = alloca i1, align 8  %cmp19529 = icmp eq i64 %n_639767, 15 store volatile i1 %cmp19529, i1* %cmpptr19532, align 8; false?
  br i1 %cmp19529, label %else19531, label %then19530                                ; if

then19530:
 %vptr19533 = alloca i64, align 8 
  %h9768 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9768, i64* %vptr19533, align 8 ; call prim_halt
  %vptr19539 = alloca i64*, align 8 
  %cloptr19534 = inttoptr i64 %h9768 to i64* 
  store volatile i64* %cloptr19534, i64** %vptr19539, align 8 ; closure/env cast; i64 -> i64*
  %vptr19540 = alloca i64*, align 8 
  %i0ptr19535 = getelementptr inbounds i64, i64* %cloptr19534, i64 1 
  store volatile i64* %i0ptr19535, i64** %vptr19540, align 8 ; &cloptr19534[1]
 %vptr19541 = alloca i64, align 8 
  %f19537 = load i64, i64* %i0ptr19535, align 8 
  store volatile i64 %f19537, i64* %vptr19541, align 8 ; load; *i0ptr19535
  %fptr19536 = inttoptr i64 %f19537 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19536(i64 %h9768, i64 %h9768)                       ; tail call
  ret void

else19531:
 %vptr19542 = alloca i64, align 8 
  %Qmo$new = call i64 @prim_car(i64 %rvp9762) 
  store volatile i64 %Qmo$new, i64* %vptr19542, align 8 ; call prim_car
 %vptr19543 = alloca i64, align 8 
  %na9593 = call i64 @prim_cdr(i64 %rvp9762) 
  store volatile i64 %na9593, i64* %vptr19543, align 8 ; call prim_cdr
 %vptr19544 = alloca i64, align 8 
  %n_639763 = call i64 @prim_null_63(i64 %na9593) 
  store volatile i64 %n_639763, i64* %vptr19544, align 8 ; call prim_null_63
  %cmpptr19548 = alloca i1, align 8  %cmp19545 = icmp eq i64 %n_639763, 15 store volatile i1 %cmp19545, i1* %cmpptr19548, align 8; false?
  br i1 %cmp19545, label %else19547, label %then19546                                ; if

then19546:
 %vptr19549 = alloca i64, align 8 
  %arg7896 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7896, i64* %vptr19549, align 8 ; quoted int
 %vptr19550 = alloca i64, align 8 
  %a7012 = call i64 @prim_vector_45ref(i64 %SdC$_37wind_45stack, i64 %arg7896) 
  store volatile i64 %a7012, i64* %vptr19550, align 8 ; call prim_vector_45ref
  %vptr19559 = alloca i64*, align 8 
  %cloptr19551 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr19551, i64** %vptr19559, align 8 ; malloc
  %vptr19560 = alloca i64*, align 8 
  %eptr19553 = getelementptr inbounds i64, i64* %cloptr19551, i64 2 
  store volatile i64* %eptr19553, i64** %vptr19560, align 8 ; &eptr19553[1]
  %vptr19561 = alloca i64*, align 8 
  %eptr19554 = getelementptr inbounds i64, i64* %cloptr19551, i64 3 
  store volatile i64* %eptr19554, i64** %vptr19561, align 8 ; &eptr19554[2]
  %vptr19562 = alloca i64*, align 8 
  %eptr19555 = getelementptr inbounds i64, i64* %cloptr19551, i64 4 
  store volatile i64* %eptr19555, i64** %vptr19562, align 8 ; &eptr19555[3]
  %vptr19563 = alloca i64*, align 8 
  %eptr19556 = getelementptr inbounds i64, i64* %cloptr19551, i64 5 
  store volatile i64* %eptr19556, i64** %vptr19563, align 8 ; &eptr19556[4]
  %vptr19564 = alloca i64*, align 8 
  %eptr19557 = getelementptr inbounds i64, i64* %cloptr19551, i64 6 
  store volatile i64* %eptr19557, i64** %vptr19564, align 8 ; &eptr19557[5]
  store i64 %emsg18637, i64* %eptr19553                                              ; *eptr19553 = %emsg18637
  store i64 %cont7172, i64* %eptr19554                                               ; *eptr19554 = %cont7172
  store i64 %Qmo$new, i64* %eptr19555                                                ; *eptr19555 = %Qmo$new
  store i64 %SdC$_37wind_45stack, i64* %eptr19556                                    ; *eptr19556 = %SdC$_37wind_45stack
  store i64 %emsg08636, i64* %eptr19557                                              ; *eptr19557 = %emsg08636
  %vptr19565 = alloca i64*, align 8 
  %eptr19552 = getelementptr inbounds i64, i64* %cloptr19551, i64 1 
  store volatile i64* %eptr19552, i64** %vptr19565, align 8 ; &cloptr19551[1]
 %vptr19566 = alloca i64, align 8 
  %f19558 = ptrtoint void(i64,i64)* @lam12076 to i64 
  store volatile i64 %f19558, i64* %vptr19566, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f19558, i64* %eptr19552                                                 ; store fptr
 %vptr19567 = alloca i64, align 8 
  %arg7900 = ptrtoint i64* %cloptr19551 to i64 
  store volatile i64 %arg7900, i64* %vptr19567, align 8 ; closure cast; i64* -> i64
 %vptr19568 = alloca i64, align 8 
  %rva9761 = add i64 0, 0 
  store volatile i64 %rva9761, i64* %vptr19568, align 8 ; quoted ()
 %vptr19569 = alloca i64, align 8 
  %rva9760 = call i64 @prim_cons(i64 %a7012, i64 %rva9761) 
  store volatile i64 %rva9760, i64* %vptr19569, align 8 ; call prim_cons
 %vptr19570 = alloca i64, align 8 
  %rva9759 = call i64 @prim_cons(i64 %Qmo$new, i64 %rva9760) 
  store volatile i64 %rva9759, i64* %vptr19570, align 8 ; call prim_cons
 %vptr19571 = alloca i64, align 8 
  %rva9758 = call i64 @prim_cons(i64 %arg7900, i64 %rva9759) 
  store volatile i64 %rva9758, i64* %vptr19571, align 8 ; call prim_cons
  %vptr19577 = alloca i64*, align 8 
  %cloptr19572 = inttoptr i64 %fDa$_37common_45tail to i64* 
  store volatile i64* %cloptr19572, i64** %vptr19577, align 8 ; closure/env cast; i64 -> i64*
  %vptr19578 = alloca i64*, align 8 
  %i0ptr19573 = getelementptr inbounds i64, i64* %cloptr19572, i64 1 
  store volatile i64* %i0ptr19573, i64** %vptr19578, align 8 ; &cloptr19572[1]
 %vptr19579 = alloca i64, align 8 
  %f19575 = load i64, i64* %i0ptr19573, align 8 
  store volatile i64 %f19575, i64* %vptr19579, align 8 ; load; *i0ptr19573
  %fptr19574 = inttoptr i64 %f19575 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19574(i64 %fDa$_37common_45tail, i64 %rva9758)      ; tail call
  ret void

else19547:
 %vptr19580 = alloca i64, align 8 
  %h9764 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9764, i64* %vptr19580, align 8 ; call prim_halt
  %vptr19586 = alloca i64*, align 8 
  %cloptr19581 = inttoptr i64 %h9764 to i64* 
  store volatile i64* %cloptr19581, i64** %vptr19586, align 8 ; closure/env cast; i64 -> i64*
  %vptr19587 = alloca i64*, align 8 
  %i0ptr19582 = getelementptr inbounds i64, i64* %cloptr19581, i64 1 
  store volatile i64* %i0ptr19582, i64** %vptr19587, align 8 ; &cloptr19581[1]
 %vptr19588 = alloca i64, align 8 
  %f19584 = load i64, i64* %i0ptr19582, align 8 
  store volatile i64 %f19584, i64* %vptr19588, align 8 ; load; *i0ptr19582
  %fptr19583 = inttoptr i64 %f19584 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19583(i64 %h9764, i64 %h9764)                       ; tail call
  ret void
}


define void @lam12076(i64 %env12077, i64 %rvp9754) {
 %vptr19591 = alloca i64, align 8 
  %envptr19589 = inttoptr i64 %env12077 to i64* 
  store volatile i64 %emsg08636, i64* %vptr19591, align 8 ; closure/env cast; i64 -> i64*
  %vptr19592 = alloca i64*, align 8 
  %envptr19590 = getelementptr inbounds i64, i64* %envptr19589, i64 6 
  store volatile i64* %envptr19590, i64** %vptr19592, align 8 ; &envptr19589[5]
 %vptr19593 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr19590, align 8 
  store volatile i64 %emsg08636, i64* %vptr19593, align 8 ; load; *envptr19590
 %vptr19596 = alloca i64, align 8 
  %envptr19594 = inttoptr i64 %env12077 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr19596, align 8 ; closure/env cast; i64 -> i64*
  %vptr19597 = alloca i64*, align 8 
  %envptr19595 = getelementptr inbounds i64, i64* %envptr19594, i64 5 
  store volatile i64* %envptr19595, i64** %vptr19597, align 8 ; &envptr19594[4]
 %vptr19598 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr19595, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr19598, align 8 ; load; *envptr19595
 %vptr19601 = alloca i64, align 8 
  %envptr19599 = inttoptr i64 %env12077 to i64* 
  store volatile i64 %Qmo$new, i64* %vptr19601, align 8 ; closure/env cast; i64 -> i64*
  %vptr19602 = alloca i64*, align 8 
  %envptr19600 = getelementptr inbounds i64, i64* %envptr19599, i64 4 
  store volatile i64* %envptr19600, i64** %vptr19602, align 8 ; &envptr19599[3]
 %vptr19603 = alloca i64, align 8 
  %Qmo$new = load i64, i64* %envptr19600, align 8 
  store volatile i64 %Qmo$new, i64* %vptr19603, align 8 ; load; *envptr19600
 %vptr19606 = alloca i64, align 8 
  %envptr19604 = inttoptr i64 %env12077 to i64* 
  store volatile i64 %cont7172, i64* %vptr19606, align 8 ; closure/env cast; i64 -> i64*
  %vptr19607 = alloca i64*, align 8 
  %envptr19605 = getelementptr inbounds i64, i64* %envptr19604, i64 3 
  store volatile i64* %envptr19605, i64** %vptr19607, align 8 ; &envptr19604[2]
 %vptr19608 = alloca i64, align 8 
  %cont7172 = load i64, i64* %envptr19605, align 8 
  store volatile i64 %cont7172, i64* %vptr19608, align 8 ; load; *envptr19605
 %vptr19611 = alloca i64, align 8 
  %envptr19609 = inttoptr i64 %env12077 to i64* 
  store volatile i64 %emsg18637, i64* %vptr19611, align 8 ; closure/env cast; i64 -> i64*
  %vptr19612 = alloca i64*, align 8 
  %envptr19610 = getelementptr inbounds i64, i64* %envptr19609, i64 2 
  store volatile i64* %envptr19610, i64** %vptr19612, align 8 ; &envptr19609[1]
 %vptr19613 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr19610, align 8 
  store volatile i64 %emsg18637, i64* %vptr19613, align 8 ; load; *envptr19610
 %vptr19614 = alloca i64, align 8 
  %_957173 = call i64 @prim_car(i64 %rvp9754) 
  store volatile i64 %_957173, i64* %vptr19614, align 8 ; call prim_car
 %vptr19615 = alloca i64, align 8 
  %rvp9750 = call i64 @prim_cdr(i64 %rvp9754) 
  store volatile i64 %rvp9750, i64* %vptr19615, align 8 ; call prim_cdr
 %vptr19616 = alloca i64, align 8 
  %n_639755 = call i64 @prim_null_63(i64 %rvp9750) 
  store volatile i64 %n_639755, i64* %vptr19616, align 8 ; call prim_null_63
  %cmpptr19620 = alloca i1, align 8  %cmp19617 = icmp eq i64 %n_639755, 15 store volatile i1 %cmp19617, i1* %cmpptr19620, align 8; false?
  br i1 %cmp19617, label %else19619, label %then19618                                ; if

then19618:
 %vptr19621 = alloca i64, align 8 
  %h9756 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9756, i64* %vptr19621, align 8 ; call prim_halt
  %vptr19627 = alloca i64*, align 8 
  %cloptr19622 = inttoptr i64 %h9756 to i64* 
  store volatile i64* %cloptr19622, i64** %vptr19627, align 8 ; closure/env cast; i64 -> i64*
  %vptr19628 = alloca i64*, align 8 
  %i0ptr19623 = getelementptr inbounds i64, i64* %cloptr19622, i64 1 
  store volatile i64* %i0ptr19623, i64** %vptr19628, align 8 ; &cloptr19622[1]
 %vptr19629 = alloca i64, align 8 
  %f19625 = load i64, i64* %i0ptr19623, align 8 
  store volatile i64 %f19625, i64* %vptr19629, align 8 ; load; *i0ptr19623
  %fptr19624 = inttoptr i64 %f19625 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19624(i64 %h9756, i64 %h9756)                       ; tail call
  ret void

else19619:
 %vptr19630 = alloca i64, align 8 
  %Fki$tail = call i64 @prim_car(i64 %rvp9750) 
  store volatile i64 %Fki$tail, i64* %vptr19630, align 8 ; call prim_car
 %vptr19631 = alloca i64, align 8 
  %na9595 = call i64 @prim_cdr(i64 %rvp9750) 
  store volatile i64 %na9595, i64* %vptr19631, align 8 ; call prim_cdr
 %vptr19632 = alloca i64, align 8 
  %n_639751 = call i64 @prim_null_63(i64 %na9595) 
  store volatile i64 %n_639751, i64* %vptr19632, align 8 ; call prim_null_63
  %cmpptr19636 = alloca i1, align 8  %cmp19633 = icmp eq i64 %n_639751, 15 store volatile i1 %cmp19633, i1* %cmpptr19636, align 8; false?
  br i1 %cmp19633, label %else19635, label %then19634                                ; if

then19634:
  %vptr19640 = alloca i64*, align 8 
  %cloptr19637 = call i64* @make_closure(i64 8) 
  store volatile i64* %cloptr19637, i64** %vptr19640, align 8 ; malloc
  %vptr19641 = alloca i64*, align 8 
  %eptr19638 = getelementptr inbounds i64, i64* %cloptr19637, i64 1 
  store volatile i64* %eptr19638, i64** %vptr19641, align 8 ; &cloptr19637[1]
 %vptr19642 = alloca i64, align 8 
  %f19639 = ptrtoint void(i64,i64)* @lam12074 to i64 
  store volatile i64 %f19639, i64* %vptr19642, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f19639, i64* %eptr19638                                                 ; store fptr
 %vptr19643 = alloca i64, align 8 
  %arg7903 = ptrtoint i64* %cloptr19637 to i64 
  store volatile i64 %arg7903, i64* %vptr19643, align 8 ; closure cast; i64* -> i64
  %vptr19653 = alloca i64*, align 8 
  %cloptr19644 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr19644, i64** %vptr19653, align 8 ; malloc
  %vptr19654 = alloca i64*, align 8 
  %eptr19646 = getelementptr inbounds i64, i64* %cloptr19644, i64 2 
  store volatile i64* %eptr19646, i64** %vptr19654, align 8 ; &eptr19646[1]
  %vptr19655 = alloca i64*, align 8 
  %eptr19647 = getelementptr inbounds i64, i64* %cloptr19644, i64 3 
  store volatile i64* %eptr19647, i64** %vptr19655, align 8 ; &eptr19647[2]
  %vptr19656 = alloca i64*, align 8 
  %eptr19648 = getelementptr inbounds i64, i64* %cloptr19644, i64 4 
  store volatile i64* %eptr19648, i64** %vptr19656, align 8 ; &eptr19648[3]
  %vptr19657 = alloca i64*, align 8 
  %eptr19649 = getelementptr inbounds i64, i64* %cloptr19644, i64 5 
  store volatile i64* %eptr19649, i64** %vptr19657, align 8 ; &eptr19649[4]
  %vptr19658 = alloca i64*, align 8 
  %eptr19650 = getelementptr inbounds i64, i64* %cloptr19644, i64 6 
  store volatile i64* %eptr19650, i64** %vptr19658, align 8 ; &eptr19650[5]
  %vptr19659 = alloca i64*, align 8 
  %eptr19651 = getelementptr inbounds i64, i64* %cloptr19644, i64 7 
  store volatile i64* %eptr19651, i64** %vptr19659, align 8 ; &eptr19651[6]
  store i64 %Fki$tail, i64* %eptr19646                                               ; *eptr19646 = %Fki$tail
  store i64 %emsg18637, i64* %eptr19647                                              ; *eptr19647 = %emsg18637
  store i64 %cont7172, i64* %eptr19648                                               ; *eptr19648 = %cont7172
  store i64 %Qmo$new, i64* %eptr19649                                                ; *eptr19649 = %Qmo$new
  store i64 %SdC$_37wind_45stack, i64* %eptr19650                                    ; *eptr19650 = %SdC$_37wind_45stack
  store i64 %emsg08636, i64* %eptr19651                                              ; *eptr19651 = %emsg08636
  %vptr19660 = alloca i64*, align 8 
  %eptr19645 = getelementptr inbounds i64, i64* %cloptr19644, i64 1 
  store volatile i64* %eptr19645, i64** %vptr19660, align 8 ; &cloptr19644[1]
 %vptr19661 = alloca i64, align 8 
  %f19652 = ptrtoint void(i64,i64)* @lam12070 to i64 
  store volatile i64 %f19652, i64* %vptr19661, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f19652, i64* %eptr19645                                                 ; store fptr
 %vptr19662 = alloca i64, align 8 
  %arg7902 = ptrtoint i64* %cloptr19644 to i64 
  store volatile i64 %arg7902, i64* %vptr19662, align 8 ; closure cast; i64* -> i64
 %vptr19663 = alloca i64, align 8 
  %rva9749 = add i64 0, 0 
  store volatile i64 %rva9749, i64* %vptr19663, align 8 ; quoted ()
 %vptr19664 = alloca i64, align 8 
  %rva9748 = call i64 @prim_cons(i64 %arg7902, i64 %rva9749) 
  store volatile i64 %rva9748, i64* %vptr19664, align 8 ; call prim_cons
  %vptr19670 = alloca i64*, align 8 
  %cloptr19665 = inttoptr i64 %arg7903 to i64* 
  store volatile i64* %cloptr19665, i64** %vptr19670, align 8 ; closure/env cast; i64 -> i64*
  %vptr19671 = alloca i64*, align 8 
  %i0ptr19666 = getelementptr inbounds i64, i64* %cloptr19665, i64 1 
  store volatile i64* %i0ptr19666, i64** %vptr19671, align 8 ; &cloptr19665[1]
 %vptr19672 = alloca i64, align 8 
  %f19668 = load i64, i64* %i0ptr19666, align 8 
  store volatile i64 %f19668, i64* %vptr19672, align 8 ; load; *i0ptr19666
  %fptr19667 = inttoptr i64 %f19668 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19667(i64 %arg7903, i64 %rva9748)                   ; tail call
  ret void

else19635:
 %vptr19673 = alloca i64, align 8 
  %h9752 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9752, i64* %vptr19673, align 8 ; call prim_halt
  %vptr19679 = alloca i64*, align 8 
  %cloptr19674 = inttoptr i64 %h9752 to i64* 
  store volatile i64* %cloptr19674, i64** %vptr19679, align 8 ; closure/env cast; i64 -> i64*
  %vptr19680 = alloca i64*, align 8 
  %i0ptr19675 = getelementptr inbounds i64, i64* %cloptr19674, i64 1 
  store volatile i64* %i0ptr19675, i64** %vptr19680, align 8 ; &cloptr19674[1]
 %vptr19681 = alloca i64, align 8 
  %f19677 = load i64, i64* %i0ptr19675, align 8 
  store volatile i64 %f19677, i64* %vptr19681, align 8 ; load; *i0ptr19675
  %fptr19676 = inttoptr i64 %f19677 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19676(i64 %h9752, i64 %h9752)                       ; tail call
  ret void
}


define void @lam12074(i64 %env12075, i64 %VNV$lst7194) {
 %vptr19682 = alloca i64, align 8 
  %cont7193 = call i64 @prim_car(i64 %VNV$lst7194) 
  store volatile i64 %cont7193, i64* %vptr19682, align 8 ; call prim_car
 %vptr19683 = alloca i64, align 8 
  %VNV$lst = call i64 @prim_cdr(i64 %VNV$lst7194) 
  store volatile i64 %VNV$lst, i64* %vptr19683, align 8 ; call prim_cdr
 %vptr19684 = alloca i64, align 8 
  %arg7907 = add i64 0, 0 
  store volatile i64 %arg7907, i64* %vptr19684, align 8 ; quoted ()
 %vptr19685 = alloca i64, align 8 
  %rva9598 = add i64 0, 0 
  store volatile i64 %rva9598, i64* %vptr19685, align 8 ; quoted ()
 %vptr19686 = alloca i64, align 8 
  %rva9597 = call i64 @prim_cons(i64 %VNV$lst, i64 %rva9598) 
  store volatile i64 %rva9597, i64* %vptr19686, align 8 ; call prim_cons
 %vptr19687 = alloca i64, align 8 
  %rva9596 = call i64 @prim_cons(i64 %arg7907, i64 %rva9597) 
  store volatile i64 %rva9596, i64* %vptr19687, align 8 ; call prim_cons
  %vptr19693 = alloca i64*, align 8 
  %cloptr19688 = inttoptr i64 %cont7193 to i64* 
  store volatile i64* %cloptr19688, i64** %vptr19693, align 8 ; closure/env cast; i64 -> i64*
  %vptr19694 = alloca i64*, align 8 
  %i0ptr19689 = getelementptr inbounds i64, i64* %cloptr19688, i64 1 
  store volatile i64* %i0ptr19689, i64** %vptr19694, align 8 ; &cloptr19688[1]
 %vptr19695 = alloca i64, align 8 
  %f19691 = load i64, i64* %i0ptr19689, align 8 
  store volatile i64 %f19691, i64* %vptr19695, align 8 ; load; *i0ptr19689
  %fptr19690 = inttoptr i64 %f19691 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19690(i64 %cont7193, i64 %rva9596)                  ; tail call
  ret void
}


define void @lam12070(i64 %env12071, i64 %rvp9744) {
 %vptr19698 = alloca i64, align 8 
  %envptr19696 = inttoptr i64 %env12071 to i64* 
  store volatile i64 %emsg08636, i64* %vptr19698, align 8 ; closure/env cast; i64 -> i64*
  %vptr19699 = alloca i64*, align 8 
  %envptr19697 = getelementptr inbounds i64, i64* %envptr19696, i64 7 
  store volatile i64* %envptr19697, i64** %vptr19699, align 8 ; &envptr19696[6]
 %vptr19700 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr19697, align 8 
  store volatile i64 %emsg08636, i64* %vptr19700, align 8 ; load; *envptr19697
 %vptr19703 = alloca i64, align 8 
  %envptr19701 = inttoptr i64 %env12071 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr19703, align 8 ; closure/env cast; i64 -> i64*
  %vptr19704 = alloca i64*, align 8 
  %envptr19702 = getelementptr inbounds i64, i64* %envptr19701, i64 6 
  store volatile i64* %envptr19702, i64** %vptr19704, align 8 ; &envptr19701[5]
 %vptr19705 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr19702, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr19705, align 8 ; load; *envptr19702
 %vptr19708 = alloca i64, align 8 
  %envptr19706 = inttoptr i64 %env12071 to i64* 
  store volatile i64 %Qmo$new, i64* %vptr19708, align 8 ; closure/env cast; i64 -> i64*
  %vptr19709 = alloca i64*, align 8 
  %envptr19707 = getelementptr inbounds i64, i64* %envptr19706, i64 5 
  store volatile i64* %envptr19707, i64** %vptr19709, align 8 ; &envptr19706[4]
 %vptr19710 = alloca i64, align 8 
  %Qmo$new = load i64, i64* %envptr19707, align 8 
  store volatile i64 %Qmo$new, i64* %vptr19710, align 8 ; load; *envptr19707
 %vptr19713 = alloca i64, align 8 
  %envptr19711 = inttoptr i64 %env12071 to i64* 
  store volatile i64 %cont7172, i64* %vptr19713, align 8 ; closure/env cast; i64 -> i64*
  %vptr19714 = alloca i64*, align 8 
  %envptr19712 = getelementptr inbounds i64, i64* %envptr19711, i64 4 
  store volatile i64* %envptr19712, i64** %vptr19714, align 8 ; &envptr19711[3]
 %vptr19715 = alloca i64, align 8 
  %cont7172 = load i64, i64* %envptr19712, align 8 
  store volatile i64 %cont7172, i64* %vptr19715, align 8 ; load; *envptr19712
 %vptr19718 = alloca i64, align 8 
  %envptr19716 = inttoptr i64 %env12071 to i64* 
  store volatile i64 %emsg18637, i64* %vptr19718, align 8 ; closure/env cast; i64 -> i64*
  %vptr19719 = alloca i64*, align 8 
  %envptr19717 = getelementptr inbounds i64, i64* %envptr19716, i64 3 
  store volatile i64* %envptr19717, i64** %vptr19719, align 8 ; &envptr19716[2]
 %vptr19720 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr19717, align 8 
  store volatile i64 %emsg18637, i64* %vptr19720, align 8 ; load; *envptr19717
 %vptr19723 = alloca i64, align 8 
  %envptr19721 = inttoptr i64 %env12071 to i64* 
  store volatile i64 %Fki$tail, i64* %vptr19723, align 8 ; closure/env cast; i64 -> i64*
  %vptr19724 = alloca i64*, align 8 
  %envptr19722 = getelementptr inbounds i64, i64* %envptr19721, i64 2 
  store volatile i64* %envptr19722, i64** %vptr19724, align 8 ; &envptr19721[1]
 %vptr19725 = alloca i64, align 8 
  %Fki$tail = load i64, i64* %envptr19722, align 8 
  store volatile i64 %Fki$tail, i64* %vptr19725, align 8 ; load; *envptr19722
 %vptr19726 = alloca i64, align 8 
  %_957191 = call i64 @prim_car(i64 %rvp9744) 
  store volatile i64 %_957191, i64* %vptr19726, align 8 ; call prim_car
 %vptr19727 = alloca i64, align 8 
  %rvp9740 = call i64 @prim_cdr(i64 %rvp9744) 
  store volatile i64 %rvp9740, i64* %vptr19727, align 8 ; call prim_cdr
 %vptr19728 = alloca i64, align 8 
  %n_639745 = call i64 @prim_null_63(i64 %rvp9740) 
  store volatile i64 %n_639745, i64* %vptr19728, align 8 ; call prim_null_63
  %cmpptr19732 = alloca i1, align 8  %cmp19729 = icmp eq i64 %n_639745, 15 store volatile i1 %cmp19729, i1* %cmpptr19732, align 8; false?
  br i1 %cmp19729, label %else19731, label %then19730                                ; if

then19730:
 %vptr19733 = alloca i64, align 8 
  %h9746 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9746, i64* %vptr19733, align 8 ; call prim_halt
  %vptr19739 = alloca i64*, align 8 
  %cloptr19734 = inttoptr i64 %h9746 to i64* 
  store volatile i64* %cloptr19734, i64** %vptr19739, align 8 ; closure/env cast; i64 -> i64*
  %vptr19740 = alloca i64*, align 8 
  %i0ptr19735 = getelementptr inbounds i64, i64* %cloptr19734, i64 1 
  store volatile i64* %i0ptr19735, i64** %vptr19740, align 8 ; &cloptr19734[1]
 %vptr19741 = alloca i64, align 8 
  %f19737 = load i64, i64* %i0ptr19735, align 8 
  store volatile i64 %f19737, i64* %vptr19741, align 8 ; load; *i0ptr19735
  %fptr19736 = inttoptr i64 %f19737 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19736(i64 %h9746, i64 %h9746)                       ; tail call
  ret void

else19731:
 %vptr19742 = alloca i64, align 8 
  %a7013 = call i64 @prim_car(i64 %rvp9740) 
  store volatile i64 %a7013, i64* %vptr19742, align 8 ; call prim_car
 %vptr19743 = alloca i64, align 8 
  %na9600 = call i64 @prim_cdr(i64 %rvp9740) 
  store volatile i64 %na9600, i64* %vptr19743, align 8 ; call prim_cdr
 %vptr19744 = alloca i64, align 8 
  %n_639741 = call i64 @prim_null_63(i64 %na9600) 
  store volatile i64 %n_639741, i64* %vptr19744, align 8 ; call prim_null_63
  %cmpptr19748 = alloca i1, align 8  %cmp19745 = icmp eq i64 %n_639741, 15 store volatile i1 %cmp19745, i1* %cmpptr19748, align 8; false?
  br i1 %cmp19745, label %else19747, label %then19746                                ; if

then19746:
 %vptr19749 = alloca i64, align 8 
  %arg7910 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg7910, i64* %vptr19749, align 8 ; quoted int
 %vptr19750 = alloca i64, align 8 
  %retprim7192 = call i64 @prim_make_45vector(i64 %arg7910, i64 %a7013) 
  store volatile i64 %retprim7192, i64* %vptr19750, align 8 ; call prim_make_45vector
  %vptr19760 = alloca i64*, align 8 
  %cloptr19751 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr19751, i64** %vptr19760, align 8 ; malloc
  %vptr19761 = alloca i64*, align 8 
  %eptr19753 = getelementptr inbounds i64, i64* %cloptr19751, i64 2 
  store volatile i64* %eptr19753, i64** %vptr19761, align 8 ; &eptr19753[1]
  %vptr19762 = alloca i64*, align 8 
  %eptr19754 = getelementptr inbounds i64, i64* %cloptr19751, i64 3 
  store volatile i64* %eptr19754, i64** %vptr19762, align 8 ; &eptr19754[2]
  %vptr19763 = alloca i64*, align 8 
  %eptr19755 = getelementptr inbounds i64, i64* %cloptr19751, i64 4 
  store volatile i64* %eptr19755, i64** %vptr19763, align 8 ; &eptr19755[3]
  %vptr19764 = alloca i64*, align 8 
  %eptr19756 = getelementptr inbounds i64, i64* %cloptr19751, i64 5 
  store volatile i64* %eptr19756, i64** %vptr19764, align 8 ; &eptr19756[4]
  %vptr19765 = alloca i64*, align 8 
  %eptr19757 = getelementptr inbounds i64, i64* %cloptr19751, i64 6 
  store volatile i64* %eptr19757, i64** %vptr19765, align 8 ; &eptr19757[5]
  %vptr19766 = alloca i64*, align 8 
  %eptr19758 = getelementptr inbounds i64, i64* %cloptr19751, i64 7 
  store volatile i64* %eptr19758, i64** %vptr19766, align 8 ; &eptr19758[6]
  store i64 %Fki$tail, i64* %eptr19753                                               ; *eptr19753 = %Fki$tail
  store i64 %emsg18637, i64* %eptr19754                                              ; *eptr19754 = %emsg18637
  store i64 %cont7172, i64* %eptr19755                                               ; *eptr19755 = %cont7172
  store i64 %Qmo$new, i64* %eptr19756                                                ; *eptr19756 = %Qmo$new
  store i64 %SdC$_37wind_45stack, i64* %eptr19757                                    ; *eptr19757 = %SdC$_37wind_45stack
  store i64 %emsg08636, i64* %eptr19758                                              ; *eptr19758 = %emsg08636
  %vptr19767 = alloca i64*, align 8 
  %eptr19752 = getelementptr inbounds i64, i64* %cloptr19751, i64 1 
  store volatile i64* %eptr19752, i64** %vptr19767, align 8 ; &cloptr19751[1]
 %vptr19768 = alloca i64, align 8 
  %f19759 = ptrtoint void(i64,i64)* @lam12067 to i64 
  store volatile i64 %f19759, i64* %vptr19768, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f19759, i64* %eptr19752                                                 ; store fptr
 %vptr19769 = alloca i64, align 8 
  %arg7913 = ptrtoint i64* %cloptr19751 to i64 
  store volatile i64 %arg7913, i64* %vptr19769, align 8 ; closure cast; i64* -> i64
 %vptr19770 = alloca i64, align 8 
  %arg7912 = add i64 0, 0 
  store volatile i64 %arg7912, i64* %vptr19770, align 8 ; quoted ()
 %vptr19771 = alloca i64, align 8 
  %rva9739 = add i64 0, 0 
  store volatile i64 %rva9739, i64* %vptr19771, align 8 ; quoted ()
 %vptr19772 = alloca i64, align 8 
  %rva9738 = call i64 @prim_cons(i64 %retprim7192, i64 %rva9739) 
  store volatile i64 %rva9738, i64* %vptr19772, align 8 ; call prim_cons
 %vptr19773 = alloca i64, align 8 
  %rva9737 = call i64 @prim_cons(i64 %arg7912, i64 %rva9738) 
  store volatile i64 %rva9737, i64* %vptr19773, align 8 ; call prim_cons
  %vptr19779 = alloca i64*, align 8 
  %cloptr19774 = inttoptr i64 %arg7913 to i64* 
  store volatile i64* %cloptr19774, i64** %vptr19779, align 8 ; closure/env cast; i64 -> i64*
  %vptr19780 = alloca i64*, align 8 
  %i0ptr19775 = getelementptr inbounds i64, i64* %cloptr19774, i64 1 
  store volatile i64* %i0ptr19775, i64** %vptr19780, align 8 ; &cloptr19774[1]
 %vptr19781 = alloca i64, align 8 
  %f19777 = load i64, i64* %i0ptr19775, align 8 
  store volatile i64 %f19777, i64* %vptr19781, align 8 ; load; *i0ptr19775
  %fptr19776 = inttoptr i64 %f19777 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19776(i64 %arg7913, i64 %rva9737)                   ; tail call
  ret void

else19747:
 %vptr19782 = alloca i64, align 8 
  %h9742 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9742, i64* %vptr19782, align 8 ; call prim_halt
  %vptr19788 = alloca i64*, align 8 
  %cloptr19783 = inttoptr i64 %h9742 to i64* 
  store volatile i64* %cloptr19783, i64** %vptr19788, align 8 ; closure/env cast; i64 -> i64*
  %vptr19789 = alloca i64*, align 8 
  %i0ptr19784 = getelementptr inbounds i64, i64* %cloptr19783, i64 1 
  store volatile i64* %i0ptr19784, i64** %vptr19789, align 8 ; &cloptr19783[1]
 %vptr19790 = alloca i64, align 8 
  %f19786 = load i64, i64* %i0ptr19784, align 8 
  store volatile i64 %f19786, i64* %vptr19790, align 8 ; load; *i0ptr19784
  %fptr19785 = inttoptr i64 %f19786 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19785(i64 %h9742, i64 %h9742)                       ; tail call
  ret void
}


define void @lam12067(i64 %env12068, i64 %rvp9733) {
 %vptr19793 = alloca i64, align 8 
  %envptr19791 = inttoptr i64 %env12068 to i64* 
  store volatile i64 %emsg08636, i64* %vptr19793, align 8 ; closure/env cast; i64 -> i64*
  %vptr19794 = alloca i64*, align 8 
  %envptr19792 = getelementptr inbounds i64, i64* %envptr19791, i64 7 
  store volatile i64* %envptr19792, i64** %vptr19794, align 8 ; &envptr19791[6]
 %vptr19795 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr19792, align 8 
  store volatile i64 %emsg08636, i64* %vptr19795, align 8 ; load; *envptr19792
 %vptr19798 = alloca i64, align 8 
  %envptr19796 = inttoptr i64 %env12068 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr19798, align 8 ; closure/env cast; i64 -> i64*
  %vptr19799 = alloca i64*, align 8 
  %envptr19797 = getelementptr inbounds i64, i64* %envptr19796, i64 6 
  store volatile i64* %envptr19797, i64** %vptr19799, align 8 ; &envptr19796[5]
 %vptr19800 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr19797, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr19800, align 8 ; load; *envptr19797
 %vptr19803 = alloca i64, align 8 
  %envptr19801 = inttoptr i64 %env12068 to i64* 
  store volatile i64 %Qmo$new, i64* %vptr19803, align 8 ; closure/env cast; i64 -> i64*
  %vptr19804 = alloca i64*, align 8 
  %envptr19802 = getelementptr inbounds i64, i64* %envptr19801, i64 5 
  store volatile i64* %envptr19802, i64** %vptr19804, align 8 ; &envptr19801[4]
 %vptr19805 = alloca i64, align 8 
  %Qmo$new = load i64, i64* %envptr19802, align 8 
  store volatile i64 %Qmo$new, i64* %vptr19805, align 8 ; load; *envptr19802
 %vptr19808 = alloca i64, align 8 
  %envptr19806 = inttoptr i64 %env12068 to i64* 
  store volatile i64 %cont7172, i64* %vptr19808, align 8 ; closure/env cast; i64 -> i64*
  %vptr19809 = alloca i64*, align 8 
  %envptr19807 = getelementptr inbounds i64, i64* %envptr19806, i64 4 
  store volatile i64* %envptr19807, i64** %vptr19809, align 8 ; &envptr19806[3]
 %vptr19810 = alloca i64, align 8 
  %cont7172 = load i64, i64* %envptr19807, align 8 
  store volatile i64 %cont7172, i64* %vptr19810, align 8 ; load; *envptr19807
 %vptr19813 = alloca i64, align 8 
  %envptr19811 = inttoptr i64 %env12068 to i64* 
  store volatile i64 %emsg18637, i64* %vptr19813, align 8 ; closure/env cast; i64 -> i64*
  %vptr19814 = alloca i64*, align 8 
  %envptr19812 = getelementptr inbounds i64, i64* %envptr19811, i64 3 
  store volatile i64* %envptr19812, i64** %vptr19814, align 8 ; &envptr19811[2]
 %vptr19815 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr19812, align 8 
  store volatile i64 %emsg18637, i64* %vptr19815, align 8 ; load; *envptr19812
 %vptr19818 = alloca i64, align 8 
  %envptr19816 = inttoptr i64 %env12068 to i64* 
  store volatile i64 %Fki$tail, i64* %vptr19818, align 8 ; closure/env cast; i64 -> i64*
  %vptr19819 = alloca i64*, align 8 
  %envptr19817 = getelementptr inbounds i64, i64* %envptr19816, i64 2 
  store volatile i64* %envptr19817, i64** %vptr19819, align 8 ; &envptr19816[1]
 %vptr19820 = alloca i64, align 8 
  %Fki$tail = load i64, i64* %envptr19817, align 8 
  store volatile i64 %Fki$tail, i64* %vptr19820, align 8 ; load; *envptr19817
 %vptr19821 = alloca i64, align 8 
  %_957185 = call i64 @prim_car(i64 %rvp9733) 
  store volatile i64 %_957185, i64* %vptr19821, align 8 ; call prim_car
 %vptr19822 = alloca i64, align 8 
  %rvp9729 = call i64 @prim_cdr(i64 %rvp9733) 
  store volatile i64 %rvp9729, i64* %vptr19822, align 8 ; call prim_cdr
 %vptr19823 = alloca i64, align 8 
  %n_639734 = call i64 @prim_null_63(i64 %rvp9729) 
  store volatile i64 %n_639734, i64* %vptr19823, align 8 ; call prim_null_63
  %cmpptr19827 = alloca i1, align 8  %cmp19824 = icmp eq i64 %n_639734, 15 store volatile i1 %cmp19824, i1* %cmpptr19827, align 8; false?
  br i1 %cmp19824, label %else19826, label %then19825                                ; if

then19825:
 %vptr19828 = alloca i64, align 8 
  %h9735 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9735, i64* %vptr19828, align 8 ; call prim_halt
  %vptr19834 = alloca i64*, align 8 
  %cloptr19829 = inttoptr i64 %h9735 to i64* 
  store volatile i64* %cloptr19829, i64** %vptr19834, align 8 ; closure/env cast; i64 -> i64*
  %vptr19835 = alloca i64*, align 8 
  %i0ptr19830 = getelementptr inbounds i64, i64* %cloptr19829, i64 1 
  store volatile i64* %i0ptr19830, i64** %vptr19835, align 8 ; &cloptr19829[1]
 %vptr19836 = alloca i64, align 8 
  %f19832 = load i64, i64* %i0ptr19830, align 8 
  store volatile i64 %f19832, i64* %vptr19836, align 8 ; load; *i0ptr19830
  %fptr19831 = inttoptr i64 %f19832 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19831(i64 %h9735, i64 %h9735)                       ; tail call
  ret void

else19826:
 %vptr19837 = alloca i64, align 8 
  %zfY$f = call i64 @prim_car(i64 %rvp9729) 
  store volatile i64 %zfY$f, i64* %vptr19837, align 8 ; call prim_car
 %vptr19838 = alloca i64, align 8 
  %na9602 = call i64 @prim_cdr(i64 %rvp9729) 
  store volatile i64 %na9602, i64* %vptr19838, align 8 ; call prim_cdr
 %vptr19839 = alloca i64, align 8 
  %n_639730 = call i64 @prim_null_63(i64 %na9602) 
  store volatile i64 %n_639730, i64* %vptr19839, align 8 ; call prim_null_63
  %cmpptr19843 = alloca i1, align 8  %cmp19840 = icmp eq i64 %n_639730, 15 store volatile i1 %cmp19840, i1* %cmpptr19843, align 8; false?
  br i1 %cmp19840, label %else19842, label %then19841                                ; if

then19841:
 %vptr19844 = alloca i64, align 8 
  %arg7915 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7915, i64* %vptr19844, align 8 ; quoted int
  %vptr19853 = alloca i64*, align 8 
  %cloptr19845 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr19845, i64** %vptr19853, align 8 ; malloc
  %vptr19854 = alloca i64*, align 8 
  %eptr19847 = getelementptr inbounds i64, i64* %cloptr19845, i64 2 
  store volatile i64* %eptr19847, i64** %vptr19854, align 8 ; &eptr19847[1]
  %vptr19855 = alloca i64*, align 8 
  %eptr19848 = getelementptr inbounds i64, i64* %cloptr19845, i64 3 
  store volatile i64* %eptr19848, i64** %vptr19855, align 8 ; &eptr19848[2]
  %vptr19856 = alloca i64*, align 8 
  %eptr19849 = getelementptr inbounds i64, i64* %cloptr19845, i64 4 
  store volatile i64* %eptr19849, i64** %vptr19856, align 8 ; &eptr19849[3]
  %vptr19857 = alloca i64*, align 8 
  %eptr19850 = getelementptr inbounds i64, i64* %cloptr19845, i64 5 
  store volatile i64* %eptr19850, i64** %vptr19857, align 8 ; &eptr19850[4]
  %vptr19858 = alloca i64*, align 8 
  %eptr19851 = getelementptr inbounds i64, i64* %cloptr19845, i64 6 
  store volatile i64* %eptr19851, i64** %vptr19858, align 8 ; &eptr19851[5]
  store i64 %Fki$tail, i64* %eptr19847                                               ; *eptr19847 = %Fki$tail
  store i64 %emsg18637, i64* %eptr19848                                              ; *eptr19848 = %emsg18637
  store i64 %SdC$_37wind_45stack, i64* %eptr19849                                    ; *eptr19849 = %SdC$_37wind_45stack
  store i64 %emsg08636, i64* %eptr19850                                              ; *eptr19850 = %emsg08636
  store i64 %zfY$f, i64* %eptr19851                                                  ; *eptr19851 = %zfY$f
  %vptr19859 = alloca i64*, align 8 
  %eptr19846 = getelementptr inbounds i64, i64* %cloptr19845, i64 1 
  store volatile i64* %eptr19846, i64** %vptr19859, align 8 ; &cloptr19845[1]
 %vptr19860 = alloca i64, align 8 
  %f19852 = ptrtoint void(i64,i64)* @lam12064 to i64 
  store volatile i64 %f19852, i64* %vptr19860, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f19852, i64* %eptr19846                                                 ; store fptr
 %vptr19861 = alloca i64, align 8 
  %arg7914 = ptrtoint i64* %cloptr19845 to i64 
  store volatile i64 %arg7914, i64* %vptr19861, align 8 ; closure cast; i64* -> i64
 %vptr19862 = alloca i64, align 8 
  %n38$_956885 = call i64 @prim_vector_45set_33(i64 %zfY$f, i64 %arg7915, i64 %arg7914) 
  store volatile i64 %n38$_956885, i64* %vptr19862, align 8 ; call prim_vector_45set_33
 %vptr19863 = alloca i64, align 8 
  %arg7940 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7940, i64* %vptr19863, align 8 ; quoted int
 %vptr19864 = alloca i64, align 8 
  %a7021 = call i64 @prim_vector_45ref(i64 %zfY$f, i64 %arg7940) 
  store volatile i64 %a7021, i64* %vptr19864, align 8 ; call prim_vector_45ref
 %vptr19865 = alloca i64, align 8 
  %arg7942 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7942, i64* %vptr19865, align 8 ; quoted int
 %vptr19866 = alloca i64, align 8 
  %a7022 = call i64 @prim_vector_45ref(i64 %SdC$_37wind_45stack, i64 %arg7942) 
  store volatile i64 %a7022, i64* %vptr19866, align 8 ; call prim_vector_45ref
  %vptr19876 = alloca i64*, align 8 
  %cloptr19867 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr19867, i64** %vptr19876, align 8 ; malloc
  %vptr19877 = alloca i64*, align 8 
  %eptr19869 = getelementptr inbounds i64, i64* %cloptr19867, i64 2 
  store volatile i64* %eptr19869, i64** %vptr19877, align 8 ; &eptr19869[1]
  %vptr19878 = alloca i64*, align 8 
  %eptr19870 = getelementptr inbounds i64, i64* %cloptr19867, i64 3 
  store volatile i64* %eptr19870, i64** %vptr19878, align 8 ; &eptr19870[2]
  %vptr19879 = alloca i64*, align 8 
  %eptr19871 = getelementptr inbounds i64, i64* %cloptr19867, i64 4 
  store volatile i64* %eptr19871, i64** %vptr19879, align 8 ; &eptr19871[3]
  %vptr19880 = alloca i64*, align 8 
  %eptr19872 = getelementptr inbounds i64, i64* %cloptr19867, i64 5 
  store volatile i64* %eptr19872, i64** %vptr19880, align 8 ; &eptr19872[4]
  %vptr19881 = alloca i64*, align 8 
  %eptr19873 = getelementptr inbounds i64, i64* %cloptr19867, i64 6 
  store volatile i64* %eptr19873, i64** %vptr19881, align 8 ; &eptr19873[5]
  %vptr19882 = alloca i64*, align 8 
  %eptr19874 = getelementptr inbounds i64, i64* %cloptr19867, i64 7 
  store volatile i64* %eptr19874, i64** %vptr19882, align 8 ; &eptr19874[6]
  store i64 %Fki$tail, i64* %eptr19869                                               ; *eptr19869 = %Fki$tail
  store i64 %emsg18637, i64* %eptr19870                                              ; *eptr19870 = %emsg18637
  store i64 %cont7172, i64* %eptr19871                                               ; *eptr19871 = %cont7172
  store i64 %Qmo$new, i64* %eptr19872                                                ; *eptr19872 = %Qmo$new
  store i64 %SdC$_37wind_45stack, i64* %eptr19873                                    ; *eptr19873 = %SdC$_37wind_45stack
  store i64 %emsg08636, i64* %eptr19874                                              ; *eptr19874 = %emsg08636
  %vptr19883 = alloca i64*, align 8 
  %eptr19868 = getelementptr inbounds i64, i64* %cloptr19867, i64 1 
  store volatile i64* %eptr19868, i64** %vptr19883, align 8 ; &cloptr19867[1]
 %vptr19884 = alloca i64, align 8 
  %f19875 = ptrtoint void(i64,i64)* @lam12048 to i64 
  store volatile i64 %f19875, i64* %vptr19884, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f19875, i64* %eptr19868                                                 ; store fptr
 %vptr19885 = alloca i64, align 8 
  %arg7945 = ptrtoint i64* %cloptr19867 to i64 
  store volatile i64 %arg7945, i64* %vptr19885, align 8 ; closure cast; i64* -> i64
 %vptr19886 = alloca i64, align 8 
  %rva9728 = add i64 0, 0 
  store volatile i64 %rva9728, i64* %vptr19886, align 8 ; quoted ()
 %vptr19887 = alloca i64, align 8 
  %rva9727 = call i64 @prim_cons(i64 %a7022, i64 %rva9728) 
  store volatile i64 %rva9727, i64* %vptr19887, align 8 ; call prim_cons
 %vptr19888 = alloca i64, align 8 
  %rva9726 = call i64 @prim_cons(i64 %arg7945, i64 %rva9727) 
  store volatile i64 %rva9726, i64* %vptr19888, align 8 ; call prim_cons
  %vptr19894 = alloca i64*, align 8 
  %cloptr19889 = inttoptr i64 %a7021 to i64* 
  store volatile i64* %cloptr19889, i64** %vptr19894, align 8 ; closure/env cast; i64 -> i64*
  %vptr19895 = alloca i64*, align 8 
  %i0ptr19890 = getelementptr inbounds i64, i64* %cloptr19889, i64 1 
  store volatile i64* %i0ptr19890, i64** %vptr19895, align 8 ; &cloptr19889[1]
 %vptr19896 = alloca i64, align 8 
  %f19892 = load i64, i64* %i0ptr19890, align 8 
  store volatile i64 %f19892, i64* %vptr19896, align 8 ; load; *i0ptr19890
  %fptr19891 = inttoptr i64 %f19892 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19891(i64 %a7021, i64 %rva9726)                     ; tail call
  ret void

else19842:
 %vptr19897 = alloca i64, align 8 
  %h9731 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9731, i64* %vptr19897, align 8 ; call prim_halt
  %vptr19903 = alloca i64*, align 8 
  %cloptr19898 = inttoptr i64 %h9731 to i64* 
  store volatile i64* %cloptr19898, i64** %vptr19903, align 8 ; closure/env cast; i64 -> i64*
  %vptr19904 = alloca i64*, align 8 
  %i0ptr19899 = getelementptr inbounds i64, i64* %cloptr19898, i64 1 
  store volatile i64* %i0ptr19899, i64** %vptr19904, align 8 ; &cloptr19898[1]
 %vptr19905 = alloca i64, align 8 
  %f19901 = load i64, i64* %i0ptr19899, align 8 
  store volatile i64 %f19901, i64* %vptr19905, align 8 ; load; *i0ptr19899
  %fptr19900 = inttoptr i64 %f19901 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19900(i64 %h9731, i64 %h9731)                       ; tail call
  ret void
}


define void @lam12064(i64 %env12065, i64 %rvp9640) {
 %vptr19908 = alloca i64, align 8 
  %envptr19906 = inttoptr i64 %env12065 to i64* 
  store volatile i64 %zfY$f, i64* %vptr19908, align 8 ; closure/env cast; i64 -> i64*
  %vptr19909 = alloca i64*, align 8 
  %envptr19907 = getelementptr inbounds i64, i64* %envptr19906, i64 6 
  store volatile i64* %envptr19907, i64** %vptr19909, align 8 ; &envptr19906[5]
 %vptr19910 = alloca i64, align 8 
  %zfY$f = load i64, i64* %envptr19907, align 8 
  store volatile i64 %zfY$f, i64* %vptr19910, align 8 ; load; *envptr19907
 %vptr19913 = alloca i64, align 8 
  %envptr19911 = inttoptr i64 %env12065 to i64* 
  store volatile i64 %emsg08636, i64* %vptr19913, align 8 ; closure/env cast; i64 -> i64*
  %vptr19914 = alloca i64*, align 8 
  %envptr19912 = getelementptr inbounds i64, i64* %envptr19911, i64 5 
  store volatile i64* %envptr19912, i64** %vptr19914, align 8 ; &envptr19911[4]
 %vptr19915 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr19912, align 8 
  store volatile i64 %emsg08636, i64* %vptr19915, align 8 ; load; *envptr19912
 %vptr19918 = alloca i64, align 8 
  %envptr19916 = inttoptr i64 %env12065 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr19918, align 8 ; closure/env cast; i64 -> i64*
  %vptr19919 = alloca i64*, align 8 
  %envptr19917 = getelementptr inbounds i64, i64* %envptr19916, i64 4 
  store volatile i64* %envptr19917, i64** %vptr19919, align 8 ; &envptr19916[3]
 %vptr19920 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr19917, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr19920, align 8 ; load; *envptr19917
 %vptr19923 = alloca i64, align 8 
  %envptr19921 = inttoptr i64 %env12065 to i64* 
  store volatile i64 %emsg18637, i64* %vptr19923, align 8 ; closure/env cast; i64 -> i64*
  %vptr19924 = alloca i64*, align 8 
  %envptr19922 = getelementptr inbounds i64, i64* %envptr19921, i64 3 
  store volatile i64* %envptr19922, i64** %vptr19924, align 8 ; &envptr19921[2]
 %vptr19925 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr19922, align 8 
  store volatile i64 %emsg18637, i64* %vptr19925, align 8 ; load; *envptr19922
 %vptr19928 = alloca i64, align 8 
  %envptr19926 = inttoptr i64 %env12065 to i64* 
  store volatile i64 %Fki$tail, i64* %vptr19928, align 8 ; closure/env cast; i64 -> i64*
  %vptr19929 = alloca i64*, align 8 
  %envptr19927 = getelementptr inbounds i64, i64* %envptr19926, i64 2 
  store volatile i64* %envptr19927, i64** %vptr19929, align 8 ; &envptr19926[1]
 %vptr19930 = alloca i64, align 8 
  %Fki$tail = load i64, i64* %envptr19927, align 8 
  store volatile i64 %Fki$tail, i64* %vptr19930, align 8 ; load; *envptr19927
 %vptr19931 = alloca i64, align 8 
  %cont7186 = call i64 @prim_car(i64 %rvp9640) 
  store volatile i64 %cont7186, i64* %vptr19931, align 8 ; call prim_car
 %vptr19932 = alloca i64, align 8 
  %rvp9636 = call i64 @prim_cdr(i64 %rvp9640) 
  store volatile i64 %rvp9636, i64* %vptr19932, align 8 ; call prim_cdr
 %vptr19933 = alloca i64, align 8 
  %n_639641 = call i64 @prim_null_63(i64 %rvp9636) 
  store volatile i64 %n_639641, i64* %vptr19933, align 8 ; call prim_null_63
  %cmpptr19937 = alloca i1, align 8  %cmp19934 = icmp eq i64 %n_639641, 15 store volatile i1 %cmp19934, i1* %cmpptr19937, align 8; false?
  br i1 %cmp19934, label %else19936, label %then19935                                ; if

then19935:
 %vptr19938 = alloca i64, align 8 
  %h9642 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9642, i64* %vptr19938, align 8 ; call prim_halt
  %vptr19944 = alloca i64*, align 8 
  %cloptr19939 = inttoptr i64 %h9642 to i64* 
  store volatile i64* %cloptr19939, i64** %vptr19944, align 8 ; closure/env cast; i64 -> i64*
  %vptr19945 = alloca i64*, align 8 
  %i0ptr19940 = getelementptr inbounds i64, i64* %cloptr19939, i64 1 
  store volatile i64* %i0ptr19940, i64** %vptr19945, align 8 ; &cloptr19939[1]
 %vptr19946 = alloca i64, align 8 
  %f19942 = load i64, i64* %i0ptr19940, align 8 
  store volatile i64 %f19942, i64* %vptr19946, align 8 ; load; *i0ptr19940
  %fptr19941 = inttoptr i64 %f19942 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19941(i64 %h9642, i64 %h9642)                       ; tail call
  ret void

else19936:
 %vptr19947 = alloca i64, align 8 
  %qBb$l = call i64 @prim_car(i64 %rvp9636) 
  store volatile i64 %qBb$l, i64* %vptr19947, align 8 ; call prim_car
 %vptr19948 = alloca i64, align 8 
  %na9604 = call i64 @prim_cdr(i64 %rvp9636) 
  store volatile i64 %na9604, i64* %vptr19948, align 8 ; call prim_cdr
 %vptr19949 = alloca i64, align 8 
  %n_639637 = call i64 @prim_null_63(i64 %na9604) 
  store volatile i64 %n_639637, i64* %vptr19949, align 8 ; call prim_null_63
  %cmpptr19953 = alloca i1, align 8  %cmp19950 = icmp eq i64 %n_639637, 15 store volatile i1 %cmp19950, i1* %cmpptr19953, align 8; false?
  br i1 %cmp19950, label %else19952, label %then19951                                ; if

then19951:
 %vptr19954 = alloca i64, align 8 
  %a7014 = call i64 @prim_eq_63(i64 %qBb$l, i64 %Fki$tail) 
  store volatile i64 %a7014, i64* %vptr19954, align 8 ; call prim_eq_63
 %vptr19955 = alloca i64, align 8 
  %a7015 = call i64 @prim_not(i64 %a7014) 
  store volatile i64 %a7015, i64* %vptr19955, align 8 ; call prim_not
  %cmpptr19959 = alloca i1, align 8  %cmp19956 = icmp eq i64 %a7015, 15 store volatile i1 %cmp19956, i1* %cmpptr19959, align 8; false?
  br i1 %cmp19956, label %else19958, label %then19957                                ; if

then19957:
 %vptr19960 = alloca i64, align 8 
  %a7016 = call i64 @prim_cdr(i64 %qBb$l) 
  store volatile i64 %a7016, i64* %vptr19960, align 8 ; call prim_cdr
 %vptr19961 = alloca i64, align 8 
  %arg7922 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7922, i64* %vptr19961, align 8 ; quoted int
 %vptr19962 = alloca i64, align 8 
  %retprim7189 = call i64 @prim_vector_45set_33(i64 %SdC$_37wind_45stack, i64 %arg7922, i64 %a7016) 
  store volatile i64 %retprim7189, i64* %vptr19962, align 8 ; call prim_vector_45set_33
  %vptr19971 = alloca i64*, align 8 
  %cloptr19963 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr19963, i64** %vptr19971, align 8 ; malloc
  %vptr19972 = alloca i64*, align 8 
  %eptr19965 = getelementptr inbounds i64, i64* %cloptr19963, i64 2 
  store volatile i64* %eptr19965, i64** %vptr19972, align 8 ; &eptr19965[1]
  %vptr19973 = alloca i64*, align 8 
  %eptr19966 = getelementptr inbounds i64, i64* %cloptr19963, i64 3 
  store volatile i64* %eptr19966, i64** %vptr19973, align 8 ; &eptr19966[2]
  %vptr19974 = alloca i64*, align 8 
  %eptr19967 = getelementptr inbounds i64, i64* %cloptr19963, i64 4 
  store volatile i64* %eptr19967, i64** %vptr19974, align 8 ; &eptr19967[3]
  %vptr19975 = alloca i64*, align 8 
  %eptr19968 = getelementptr inbounds i64, i64* %cloptr19963, i64 5 
  store volatile i64* %eptr19968, i64** %vptr19975, align 8 ; &eptr19968[4]
  %vptr19976 = alloca i64*, align 8 
  %eptr19969 = getelementptr inbounds i64, i64* %cloptr19963, i64 6 
  store volatile i64* %eptr19969, i64** %vptr19976, align 8 ; &eptr19969[5]
  store i64 %qBb$l, i64* %eptr19965                                                  ; *eptr19965 = %qBb$l
  store i64 %emsg18637, i64* %eptr19966                                              ; *eptr19966 = %emsg18637
  store i64 %emsg08636, i64* %eptr19967                                              ; *eptr19967 = %emsg08636
  store i64 %zfY$f, i64* %eptr19968                                                  ; *eptr19968 = %zfY$f
  store i64 %cont7186, i64* %eptr19969                                               ; *eptr19969 = %cont7186
  %vptr19977 = alloca i64*, align 8 
  %eptr19964 = getelementptr inbounds i64, i64* %cloptr19963, i64 1 
  store volatile i64* %eptr19964, i64** %vptr19977, align 8 ; &cloptr19963[1]
 %vptr19978 = alloca i64, align 8 
  %f19970 = ptrtoint void(i64,i64)* @lam12059 to i64 
  store volatile i64 %f19970, i64* %vptr19978, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f19970, i64* %eptr19964                                                 ; store fptr
 %vptr19979 = alloca i64, align 8 
  %arg7926 = ptrtoint i64* %cloptr19963 to i64 
  store volatile i64 %arg7926, i64* %vptr19979, align 8 ; closure cast; i64* -> i64
 %vptr19980 = alloca i64, align 8 
  %arg7925 = add i64 0, 0 
  store volatile i64 %arg7925, i64* %vptr19980, align 8 ; quoted ()
 %vptr19981 = alloca i64, align 8 
  %rva9632 = add i64 0, 0 
  store volatile i64 %rva9632, i64* %vptr19981, align 8 ; quoted ()
 %vptr19982 = alloca i64, align 8 
  %rva9631 = call i64 @prim_cons(i64 %retprim7189, i64 %rva9632) 
  store volatile i64 %rva9631, i64* %vptr19982, align 8 ; call prim_cons
 %vptr19983 = alloca i64, align 8 
  %rva9630 = call i64 @prim_cons(i64 %arg7925, i64 %rva9631) 
  store volatile i64 %rva9630, i64* %vptr19983, align 8 ; call prim_cons
  %vptr19989 = alloca i64*, align 8 
  %cloptr19984 = inttoptr i64 %arg7926 to i64* 
  store volatile i64* %cloptr19984, i64** %vptr19989, align 8 ; closure/env cast; i64 -> i64*
  %vptr19990 = alloca i64*, align 8 
  %i0ptr19985 = getelementptr inbounds i64, i64* %cloptr19984, i64 1 
  store volatile i64* %i0ptr19985, i64** %vptr19990, align 8 ; &cloptr19984[1]
 %vptr19991 = alloca i64, align 8 
  %f19987 = load i64, i64* %i0ptr19985, align 8 
  store volatile i64 %f19987, i64* %vptr19991, align 8 ; load; *i0ptr19985
  %fptr19986 = inttoptr i64 %f19987 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19986(i64 %arg7926, i64 %rva9630)                   ; tail call
  ret void

else19958:
 %vptr19992 = alloca i64, align 8 
  %retprim7190 = call i64 @prim_void() 
  store volatile i64 %retprim7190, i64* %vptr19992, align 8 ; call prim_void
 %vptr19993 = alloca i64, align 8 
  %arg7938 = add i64 0, 0 
  store volatile i64 %arg7938, i64* %vptr19993, align 8 ; quoted ()
 %vptr19994 = alloca i64, align 8 
  %rva9635 = add i64 0, 0 
  store volatile i64 %rva9635, i64* %vptr19994, align 8 ; quoted ()
 %vptr19995 = alloca i64, align 8 
  %rva9634 = call i64 @prim_cons(i64 %retprim7190, i64 %rva9635) 
  store volatile i64 %rva9634, i64* %vptr19995, align 8 ; call prim_cons
 %vptr19996 = alloca i64, align 8 
  %rva9633 = call i64 @prim_cons(i64 %arg7938, i64 %rva9634) 
  store volatile i64 %rva9633, i64* %vptr19996, align 8 ; call prim_cons
  %vptr20002 = alloca i64*, align 8 
  %cloptr19997 = inttoptr i64 %cont7186 to i64* 
  store volatile i64* %cloptr19997, i64** %vptr20002, align 8 ; closure/env cast; i64 -> i64*
  %vptr20003 = alloca i64*, align 8 
  %i0ptr19998 = getelementptr inbounds i64, i64* %cloptr19997, i64 1 
  store volatile i64* %i0ptr19998, i64** %vptr20003, align 8 ; &cloptr19997[1]
 %vptr20004 = alloca i64, align 8 
  %f20000 = load i64, i64* %i0ptr19998, align 8 
  store volatile i64 %f20000, i64* %vptr20004, align 8 ; load; *i0ptr19998
  %fptr19999 = inttoptr i64 %f20000 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr19999(i64 %cont7186, i64 %rva9633)                  ; tail call
  ret void

else19952:
 %vptr20005 = alloca i64, align 8 
  %h9638 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9638, i64* %vptr20005, align 8 ; call prim_halt
  %vptr20011 = alloca i64*, align 8 
  %cloptr20006 = inttoptr i64 %h9638 to i64* 
  store volatile i64* %cloptr20006, i64** %vptr20011, align 8 ; closure/env cast; i64 -> i64*
  %vptr20012 = alloca i64*, align 8 
  %i0ptr20007 = getelementptr inbounds i64, i64* %cloptr20006, i64 1 
  store volatile i64* %i0ptr20007, i64** %vptr20012, align 8 ; &cloptr20006[1]
 %vptr20013 = alloca i64, align 8 
  %f20009 = load i64, i64* %i0ptr20007, align 8 
  store volatile i64 %f20009, i64* %vptr20013, align 8 ; load; *i0ptr20007
  %fptr20008 = inttoptr i64 %f20009 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20008(i64 %h9638, i64 %h9638)                       ; tail call
  ret void
}


define void @lam12059(i64 %env12060, i64 %rvp9626) {
 %vptr20016 = alloca i64, align 8 
  %envptr20014 = inttoptr i64 %env12060 to i64* 
  store volatile i64 %cont7186, i64* %vptr20016, align 8 ; closure/env cast; i64 -> i64*
  %vptr20017 = alloca i64*, align 8 
  %envptr20015 = getelementptr inbounds i64, i64* %envptr20014, i64 6 
  store volatile i64* %envptr20015, i64** %vptr20017, align 8 ; &envptr20014[5]
 %vptr20018 = alloca i64, align 8 
  %cont7186 = load i64, i64* %envptr20015, align 8 
  store volatile i64 %cont7186, i64* %vptr20018, align 8 ; load; *envptr20015
 %vptr20021 = alloca i64, align 8 
  %envptr20019 = inttoptr i64 %env12060 to i64* 
  store volatile i64 %zfY$f, i64* %vptr20021, align 8 ; closure/env cast; i64 -> i64*
  %vptr20022 = alloca i64*, align 8 
  %envptr20020 = getelementptr inbounds i64, i64* %envptr20019, i64 5 
  store volatile i64* %envptr20020, i64** %vptr20022, align 8 ; &envptr20019[4]
 %vptr20023 = alloca i64, align 8 
  %zfY$f = load i64, i64* %envptr20020, align 8 
  store volatile i64 %zfY$f, i64* %vptr20023, align 8 ; load; *envptr20020
 %vptr20026 = alloca i64, align 8 
  %envptr20024 = inttoptr i64 %env12060 to i64* 
  store volatile i64 %emsg08636, i64* %vptr20026, align 8 ; closure/env cast; i64 -> i64*
  %vptr20027 = alloca i64*, align 8 
  %envptr20025 = getelementptr inbounds i64, i64* %envptr20024, i64 4 
  store volatile i64* %envptr20025, i64** %vptr20027, align 8 ; &envptr20024[3]
 %vptr20028 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr20025, align 8 
  store volatile i64 %emsg08636, i64* %vptr20028, align 8 ; load; *envptr20025
 %vptr20031 = alloca i64, align 8 
  %envptr20029 = inttoptr i64 %env12060 to i64* 
  store volatile i64 %emsg18637, i64* %vptr20031, align 8 ; closure/env cast; i64 -> i64*
  %vptr20032 = alloca i64*, align 8 
  %envptr20030 = getelementptr inbounds i64, i64* %envptr20029, i64 3 
  store volatile i64* %envptr20030, i64** %vptr20032, align 8 ; &envptr20029[2]
 %vptr20033 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr20030, align 8 
  store volatile i64 %emsg18637, i64* %vptr20033, align 8 ; load; *envptr20030
 %vptr20036 = alloca i64, align 8 
  %envptr20034 = inttoptr i64 %env12060 to i64* 
  store volatile i64 %qBb$l, i64* %vptr20036, align 8 ; closure/env cast; i64 -> i64*
  %vptr20037 = alloca i64*, align 8 
  %envptr20035 = getelementptr inbounds i64, i64* %envptr20034, i64 2 
  store volatile i64* %envptr20035, i64** %vptr20037, align 8 ; &envptr20034[1]
 %vptr20038 = alloca i64, align 8 
  %qBb$l = load i64, i64* %envptr20035, align 8 
  store volatile i64 %qBb$l, i64* %vptr20038, align 8 ; load; *envptr20035
 %vptr20039 = alloca i64, align 8 
  %_957187 = call i64 @prim_car(i64 %rvp9626) 
  store volatile i64 %_957187, i64* %vptr20039, align 8 ; call prim_car
 %vptr20040 = alloca i64, align 8 
  %rvp9622 = call i64 @prim_cdr(i64 %rvp9626) 
  store volatile i64 %rvp9622, i64* %vptr20040, align 8 ; call prim_cdr
 %vptr20041 = alloca i64, align 8 
  %n_639627 = call i64 @prim_null_63(i64 %rvp9622) 
  store volatile i64 %n_639627, i64* %vptr20041, align 8 ; call prim_null_63
  %cmpptr20045 = alloca i1, align 8  %cmp20042 = icmp eq i64 %n_639627, 15 store volatile i1 %cmp20042, i1* %cmpptr20045, align 8; false?
  br i1 %cmp20042, label %else20044, label %then20043                                ; if

then20043:
 %vptr20046 = alloca i64, align 8 
  %h9628 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9628, i64* %vptr20046, align 8 ; call prim_halt
  %vptr20052 = alloca i64*, align 8 
  %cloptr20047 = inttoptr i64 %h9628 to i64* 
  store volatile i64* %cloptr20047, i64** %vptr20052, align 8 ; closure/env cast; i64 -> i64*
  %vptr20053 = alloca i64*, align 8 
  %i0ptr20048 = getelementptr inbounds i64, i64* %cloptr20047, i64 1 
  store volatile i64* %i0ptr20048, i64** %vptr20053, align 8 ; &cloptr20047[1]
 %vptr20054 = alloca i64, align 8 
  %f20050 = load i64, i64* %i0ptr20048, align 8 
  store volatile i64 %f20050, i64* %vptr20054, align 8 ; load; *i0ptr20048
  %fptr20049 = inttoptr i64 %f20050 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20049(i64 %h9628, i64 %h9628)                       ; tail call
  ret void

else20044:
 %vptr20055 = alloca i64, align 8 
  %j86$_956886 = call i64 @prim_car(i64 %rvp9622) 
  store volatile i64 %j86$_956886, i64* %vptr20055, align 8 ; call prim_car
 %vptr20056 = alloca i64, align 8 
  %na9606 = call i64 @prim_cdr(i64 %rvp9622) 
  store volatile i64 %na9606, i64* %vptr20056, align 8 ; call prim_cdr
 %vptr20057 = alloca i64, align 8 
  %n_639623 = call i64 @prim_null_63(i64 %na9606) 
  store volatile i64 %n_639623, i64* %vptr20057, align 8 ; call prim_null_63
  %cmpptr20061 = alloca i1, align 8  %cmp20058 = icmp eq i64 %n_639623, 15 store volatile i1 %cmp20058, i1* %cmpptr20061, align 8; false?
  br i1 %cmp20058, label %else20060, label %then20059                                ; if

then20059:
 %vptr20062 = alloca i64, align 8 
  %a7017 = call i64 @prim_car(i64 %qBb$l) 
  store volatile i64 %a7017, i64* %vptr20062, align 8 ; call prim_car
 %vptr20063 = alloca i64, align 8 
  %a7018 = call i64 @prim_cdr(i64 %a7017) 
  store volatile i64 %a7018, i64* %vptr20063, align 8 ; call prim_cdr
  %vptr20072 = alloca i64*, align 8 
  %cloptr20064 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr20064, i64** %vptr20072, align 8 ; malloc
  %vptr20073 = alloca i64*, align 8 
  %eptr20066 = getelementptr inbounds i64, i64* %cloptr20064, i64 2 
  store volatile i64* %eptr20066, i64** %vptr20073, align 8 ; &eptr20066[1]
  %vptr20074 = alloca i64*, align 8 
  %eptr20067 = getelementptr inbounds i64, i64* %cloptr20064, i64 3 
  store volatile i64* %eptr20067, i64** %vptr20074, align 8 ; &eptr20067[2]
  %vptr20075 = alloca i64*, align 8 
  %eptr20068 = getelementptr inbounds i64, i64* %cloptr20064, i64 4 
  store volatile i64* %eptr20068, i64** %vptr20075, align 8 ; &eptr20068[3]
  %vptr20076 = alloca i64*, align 8 
  %eptr20069 = getelementptr inbounds i64, i64* %cloptr20064, i64 5 
  store volatile i64* %eptr20069, i64** %vptr20076, align 8 ; &eptr20069[4]
  %vptr20077 = alloca i64*, align 8 
  %eptr20070 = getelementptr inbounds i64, i64* %cloptr20064, i64 6 
  store volatile i64* %eptr20070, i64** %vptr20077, align 8 ; &eptr20070[5]
  store i64 %qBb$l, i64* %eptr20066                                                  ; *eptr20066 = %qBb$l
  store i64 %emsg18637, i64* %eptr20067                                              ; *eptr20067 = %emsg18637
  store i64 %emsg08636, i64* %eptr20068                                              ; *eptr20068 = %emsg08636
  store i64 %zfY$f, i64* %eptr20069                                                  ; *eptr20069 = %zfY$f
  store i64 %cont7186, i64* %eptr20070                                               ; *eptr20070 = %cont7186
  %vptr20078 = alloca i64*, align 8 
  %eptr20065 = getelementptr inbounds i64, i64* %cloptr20064, i64 1 
  store volatile i64* %eptr20065, i64** %vptr20078, align 8 ; &cloptr20064[1]
 %vptr20079 = alloca i64, align 8 
  %f20071 = ptrtoint void(i64,i64)* @lam12057 to i64 
  store volatile i64 %f20071, i64* %vptr20079, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f20071, i64* %eptr20065                                                 ; store fptr
 %vptr20080 = alloca i64, align 8 
  %arg7929 = ptrtoint i64* %cloptr20064 to i64 
  store volatile i64 %arg7929, i64* %vptr20080, align 8 ; closure cast; i64* -> i64
 %vptr20081 = alloca i64, align 8 
  %rva9621 = add i64 0, 0 
  store volatile i64 %rva9621, i64* %vptr20081, align 8 ; quoted ()
 %vptr20082 = alloca i64, align 8 
  %rva9620 = call i64 @prim_cons(i64 %arg7929, i64 %rva9621) 
  store volatile i64 %rva9620, i64* %vptr20082, align 8 ; call prim_cons
  %vptr20088 = alloca i64*, align 8 
  %cloptr20083 = inttoptr i64 %a7018 to i64* 
  store volatile i64* %cloptr20083, i64** %vptr20088, align 8 ; closure/env cast; i64 -> i64*
  %vptr20089 = alloca i64*, align 8 
  %i0ptr20084 = getelementptr inbounds i64, i64* %cloptr20083, i64 1 
  store volatile i64* %i0ptr20084, i64** %vptr20089, align 8 ; &cloptr20083[1]
 %vptr20090 = alloca i64, align 8 
  %f20086 = load i64, i64* %i0ptr20084, align 8 
  store volatile i64 %f20086, i64* %vptr20090, align 8 ; load; *i0ptr20084
  %fptr20085 = inttoptr i64 %f20086 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20085(i64 %a7018, i64 %rva9620)                     ; tail call
  ret void

else20060:
 %vptr20091 = alloca i64, align 8 
  %h9624 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9624, i64* %vptr20091, align 8 ; call prim_halt
  %vptr20097 = alloca i64*, align 8 
  %cloptr20092 = inttoptr i64 %h9624 to i64* 
  store volatile i64* %cloptr20092, i64** %vptr20097, align 8 ; closure/env cast; i64 -> i64*
  %vptr20098 = alloca i64*, align 8 
  %i0ptr20093 = getelementptr inbounds i64, i64* %cloptr20092, i64 1 
  store volatile i64* %i0ptr20093, i64** %vptr20098, align 8 ; &cloptr20092[1]
 %vptr20099 = alloca i64, align 8 
  %f20095 = load i64, i64* %i0ptr20093, align 8 
  store volatile i64 %f20095, i64* %vptr20099, align 8 ; load; *i0ptr20093
  %fptr20094 = inttoptr i64 %f20095 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20094(i64 %h9624, i64 %h9624)                       ; tail call
  ret void
}


define void @lam12057(i64 %env12058, i64 %rvp9616) {
 %vptr20102 = alloca i64, align 8 
  %envptr20100 = inttoptr i64 %env12058 to i64* 
  store volatile i64 %cont7186, i64* %vptr20102, align 8 ; closure/env cast; i64 -> i64*
  %vptr20103 = alloca i64*, align 8 
  %envptr20101 = getelementptr inbounds i64, i64* %envptr20100, i64 6 
  store volatile i64* %envptr20101, i64** %vptr20103, align 8 ; &envptr20100[5]
 %vptr20104 = alloca i64, align 8 
  %cont7186 = load i64, i64* %envptr20101, align 8 
  store volatile i64 %cont7186, i64* %vptr20104, align 8 ; load; *envptr20101
 %vptr20107 = alloca i64, align 8 
  %envptr20105 = inttoptr i64 %env12058 to i64* 
  store volatile i64 %zfY$f, i64* %vptr20107, align 8 ; closure/env cast; i64 -> i64*
  %vptr20108 = alloca i64*, align 8 
  %envptr20106 = getelementptr inbounds i64, i64* %envptr20105, i64 5 
  store volatile i64* %envptr20106, i64** %vptr20108, align 8 ; &envptr20105[4]
 %vptr20109 = alloca i64, align 8 
  %zfY$f = load i64, i64* %envptr20106, align 8 
  store volatile i64 %zfY$f, i64* %vptr20109, align 8 ; load; *envptr20106
 %vptr20112 = alloca i64, align 8 
  %envptr20110 = inttoptr i64 %env12058 to i64* 
  store volatile i64 %emsg08636, i64* %vptr20112, align 8 ; closure/env cast; i64 -> i64*
  %vptr20113 = alloca i64*, align 8 
  %envptr20111 = getelementptr inbounds i64, i64* %envptr20110, i64 4 
  store volatile i64* %envptr20111, i64** %vptr20113, align 8 ; &envptr20110[3]
 %vptr20114 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr20111, align 8 
  store volatile i64 %emsg08636, i64* %vptr20114, align 8 ; load; *envptr20111
 %vptr20117 = alloca i64, align 8 
  %envptr20115 = inttoptr i64 %env12058 to i64* 
  store volatile i64 %emsg18637, i64* %vptr20117, align 8 ; closure/env cast; i64 -> i64*
  %vptr20118 = alloca i64*, align 8 
  %envptr20116 = getelementptr inbounds i64, i64* %envptr20115, i64 3 
  store volatile i64* %envptr20116, i64** %vptr20118, align 8 ; &envptr20115[2]
 %vptr20119 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr20116, align 8 
  store volatile i64 %emsg18637, i64* %vptr20119, align 8 ; load; *envptr20116
 %vptr20122 = alloca i64, align 8 
  %envptr20120 = inttoptr i64 %env12058 to i64* 
  store volatile i64 %qBb$l, i64* %vptr20122, align 8 ; closure/env cast; i64 -> i64*
  %vptr20123 = alloca i64*, align 8 
  %envptr20121 = getelementptr inbounds i64, i64* %envptr20120, i64 2 
  store volatile i64* %envptr20121, i64** %vptr20123, align 8 ; &envptr20120[1]
 %vptr20124 = alloca i64, align 8 
  %qBb$l = load i64, i64* %envptr20121, align 8 
  store volatile i64 %qBb$l, i64* %vptr20124, align 8 ; load; *envptr20121
 %vptr20125 = alloca i64, align 8 
  %_957188 = call i64 @prim_car(i64 %rvp9616) 
  store volatile i64 %_957188, i64* %vptr20125, align 8 ; call prim_car
 %vptr20126 = alloca i64, align 8 
  %rvp9612 = call i64 @prim_cdr(i64 %rvp9616) 
  store volatile i64 %rvp9612, i64* %vptr20126, align 8 ; call prim_cdr
 %vptr20127 = alloca i64, align 8 
  %n_639617 = call i64 @prim_null_63(i64 %rvp9612) 
  store volatile i64 %n_639617, i64* %vptr20127, align 8 ; call prim_null_63
  %cmpptr20131 = alloca i1, align 8  %cmp20128 = icmp eq i64 %n_639617, 15 store volatile i1 %cmp20128, i1* %cmpptr20131, align 8; false?
  br i1 %cmp20128, label %else20130, label %then20129                                ; if

then20129:
 %vptr20132 = alloca i64, align 8 
  %h9618 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9618, i64* %vptr20132, align 8 ; call prim_halt
  %vptr20138 = alloca i64*, align 8 
  %cloptr20133 = inttoptr i64 %h9618 to i64* 
  store volatile i64* %cloptr20133, i64** %vptr20138, align 8 ; closure/env cast; i64 -> i64*
  %vptr20139 = alloca i64*, align 8 
  %i0ptr20134 = getelementptr inbounds i64, i64* %cloptr20133, i64 1 
  store volatile i64* %i0ptr20134, i64** %vptr20139, align 8 ; &cloptr20133[1]
 %vptr20140 = alloca i64, align 8 
  %f20136 = load i64, i64* %i0ptr20134, align 8 
  store volatile i64 %f20136, i64* %vptr20140, align 8 ; load; *i0ptr20134
  %fptr20135 = inttoptr i64 %f20136 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20135(i64 %h9618, i64 %h9618)                       ; tail call
  ret void

else20130:
 %vptr20141 = alloca i64, align 8 
  %Mz3$_956887 = call i64 @prim_car(i64 %rvp9612) 
  store volatile i64 %Mz3$_956887, i64* %vptr20141, align 8 ; call prim_car
 %vptr20142 = alloca i64, align 8 
  %na9608 = call i64 @prim_cdr(i64 %rvp9612) 
  store volatile i64 %na9608, i64* %vptr20142, align 8 ; call prim_cdr
 %vptr20143 = alloca i64, align 8 
  %n_639613 = call i64 @prim_null_63(i64 %na9608) 
  store volatile i64 %n_639613, i64* %vptr20143, align 8 ; call prim_null_63
  %cmpptr20147 = alloca i1, align 8  %cmp20144 = icmp eq i64 %n_639613, 15 store volatile i1 %cmp20144, i1* %cmpptr20147, align 8; false?
  br i1 %cmp20144, label %else20146, label %then20145                                ; if

then20145:
 %vptr20148 = alloca i64, align 8 
  %arg7931 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7931, i64* %vptr20148, align 8 ; quoted int
 %vptr20149 = alloca i64, align 8 
  %a7019 = call i64 @prim_vector_45ref(i64 %zfY$f, i64 %arg7931) 
  store volatile i64 %a7019, i64* %vptr20149, align 8 ; call prim_vector_45ref
 %vptr20150 = alloca i64, align 8 
  %a7020 = call i64 @prim_cdr(i64 %qBb$l) 
  store volatile i64 %a7020, i64* %vptr20150, align 8 ; call prim_cdr
 %vptr20151 = alloca i64, align 8 
  %rva9611 = add i64 0, 0 
  store volatile i64 %rva9611, i64* %vptr20151, align 8 ; quoted ()
 %vptr20152 = alloca i64, align 8 
  %rva9610 = call i64 @prim_cons(i64 %a7020, i64 %rva9611) 
  store volatile i64 %rva9610, i64* %vptr20152, align 8 ; call prim_cons
 %vptr20153 = alloca i64, align 8 
  %rva9609 = call i64 @prim_cons(i64 %cont7186, i64 %rva9610) 
  store volatile i64 %rva9609, i64* %vptr20153, align 8 ; call prim_cons
  %vptr20159 = alloca i64*, align 8 
  %cloptr20154 = inttoptr i64 %a7019 to i64* 
  store volatile i64* %cloptr20154, i64** %vptr20159, align 8 ; closure/env cast; i64 -> i64*
  %vptr20160 = alloca i64*, align 8 
  %i0ptr20155 = getelementptr inbounds i64, i64* %cloptr20154, i64 1 
  store volatile i64* %i0ptr20155, i64** %vptr20160, align 8 ; &cloptr20154[1]
 %vptr20161 = alloca i64, align 8 
  %f20157 = load i64, i64* %i0ptr20155, align 8 
  store volatile i64 %f20157, i64* %vptr20161, align 8 ; load; *i0ptr20155
  %fptr20156 = inttoptr i64 %f20157 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20156(i64 %a7019, i64 %rva9609)                     ; tail call
  ret void

else20146:
 %vptr20162 = alloca i64, align 8 
  %h9614 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9614, i64* %vptr20162, align 8 ; call prim_halt
  %vptr20168 = alloca i64*, align 8 
  %cloptr20163 = inttoptr i64 %h9614 to i64* 
  store volatile i64* %cloptr20163, i64** %vptr20168, align 8 ; closure/env cast; i64 -> i64*
  %vptr20169 = alloca i64*, align 8 
  %i0ptr20164 = getelementptr inbounds i64, i64* %cloptr20163, i64 1 
  store volatile i64* %i0ptr20164, i64** %vptr20169, align 8 ; &cloptr20163[1]
 %vptr20170 = alloca i64, align 8 
  %f20166 = load i64, i64* %i0ptr20164, align 8 
  store volatile i64 %f20166, i64* %vptr20170, align 8 ; load; *i0ptr20164
  %fptr20165 = inttoptr i64 %f20166 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20165(i64 %h9614, i64 %h9614)                       ; tail call
  ret void
}


define void @lam12048(i64 %env12049, i64 %rvp9722) {
 %vptr20173 = alloca i64, align 8 
  %envptr20171 = inttoptr i64 %env12049 to i64* 
  store volatile i64 %emsg08636, i64* %vptr20173, align 8 ; closure/env cast; i64 -> i64*
  %vptr20174 = alloca i64*, align 8 
  %envptr20172 = getelementptr inbounds i64, i64* %envptr20171, i64 7 
  store volatile i64* %envptr20172, i64** %vptr20174, align 8 ; &envptr20171[6]
 %vptr20175 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr20172, align 8 
  store volatile i64 %emsg08636, i64* %vptr20175, align 8 ; load; *envptr20172
 %vptr20178 = alloca i64, align 8 
  %envptr20176 = inttoptr i64 %env12049 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr20178, align 8 ; closure/env cast; i64 -> i64*
  %vptr20179 = alloca i64*, align 8 
  %envptr20177 = getelementptr inbounds i64, i64* %envptr20176, i64 6 
  store volatile i64* %envptr20177, i64** %vptr20179, align 8 ; &envptr20176[5]
 %vptr20180 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr20177, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr20180, align 8 ; load; *envptr20177
 %vptr20183 = alloca i64, align 8 
  %envptr20181 = inttoptr i64 %env12049 to i64* 
  store volatile i64 %Qmo$new, i64* %vptr20183, align 8 ; closure/env cast; i64 -> i64*
  %vptr20184 = alloca i64*, align 8 
  %envptr20182 = getelementptr inbounds i64, i64* %envptr20181, i64 5 
  store volatile i64* %envptr20182, i64** %vptr20184, align 8 ; &envptr20181[4]
 %vptr20185 = alloca i64, align 8 
  %Qmo$new = load i64, i64* %envptr20182, align 8 
  store volatile i64 %Qmo$new, i64* %vptr20185, align 8 ; load; *envptr20182
 %vptr20188 = alloca i64, align 8 
  %envptr20186 = inttoptr i64 %env12049 to i64* 
  store volatile i64 %cont7172, i64* %vptr20188, align 8 ; closure/env cast; i64 -> i64*
  %vptr20189 = alloca i64*, align 8 
  %envptr20187 = getelementptr inbounds i64, i64* %envptr20186, i64 4 
  store volatile i64* %envptr20187, i64** %vptr20189, align 8 ; &envptr20186[3]
 %vptr20190 = alloca i64, align 8 
  %cont7172 = load i64, i64* %envptr20187, align 8 
  store volatile i64 %cont7172, i64* %vptr20190, align 8 ; load; *envptr20187
 %vptr20193 = alloca i64, align 8 
  %envptr20191 = inttoptr i64 %env12049 to i64* 
  store volatile i64 %emsg18637, i64* %vptr20193, align 8 ; closure/env cast; i64 -> i64*
  %vptr20194 = alloca i64*, align 8 
  %envptr20192 = getelementptr inbounds i64, i64* %envptr20191, i64 3 
  store volatile i64* %envptr20192, i64** %vptr20194, align 8 ; &envptr20191[2]
 %vptr20195 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr20192, align 8 
  store volatile i64 %emsg18637, i64* %vptr20195, align 8 ; load; *envptr20192
 %vptr20198 = alloca i64, align 8 
  %envptr20196 = inttoptr i64 %env12049 to i64* 
  store volatile i64 %Fki$tail, i64* %vptr20198, align 8 ; closure/env cast; i64 -> i64*
  %vptr20199 = alloca i64*, align 8 
  %envptr20197 = getelementptr inbounds i64, i64* %envptr20196, i64 2 
  store volatile i64* %envptr20197, i64** %vptr20199, align 8 ; &envptr20196[1]
 %vptr20200 = alloca i64, align 8 
  %Fki$tail = load i64, i64* %envptr20197, align 8 
  store volatile i64 %Fki$tail, i64* %vptr20200, align 8 ; load; *envptr20197
 %vptr20201 = alloca i64, align 8 
  %_957174 = call i64 @prim_car(i64 %rvp9722) 
  store volatile i64 %_957174, i64* %vptr20201, align 8 ; call prim_car
 %vptr20202 = alloca i64, align 8 
  %rvp9718 = call i64 @prim_cdr(i64 %rvp9722) 
  store volatile i64 %rvp9718, i64* %vptr20202, align 8 ; call prim_cdr
 %vptr20203 = alloca i64, align 8 
  %n_639723 = call i64 @prim_null_63(i64 %rvp9718) 
  store volatile i64 %n_639723, i64* %vptr20203, align 8 ; call prim_null_63
  %cmpptr20207 = alloca i1, align 8  %cmp20204 = icmp eq i64 %n_639723, 15 store volatile i1 %cmp20204, i1* %cmpptr20207, align 8; false?
  br i1 %cmp20204, label %else20206, label %then20205                                ; if

then20205:
 %vptr20208 = alloca i64, align 8 
  %h9724 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9724, i64* %vptr20208, align 8 ; call prim_halt
  %vptr20214 = alloca i64*, align 8 
  %cloptr20209 = inttoptr i64 %h9724 to i64* 
  store volatile i64* %cloptr20209, i64** %vptr20214, align 8 ; closure/env cast; i64 -> i64*
  %vptr20215 = alloca i64*, align 8 
  %i0ptr20210 = getelementptr inbounds i64, i64* %cloptr20209, i64 1 
  store volatile i64* %i0ptr20210, i64** %vptr20215, align 8 ; &cloptr20209[1]
 %vptr20216 = alloca i64, align 8 
  %f20212 = load i64, i64* %i0ptr20210, align 8 
  store volatile i64 %f20212, i64* %vptr20216, align 8 ; load; *i0ptr20210
  %fptr20211 = inttoptr i64 %f20212 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20211(i64 %h9724, i64 %h9724)                       ; tail call
  ret void

else20206:
 %vptr20217 = alloca i64, align 8 
  %Lhx$_956884 = call i64 @prim_car(i64 %rvp9718) 
  store volatile i64 %Lhx$_956884, i64* %vptr20217, align 8 ; call prim_car
 %vptr20218 = alloca i64, align 8 
  %na9645 = call i64 @prim_cdr(i64 %rvp9718) 
  store volatile i64 %na9645, i64* %vptr20218, align 8 ; call prim_cdr
 %vptr20219 = alloca i64, align 8 
  %n_639719 = call i64 @prim_null_63(i64 %na9645) 
  store volatile i64 %n_639719, i64* %vptr20219, align 8 ; call prim_null_63
  %cmpptr20223 = alloca i1, align 8  %cmp20220 = icmp eq i64 %n_639719, 15 store volatile i1 %cmp20220, i1* %cmpptr20223, align 8; false?
  br i1 %cmp20220, label %else20222, label %then20221                                ; if

then20221:
  %vptr20227 = alloca i64*, align 8 
  %cloptr20224 = call i64* @make_closure(i64 8) 
  store volatile i64* %cloptr20224, i64** %vptr20227, align 8 ; malloc
  %vptr20228 = alloca i64*, align 8 
  %eptr20225 = getelementptr inbounds i64, i64* %cloptr20224, i64 1 
  store volatile i64* %eptr20225, i64** %vptr20228, align 8 ; &cloptr20224[1]
 %vptr20229 = alloca i64, align 8 
  %f20226 = ptrtoint void(i64,i64)* @lam12046 to i64 
  store volatile i64 %f20226, i64* %vptr20229, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f20226, i64* %eptr20225                                                 ; store fptr
 %vptr20230 = alloca i64, align 8 
  %arg7948 = ptrtoint i64* %cloptr20224 to i64 
  store volatile i64 %arg7948, i64* %vptr20230, align 8 ; closure cast; i64* -> i64
  %vptr20240 = alloca i64*, align 8 
  %cloptr20231 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr20231, i64** %vptr20240, align 8 ; malloc
  %vptr20241 = alloca i64*, align 8 
  %eptr20233 = getelementptr inbounds i64, i64* %cloptr20231, i64 2 
  store volatile i64* %eptr20233, i64** %vptr20241, align 8 ; &eptr20233[1]
  %vptr20242 = alloca i64*, align 8 
  %eptr20234 = getelementptr inbounds i64, i64* %cloptr20231, i64 3 
  store volatile i64* %eptr20234, i64** %vptr20242, align 8 ; &eptr20234[2]
  %vptr20243 = alloca i64*, align 8 
  %eptr20235 = getelementptr inbounds i64, i64* %cloptr20231, i64 4 
  store volatile i64* %eptr20235, i64** %vptr20243, align 8 ; &eptr20235[3]
  %vptr20244 = alloca i64*, align 8 
  %eptr20236 = getelementptr inbounds i64, i64* %cloptr20231, i64 5 
  store volatile i64* %eptr20236, i64** %vptr20244, align 8 ; &eptr20236[4]
  %vptr20245 = alloca i64*, align 8 
  %eptr20237 = getelementptr inbounds i64, i64* %cloptr20231, i64 6 
  store volatile i64* %eptr20237, i64** %vptr20245, align 8 ; &eptr20237[5]
  %vptr20246 = alloca i64*, align 8 
  %eptr20238 = getelementptr inbounds i64, i64* %cloptr20231, i64 7 
  store volatile i64* %eptr20238, i64** %vptr20246, align 8 ; &eptr20238[6]
  store i64 %Fki$tail, i64* %eptr20233                                               ; *eptr20233 = %Fki$tail
  store i64 %emsg18637, i64* %eptr20234                                              ; *eptr20234 = %emsg18637
  store i64 %cont7172, i64* %eptr20235                                               ; *eptr20235 = %cont7172
  store i64 %Qmo$new, i64* %eptr20236                                                ; *eptr20236 = %Qmo$new
  store i64 %SdC$_37wind_45stack, i64* %eptr20237                                    ; *eptr20237 = %SdC$_37wind_45stack
  store i64 %emsg08636, i64* %eptr20238                                              ; *eptr20238 = %emsg08636
  %vptr20247 = alloca i64*, align 8 
  %eptr20232 = getelementptr inbounds i64, i64* %cloptr20231, i64 1 
  store volatile i64* %eptr20232, i64** %vptr20247, align 8 ; &cloptr20231[1]
 %vptr20248 = alloca i64, align 8 
  %f20239 = ptrtoint void(i64,i64)* @lam12042 to i64 
  store volatile i64 %f20239, i64* %vptr20248, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f20239, i64* %eptr20232                                                 ; store fptr
 %vptr20249 = alloca i64, align 8 
  %arg7947 = ptrtoint i64* %cloptr20231 to i64 
  store volatile i64 %arg7947, i64* %vptr20249, align 8 ; closure cast; i64* -> i64
 %vptr20250 = alloca i64, align 8 
  %rva9717 = add i64 0, 0 
  store volatile i64 %rva9717, i64* %vptr20250, align 8 ; quoted ()
 %vptr20251 = alloca i64, align 8 
  %rva9716 = call i64 @prim_cons(i64 %arg7947, i64 %rva9717) 
  store volatile i64 %rva9716, i64* %vptr20251, align 8 ; call prim_cons
  %vptr20257 = alloca i64*, align 8 
  %cloptr20252 = inttoptr i64 %arg7948 to i64* 
  store volatile i64* %cloptr20252, i64** %vptr20257, align 8 ; closure/env cast; i64 -> i64*
  %vptr20258 = alloca i64*, align 8 
  %i0ptr20253 = getelementptr inbounds i64, i64* %cloptr20252, i64 1 
  store volatile i64* %i0ptr20253, i64** %vptr20258, align 8 ; &cloptr20252[1]
 %vptr20259 = alloca i64, align 8 
  %f20255 = load i64, i64* %i0ptr20253, align 8 
  store volatile i64 %f20255, i64* %vptr20259, align 8 ; load; *i0ptr20253
  %fptr20254 = inttoptr i64 %f20255 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20254(i64 %arg7948, i64 %rva9716)                   ; tail call
  ret void

else20222:
 %vptr20260 = alloca i64, align 8 
  %h9720 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9720, i64* %vptr20260, align 8 ; call prim_halt
  %vptr20266 = alloca i64*, align 8 
  %cloptr20261 = inttoptr i64 %h9720 to i64* 
  store volatile i64* %cloptr20261, i64** %vptr20266, align 8 ; closure/env cast; i64 -> i64*
  %vptr20267 = alloca i64*, align 8 
  %i0ptr20262 = getelementptr inbounds i64, i64* %cloptr20261, i64 1 
  store volatile i64* %i0ptr20262, i64** %vptr20267, align 8 ; &cloptr20261[1]
 %vptr20268 = alloca i64, align 8 
  %f20264 = load i64, i64* %i0ptr20262, align 8 
  store volatile i64 %f20264, i64* %vptr20268, align 8 ; load; *i0ptr20262
  %fptr20263 = inttoptr i64 %f20264 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20263(i64 %h9720, i64 %h9720)                       ; tail call
  ret void
}


define void @lam12046(i64 %env12047, i64 %NkJ$lst7184) {
 %vptr20269 = alloca i64, align 8 
  %cont7183 = call i64 @prim_car(i64 %NkJ$lst7184) 
  store volatile i64 %cont7183, i64* %vptr20269, align 8 ; call prim_car
 %vptr20270 = alloca i64, align 8 
  %NkJ$lst = call i64 @prim_cdr(i64 %NkJ$lst7184) 
  store volatile i64 %NkJ$lst, i64* %vptr20270, align 8 ; call prim_cdr
 %vptr20271 = alloca i64, align 8 
  %arg7952 = add i64 0, 0 
  store volatile i64 %arg7952, i64* %vptr20271, align 8 ; quoted ()
 %vptr20272 = alloca i64, align 8 
  %rva9648 = add i64 0, 0 
  store volatile i64 %rva9648, i64* %vptr20272, align 8 ; quoted ()
 %vptr20273 = alloca i64, align 8 
  %rva9647 = call i64 @prim_cons(i64 %NkJ$lst, i64 %rva9648) 
  store volatile i64 %rva9647, i64* %vptr20273, align 8 ; call prim_cons
 %vptr20274 = alloca i64, align 8 
  %rva9646 = call i64 @prim_cons(i64 %arg7952, i64 %rva9647) 
  store volatile i64 %rva9646, i64* %vptr20274, align 8 ; call prim_cons
  %vptr20280 = alloca i64*, align 8 
  %cloptr20275 = inttoptr i64 %cont7183 to i64* 
  store volatile i64* %cloptr20275, i64** %vptr20280, align 8 ; closure/env cast; i64 -> i64*
  %vptr20281 = alloca i64*, align 8 
  %i0ptr20276 = getelementptr inbounds i64, i64* %cloptr20275, i64 1 
  store volatile i64* %i0ptr20276, i64** %vptr20281, align 8 ; &cloptr20275[1]
 %vptr20282 = alloca i64, align 8 
  %f20278 = load i64, i64* %i0ptr20276, align 8 
  store volatile i64 %f20278, i64* %vptr20282, align 8 ; load; *i0ptr20276
  %fptr20277 = inttoptr i64 %f20278 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20277(i64 %cont7183, i64 %rva9646)                  ; tail call
  ret void
}


define void @lam12042(i64 %env12043, i64 %rvp9712) {
 %vptr20285 = alloca i64, align 8 
  %envptr20283 = inttoptr i64 %env12043 to i64* 
  store volatile i64 %emsg08636, i64* %vptr20285, align 8 ; closure/env cast; i64 -> i64*
  %vptr20286 = alloca i64*, align 8 
  %envptr20284 = getelementptr inbounds i64, i64* %envptr20283, i64 7 
  store volatile i64* %envptr20284, i64** %vptr20286, align 8 ; &envptr20283[6]
 %vptr20287 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr20284, align 8 
  store volatile i64 %emsg08636, i64* %vptr20287, align 8 ; load; *envptr20284
 %vptr20290 = alloca i64, align 8 
  %envptr20288 = inttoptr i64 %env12043 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr20290, align 8 ; closure/env cast; i64 -> i64*
  %vptr20291 = alloca i64*, align 8 
  %envptr20289 = getelementptr inbounds i64, i64* %envptr20288, i64 6 
  store volatile i64* %envptr20289, i64** %vptr20291, align 8 ; &envptr20288[5]
 %vptr20292 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr20289, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr20292, align 8 ; load; *envptr20289
 %vptr20295 = alloca i64, align 8 
  %envptr20293 = inttoptr i64 %env12043 to i64* 
  store volatile i64 %Qmo$new, i64* %vptr20295, align 8 ; closure/env cast; i64 -> i64*
  %vptr20296 = alloca i64*, align 8 
  %envptr20294 = getelementptr inbounds i64, i64* %envptr20293, i64 5 
  store volatile i64* %envptr20294, i64** %vptr20296, align 8 ; &envptr20293[4]
 %vptr20297 = alloca i64, align 8 
  %Qmo$new = load i64, i64* %envptr20294, align 8 
  store volatile i64 %Qmo$new, i64* %vptr20297, align 8 ; load; *envptr20294
 %vptr20300 = alloca i64, align 8 
  %envptr20298 = inttoptr i64 %env12043 to i64* 
  store volatile i64 %cont7172, i64* %vptr20300, align 8 ; closure/env cast; i64 -> i64*
  %vptr20301 = alloca i64*, align 8 
  %envptr20299 = getelementptr inbounds i64, i64* %envptr20298, i64 4 
  store volatile i64* %envptr20299, i64** %vptr20301, align 8 ; &envptr20298[3]
 %vptr20302 = alloca i64, align 8 
  %cont7172 = load i64, i64* %envptr20299, align 8 
  store volatile i64 %cont7172, i64* %vptr20302, align 8 ; load; *envptr20299
 %vptr20305 = alloca i64, align 8 
  %envptr20303 = inttoptr i64 %env12043 to i64* 
  store volatile i64 %emsg18637, i64* %vptr20305, align 8 ; closure/env cast; i64 -> i64*
  %vptr20306 = alloca i64*, align 8 
  %envptr20304 = getelementptr inbounds i64, i64* %envptr20303, i64 3 
  store volatile i64* %envptr20304, i64** %vptr20306, align 8 ; &envptr20303[2]
 %vptr20307 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr20304, align 8 
  store volatile i64 %emsg18637, i64* %vptr20307, align 8 ; load; *envptr20304
 %vptr20310 = alloca i64, align 8 
  %envptr20308 = inttoptr i64 %env12043 to i64* 
  store volatile i64 %Fki$tail, i64* %vptr20310, align 8 ; closure/env cast; i64 -> i64*
  %vptr20311 = alloca i64*, align 8 
  %envptr20309 = getelementptr inbounds i64, i64* %envptr20308, i64 2 
  store volatile i64* %envptr20309, i64** %vptr20311, align 8 ; &envptr20308[1]
 %vptr20312 = alloca i64, align 8 
  %Fki$tail = load i64, i64* %envptr20309, align 8 
  store volatile i64 %Fki$tail, i64* %vptr20312, align 8 ; load; *envptr20309
 %vptr20313 = alloca i64, align 8 
  %_957181 = call i64 @prim_car(i64 %rvp9712) 
  store volatile i64 %_957181, i64* %vptr20313, align 8 ; call prim_car
 %vptr20314 = alloca i64, align 8 
  %rvp9708 = call i64 @prim_cdr(i64 %rvp9712) 
  store volatile i64 %rvp9708, i64* %vptr20314, align 8 ; call prim_cdr
 %vptr20315 = alloca i64, align 8 
  %n_639713 = call i64 @prim_null_63(i64 %rvp9708) 
  store volatile i64 %n_639713, i64* %vptr20315, align 8 ; call prim_null_63
  %cmpptr20319 = alloca i1, align 8  %cmp20316 = icmp eq i64 %n_639713, 15 store volatile i1 %cmp20316, i1* %cmpptr20319, align 8; false?
  br i1 %cmp20316, label %else20318, label %then20317                                ; if

then20317:
 %vptr20320 = alloca i64, align 8 
  %h9714 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9714, i64* %vptr20320, align 8 ; call prim_halt
  %vptr20326 = alloca i64*, align 8 
  %cloptr20321 = inttoptr i64 %h9714 to i64* 
  store volatile i64* %cloptr20321, i64** %vptr20326, align 8 ; closure/env cast; i64 -> i64*
  %vptr20327 = alloca i64*, align 8 
  %i0ptr20322 = getelementptr inbounds i64, i64* %cloptr20321, i64 1 
  store volatile i64* %i0ptr20322, i64** %vptr20327, align 8 ; &cloptr20321[1]
 %vptr20328 = alloca i64, align 8 
  %f20324 = load i64, i64* %i0ptr20322, align 8 
  store volatile i64 %f20324, i64* %vptr20328, align 8 ; load; *i0ptr20322
  %fptr20323 = inttoptr i64 %f20324 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20323(i64 %h9714, i64 %h9714)                       ; tail call
  ret void

else20318:
 %vptr20329 = alloca i64, align 8 
  %a7023 = call i64 @prim_car(i64 %rvp9708) 
  store volatile i64 %a7023, i64* %vptr20329, align 8 ; call prim_car
 %vptr20330 = alloca i64, align 8 
  %na9650 = call i64 @prim_cdr(i64 %rvp9708) 
  store volatile i64 %na9650, i64* %vptr20330, align 8 ; call prim_cdr
 %vptr20331 = alloca i64, align 8 
  %n_639709 = call i64 @prim_null_63(i64 %na9650) 
  store volatile i64 %n_639709, i64* %vptr20331, align 8 ; call prim_null_63
  %cmpptr20335 = alloca i1, align 8  %cmp20332 = icmp eq i64 %n_639709, 15 store volatile i1 %cmp20332, i1* %cmpptr20335, align 8; false?
  br i1 %cmp20332, label %else20334, label %then20333                                ; if

then20333:
 %vptr20336 = alloca i64, align 8 
  %arg7955 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg7955, i64* %vptr20336, align 8 ; quoted int
 %vptr20337 = alloca i64, align 8 
  %retprim7182 = call i64 @prim_make_45vector(i64 %arg7955, i64 %a7023) 
  store volatile i64 %retprim7182, i64* %vptr20337, align 8 ; call prim_make_45vector
  %vptr20347 = alloca i64*, align 8 
  %cloptr20338 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr20338, i64** %vptr20347, align 8 ; malloc
  %vptr20348 = alloca i64*, align 8 
  %eptr20340 = getelementptr inbounds i64, i64* %cloptr20338, i64 2 
  store volatile i64* %eptr20340, i64** %vptr20348, align 8 ; &eptr20340[1]
  %vptr20349 = alloca i64*, align 8 
  %eptr20341 = getelementptr inbounds i64, i64* %cloptr20338, i64 3 
  store volatile i64* %eptr20341, i64** %vptr20349, align 8 ; &eptr20341[2]
  %vptr20350 = alloca i64*, align 8 
  %eptr20342 = getelementptr inbounds i64, i64* %cloptr20338, i64 4 
  store volatile i64* %eptr20342, i64** %vptr20350, align 8 ; &eptr20342[3]
  %vptr20351 = alloca i64*, align 8 
  %eptr20343 = getelementptr inbounds i64, i64* %cloptr20338, i64 5 
  store volatile i64* %eptr20343, i64** %vptr20351, align 8 ; &eptr20343[4]
  %vptr20352 = alloca i64*, align 8 
  %eptr20344 = getelementptr inbounds i64, i64* %cloptr20338, i64 6 
  store volatile i64* %eptr20344, i64** %vptr20352, align 8 ; &eptr20344[5]
  %vptr20353 = alloca i64*, align 8 
  %eptr20345 = getelementptr inbounds i64, i64* %cloptr20338, i64 7 
  store volatile i64* %eptr20345, i64** %vptr20353, align 8 ; &eptr20345[6]
  store i64 %Fki$tail, i64* %eptr20340                                               ; *eptr20340 = %Fki$tail
  store i64 %emsg18637, i64* %eptr20341                                              ; *eptr20341 = %emsg18637
  store i64 %cont7172, i64* %eptr20342                                               ; *eptr20342 = %cont7172
  store i64 %Qmo$new, i64* %eptr20343                                                ; *eptr20343 = %Qmo$new
  store i64 %SdC$_37wind_45stack, i64* %eptr20344                                    ; *eptr20344 = %SdC$_37wind_45stack
  store i64 %emsg08636, i64* %eptr20345                                              ; *eptr20345 = %emsg08636
  %vptr20354 = alloca i64*, align 8 
  %eptr20339 = getelementptr inbounds i64, i64* %cloptr20338, i64 1 
  store volatile i64* %eptr20339, i64** %vptr20354, align 8 ; &cloptr20338[1]
 %vptr20355 = alloca i64, align 8 
  %f20346 = ptrtoint void(i64,i64)* @lam12039 to i64 
  store volatile i64 %f20346, i64* %vptr20355, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f20346, i64* %eptr20339                                                 ; store fptr
 %vptr20356 = alloca i64, align 8 
  %arg7958 = ptrtoint i64* %cloptr20338 to i64 
  store volatile i64 %arg7958, i64* %vptr20356, align 8 ; closure cast; i64* -> i64
 %vptr20357 = alloca i64, align 8 
  %arg7957 = add i64 0, 0 
  store volatile i64 %arg7957, i64* %vptr20357, align 8 ; quoted ()
 %vptr20358 = alloca i64, align 8 
  %rva9707 = add i64 0, 0 
  store volatile i64 %rva9707, i64* %vptr20358, align 8 ; quoted ()
 %vptr20359 = alloca i64, align 8 
  %rva9706 = call i64 @prim_cons(i64 %retprim7182, i64 %rva9707) 
  store volatile i64 %rva9706, i64* %vptr20359, align 8 ; call prim_cons
 %vptr20360 = alloca i64, align 8 
  %rva9705 = call i64 @prim_cons(i64 %arg7957, i64 %rva9706) 
  store volatile i64 %rva9705, i64* %vptr20360, align 8 ; call prim_cons
  %vptr20366 = alloca i64*, align 8 
  %cloptr20361 = inttoptr i64 %arg7958 to i64* 
  store volatile i64* %cloptr20361, i64** %vptr20366, align 8 ; closure/env cast; i64 -> i64*
  %vptr20367 = alloca i64*, align 8 
  %i0ptr20362 = getelementptr inbounds i64, i64* %cloptr20361, i64 1 
  store volatile i64* %i0ptr20362, i64** %vptr20367, align 8 ; &cloptr20361[1]
 %vptr20368 = alloca i64, align 8 
  %f20364 = load i64, i64* %i0ptr20362, align 8 
  store volatile i64 %f20364, i64* %vptr20368, align 8 ; load; *i0ptr20362
  %fptr20363 = inttoptr i64 %f20364 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20363(i64 %arg7958, i64 %rva9705)                   ; tail call
  ret void

else20334:
 %vptr20369 = alloca i64, align 8 
  %h9710 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9710, i64* %vptr20369, align 8 ; call prim_halt
  %vptr20375 = alloca i64*, align 8 
  %cloptr20370 = inttoptr i64 %h9710 to i64* 
  store volatile i64* %cloptr20370, i64** %vptr20375, align 8 ; closure/env cast; i64 -> i64*
  %vptr20376 = alloca i64*, align 8 
  %i0ptr20371 = getelementptr inbounds i64, i64* %cloptr20370, i64 1 
  store volatile i64* %i0ptr20371, i64** %vptr20376, align 8 ; &cloptr20370[1]
 %vptr20377 = alloca i64, align 8 
  %f20373 = load i64, i64* %i0ptr20371, align 8 
  store volatile i64 %f20373, i64* %vptr20377, align 8 ; load; *i0ptr20371
  %fptr20372 = inttoptr i64 %f20373 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20372(i64 %h9710, i64 %h9710)                       ; tail call
  ret void
}


define void @lam12039(i64 %env12040, i64 %rvp9701) {
 %vptr20380 = alloca i64, align 8 
  %envptr20378 = inttoptr i64 %env12040 to i64* 
  store volatile i64 %emsg08636, i64* %vptr20380, align 8 ; closure/env cast; i64 -> i64*
  %vptr20381 = alloca i64*, align 8 
  %envptr20379 = getelementptr inbounds i64, i64* %envptr20378, i64 7 
  store volatile i64* %envptr20379, i64** %vptr20381, align 8 ; &envptr20378[6]
 %vptr20382 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr20379, align 8 
  store volatile i64 %emsg08636, i64* %vptr20382, align 8 ; load; *envptr20379
 %vptr20385 = alloca i64, align 8 
  %envptr20383 = inttoptr i64 %env12040 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr20385, align 8 ; closure/env cast; i64 -> i64*
  %vptr20386 = alloca i64*, align 8 
  %envptr20384 = getelementptr inbounds i64, i64* %envptr20383, i64 6 
  store volatile i64* %envptr20384, i64** %vptr20386, align 8 ; &envptr20383[5]
 %vptr20387 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr20384, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr20387, align 8 ; load; *envptr20384
 %vptr20390 = alloca i64, align 8 
  %envptr20388 = inttoptr i64 %env12040 to i64* 
  store volatile i64 %Qmo$new, i64* %vptr20390, align 8 ; closure/env cast; i64 -> i64*
  %vptr20391 = alloca i64*, align 8 
  %envptr20389 = getelementptr inbounds i64, i64* %envptr20388, i64 5 
  store volatile i64* %envptr20389, i64** %vptr20391, align 8 ; &envptr20388[4]
 %vptr20392 = alloca i64, align 8 
  %Qmo$new = load i64, i64* %envptr20389, align 8 
  store volatile i64 %Qmo$new, i64* %vptr20392, align 8 ; load; *envptr20389
 %vptr20395 = alloca i64, align 8 
  %envptr20393 = inttoptr i64 %env12040 to i64* 
  store volatile i64 %cont7172, i64* %vptr20395, align 8 ; closure/env cast; i64 -> i64*
  %vptr20396 = alloca i64*, align 8 
  %envptr20394 = getelementptr inbounds i64, i64* %envptr20393, i64 4 
  store volatile i64* %envptr20394, i64** %vptr20396, align 8 ; &envptr20393[3]
 %vptr20397 = alloca i64, align 8 
  %cont7172 = load i64, i64* %envptr20394, align 8 
  store volatile i64 %cont7172, i64* %vptr20397, align 8 ; load; *envptr20394
 %vptr20400 = alloca i64, align 8 
  %envptr20398 = inttoptr i64 %env12040 to i64* 
  store volatile i64 %emsg18637, i64* %vptr20400, align 8 ; closure/env cast; i64 -> i64*
  %vptr20401 = alloca i64*, align 8 
  %envptr20399 = getelementptr inbounds i64, i64* %envptr20398, i64 3 
  store volatile i64* %envptr20399, i64** %vptr20401, align 8 ; &envptr20398[2]
 %vptr20402 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr20399, align 8 
  store volatile i64 %emsg18637, i64* %vptr20402, align 8 ; load; *envptr20399
 %vptr20405 = alloca i64, align 8 
  %envptr20403 = inttoptr i64 %env12040 to i64* 
  store volatile i64 %Fki$tail, i64* %vptr20405, align 8 ; closure/env cast; i64 -> i64*
  %vptr20406 = alloca i64*, align 8 
  %envptr20404 = getelementptr inbounds i64, i64* %envptr20403, i64 2 
  store volatile i64* %envptr20404, i64** %vptr20406, align 8 ; &envptr20403[1]
 %vptr20407 = alloca i64, align 8 
  %Fki$tail = load i64, i64* %envptr20404, align 8 
  store volatile i64 %Fki$tail, i64* %vptr20407, align 8 ; load; *envptr20404
 %vptr20408 = alloca i64, align 8 
  %_957175 = call i64 @prim_car(i64 %rvp9701) 
  store volatile i64 %_957175, i64* %vptr20408, align 8 ; call prim_car
 %vptr20409 = alloca i64, align 8 
  %rvp9697 = call i64 @prim_cdr(i64 %rvp9701) 
  store volatile i64 %rvp9697, i64* %vptr20409, align 8 ; call prim_cdr
 %vptr20410 = alloca i64, align 8 
  %n_639702 = call i64 @prim_null_63(i64 %rvp9697) 
  store volatile i64 %n_639702, i64* %vptr20410, align 8 ; call prim_null_63
  %cmpptr20414 = alloca i1, align 8  %cmp20411 = icmp eq i64 %n_639702, 15 store volatile i1 %cmp20411, i1* %cmpptr20414, align 8; false?
  br i1 %cmp20411, label %else20413, label %then20412                                ; if

then20412:
 %vptr20415 = alloca i64, align 8 
  %h9703 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9703, i64* %vptr20415, align 8 ; call prim_halt
  %vptr20421 = alloca i64*, align 8 
  %cloptr20416 = inttoptr i64 %h9703 to i64* 
  store volatile i64* %cloptr20416, i64** %vptr20421, align 8 ; closure/env cast; i64 -> i64*
  %vptr20422 = alloca i64*, align 8 
  %i0ptr20417 = getelementptr inbounds i64, i64* %cloptr20416, i64 1 
  store volatile i64* %i0ptr20417, i64** %vptr20422, align 8 ; &cloptr20416[1]
 %vptr20423 = alloca i64, align 8 
  %f20419 = load i64, i64* %i0ptr20417, align 8 
  store volatile i64 %f20419, i64* %vptr20423, align 8 ; load; *i0ptr20417
  %fptr20418 = inttoptr i64 %f20419 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20418(i64 %h9703, i64 %h9703)                       ; tail call
  ret void

else20413:
 %vptr20424 = alloca i64, align 8 
  %KLv$f = call i64 @prim_car(i64 %rvp9697) 
  store volatile i64 %KLv$f, i64* %vptr20424, align 8 ; call prim_car
 %vptr20425 = alloca i64, align 8 
  %na9652 = call i64 @prim_cdr(i64 %rvp9697) 
  store volatile i64 %na9652, i64* %vptr20425, align 8 ; call prim_cdr
 %vptr20426 = alloca i64, align 8 
  %n_639698 = call i64 @prim_null_63(i64 %na9652) 
  store volatile i64 %n_639698, i64* %vptr20426, align 8 ; call prim_null_63
  %cmpptr20430 = alloca i1, align 8  %cmp20427 = icmp eq i64 %n_639698, 15 store volatile i1 %cmp20427, i1* %cmpptr20430, align 8; false?
  br i1 %cmp20427, label %else20429, label %then20428                                ; if

then20428:
 %vptr20431 = alloca i64, align 8 
  %arg7960 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7960, i64* %vptr20431, align 8 ; quoted int
  %vptr20440 = alloca i64*, align 8 
  %cloptr20432 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr20432, i64** %vptr20440, align 8 ; malloc
  %vptr20441 = alloca i64*, align 8 
  %eptr20434 = getelementptr inbounds i64, i64* %cloptr20432, i64 2 
  store volatile i64* %eptr20434, i64** %vptr20441, align 8 ; &eptr20434[1]
  %vptr20442 = alloca i64*, align 8 
  %eptr20435 = getelementptr inbounds i64, i64* %cloptr20432, i64 3 
  store volatile i64* %eptr20435, i64** %vptr20442, align 8 ; &eptr20435[2]
  %vptr20443 = alloca i64*, align 8 
  %eptr20436 = getelementptr inbounds i64, i64* %cloptr20432, i64 4 
  store volatile i64* %eptr20436, i64** %vptr20443, align 8 ; &eptr20436[3]
  %vptr20444 = alloca i64*, align 8 
  %eptr20437 = getelementptr inbounds i64, i64* %cloptr20432, i64 5 
  store volatile i64* %eptr20437, i64** %vptr20444, align 8 ; &eptr20437[4]
  %vptr20445 = alloca i64*, align 8 
  %eptr20438 = getelementptr inbounds i64, i64* %cloptr20432, i64 6 
  store volatile i64* %eptr20438, i64** %vptr20445, align 8 ; &eptr20438[5]
  store i64 %Fki$tail, i64* %eptr20434                                               ; *eptr20434 = %Fki$tail
  store i64 %KLv$f, i64* %eptr20435                                                  ; *eptr20435 = %KLv$f
  store i64 %emsg18637, i64* %eptr20436                                              ; *eptr20436 = %emsg18637
  store i64 %SdC$_37wind_45stack, i64* %eptr20437                                    ; *eptr20437 = %SdC$_37wind_45stack
  store i64 %emsg08636, i64* %eptr20438                                              ; *eptr20438 = %emsg08636
  %vptr20446 = alloca i64*, align 8 
  %eptr20433 = getelementptr inbounds i64, i64* %cloptr20432, i64 1 
  store volatile i64* %eptr20433, i64** %vptr20446, align 8 ; &cloptr20432[1]
 %vptr20447 = alloca i64, align 8 
  %f20439 = ptrtoint void(i64,i64)* @lam12036 to i64 
  store volatile i64 %f20439, i64* %vptr20447, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f20439, i64* %eptr20433                                                 ; store fptr
 %vptr20448 = alloca i64, align 8 
  %arg7959 = ptrtoint i64* %cloptr20432 to i64 
  store volatile i64 %arg7959, i64* %vptr20448, align 8 ; closure cast; i64* -> i64
 %vptr20449 = alloca i64, align 8 
  %SJ1$_956888 = call i64 @prim_vector_45set_33(i64 %KLv$f, i64 %arg7960, i64 %arg7959) 
  store volatile i64 %SJ1$_956888, i64* %vptr20449, align 8 ; call prim_vector_45set_33
 %vptr20450 = alloca i64, align 8 
  %arg7984 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7984, i64* %vptr20450, align 8 ; quoted int
 %vptr20451 = alloca i64, align 8 
  %a7030 = call i64 @prim_vector_45ref(i64 %KLv$f, i64 %arg7984) 
  store volatile i64 %a7030, i64* %vptr20451, align 8 ; call prim_vector_45ref
 %vptr20452 = alloca i64, align 8 
  %rva9696 = add i64 0, 0 
  store volatile i64 %rva9696, i64* %vptr20452, align 8 ; quoted ()
 %vptr20453 = alloca i64, align 8 
  %rva9695 = call i64 @prim_cons(i64 %Qmo$new, i64 %rva9696) 
  store volatile i64 %rva9695, i64* %vptr20453, align 8 ; call prim_cons
 %vptr20454 = alloca i64, align 8 
  %rva9694 = call i64 @prim_cons(i64 %cont7172, i64 %rva9695) 
  store volatile i64 %rva9694, i64* %vptr20454, align 8 ; call prim_cons
  %vptr20460 = alloca i64*, align 8 
  %cloptr20455 = inttoptr i64 %a7030 to i64* 
  store volatile i64* %cloptr20455, i64** %vptr20460, align 8 ; closure/env cast; i64 -> i64*
  %vptr20461 = alloca i64*, align 8 
  %i0ptr20456 = getelementptr inbounds i64, i64* %cloptr20455, i64 1 
  store volatile i64* %i0ptr20456, i64** %vptr20461, align 8 ; &cloptr20455[1]
 %vptr20462 = alloca i64, align 8 
  %f20458 = load i64, i64* %i0ptr20456, align 8 
  store volatile i64 %f20458, i64* %vptr20462, align 8 ; load; *i0ptr20456
  %fptr20457 = inttoptr i64 %f20458 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20457(i64 %a7030, i64 %rva9694)                     ; tail call
  ret void

else20429:
 %vptr20463 = alloca i64, align 8 
  %h9699 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9699, i64* %vptr20463, align 8 ; call prim_halt
  %vptr20469 = alloca i64*, align 8 
  %cloptr20464 = inttoptr i64 %h9699 to i64* 
  store volatile i64* %cloptr20464, i64** %vptr20469, align 8 ; closure/env cast; i64 -> i64*
  %vptr20470 = alloca i64*, align 8 
  %i0ptr20465 = getelementptr inbounds i64, i64* %cloptr20464, i64 1 
  store volatile i64* %i0ptr20465, i64** %vptr20470, align 8 ; &cloptr20464[1]
 %vptr20471 = alloca i64, align 8 
  %f20467 = load i64, i64* %i0ptr20465, align 8 
  store volatile i64 %f20467, i64* %vptr20471, align 8 ; load; *i0ptr20465
  %fptr20466 = inttoptr i64 %f20467 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20466(i64 %h9699, i64 %h9699)                       ; tail call
  ret void
}


define void @lam12036(i64 %env12037, i64 %rvp9690) {
 %vptr20474 = alloca i64, align 8 
  %envptr20472 = inttoptr i64 %env12037 to i64* 
  store volatile i64 %emsg08636, i64* %vptr20474, align 8 ; closure/env cast; i64 -> i64*
  %vptr20475 = alloca i64*, align 8 
  %envptr20473 = getelementptr inbounds i64, i64* %envptr20472, i64 6 
  store volatile i64* %envptr20473, i64** %vptr20475, align 8 ; &envptr20472[5]
 %vptr20476 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr20473, align 8 
  store volatile i64 %emsg08636, i64* %vptr20476, align 8 ; load; *envptr20473
 %vptr20479 = alloca i64, align 8 
  %envptr20477 = inttoptr i64 %env12037 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr20479, align 8 ; closure/env cast; i64 -> i64*
  %vptr20480 = alloca i64*, align 8 
  %envptr20478 = getelementptr inbounds i64, i64* %envptr20477, i64 5 
  store volatile i64* %envptr20478, i64** %vptr20480, align 8 ; &envptr20477[4]
 %vptr20481 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr20478, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr20481, align 8 ; load; *envptr20478
 %vptr20484 = alloca i64, align 8 
  %envptr20482 = inttoptr i64 %env12037 to i64* 
  store volatile i64 %emsg18637, i64* %vptr20484, align 8 ; closure/env cast; i64 -> i64*
  %vptr20485 = alloca i64*, align 8 
  %envptr20483 = getelementptr inbounds i64, i64* %envptr20482, i64 4 
  store volatile i64* %envptr20483, i64** %vptr20485, align 8 ; &envptr20482[3]
 %vptr20486 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr20483, align 8 
  store volatile i64 %emsg18637, i64* %vptr20486, align 8 ; load; *envptr20483
 %vptr20489 = alloca i64, align 8 
  %envptr20487 = inttoptr i64 %env12037 to i64* 
  store volatile i64 %KLv$f, i64* %vptr20489, align 8 ; closure/env cast; i64 -> i64*
  %vptr20490 = alloca i64*, align 8 
  %envptr20488 = getelementptr inbounds i64, i64* %envptr20487, i64 3 
  store volatile i64* %envptr20488, i64** %vptr20490, align 8 ; &envptr20487[2]
 %vptr20491 = alloca i64, align 8 
  %KLv$f = load i64, i64* %envptr20488, align 8 
  store volatile i64 %KLv$f, i64* %vptr20491, align 8 ; load; *envptr20488
 %vptr20494 = alloca i64, align 8 
  %envptr20492 = inttoptr i64 %env12037 to i64* 
  store volatile i64 %Fki$tail, i64* %vptr20494, align 8 ; closure/env cast; i64 -> i64*
  %vptr20495 = alloca i64*, align 8 
  %envptr20493 = getelementptr inbounds i64, i64* %envptr20492, i64 2 
  store volatile i64* %envptr20493, i64** %vptr20495, align 8 ; &envptr20492[1]
 %vptr20496 = alloca i64, align 8 
  %Fki$tail = load i64, i64* %envptr20493, align 8 
  store volatile i64 %Fki$tail, i64* %vptr20496, align 8 ; load; *envptr20493
 %vptr20497 = alloca i64, align 8 
  %cont7176 = call i64 @prim_car(i64 %rvp9690) 
  store volatile i64 %cont7176, i64* %vptr20497, align 8 ; call prim_car
 %vptr20498 = alloca i64, align 8 
  %rvp9686 = call i64 @prim_cdr(i64 %rvp9690) 
  store volatile i64 %rvp9686, i64* %vptr20498, align 8 ; call prim_cdr
 %vptr20499 = alloca i64, align 8 
  %n_639691 = call i64 @prim_null_63(i64 %rvp9686) 
  store volatile i64 %n_639691, i64* %vptr20499, align 8 ; call prim_null_63
  %cmpptr20503 = alloca i1, align 8  %cmp20500 = icmp eq i64 %n_639691, 15 store volatile i1 %cmp20500, i1* %cmpptr20503, align 8; false?
  br i1 %cmp20500, label %else20502, label %then20501                                ; if

then20501:
 %vptr20504 = alloca i64, align 8 
  %h9692 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9692, i64* %vptr20504, align 8 ; call prim_halt
  %vptr20510 = alloca i64*, align 8 
  %cloptr20505 = inttoptr i64 %h9692 to i64* 
  store volatile i64* %cloptr20505, i64** %vptr20510, align 8 ; closure/env cast; i64 -> i64*
  %vptr20511 = alloca i64*, align 8 
  %i0ptr20506 = getelementptr inbounds i64, i64* %cloptr20505, i64 1 
  store volatile i64* %i0ptr20506, i64** %vptr20511, align 8 ; &cloptr20505[1]
 %vptr20512 = alloca i64, align 8 
  %f20508 = load i64, i64* %i0ptr20506, align 8 
  store volatile i64 %f20508, i64* %vptr20512, align 8 ; load; *i0ptr20506
  %fptr20507 = inttoptr i64 %f20508 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20507(i64 %h9692, i64 %h9692)                       ; tail call
  ret void

else20502:
 %vptr20513 = alloca i64, align 8 
  %jg8$l = call i64 @prim_car(i64 %rvp9686) 
  store volatile i64 %jg8$l, i64* %vptr20513, align 8 ; call prim_car
 %vptr20514 = alloca i64, align 8 
  %na9654 = call i64 @prim_cdr(i64 %rvp9686) 
  store volatile i64 %na9654, i64* %vptr20514, align 8 ; call prim_cdr
 %vptr20515 = alloca i64, align 8 
  %n_639687 = call i64 @prim_null_63(i64 %na9654) 
  store volatile i64 %n_639687, i64* %vptr20515, align 8 ; call prim_null_63
  %cmpptr20519 = alloca i1, align 8  %cmp20516 = icmp eq i64 %n_639687, 15 store volatile i1 %cmp20516, i1* %cmpptr20519, align 8; false?
  br i1 %cmp20516, label %else20518, label %then20517                                ; if

then20517:
 %vptr20520 = alloca i64, align 8 
  %a7024 = call i64 @prim_eq_63(i64 %jg8$l, i64 %Fki$tail) 
  store volatile i64 %a7024, i64* %vptr20520, align 8 ; call prim_eq_63
 %vptr20521 = alloca i64, align 8 
  %a7025 = call i64 @prim_not(i64 %a7024) 
  store volatile i64 %a7025, i64* %vptr20521, align 8 ; call prim_not
  %cmpptr20525 = alloca i1, align 8  %cmp20522 = icmp eq i64 %a7025, 15 store volatile i1 %cmp20522, i1* %cmpptr20525, align 8; false?
  br i1 %cmp20522, label %else20524, label %then20523                                ; if

then20523:
 %vptr20526 = alloca i64, align 8 
  %arg7965 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7965, i64* %vptr20526, align 8 ; quoted int
 %vptr20527 = alloca i64, align 8 
  %a7026 = call i64 @prim_vector_45ref(i64 %KLv$f, i64 %arg7965) 
  store volatile i64 %a7026, i64* %vptr20527, align 8 ; call prim_vector_45ref
 %vptr20528 = alloca i64, align 8 
  %a7027 = call i64 @prim_cdr(i64 %jg8$l) 
  store volatile i64 %a7027, i64* %vptr20528, align 8 ; call prim_cdr
  %vptr20537 = alloca i64*, align 8 
  %cloptr20529 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr20529, i64** %vptr20537, align 8 ; malloc
  %vptr20538 = alloca i64*, align 8 
  %eptr20531 = getelementptr inbounds i64, i64* %cloptr20529, i64 2 
  store volatile i64* %eptr20531, i64** %vptr20538, align 8 ; &eptr20531[1]
  %vptr20539 = alloca i64*, align 8 
  %eptr20532 = getelementptr inbounds i64, i64* %cloptr20529, i64 3 
  store volatile i64* %eptr20532, i64** %vptr20539, align 8 ; &eptr20532[2]
  %vptr20540 = alloca i64*, align 8 
  %eptr20533 = getelementptr inbounds i64, i64* %cloptr20529, i64 4 
  store volatile i64* %eptr20533, i64** %vptr20540, align 8 ; &eptr20533[3]
  %vptr20541 = alloca i64*, align 8 
  %eptr20534 = getelementptr inbounds i64, i64* %cloptr20529, i64 5 
  store volatile i64* %eptr20534, i64** %vptr20541, align 8 ; &eptr20534[4]
  %vptr20542 = alloca i64*, align 8 
  %eptr20535 = getelementptr inbounds i64, i64* %cloptr20529, i64 6 
  store volatile i64* %eptr20535, i64** %vptr20542, align 8 ; &eptr20535[5]
  store i64 %emsg18637, i64* %eptr20531                                              ; *eptr20531 = %emsg18637
  store i64 %cont7176, i64* %eptr20532                                               ; *eptr20532 = %cont7176
  store i64 %SdC$_37wind_45stack, i64* %eptr20533                                    ; *eptr20533 = %SdC$_37wind_45stack
  store i64 %jg8$l, i64* %eptr20534                                                  ; *eptr20534 = %jg8$l
  store i64 %emsg08636, i64* %eptr20535                                              ; *eptr20535 = %emsg08636
  %vptr20543 = alloca i64*, align 8 
  %eptr20530 = getelementptr inbounds i64, i64* %cloptr20529, i64 1 
  store volatile i64* %eptr20530, i64** %vptr20543, align 8 ; &cloptr20529[1]
 %vptr20544 = alloca i64, align 8 
  %f20536 = ptrtoint void(i64,i64)* @lam12031 to i64 
  store volatile i64 %f20536, i64* %vptr20544, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f20536, i64* %eptr20530                                                 ; store fptr
 %vptr20545 = alloca i64, align 8 
  %arg7969 = ptrtoint i64* %cloptr20529 to i64 
  store volatile i64 %arg7969, i64* %vptr20545, align 8 ; closure cast; i64* -> i64
 %vptr20546 = alloca i64, align 8 
  %rva9682 = add i64 0, 0 
  store volatile i64 %rva9682, i64* %vptr20546, align 8 ; quoted ()
 %vptr20547 = alloca i64, align 8 
  %rva9681 = call i64 @prim_cons(i64 %a7027, i64 %rva9682) 
  store volatile i64 %rva9681, i64* %vptr20547, align 8 ; call prim_cons
 %vptr20548 = alloca i64, align 8 
  %rva9680 = call i64 @prim_cons(i64 %arg7969, i64 %rva9681) 
  store volatile i64 %rva9680, i64* %vptr20548, align 8 ; call prim_cons
  %vptr20554 = alloca i64*, align 8 
  %cloptr20549 = inttoptr i64 %a7026 to i64* 
  store volatile i64* %cloptr20549, i64** %vptr20554, align 8 ; closure/env cast; i64 -> i64*
  %vptr20555 = alloca i64*, align 8 
  %i0ptr20550 = getelementptr inbounds i64, i64* %cloptr20549, i64 1 
  store volatile i64* %i0ptr20550, i64** %vptr20555, align 8 ; &cloptr20549[1]
 %vptr20556 = alloca i64, align 8 
  %f20552 = load i64, i64* %i0ptr20550, align 8 
  store volatile i64 %f20552, i64* %vptr20556, align 8 ; load; *i0ptr20550
  %fptr20551 = inttoptr i64 %f20552 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20551(i64 %a7026, i64 %rva9680)                     ; tail call
  ret void

else20524:
 %vptr20557 = alloca i64, align 8 
  %retprim7180 = call i64 @prim_void() 
  store volatile i64 %retprim7180, i64* %vptr20557, align 8 ; call prim_void
 %vptr20558 = alloca i64, align 8 
  %arg7982 = add i64 0, 0 
  store volatile i64 %arg7982, i64* %vptr20558, align 8 ; quoted ()
 %vptr20559 = alloca i64, align 8 
  %rva9685 = add i64 0, 0 
  store volatile i64 %rva9685, i64* %vptr20559, align 8 ; quoted ()
 %vptr20560 = alloca i64, align 8 
  %rva9684 = call i64 @prim_cons(i64 %retprim7180, i64 %rva9685) 
  store volatile i64 %rva9684, i64* %vptr20560, align 8 ; call prim_cons
 %vptr20561 = alloca i64, align 8 
  %rva9683 = call i64 @prim_cons(i64 %arg7982, i64 %rva9684) 
  store volatile i64 %rva9683, i64* %vptr20561, align 8 ; call prim_cons
  %vptr20567 = alloca i64*, align 8 
  %cloptr20562 = inttoptr i64 %cont7176 to i64* 
  store volatile i64* %cloptr20562, i64** %vptr20567, align 8 ; closure/env cast; i64 -> i64*
  %vptr20568 = alloca i64*, align 8 
  %i0ptr20563 = getelementptr inbounds i64, i64* %cloptr20562, i64 1 
  store volatile i64* %i0ptr20563, i64** %vptr20568, align 8 ; &cloptr20562[1]
 %vptr20569 = alloca i64, align 8 
  %f20565 = load i64, i64* %i0ptr20563, align 8 
  store volatile i64 %f20565, i64* %vptr20569, align 8 ; load; *i0ptr20563
  %fptr20564 = inttoptr i64 %f20565 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20564(i64 %cont7176, i64 %rva9683)                  ; tail call
  ret void

else20518:
 %vptr20570 = alloca i64, align 8 
  %h9688 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9688, i64* %vptr20570, align 8 ; call prim_halt
  %vptr20576 = alloca i64*, align 8 
  %cloptr20571 = inttoptr i64 %h9688 to i64* 
  store volatile i64* %cloptr20571, i64** %vptr20576, align 8 ; closure/env cast; i64 -> i64*
  %vptr20577 = alloca i64*, align 8 
  %i0ptr20572 = getelementptr inbounds i64, i64* %cloptr20571, i64 1 
  store volatile i64* %i0ptr20572, i64** %vptr20577, align 8 ; &cloptr20571[1]
 %vptr20578 = alloca i64, align 8 
  %f20574 = load i64, i64* %i0ptr20572, align 8 
  store volatile i64 %f20574, i64* %vptr20578, align 8 ; load; *i0ptr20572
  %fptr20573 = inttoptr i64 %f20574 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20573(i64 %h9688, i64 %h9688)                       ; tail call
  ret void
}


define void @lam12031(i64 %env12032, i64 %rvp9676) {
 %vptr20581 = alloca i64, align 8 
  %envptr20579 = inttoptr i64 %env12032 to i64* 
  store volatile i64 %emsg08636, i64* %vptr20581, align 8 ; closure/env cast; i64 -> i64*
  %vptr20582 = alloca i64*, align 8 
  %envptr20580 = getelementptr inbounds i64, i64* %envptr20579, i64 6 
  store volatile i64* %envptr20580, i64** %vptr20582, align 8 ; &envptr20579[5]
 %vptr20583 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr20580, align 8 
  store volatile i64 %emsg08636, i64* %vptr20583, align 8 ; load; *envptr20580
 %vptr20586 = alloca i64, align 8 
  %envptr20584 = inttoptr i64 %env12032 to i64* 
  store volatile i64 %jg8$l, i64* %vptr20586, align 8 ; closure/env cast; i64 -> i64*
  %vptr20587 = alloca i64*, align 8 
  %envptr20585 = getelementptr inbounds i64, i64* %envptr20584, i64 5 
  store volatile i64* %envptr20585, i64** %vptr20587, align 8 ; &envptr20584[4]
 %vptr20588 = alloca i64, align 8 
  %jg8$l = load i64, i64* %envptr20585, align 8 
  store volatile i64 %jg8$l, i64* %vptr20588, align 8 ; load; *envptr20585
 %vptr20591 = alloca i64, align 8 
  %envptr20589 = inttoptr i64 %env12032 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr20591, align 8 ; closure/env cast; i64 -> i64*
  %vptr20592 = alloca i64*, align 8 
  %envptr20590 = getelementptr inbounds i64, i64* %envptr20589, i64 4 
  store volatile i64* %envptr20590, i64** %vptr20592, align 8 ; &envptr20589[3]
 %vptr20593 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr20590, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr20593, align 8 ; load; *envptr20590
 %vptr20596 = alloca i64, align 8 
  %envptr20594 = inttoptr i64 %env12032 to i64* 
  store volatile i64 %cont7176, i64* %vptr20596, align 8 ; closure/env cast; i64 -> i64*
  %vptr20597 = alloca i64*, align 8 
  %envptr20595 = getelementptr inbounds i64, i64* %envptr20594, i64 3 
  store volatile i64* %envptr20595, i64** %vptr20597, align 8 ; &envptr20594[2]
 %vptr20598 = alloca i64, align 8 
  %cont7176 = load i64, i64* %envptr20595, align 8 
  store volatile i64 %cont7176, i64* %vptr20598, align 8 ; load; *envptr20595
 %vptr20601 = alloca i64, align 8 
  %envptr20599 = inttoptr i64 %env12032 to i64* 
  store volatile i64 %emsg18637, i64* %vptr20601, align 8 ; closure/env cast; i64 -> i64*
  %vptr20602 = alloca i64*, align 8 
  %envptr20600 = getelementptr inbounds i64, i64* %envptr20599, i64 2 
  store volatile i64* %envptr20600, i64** %vptr20602, align 8 ; &envptr20599[1]
 %vptr20603 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr20600, align 8 
  store volatile i64 %emsg18637, i64* %vptr20603, align 8 ; load; *envptr20600
 %vptr20604 = alloca i64, align 8 
  %_957177 = call i64 @prim_car(i64 %rvp9676) 
  store volatile i64 %_957177, i64* %vptr20604, align 8 ; call prim_car
 %vptr20605 = alloca i64, align 8 
  %rvp9672 = call i64 @prim_cdr(i64 %rvp9676) 
  store volatile i64 %rvp9672, i64* %vptr20605, align 8 ; call prim_cdr
 %vptr20606 = alloca i64, align 8 
  %n_639677 = call i64 @prim_null_63(i64 %rvp9672) 
  store volatile i64 %n_639677, i64* %vptr20606, align 8 ; call prim_null_63
  %cmpptr20610 = alloca i1, align 8  %cmp20607 = icmp eq i64 %n_639677, 15 store volatile i1 %cmp20607, i1* %cmpptr20610, align 8; false?
  br i1 %cmp20607, label %else20609, label %then20608                                ; if

then20608:
 %vptr20611 = alloca i64, align 8 
  %h9678 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9678, i64* %vptr20611, align 8 ; call prim_halt
  %vptr20617 = alloca i64*, align 8 
  %cloptr20612 = inttoptr i64 %h9678 to i64* 
  store volatile i64* %cloptr20612, i64** %vptr20617, align 8 ; closure/env cast; i64 -> i64*
  %vptr20618 = alloca i64*, align 8 
  %i0ptr20613 = getelementptr inbounds i64, i64* %cloptr20612, i64 1 
  store volatile i64* %i0ptr20613, i64** %vptr20618, align 8 ; &cloptr20612[1]
 %vptr20619 = alloca i64, align 8 
  %f20615 = load i64, i64* %i0ptr20613, align 8 
  store volatile i64 %f20615, i64* %vptr20619, align 8 ; load; *i0ptr20613
  %fptr20614 = inttoptr i64 %f20615 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20614(i64 %h9678, i64 %h9678)                       ; tail call
  ret void

else20609:
 %vptr20620 = alloca i64, align 8 
  %ghr$_956889 = call i64 @prim_car(i64 %rvp9672) 
  store volatile i64 %ghr$_956889, i64* %vptr20620, align 8 ; call prim_car
 %vptr20621 = alloca i64, align 8 
  %na9656 = call i64 @prim_cdr(i64 %rvp9672) 
  store volatile i64 %na9656, i64* %vptr20621, align 8 ; call prim_cdr
 %vptr20622 = alloca i64, align 8 
  %n_639673 = call i64 @prim_null_63(i64 %na9656) 
  store volatile i64 %n_639673, i64* %vptr20622, align 8 ; call prim_null_63
  %cmpptr20626 = alloca i1, align 8  %cmp20623 = icmp eq i64 %n_639673, 15 store volatile i1 %cmp20623, i1* %cmpptr20626, align 8; false?
  br i1 %cmp20623, label %else20625, label %then20624                                ; if

then20624:
 %vptr20627 = alloca i64, align 8 
  %a7028 = call i64 @prim_car(i64 %jg8$l) 
  store volatile i64 %a7028, i64* %vptr20627, align 8 ; call prim_car
 %vptr20628 = alloca i64, align 8 
  %a7029 = call i64 @prim_car(i64 %a7028) 
  store volatile i64 %a7029, i64* %vptr20628, align 8 ; call prim_car
  %vptr20637 = alloca i64*, align 8 
  %cloptr20629 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr20629, i64** %vptr20637, align 8 ; malloc
  %vptr20638 = alloca i64*, align 8 
  %eptr20631 = getelementptr inbounds i64, i64* %cloptr20629, i64 2 
  store volatile i64* %eptr20631, i64** %vptr20638, align 8 ; &eptr20631[1]
  %vptr20639 = alloca i64*, align 8 
  %eptr20632 = getelementptr inbounds i64, i64* %cloptr20629, i64 3 
  store volatile i64* %eptr20632, i64** %vptr20639, align 8 ; &eptr20632[2]
  %vptr20640 = alloca i64*, align 8 
  %eptr20633 = getelementptr inbounds i64, i64* %cloptr20629, i64 4 
  store volatile i64* %eptr20633, i64** %vptr20640, align 8 ; &eptr20633[3]
  %vptr20641 = alloca i64*, align 8 
  %eptr20634 = getelementptr inbounds i64, i64* %cloptr20629, i64 5 
  store volatile i64* %eptr20634, i64** %vptr20641, align 8 ; &eptr20634[4]
  %vptr20642 = alloca i64*, align 8 
  %eptr20635 = getelementptr inbounds i64, i64* %cloptr20629, i64 6 
  store volatile i64* %eptr20635, i64** %vptr20642, align 8 ; &eptr20635[5]
  store i64 %emsg18637, i64* %eptr20631                                              ; *eptr20631 = %emsg18637
  store i64 %cont7176, i64* %eptr20632                                               ; *eptr20632 = %cont7176
  store i64 %SdC$_37wind_45stack, i64* %eptr20633                                    ; *eptr20633 = %SdC$_37wind_45stack
  store i64 %jg8$l, i64* %eptr20634                                                  ; *eptr20634 = %jg8$l
  store i64 %emsg08636, i64* %eptr20635                                              ; *eptr20635 = %emsg08636
  %vptr20643 = alloca i64*, align 8 
  %eptr20630 = getelementptr inbounds i64, i64* %cloptr20629, i64 1 
  store volatile i64* %eptr20630, i64** %vptr20643, align 8 ; &cloptr20629[1]
 %vptr20644 = alloca i64, align 8 
  %f20636 = ptrtoint void(i64,i64)* @lam12029 to i64 
  store volatile i64 %f20636, i64* %vptr20644, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f20636, i64* %eptr20630                                                 ; store fptr
 %vptr20645 = alloca i64, align 8 
  %arg7973 = ptrtoint i64* %cloptr20629 to i64 
  store volatile i64 %arg7973, i64* %vptr20645, align 8 ; closure cast; i64* -> i64
 %vptr20646 = alloca i64, align 8 
  %rva9671 = add i64 0, 0 
  store volatile i64 %rva9671, i64* %vptr20646, align 8 ; quoted ()
 %vptr20647 = alloca i64, align 8 
  %rva9670 = call i64 @prim_cons(i64 %arg7973, i64 %rva9671) 
  store volatile i64 %rva9670, i64* %vptr20647, align 8 ; call prim_cons
  %vptr20653 = alloca i64*, align 8 
  %cloptr20648 = inttoptr i64 %a7029 to i64* 
  store volatile i64* %cloptr20648, i64** %vptr20653, align 8 ; closure/env cast; i64 -> i64*
  %vptr20654 = alloca i64*, align 8 
  %i0ptr20649 = getelementptr inbounds i64, i64* %cloptr20648, i64 1 
  store volatile i64* %i0ptr20649, i64** %vptr20654, align 8 ; &cloptr20648[1]
 %vptr20655 = alloca i64, align 8 
  %f20651 = load i64, i64* %i0ptr20649, align 8 
  store volatile i64 %f20651, i64* %vptr20655, align 8 ; load; *i0ptr20649
  %fptr20650 = inttoptr i64 %f20651 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20650(i64 %a7029, i64 %rva9670)                     ; tail call
  ret void

else20625:
 %vptr20656 = alloca i64, align 8 
  %h9674 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9674, i64* %vptr20656, align 8 ; call prim_halt
  %vptr20662 = alloca i64*, align 8 
  %cloptr20657 = inttoptr i64 %h9674 to i64* 
  store volatile i64* %cloptr20657, i64** %vptr20662, align 8 ; closure/env cast; i64 -> i64*
  %vptr20663 = alloca i64*, align 8 
  %i0ptr20658 = getelementptr inbounds i64, i64* %cloptr20657, i64 1 
  store volatile i64* %i0ptr20658, i64** %vptr20663, align 8 ; &cloptr20657[1]
 %vptr20664 = alloca i64, align 8 
  %f20660 = load i64, i64* %i0ptr20658, align 8 
  store volatile i64 %f20660, i64* %vptr20664, align 8 ; load; *i0ptr20658
  %fptr20659 = inttoptr i64 %f20660 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20659(i64 %h9674, i64 %h9674)                       ; tail call
  ret void
}


define void @lam12029(i64 %env12030, i64 %rvp9666) {
 %vptr20667 = alloca i64, align 8 
  %envptr20665 = inttoptr i64 %env12030 to i64* 
  store volatile i64 %emsg08636, i64* %vptr20667, align 8 ; closure/env cast; i64 -> i64*
  %vptr20668 = alloca i64*, align 8 
  %envptr20666 = getelementptr inbounds i64, i64* %envptr20665, i64 6 
  store volatile i64* %envptr20666, i64** %vptr20668, align 8 ; &envptr20665[5]
 %vptr20669 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr20666, align 8 
  store volatile i64 %emsg08636, i64* %vptr20669, align 8 ; load; *envptr20666
 %vptr20672 = alloca i64, align 8 
  %envptr20670 = inttoptr i64 %env12030 to i64* 
  store volatile i64 %jg8$l, i64* %vptr20672, align 8 ; closure/env cast; i64 -> i64*
  %vptr20673 = alloca i64*, align 8 
  %envptr20671 = getelementptr inbounds i64, i64* %envptr20670, i64 5 
  store volatile i64* %envptr20671, i64** %vptr20673, align 8 ; &envptr20670[4]
 %vptr20674 = alloca i64, align 8 
  %jg8$l = load i64, i64* %envptr20671, align 8 
  store volatile i64 %jg8$l, i64* %vptr20674, align 8 ; load; *envptr20671
 %vptr20677 = alloca i64, align 8 
  %envptr20675 = inttoptr i64 %env12030 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr20677, align 8 ; closure/env cast; i64 -> i64*
  %vptr20678 = alloca i64*, align 8 
  %envptr20676 = getelementptr inbounds i64, i64* %envptr20675, i64 4 
  store volatile i64* %envptr20676, i64** %vptr20678, align 8 ; &envptr20675[3]
 %vptr20679 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr20676, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr20679, align 8 ; load; *envptr20676
 %vptr20682 = alloca i64, align 8 
  %envptr20680 = inttoptr i64 %env12030 to i64* 
  store volatile i64 %cont7176, i64* %vptr20682, align 8 ; closure/env cast; i64 -> i64*
  %vptr20683 = alloca i64*, align 8 
  %envptr20681 = getelementptr inbounds i64, i64* %envptr20680, i64 3 
  store volatile i64* %envptr20681, i64** %vptr20683, align 8 ; &envptr20680[2]
 %vptr20684 = alloca i64, align 8 
  %cont7176 = load i64, i64* %envptr20681, align 8 
  store volatile i64 %cont7176, i64* %vptr20684, align 8 ; load; *envptr20681
 %vptr20687 = alloca i64, align 8 
  %envptr20685 = inttoptr i64 %env12030 to i64* 
  store volatile i64 %emsg18637, i64* %vptr20687, align 8 ; closure/env cast; i64 -> i64*
  %vptr20688 = alloca i64*, align 8 
  %envptr20686 = getelementptr inbounds i64, i64* %envptr20685, i64 2 
  store volatile i64* %envptr20686, i64** %vptr20688, align 8 ; &envptr20685[1]
 %vptr20689 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr20686, align 8 
  store volatile i64 %emsg18637, i64* %vptr20689, align 8 ; load; *envptr20686
 %vptr20690 = alloca i64, align 8 
  %_957178 = call i64 @prim_car(i64 %rvp9666) 
  store volatile i64 %_957178, i64* %vptr20690, align 8 ; call prim_car
 %vptr20691 = alloca i64, align 8 
  %rvp9662 = call i64 @prim_cdr(i64 %rvp9666) 
  store volatile i64 %rvp9662, i64* %vptr20691, align 8 ; call prim_cdr
 %vptr20692 = alloca i64, align 8 
  %n_639667 = call i64 @prim_null_63(i64 %rvp9662) 
  store volatile i64 %n_639667, i64* %vptr20692, align 8 ; call prim_null_63
  %cmpptr20696 = alloca i1, align 8  %cmp20693 = icmp eq i64 %n_639667, 15 store volatile i1 %cmp20693, i1* %cmpptr20696, align 8; false?
  br i1 %cmp20693, label %else20695, label %then20694                                ; if

then20694:
 %vptr20697 = alloca i64, align 8 
  %h9668 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9668, i64* %vptr20697, align 8 ; call prim_halt
  %vptr20703 = alloca i64*, align 8 
  %cloptr20698 = inttoptr i64 %h9668 to i64* 
  store volatile i64* %cloptr20698, i64** %vptr20703, align 8 ; closure/env cast; i64 -> i64*
  %vptr20704 = alloca i64*, align 8 
  %i0ptr20699 = getelementptr inbounds i64, i64* %cloptr20698, i64 1 
  store volatile i64* %i0ptr20699, i64** %vptr20704, align 8 ; &cloptr20698[1]
 %vptr20705 = alloca i64, align 8 
  %f20701 = load i64, i64* %i0ptr20699, align 8 
  store volatile i64 %f20701, i64* %vptr20705, align 8 ; load; *i0ptr20699
  %fptr20700 = inttoptr i64 %f20701 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20700(i64 %h9668, i64 %h9668)                       ; tail call
  ret void

else20695:
 %vptr20706 = alloca i64, align 8 
  %kTw$_956890 = call i64 @prim_car(i64 %rvp9662) 
  store volatile i64 %kTw$_956890, i64* %vptr20706, align 8 ; call prim_car
 %vptr20707 = alloca i64, align 8 
  %na9658 = call i64 @prim_cdr(i64 %rvp9662) 
  store volatile i64 %na9658, i64* %vptr20707, align 8 ; call prim_cdr
 %vptr20708 = alloca i64, align 8 
  %n_639663 = call i64 @prim_null_63(i64 %na9658) 
  store volatile i64 %n_639663, i64* %vptr20708, align 8 ; call prim_null_63
  %cmpptr20712 = alloca i1, align 8  %cmp20709 = icmp eq i64 %n_639663, 15 store volatile i1 %cmp20709, i1* %cmpptr20712, align 8; false?
  br i1 %cmp20709, label %else20711, label %then20710                                ; if

then20710:
 %vptr20713 = alloca i64, align 8 
  %arg7976 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg7976, i64* %vptr20713, align 8 ; quoted int
 %vptr20714 = alloca i64, align 8 
  %retprim7179 = call i64 @prim_vector_45set_33(i64 %SdC$_37wind_45stack, i64 %arg7976, i64 %jg8$l) 
  store volatile i64 %retprim7179, i64* %vptr20714, align 8 ; call prim_vector_45set_33
 %vptr20715 = alloca i64, align 8 
  %arg7979 = add i64 0, 0 
  store volatile i64 %arg7979, i64* %vptr20715, align 8 ; quoted ()
 %vptr20716 = alloca i64, align 8 
  %rva9661 = add i64 0, 0 
  store volatile i64 %rva9661, i64* %vptr20716, align 8 ; quoted ()
 %vptr20717 = alloca i64, align 8 
  %rva9660 = call i64 @prim_cons(i64 %retprim7179, i64 %rva9661) 
  store volatile i64 %rva9660, i64* %vptr20717, align 8 ; call prim_cons
 %vptr20718 = alloca i64, align 8 
  %rva9659 = call i64 @prim_cons(i64 %arg7979, i64 %rva9660) 
  store volatile i64 %rva9659, i64* %vptr20718, align 8 ; call prim_cons
  %vptr20724 = alloca i64*, align 8 
  %cloptr20719 = inttoptr i64 %cont7176 to i64* 
  store volatile i64* %cloptr20719, i64** %vptr20724, align 8 ; closure/env cast; i64 -> i64*
  %vptr20725 = alloca i64*, align 8 
  %i0ptr20720 = getelementptr inbounds i64, i64* %cloptr20719, i64 1 
  store volatile i64* %i0ptr20720, i64** %vptr20725, align 8 ; &cloptr20719[1]
 %vptr20726 = alloca i64, align 8 
  %f20722 = load i64, i64* %i0ptr20720, align 8 
  store volatile i64 %f20722, i64* %vptr20726, align 8 ; load; *i0ptr20720
  %fptr20721 = inttoptr i64 %f20722 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20721(i64 %cont7176, i64 %rva9659)                  ; tail call
  ret void

else20711:
 %vptr20727 = alloca i64, align 8 
  %h9664 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9664, i64* %vptr20727, align 8 ; call prim_halt
  %vptr20733 = alloca i64*, align 8 
  %cloptr20728 = inttoptr i64 %h9664 to i64* 
  store volatile i64* %cloptr20728, i64** %vptr20733, align 8 ; closure/env cast; i64 -> i64*
  %vptr20734 = alloca i64*, align 8 
  %i0ptr20729 = getelementptr inbounds i64, i64* %cloptr20728, i64 1 
  store volatile i64* %i0ptr20729, i64** %vptr20734, align 8 ; &cloptr20728[1]
 %vptr20735 = alloca i64, align 8 
  %f20731 = load i64, i64* %i0ptr20729, align 8 
  store volatile i64 %f20731, i64* %vptr20735, align 8 ; load; *i0ptr20729
  %fptr20730 = inttoptr i64 %f20731 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20730(i64 %h9664, i64 %h9664)                       ; tail call
  ret void
}


define void @lam12012(i64 %env12013, i64 %i3n$lst7281) {
 %vptr20736 = alloca i64, align 8 
  %cont7280 = call i64 @prim_car(i64 %i3n$lst7281) 
  store volatile i64 %cont7280, i64* %vptr20736, align 8 ; call prim_car
 %vptr20737 = alloca i64, align 8 
  %i3n$lst = call i64 @prim_cdr(i64 %i3n$lst7281) 
  store volatile i64 %i3n$lst, i64* %vptr20737, align 8 ; call prim_cdr
 %vptr20738 = alloca i64, align 8 
  %arg7994 = add i64 0, 0 
  store volatile i64 %arg7994, i64* %vptr20738, align 8 ; quoted ()
 %vptr20739 = alloca i64, align 8 
  %rva9772 = add i64 0, 0 
  store volatile i64 %rva9772, i64* %vptr20739, align 8 ; quoted ()
 %vptr20740 = alloca i64, align 8 
  %rva9771 = call i64 @prim_cons(i64 %i3n$lst, i64 %rva9772) 
  store volatile i64 %rva9771, i64* %vptr20740, align 8 ; call prim_cons
 %vptr20741 = alloca i64, align 8 
  %rva9770 = call i64 @prim_cons(i64 %arg7994, i64 %rva9771) 
  store volatile i64 %rva9770, i64* %vptr20741, align 8 ; call prim_cons
  %vptr20747 = alloca i64*, align 8 
  %cloptr20742 = inttoptr i64 %cont7280 to i64* 
  store volatile i64* %cloptr20742, i64** %vptr20747, align 8 ; closure/env cast; i64 -> i64*
  %vptr20748 = alloca i64*, align 8 
  %i0ptr20743 = getelementptr inbounds i64, i64* %cloptr20742, i64 1 
  store volatile i64* %i0ptr20743, i64** %vptr20748, align 8 ; &cloptr20742[1]
 %vptr20749 = alloca i64, align 8 
  %f20745 = load i64, i64* %i0ptr20743, align 8 
  store volatile i64 %f20745, i64* %vptr20749, align 8 ; load; *i0ptr20743
  %fptr20744 = inttoptr i64 %f20745 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20744(i64 %cont7280, i64 %rva9770)                  ; tail call
  ret void
}


define void @lam12008(i64 %env12009, i64 %rvp10697) {
 %vptr20752 = alloca i64, align 8 
  %envptr20750 = inttoptr i64 %env12009 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr20752, align 8 ; closure/env cast; i64 -> i64*
  %vptr20753 = alloca i64*, align 8 
  %envptr20751 = getelementptr inbounds i64, i64* %envptr20750, i64 5 
  store volatile i64* %envptr20751, i64** %vptr20753, align 8 ; &envptr20750[4]
 %vptr20754 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr20751, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr20754, align 8 ; load; *envptr20751
 %vptr20757 = alloca i64, align 8 
  %envptr20755 = inttoptr i64 %env12009 to i64* 
  store volatile i64 %emsg08636, i64* %vptr20757, align 8 ; closure/env cast; i64 -> i64*
  %vptr20758 = alloca i64*, align 8 
  %envptr20756 = getelementptr inbounds i64, i64* %envptr20755, i64 4 
  store volatile i64* %envptr20756, i64** %vptr20758, align 8 ; &envptr20755[3]
 %vptr20759 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr20756, align 8 
  store volatile i64 %emsg08636, i64* %vptr20759, align 8 ; load; *envptr20756
 %vptr20762 = alloca i64, align 8 
  %envptr20760 = inttoptr i64 %env12009 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr20762, align 8 ; closure/env cast; i64 -> i64*
  %vptr20763 = alloca i64*, align 8 
  %envptr20761 = getelementptr inbounds i64, i64* %envptr20760, i64 3 
  store volatile i64* %envptr20761, i64** %vptr20763, align 8 ; &envptr20760[2]
 %vptr20764 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr20761, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr20764, align 8 ; load; *envptr20761
 %vptr20767 = alloca i64, align 8 
  %envptr20765 = inttoptr i64 %env12009 to i64* 
  store volatile i64 %emsg18637, i64* %vptr20767, align 8 ; closure/env cast; i64 -> i64*
  %vptr20768 = alloca i64*, align 8 
  %envptr20766 = getelementptr inbounds i64, i64* %envptr20765, i64 2 
  store volatile i64* %envptr20766, i64** %vptr20768, align 8 ; &envptr20765[1]
 %vptr20769 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr20766, align 8 
  store volatile i64 %emsg18637, i64* %vptr20769, align 8 ; load; *envptr20766
 %vptr20770 = alloca i64, align 8 
  %_957278 = call i64 @prim_car(i64 %rvp10697) 
  store volatile i64 %_957278, i64* %vptr20770, align 8 ; call prim_car
 %vptr20771 = alloca i64, align 8 
  %rvp10693 = call i64 @prim_cdr(i64 %rvp10697) 
  store volatile i64 %rvp10693, i64* %vptr20771, align 8 ; call prim_cdr
 %vptr20772 = alloca i64, align 8 
  %n_6310698 = call i64 @prim_null_63(i64 %rvp10693) 
  store volatile i64 %n_6310698, i64* %vptr20772, align 8 ; call prim_null_63
  %cmpptr20776 = alloca i1, align 8  %cmp20773 = icmp eq i64 %n_6310698, 15 store volatile i1 %cmp20773, i1* %cmpptr20776, align 8; false?
  br i1 %cmp20773, label %else20775, label %then20774                                ; if

then20774:
 %vptr20777 = alloca i64, align 8 
  %h10699 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10699, i64* %vptr20777, align 8 ; call prim_halt
  %vptr20783 = alloca i64*, align 8 
  %cloptr20778 = inttoptr i64 %h10699 to i64* 
  store volatile i64* %cloptr20778, i64** %vptr20783, align 8 ; closure/env cast; i64 -> i64*
  %vptr20784 = alloca i64*, align 8 
  %i0ptr20779 = getelementptr inbounds i64, i64* %cloptr20778, i64 1 
  store volatile i64* %i0ptr20779, i64** %vptr20784, align 8 ; &cloptr20778[1]
 %vptr20785 = alloca i64, align 8 
  %f20781 = load i64, i64* %i0ptr20779, align 8 
  store volatile i64 %f20781, i64* %vptr20785, align 8 ; load; *i0ptr20779
  %fptr20780 = inttoptr i64 %f20781 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20780(i64 %h10699, i64 %h10699)                     ; tail call
  ret void

else20775:
 %vptr20786 = alloca i64, align 8 
  %a7031 = call i64 @prim_car(i64 %rvp10693) 
  store volatile i64 %a7031, i64* %vptr20786, align 8 ; call prim_car
 %vptr20787 = alloca i64, align 8 
  %na9774 = call i64 @prim_cdr(i64 %rvp10693) 
  store volatile i64 %na9774, i64* %vptr20787, align 8 ; call prim_cdr
 %vptr20788 = alloca i64, align 8 
  %n_6310694 = call i64 @prim_null_63(i64 %na9774) 
  store volatile i64 %n_6310694, i64* %vptr20788, align 8 ; call prim_null_63
  %cmpptr20792 = alloca i1, align 8  %cmp20789 = icmp eq i64 %n_6310694, 15 store volatile i1 %cmp20789, i1* %cmpptr20792, align 8; false?
  br i1 %cmp20789, label %else20791, label %then20790                                ; if

then20790:
 %vptr20793 = alloca i64, align 8 
  %arg7997 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg7997, i64* %vptr20793, align 8 ; quoted int
 %vptr20794 = alloca i64, align 8 
  %retprim7279 = call i64 @prim_make_45vector(i64 %arg7997, i64 %a7031) 
  store volatile i64 %retprim7279, i64* %vptr20794, align 8 ; call prim_make_45vector
  %vptr20802 = alloca i64*, align 8 
  %cloptr20795 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr20795, i64** %vptr20802, align 8 ; malloc
  %vptr20803 = alloca i64*, align 8 
  %eptr20797 = getelementptr inbounds i64, i64* %cloptr20795, i64 2 
  store volatile i64* %eptr20797, i64** %vptr20803, align 8 ; &eptr20797[1]
  %vptr20804 = alloca i64*, align 8 
  %eptr20798 = getelementptr inbounds i64, i64* %cloptr20795, i64 3 
  store volatile i64* %eptr20798, i64** %vptr20804, align 8 ; &eptr20798[2]
  %vptr20805 = alloca i64*, align 8 
  %eptr20799 = getelementptr inbounds i64, i64* %cloptr20795, i64 4 
  store volatile i64* %eptr20799, i64** %vptr20805, align 8 ; &eptr20799[3]
  %vptr20806 = alloca i64*, align 8 
  %eptr20800 = getelementptr inbounds i64, i64* %cloptr20795, i64 5 
  store volatile i64* %eptr20800, i64** %vptr20806, align 8 ; &eptr20800[4]
  store i64 %emsg18637, i64* %eptr20797                                              ; *eptr20797 = %emsg18637
  store i64 %SdC$_37wind_45stack, i64* %eptr20798                                    ; *eptr20798 = %SdC$_37wind_45stack
  store i64 %emsg08636, i64* %eptr20799                                              ; *eptr20799 = %emsg08636
  store i64 %U8g$_37do_45wind, i64* %eptr20800                                       ; *eptr20800 = %U8g$_37do_45wind
  %vptr20807 = alloca i64*, align 8 
  %eptr20796 = getelementptr inbounds i64, i64* %cloptr20795, i64 1 
  store volatile i64* %eptr20796, i64** %vptr20807, align 8 ; &cloptr20795[1]
 %vptr20808 = alloca i64, align 8 
  %f20801 = ptrtoint void(i64,i64)* @lam12005 to i64 
  store volatile i64 %f20801, i64* %vptr20808, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f20801, i64* %eptr20796                                                 ; store fptr
 %vptr20809 = alloca i64, align 8 
  %arg8000 = ptrtoint i64* %cloptr20795 to i64 
  store volatile i64 %arg8000, i64* %vptr20809, align 8 ; closure cast; i64* -> i64
 %vptr20810 = alloca i64, align 8 
  %arg7999 = add i64 0, 0 
  store volatile i64 %arg7999, i64* %vptr20810, align 8 ; quoted ()
 %vptr20811 = alloca i64, align 8 
  %rva10692 = add i64 0, 0 
  store volatile i64 %rva10692, i64* %vptr20811, align 8 ; quoted ()
 %vptr20812 = alloca i64, align 8 
  %rva10691 = call i64 @prim_cons(i64 %retprim7279, i64 %rva10692) 
  store volatile i64 %rva10691, i64* %vptr20812, align 8 ; call prim_cons
 %vptr20813 = alloca i64, align 8 
  %rva10690 = call i64 @prim_cons(i64 %arg7999, i64 %rva10691) 
  store volatile i64 %rva10690, i64* %vptr20813, align 8 ; call prim_cons
  %vptr20819 = alloca i64*, align 8 
  %cloptr20814 = inttoptr i64 %arg8000 to i64* 
  store volatile i64* %cloptr20814, i64** %vptr20819, align 8 ; closure/env cast; i64 -> i64*
  %vptr20820 = alloca i64*, align 8 
  %i0ptr20815 = getelementptr inbounds i64, i64* %cloptr20814, i64 1 
  store volatile i64* %i0ptr20815, i64** %vptr20820, align 8 ; &cloptr20814[1]
 %vptr20821 = alloca i64, align 8 
  %f20817 = load i64, i64* %i0ptr20815, align 8 
  store volatile i64 %f20817, i64* %vptr20821, align 8 ; load; *i0ptr20815
  %fptr20816 = inttoptr i64 %f20817 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20816(i64 %arg8000, i64 %rva10690)                  ; tail call
  ret void

else20791:
 %vptr20822 = alloca i64, align 8 
  %h10695 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10695, i64* %vptr20822, align 8 ; call prim_halt
  %vptr20828 = alloca i64*, align 8 
  %cloptr20823 = inttoptr i64 %h10695 to i64* 
  store volatile i64* %cloptr20823, i64** %vptr20828, align 8 ; closure/env cast; i64 -> i64*
  %vptr20829 = alloca i64*, align 8 
  %i0ptr20824 = getelementptr inbounds i64, i64* %cloptr20823, i64 1 
  store volatile i64* %i0ptr20824, i64** %vptr20829, align 8 ; &cloptr20823[1]
 %vptr20830 = alloca i64, align 8 
  %f20826 = load i64, i64* %i0ptr20824, align 8 
  store volatile i64 %f20826, i64* %vptr20830, align 8 ; load; *i0ptr20824
  %fptr20825 = inttoptr i64 %f20826 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20825(i64 %h10695, i64 %h10695)                     ; tail call
  ret void
}


define void @lam12005(i64 %env12006, i64 %rvp10686) {
 %vptr20833 = alloca i64, align 8 
  %envptr20831 = inttoptr i64 %env12006 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr20833, align 8 ; closure/env cast; i64 -> i64*
  %vptr20834 = alloca i64*, align 8 
  %envptr20832 = getelementptr inbounds i64, i64* %envptr20831, i64 5 
  store volatile i64* %envptr20832, i64** %vptr20834, align 8 ; &envptr20831[4]
 %vptr20835 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr20832, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr20835, align 8 ; load; *envptr20832
 %vptr20838 = alloca i64, align 8 
  %envptr20836 = inttoptr i64 %env12006 to i64* 
  store volatile i64 %emsg08636, i64* %vptr20838, align 8 ; closure/env cast; i64 -> i64*
  %vptr20839 = alloca i64*, align 8 
  %envptr20837 = getelementptr inbounds i64, i64* %envptr20836, i64 4 
  store volatile i64* %envptr20837, i64** %vptr20839, align 8 ; &envptr20836[3]
 %vptr20840 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr20837, align 8 
  store volatile i64 %emsg08636, i64* %vptr20840, align 8 ; load; *envptr20837
 %vptr20843 = alloca i64, align 8 
  %envptr20841 = inttoptr i64 %env12006 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr20843, align 8 ; closure/env cast; i64 -> i64*
  %vptr20844 = alloca i64*, align 8 
  %envptr20842 = getelementptr inbounds i64, i64* %envptr20841, i64 3 
  store volatile i64* %envptr20842, i64** %vptr20844, align 8 ; &envptr20841[2]
 %vptr20845 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr20842, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr20845, align 8 ; load; *envptr20842
 %vptr20848 = alloca i64, align 8 
  %envptr20846 = inttoptr i64 %env12006 to i64* 
  store volatile i64 %emsg18637, i64* %vptr20848, align 8 ; closure/env cast; i64 -> i64*
  %vptr20849 = alloca i64*, align 8 
  %envptr20847 = getelementptr inbounds i64, i64* %envptr20846, i64 2 
  store volatile i64* %envptr20847, i64** %vptr20849, align 8 ; &envptr20846[1]
 %vptr20850 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr20847, align 8 
  store volatile i64 %emsg18637, i64* %vptr20850, align 8 ; load; *envptr20847
 %vptr20851 = alloca i64, align 8 
  %_957195 = call i64 @prim_car(i64 %rvp10686) 
  store volatile i64 %_957195, i64* %vptr20851, align 8 ; call prim_car
 %vptr20852 = alloca i64, align 8 
  %rvp10682 = call i64 @prim_cdr(i64 %rvp10686) 
  store volatile i64 %rvp10682, i64* %vptr20852, align 8 ; call prim_cdr
 %vptr20853 = alloca i64, align 8 
  %n_6310687 = call i64 @prim_null_63(i64 %rvp10682) 
  store volatile i64 %n_6310687, i64* %vptr20853, align 8 ; call prim_null_63
  %cmpptr20857 = alloca i1, align 8  %cmp20854 = icmp eq i64 %n_6310687, 15 store volatile i1 %cmp20854, i1* %cmpptr20857, align 8; false?
  br i1 %cmp20854, label %else20856, label %then20855                                ; if

then20855:
 %vptr20858 = alloca i64, align 8 
  %h10688 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10688, i64* %vptr20858, align 8 ; call prim_halt
  %vptr20864 = alloca i64*, align 8 
  %cloptr20859 = inttoptr i64 %h10688 to i64* 
  store volatile i64* %cloptr20859, i64** %vptr20864, align 8 ; closure/env cast; i64 -> i64*
  %vptr20865 = alloca i64*, align 8 
  %i0ptr20860 = getelementptr inbounds i64, i64* %cloptr20859, i64 1 
  store volatile i64* %i0ptr20860, i64** %vptr20865, align 8 ; &cloptr20859[1]
 %vptr20866 = alloca i64, align 8 
  %f20862 = load i64, i64* %i0ptr20860, align 8 
  store volatile i64 %f20862, i64* %vptr20866, align 8 ; load; *i0ptr20860
  %fptr20861 = inttoptr i64 %f20862 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20861(i64 %h10688, i64 %h10688)                     ; tail call
  ret void

else20856:
 %vptr20867 = alloca i64, align 8 
  %bmP$nat_45_62peano = call i64 @prim_car(i64 %rvp10682) 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr20867, align 8 ; call prim_car
 %vptr20868 = alloca i64, align 8 
  %na9776 = call i64 @prim_cdr(i64 %rvp10682) 
  store volatile i64 %na9776, i64* %vptr20868, align 8 ; call prim_cdr
 %vptr20869 = alloca i64, align 8 
  %n_6310683 = call i64 @prim_null_63(i64 %na9776) 
  store volatile i64 %n_6310683, i64* %vptr20869, align 8 ; call prim_null_63
  %cmpptr20873 = alloca i1, align 8  %cmp20870 = icmp eq i64 %n_6310683, 15 store volatile i1 %cmp20870, i1* %cmpptr20873, align 8; false?
  br i1 %cmp20870, label %else20872, label %then20871                                ; if

then20871:
  %vptr20877 = alloca i64*, align 8 
  %cloptr20874 = call i64* @make_closure(i64 8) 
  store volatile i64* %cloptr20874, i64** %vptr20877, align 8 ; malloc
  %vptr20878 = alloca i64*, align 8 
  %eptr20875 = getelementptr inbounds i64, i64* %cloptr20874, i64 1 
  store volatile i64* %eptr20875, i64** %vptr20878, align 8 ; &cloptr20874[1]
 %vptr20879 = alloca i64, align 8 
  %f20876 = ptrtoint void(i64,i64)* @lam12003 to i64 
  store volatile i64 %f20876, i64* %vptr20879, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f20876, i64* %eptr20875                                                 ; store fptr
 %vptr20880 = alloca i64, align 8 
  %arg8002 = ptrtoint i64* %cloptr20874 to i64 
  store volatile i64 %arg8002, i64* %vptr20880, align 8 ; closure cast; i64* -> i64
  %vptr20889 = alloca i64*, align 8 
  %cloptr20881 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr20881, i64** %vptr20889, align 8 ; malloc
  %vptr20890 = alloca i64*, align 8 
  %eptr20883 = getelementptr inbounds i64, i64* %cloptr20881, i64 2 
  store volatile i64* %eptr20883, i64** %vptr20890, align 8 ; &eptr20883[1]
  %vptr20891 = alloca i64*, align 8 
  %eptr20884 = getelementptr inbounds i64, i64* %cloptr20881, i64 3 
  store volatile i64* %eptr20884, i64** %vptr20891, align 8 ; &eptr20884[2]
  %vptr20892 = alloca i64*, align 8 
  %eptr20885 = getelementptr inbounds i64, i64* %cloptr20881, i64 4 
  store volatile i64* %eptr20885, i64** %vptr20892, align 8 ; &eptr20885[3]
  %vptr20893 = alloca i64*, align 8 
  %eptr20886 = getelementptr inbounds i64, i64* %cloptr20881, i64 5 
  store volatile i64* %eptr20886, i64** %vptr20893, align 8 ; &eptr20886[4]
  %vptr20894 = alloca i64*, align 8 
  %eptr20887 = getelementptr inbounds i64, i64* %cloptr20881, i64 6 
  store volatile i64* %eptr20887, i64** %vptr20894, align 8 ; &eptr20887[5]
  store i64 %bmP$nat_45_62peano, i64* %eptr20883                                     ; *eptr20883 = %bmP$nat_45_62peano
  store i64 %emsg18637, i64* %eptr20884                                              ; *eptr20884 = %emsg18637
  store i64 %SdC$_37wind_45stack, i64* %eptr20885                                    ; *eptr20885 = %SdC$_37wind_45stack
  store i64 %emsg08636, i64* %eptr20886                                              ; *eptr20886 = %emsg08636
  store i64 %U8g$_37do_45wind, i64* %eptr20887                                       ; *eptr20887 = %U8g$_37do_45wind
  %vptr20895 = alloca i64*, align 8 
  %eptr20882 = getelementptr inbounds i64, i64* %cloptr20881, i64 1 
  store volatile i64* %eptr20882, i64** %vptr20895, align 8 ; &cloptr20881[1]
 %vptr20896 = alloca i64, align 8 
  %f20888 = ptrtoint void(i64,i64)* @lam11999 to i64 
  store volatile i64 %f20888, i64* %vptr20896, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f20888, i64* %eptr20882                                                 ; store fptr
 %vptr20897 = alloca i64, align 8 
  %arg8001 = ptrtoint i64* %cloptr20881 to i64 
  store volatile i64 %arg8001, i64* %vptr20897, align 8 ; closure cast; i64* -> i64
 %vptr20898 = alloca i64, align 8 
  %rva10681 = add i64 0, 0 
  store volatile i64 %rva10681, i64* %vptr20898, align 8 ; quoted ()
 %vptr20899 = alloca i64, align 8 
  %rva10680 = call i64 @prim_cons(i64 %arg8001, i64 %rva10681) 
  store volatile i64 %rva10680, i64* %vptr20899, align 8 ; call prim_cons
  %vptr20905 = alloca i64*, align 8 
  %cloptr20900 = inttoptr i64 %arg8002 to i64* 
  store volatile i64* %cloptr20900, i64** %vptr20905, align 8 ; closure/env cast; i64 -> i64*
  %vptr20906 = alloca i64*, align 8 
  %i0ptr20901 = getelementptr inbounds i64, i64* %cloptr20900, i64 1 
  store volatile i64* %i0ptr20901, i64** %vptr20906, align 8 ; &cloptr20900[1]
 %vptr20907 = alloca i64, align 8 
  %f20903 = load i64, i64* %i0ptr20901, align 8 
  store volatile i64 %f20903, i64* %vptr20907, align 8 ; load; *i0ptr20901
  %fptr20902 = inttoptr i64 %f20903 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20902(i64 %arg8002, i64 %rva10680)                  ; tail call
  ret void

else20872:
 %vptr20908 = alloca i64, align 8 
  %h10684 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10684, i64* %vptr20908, align 8 ; call prim_halt
  %vptr20914 = alloca i64*, align 8 
  %cloptr20909 = inttoptr i64 %h10684 to i64* 
  store volatile i64* %cloptr20909, i64** %vptr20914, align 8 ; closure/env cast; i64 -> i64*
  %vptr20915 = alloca i64*, align 8 
  %i0ptr20910 = getelementptr inbounds i64, i64* %cloptr20909, i64 1 
  store volatile i64* %i0ptr20910, i64** %vptr20915, align 8 ; &cloptr20909[1]
 %vptr20916 = alloca i64, align 8 
  %f20912 = load i64, i64* %i0ptr20910, align 8 
  store volatile i64 %f20912, i64* %vptr20916, align 8 ; load; *i0ptr20910
  %fptr20911 = inttoptr i64 %f20912 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20911(i64 %h10684, i64 %h10684)                     ; tail call
  ret void
}


define void @lam12003(i64 %env12004, i64 %hhG$lst7277) {
 %vptr20917 = alloca i64, align 8 
  %cont7276 = call i64 @prim_car(i64 %hhG$lst7277) 
  store volatile i64 %cont7276, i64* %vptr20917, align 8 ; call prim_car
 %vptr20918 = alloca i64, align 8 
  %hhG$lst = call i64 @prim_cdr(i64 %hhG$lst7277) 
  store volatile i64 %hhG$lst, i64* %vptr20918, align 8 ; call prim_cdr
 %vptr20919 = alloca i64, align 8 
  %arg8006 = add i64 0, 0 
  store volatile i64 %arg8006, i64* %vptr20919, align 8 ; quoted ()
 %vptr20920 = alloca i64, align 8 
  %rva9779 = add i64 0, 0 
  store volatile i64 %rva9779, i64* %vptr20920, align 8 ; quoted ()
 %vptr20921 = alloca i64, align 8 
  %rva9778 = call i64 @prim_cons(i64 %hhG$lst, i64 %rva9779) 
  store volatile i64 %rva9778, i64* %vptr20921, align 8 ; call prim_cons
 %vptr20922 = alloca i64, align 8 
  %rva9777 = call i64 @prim_cons(i64 %arg8006, i64 %rva9778) 
  store volatile i64 %rva9777, i64* %vptr20922, align 8 ; call prim_cons
  %vptr20928 = alloca i64*, align 8 
  %cloptr20923 = inttoptr i64 %cont7276 to i64* 
  store volatile i64* %cloptr20923, i64** %vptr20928, align 8 ; closure/env cast; i64 -> i64*
  %vptr20929 = alloca i64*, align 8 
  %i0ptr20924 = getelementptr inbounds i64, i64* %cloptr20923, i64 1 
  store volatile i64* %i0ptr20924, i64** %vptr20929, align 8 ; &cloptr20923[1]
 %vptr20930 = alloca i64, align 8 
  %f20926 = load i64, i64* %i0ptr20924, align 8 
  store volatile i64 %f20926, i64* %vptr20930, align 8 ; load; *i0ptr20924
  %fptr20925 = inttoptr i64 %f20926 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20925(i64 %cont7276, i64 %rva9777)                  ; tail call
  ret void
}


define void @lam11999(i64 %env12000, i64 %rvp10676) {
 %vptr20933 = alloca i64, align 8 
  %envptr20931 = inttoptr i64 %env12000 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr20933, align 8 ; closure/env cast; i64 -> i64*
  %vptr20934 = alloca i64*, align 8 
  %envptr20932 = getelementptr inbounds i64, i64* %envptr20931, i64 6 
  store volatile i64* %envptr20932, i64** %vptr20934, align 8 ; &envptr20931[5]
 %vptr20935 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr20932, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr20935, align 8 ; load; *envptr20932
 %vptr20938 = alloca i64, align 8 
  %envptr20936 = inttoptr i64 %env12000 to i64* 
  store volatile i64 %emsg08636, i64* %vptr20938, align 8 ; closure/env cast; i64 -> i64*
  %vptr20939 = alloca i64*, align 8 
  %envptr20937 = getelementptr inbounds i64, i64* %envptr20936, i64 5 
  store volatile i64* %envptr20937, i64** %vptr20939, align 8 ; &envptr20936[4]
 %vptr20940 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr20937, align 8 
  store volatile i64 %emsg08636, i64* %vptr20940, align 8 ; load; *envptr20937
 %vptr20943 = alloca i64, align 8 
  %envptr20941 = inttoptr i64 %env12000 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr20943, align 8 ; closure/env cast; i64 -> i64*
  %vptr20944 = alloca i64*, align 8 
  %envptr20942 = getelementptr inbounds i64, i64* %envptr20941, i64 4 
  store volatile i64* %envptr20942, i64** %vptr20944, align 8 ; &envptr20941[3]
 %vptr20945 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr20942, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr20945, align 8 ; load; *envptr20942
 %vptr20948 = alloca i64, align 8 
  %envptr20946 = inttoptr i64 %env12000 to i64* 
  store volatile i64 %emsg18637, i64* %vptr20948, align 8 ; closure/env cast; i64 -> i64*
  %vptr20949 = alloca i64*, align 8 
  %envptr20947 = getelementptr inbounds i64, i64* %envptr20946, i64 3 
  store volatile i64* %envptr20947, i64** %vptr20949, align 8 ; &envptr20946[2]
 %vptr20950 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr20947, align 8 
  store volatile i64 %emsg18637, i64* %vptr20950, align 8 ; load; *envptr20947
 %vptr20953 = alloca i64, align 8 
  %envptr20951 = inttoptr i64 %env12000 to i64* 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr20953, align 8 ; closure/env cast; i64 -> i64*
  %vptr20954 = alloca i64*, align 8 
  %envptr20952 = getelementptr inbounds i64, i64* %envptr20951, i64 2 
  store volatile i64* %envptr20952, i64** %vptr20954, align 8 ; &envptr20951[1]
 %vptr20955 = alloca i64, align 8 
  %bmP$nat_45_62peano = load i64, i64* %envptr20952, align 8 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr20955, align 8 ; load; *envptr20952
 %vptr20956 = alloca i64, align 8 
  %_957274 = call i64 @prim_car(i64 %rvp10676) 
  store volatile i64 %_957274, i64* %vptr20956, align 8 ; call prim_car
 %vptr20957 = alloca i64, align 8 
  %rvp10672 = call i64 @prim_cdr(i64 %rvp10676) 
  store volatile i64 %rvp10672, i64* %vptr20957, align 8 ; call prim_cdr
 %vptr20958 = alloca i64, align 8 
  %n_6310677 = call i64 @prim_null_63(i64 %rvp10672) 
  store volatile i64 %n_6310677, i64* %vptr20958, align 8 ; call prim_null_63
  %cmpptr20962 = alloca i1, align 8  %cmp20959 = icmp eq i64 %n_6310677, 15 store volatile i1 %cmp20959, i1* %cmpptr20962, align 8; false?
  br i1 %cmp20959, label %else20961, label %then20960                                ; if

then20960:
 %vptr20963 = alloca i64, align 8 
  %h10678 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10678, i64* %vptr20963, align 8 ; call prim_halt
  %vptr20969 = alloca i64*, align 8 
  %cloptr20964 = inttoptr i64 %h10678 to i64* 
  store volatile i64* %cloptr20964, i64** %vptr20969, align 8 ; closure/env cast; i64 -> i64*
  %vptr20970 = alloca i64*, align 8 
  %i0ptr20965 = getelementptr inbounds i64, i64* %cloptr20964, i64 1 
  store volatile i64* %i0ptr20965, i64** %vptr20970, align 8 ; &cloptr20964[1]
 %vptr20971 = alloca i64, align 8 
  %f20967 = load i64, i64* %i0ptr20965, align 8 
  store volatile i64 %f20967, i64* %vptr20971, align 8 ; load; *i0ptr20965
  %fptr20966 = inttoptr i64 %f20967 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr20966(i64 %h10678, i64 %h10678)                     ; tail call
  ret void

else20961:
 %vptr20972 = alloca i64, align 8 
  %a7032 = call i64 @prim_car(i64 %rvp10672) 
  store volatile i64 %a7032, i64* %vptr20972, align 8 ; call prim_car
 %vptr20973 = alloca i64, align 8 
  %na9781 = call i64 @prim_cdr(i64 %rvp10672) 
  store volatile i64 %na9781, i64* %vptr20973, align 8 ; call prim_cdr
 %vptr20974 = alloca i64, align 8 
  %n_6310673 = call i64 @prim_null_63(i64 %na9781) 
  store volatile i64 %n_6310673, i64* %vptr20974, align 8 ; call prim_null_63
  %cmpptr20978 = alloca i1, align 8  %cmp20975 = icmp eq i64 %n_6310673, 15 store volatile i1 %cmp20975, i1* %cmpptr20978, align 8; false?
  br i1 %cmp20975, label %else20977, label %then20976                                ; if

then20976:
 %vptr20979 = alloca i64, align 8 
  %arg8009 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg8009, i64* %vptr20979, align 8 ; quoted int
 %vptr20980 = alloca i64, align 8 
  %retprim7275 = call i64 @prim_make_45vector(i64 %arg8009, i64 %a7032) 
  store volatile i64 %retprim7275, i64* %vptr20980, align 8 ; call prim_make_45vector
  %vptr20989 = alloca i64*, align 8 
  %cloptr20981 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr20981, i64** %vptr20989, align 8 ; malloc
  %vptr20990 = alloca i64*, align 8 
  %eptr20983 = getelementptr inbounds i64, i64* %cloptr20981, i64 2 
  store volatile i64* %eptr20983, i64** %vptr20990, align 8 ; &eptr20983[1]
  %vptr20991 = alloca i64*, align 8 
  %eptr20984 = getelementptr inbounds i64, i64* %cloptr20981, i64 3 
  store volatile i64* %eptr20984, i64** %vptr20991, align 8 ; &eptr20984[2]
  %vptr20992 = alloca i64*, align 8 
  %eptr20985 = getelementptr inbounds i64, i64* %cloptr20981, i64 4 
  store volatile i64* %eptr20985, i64** %vptr20992, align 8 ; &eptr20985[3]
  %vptr20993 = alloca i64*, align 8 
  %eptr20986 = getelementptr inbounds i64, i64* %cloptr20981, i64 5 
  store volatile i64* %eptr20986, i64** %vptr20993, align 8 ; &eptr20986[4]
  %vptr20994 = alloca i64*, align 8 
  %eptr20987 = getelementptr inbounds i64, i64* %cloptr20981, i64 6 
  store volatile i64* %eptr20987, i64** %vptr20994, align 8 ; &eptr20987[5]
  store i64 %bmP$nat_45_62peano, i64* %eptr20983                                     ; *eptr20983 = %bmP$nat_45_62peano
  store i64 %emsg18637, i64* %eptr20984                                              ; *eptr20984 = %emsg18637
  store i64 %SdC$_37wind_45stack, i64* %eptr20985                                    ; *eptr20985 = %SdC$_37wind_45stack
  store i64 %emsg08636, i64* %eptr20986                                              ; *eptr20986 = %emsg08636
  store i64 %U8g$_37do_45wind, i64* %eptr20987                                       ; *eptr20987 = %U8g$_37do_45wind
  %vptr20995 = alloca i64*, align 8 
  %eptr20982 = getelementptr inbounds i64, i64* %cloptr20981, i64 1 
  store volatile i64* %eptr20982, i64** %vptr20995, align 8 ; &cloptr20981[1]
 %vptr20996 = alloca i64, align 8 
  %f20988 = ptrtoint void(i64,i64)* @lam11996 to i64 
  store volatile i64 %f20988, i64* %vptr20996, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f20988, i64* %eptr20982                                                 ; store fptr
 %vptr20997 = alloca i64, align 8 
  %arg8012 = ptrtoint i64* %cloptr20981 to i64 
  store volatile i64 %arg8012, i64* %vptr20997, align 8 ; closure cast; i64* -> i64
 %vptr20998 = alloca i64, align 8 
  %arg8011 = add i64 0, 0 
  store volatile i64 %arg8011, i64* %vptr20998, align 8 ; quoted ()
 %vptr20999 = alloca i64, align 8 
  %rva10671 = add i64 0, 0 
  store volatile i64 %rva10671, i64* %vptr20999, align 8 ; quoted ()
 %vptr21000 = alloca i64, align 8 
  %rva10670 = call i64 @prim_cons(i64 %retprim7275, i64 %rva10671) 
  store volatile i64 %rva10670, i64* %vptr21000, align 8 ; call prim_cons
 %vptr21001 = alloca i64, align 8 
  %rva10669 = call i64 @prim_cons(i64 %arg8011, i64 %rva10670) 
  store volatile i64 %rva10669, i64* %vptr21001, align 8 ; call prim_cons
  %vptr21007 = alloca i64*, align 8 
  %cloptr21002 = inttoptr i64 %arg8012 to i64* 
  store volatile i64* %cloptr21002, i64** %vptr21007, align 8 ; closure/env cast; i64 -> i64*
  %vptr21008 = alloca i64*, align 8 
  %i0ptr21003 = getelementptr inbounds i64, i64* %cloptr21002, i64 1 
  store volatile i64* %i0ptr21003, i64** %vptr21008, align 8 ; &cloptr21002[1]
 %vptr21009 = alloca i64, align 8 
  %f21005 = load i64, i64* %i0ptr21003, align 8 
  store volatile i64 %f21005, i64* %vptr21009, align 8 ; load; *i0ptr21003
  %fptr21004 = inttoptr i64 %f21005 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21004(i64 %arg8012, i64 %rva10669)                  ; tail call
  ret void

else20977:
 %vptr21010 = alloca i64, align 8 
  %h10674 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10674, i64* %vptr21010, align 8 ; call prim_halt
  %vptr21016 = alloca i64*, align 8 
  %cloptr21011 = inttoptr i64 %h10674 to i64* 
  store volatile i64* %cloptr21011, i64** %vptr21016, align 8 ; closure/env cast; i64 -> i64*
  %vptr21017 = alloca i64*, align 8 
  %i0ptr21012 = getelementptr inbounds i64, i64* %cloptr21011, i64 1 
  store volatile i64* %i0ptr21012, i64** %vptr21017, align 8 ; &cloptr21011[1]
 %vptr21018 = alloca i64, align 8 
  %f21014 = load i64, i64* %i0ptr21012, align 8 
  store volatile i64 %f21014, i64* %vptr21018, align 8 ; load; *i0ptr21012
  %fptr21013 = inttoptr i64 %f21014 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21013(i64 %h10674, i64 %h10674)                     ; tail call
  ret void
}


define void @lam11996(i64 %env11997, i64 %rvp10665) {
 %vptr21021 = alloca i64, align 8 
  %envptr21019 = inttoptr i64 %env11997 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr21021, align 8 ; closure/env cast; i64 -> i64*
  %vptr21022 = alloca i64*, align 8 
  %envptr21020 = getelementptr inbounds i64, i64* %envptr21019, i64 6 
  store volatile i64* %envptr21020, i64** %vptr21022, align 8 ; &envptr21019[5]
 %vptr21023 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr21020, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr21023, align 8 ; load; *envptr21020
 %vptr21026 = alloca i64, align 8 
  %envptr21024 = inttoptr i64 %env11997 to i64* 
  store volatile i64 %emsg08636, i64* %vptr21026, align 8 ; closure/env cast; i64 -> i64*
  %vptr21027 = alloca i64*, align 8 
  %envptr21025 = getelementptr inbounds i64, i64* %envptr21024, i64 5 
  store volatile i64* %envptr21025, i64** %vptr21027, align 8 ; &envptr21024[4]
 %vptr21028 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr21025, align 8 
  store volatile i64 %emsg08636, i64* %vptr21028, align 8 ; load; *envptr21025
 %vptr21031 = alloca i64, align 8 
  %envptr21029 = inttoptr i64 %env11997 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr21031, align 8 ; closure/env cast; i64 -> i64*
  %vptr21032 = alloca i64*, align 8 
  %envptr21030 = getelementptr inbounds i64, i64* %envptr21029, i64 4 
  store volatile i64* %envptr21030, i64** %vptr21032, align 8 ; &envptr21029[3]
 %vptr21033 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr21030, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr21033, align 8 ; load; *envptr21030
 %vptr21036 = alloca i64, align 8 
  %envptr21034 = inttoptr i64 %env11997 to i64* 
  store volatile i64 %emsg18637, i64* %vptr21036, align 8 ; closure/env cast; i64 -> i64*
  %vptr21037 = alloca i64*, align 8 
  %envptr21035 = getelementptr inbounds i64, i64* %envptr21034, i64 3 
  store volatile i64* %envptr21035, i64** %vptr21037, align 8 ; &envptr21034[2]
 %vptr21038 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr21035, align 8 
  store volatile i64 %emsg18637, i64* %vptr21038, align 8 ; load; *envptr21035
 %vptr21041 = alloca i64, align 8 
  %envptr21039 = inttoptr i64 %env11997 to i64* 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr21041, align 8 ; closure/env cast; i64 -> i64*
  %vptr21042 = alloca i64*, align 8 
  %envptr21040 = getelementptr inbounds i64, i64* %envptr21039, i64 2 
  store volatile i64* %envptr21040, i64** %vptr21042, align 8 ; &envptr21039[1]
 %vptr21043 = alloca i64, align 8 
  %bmP$nat_45_62peano = load i64, i64* %envptr21040, align 8 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr21043, align 8 ; load; *envptr21040
 %vptr21044 = alloca i64, align 8 
  %_957196 = call i64 @prim_car(i64 %rvp10665) 
  store volatile i64 %_957196, i64* %vptr21044, align 8 ; call prim_car
 %vptr21045 = alloca i64, align 8 
  %rvp10661 = call i64 @prim_cdr(i64 %rvp10665) 
  store volatile i64 %rvp10661, i64* %vptr21045, align 8 ; call prim_cdr
 %vptr21046 = alloca i64, align 8 
  %n_6310666 = call i64 @prim_null_63(i64 %rvp10661) 
  store volatile i64 %n_6310666, i64* %vptr21046, align 8 ; call prim_null_63
  %cmpptr21050 = alloca i1, align 8  %cmp21047 = icmp eq i64 %n_6310666, 15 store volatile i1 %cmp21047, i1* %cmpptr21050, align 8; false?
  br i1 %cmp21047, label %else21049, label %then21048                                ; if

then21048:
 %vptr21051 = alloca i64, align 8 
  %h10667 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10667, i64* %vptr21051, align 8 ; call prim_halt
  %vptr21057 = alloca i64*, align 8 
  %cloptr21052 = inttoptr i64 %h10667 to i64* 
  store volatile i64* %cloptr21052, i64** %vptr21057, align 8 ; closure/env cast; i64 -> i64*
  %vptr21058 = alloca i64*, align 8 
  %i0ptr21053 = getelementptr inbounds i64, i64* %cloptr21052, i64 1 
  store volatile i64* %i0ptr21053, i64** %vptr21058, align 8 ; &cloptr21052[1]
 %vptr21059 = alloca i64, align 8 
  %f21055 = load i64, i64* %i0ptr21053, align 8 
  store volatile i64 %f21055, i64* %vptr21059, align 8 ; load; *i0ptr21053
  %fptr21054 = inttoptr i64 %f21055 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21054(i64 %h10667, i64 %h10667)                     ; tail call
  ret void

else21049:
 %vptr21060 = alloca i64, align 8 
  %Iic$peano_45_62nat = call i64 @prim_car(i64 %rvp10661) 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr21060, align 8 ; call prim_car
 %vptr21061 = alloca i64, align 8 
  %na9783 = call i64 @prim_cdr(i64 %rvp10661) 
  store volatile i64 %na9783, i64* %vptr21061, align 8 ; call prim_cdr
 %vptr21062 = alloca i64, align 8 
  %n_6310662 = call i64 @prim_null_63(i64 %na9783) 
  store volatile i64 %n_6310662, i64* %vptr21062, align 8 ; call prim_null_63
  %cmpptr21066 = alloca i1, align 8  %cmp21063 = icmp eq i64 %n_6310662, 15 store volatile i1 %cmp21063, i1* %cmpptr21066, align 8; false?
  br i1 %cmp21063, label %else21065, label %then21064                                ; if

then21064:
  %vptr21070 = alloca i64*, align 8 
  %cloptr21067 = call i64* @make_closure(i64 8) 
  store volatile i64* %cloptr21067, i64** %vptr21070, align 8 ; malloc
  %vptr21071 = alloca i64*, align 8 
  %eptr21068 = getelementptr inbounds i64, i64* %cloptr21067, i64 1 
  store volatile i64* %eptr21068, i64** %vptr21071, align 8 ; &cloptr21067[1]
 %vptr21072 = alloca i64, align 8 
  %f21069 = ptrtoint void(i64,i64)* @lam11994 to i64 
  store volatile i64 %f21069, i64* %vptr21072, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f21069, i64* %eptr21068                                                 ; store fptr
 %vptr21073 = alloca i64, align 8 
  %arg8014 = ptrtoint i64* %cloptr21067 to i64 
  store volatile i64 %arg8014, i64* %vptr21073, align 8 ; closure cast; i64* -> i64
  %vptr21083 = alloca i64*, align 8 
  %cloptr21074 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr21074, i64** %vptr21083, align 8 ; malloc
  %vptr21084 = alloca i64*, align 8 
  %eptr21076 = getelementptr inbounds i64, i64* %cloptr21074, i64 2 
  store volatile i64* %eptr21076, i64** %vptr21084, align 8 ; &eptr21076[1]
  %vptr21085 = alloca i64*, align 8 
  %eptr21077 = getelementptr inbounds i64, i64* %cloptr21074, i64 3 
  store volatile i64* %eptr21077, i64** %vptr21085, align 8 ; &eptr21077[2]
  %vptr21086 = alloca i64*, align 8 
  %eptr21078 = getelementptr inbounds i64, i64* %cloptr21074, i64 4 
  store volatile i64* %eptr21078, i64** %vptr21086, align 8 ; &eptr21078[3]
  %vptr21087 = alloca i64*, align 8 
  %eptr21079 = getelementptr inbounds i64, i64* %cloptr21074, i64 5 
  store volatile i64* %eptr21079, i64** %vptr21087, align 8 ; &eptr21079[4]
  %vptr21088 = alloca i64*, align 8 
  %eptr21080 = getelementptr inbounds i64, i64* %cloptr21074, i64 6 
  store volatile i64* %eptr21080, i64** %vptr21088, align 8 ; &eptr21080[5]
  %vptr21089 = alloca i64*, align 8 
  %eptr21081 = getelementptr inbounds i64, i64* %cloptr21074, i64 7 
  store volatile i64* %eptr21081, i64** %vptr21089, align 8 ; &eptr21081[6]
  store i64 %bmP$nat_45_62peano, i64* %eptr21076                                     ; *eptr21076 = %bmP$nat_45_62peano
  store i64 %emsg18637, i64* %eptr21077                                              ; *eptr21077 = %emsg18637
  store i64 %SdC$_37wind_45stack, i64* %eptr21078                                    ; *eptr21078 = %SdC$_37wind_45stack
  store i64 %emsg08636, i64* %eptr21079                                              ; *eptr21079 = %emsg08636
  store i64 %Iic$peano_45_62nat, i64* %eptr21080                                     ; *eptr21080 = %Iic$peano_45_62nat
  store i64 %U8g$_37do_45wind, i64* %eptr21081                                       ; *eptr21081 = %U8g$_37do_45wind
  %vptr21090 = alloca i64*, align 8 
  %eptr21075 = getelementptr inbounds i64, i64* %cloptr21074, i64 1 
  store volatile i64* %eptr21075, i64** %vptr21090, align 8 ; &cloptr21074[1]
 %vptr21091 = alloca i64, align 8 
  %f21082 = ptrtoint void(i64,i64)* @lam11990 to i64 
  store volatile i64 %f21082, i64* %vptr21091, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f21082, i64* %eptr21075                                                 ; store fptr
 %vptr21092 = alloca i64, align 8 
  %arg8013 = ptrtoint i64* %cloptr21074 to i64 
  store volatile i64 %arg8013, i64* %vptr21092, align 8 ; closure cast; i64* -> i64
 %vptr21093 = alloca i64, align 8 
  %rva10660 = add i64 0, 0 
  store volatile i64 %rva10660, i64* %vptr21093, align 8 ; quoted ()
 %vptr21094 = alloca i64, align 8 
  %rva10659 = call i64 @prim_cons(i64 %arg8013, i64 %rva10660) 
  store volatile i64 %rva10659, i64* %vptr21094, align 8 ; call prim_cons
  %vptr21100 = alloca i64*, align 8 
  %cloptr21095 = inttoptr i64 %arg8014 to i64* 
  store volatile i64* %cloptr21095, i64** %vptr21100, align 8 ; closure/env cast; i64 -> i64*
  %vptr21101 = alloca i64*, align 8 
  %i0ptr21096 = getelementptr inbounds i64, i64* %cloptr21095, i64 1 
  store volatile i64* %i0ptr21096, i64** %vptr21101, align 8 ; &cloptr21095[1]
 %vptr21102 = alloca i64, align 8 
  %f21098 = load i64, i64* %i0ptr21096, align 8 
  store volatile i64 %f21098, i64* %vptr21102, align 8 ; load; *i0ptr21096
  %fptr21097 = inttoptr i64 %f21098 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21097(i64 %arg8014, i64 %rva10659)                  ; tail call
  ret void

else21065:
 %vptr21103 = alloca i64, align 8 
  %h10663 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10663, i64* %vptr21103, align 8 ; call prim_halt
  %vptr21109 = alloca i64*, align 8 
  %cloptr21104 = inttoptr i64 %h10663 to i64* 
  store volatile i64* %cloptr21104, i64** %vptr21109, align 8 ; closure/env cast; i64 -> i64*
  %vptr21110 = alloca i64*, align 8 
  %i0ptr21105 = getelementptr inbounds i64, i64* %cloptr21104, i64 1 
  store volatile i64* %i0ptr21105, i64** %vptr21110, align 8 ; &cloptr21104[1]
 %vptr21111 = alloca i64, align 8 
  %f21107 = load i64, i64* %i0ptr21105, align 8 
  store volatile i64 %f21107, i64* %vptr21111, align 8 ; load; *i0ptr21105
  %fptr21106 = inttoptr i64 %f21107 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21106(i64 %h10663, i64 %h10663)                     ; tail call
  ret void
}


define void @lam11994(i64 %env11995, i64 %xHk$lst7273) {
 %vptr21112 = alloca i64, align 8 
  %cont7272 = call i64 @prim_car(i64 %xHk$lst7273) 
  store volatile i64 %cont7272, i64* %vptr21112, align 8 ; call prim_car
 %vptr21113 = alloca i64, align 8 
  %xHk$lst = call i64 @prim_cdr(i64 %xHk$lst7273) 
  store volatile i64 %xHk$lst, i64* %vptr21113, align 8 ; call prim_cdr
 %vptr21114 = alloca i64, align 8 
  %arg8018 = add i64 0, 0 
  store volatile i64 %arg8018, i64* %vptr21114, align 8 ; quoted ()
 %vptr21115 = alloca i64, align 8 
  %rva9786 = add i64 0, 0 
  store volatile i64 %rva9786, i64* %vptr21115, align 8 ; quoted ()
 %vptr21116 = alloca i64, align 8 
  %rva9785 = call i64 @prim_cons(i64 %xHk$lst, i64 %rva9786) 
  store volatile i64 %rva9785, i64* %vptr21116, align 8 ; call prim_cons
 %vptr21117 = alloca i64, align 8 
  %rva9784 = call i64 @prim_cons(i64 %arg8018, i64 %rva9785) 
  store volatile i64 %rva9784, i64* %vptr21117, align 8 ; call prim_cons
  %vptr21123 = alloca i64*, align 8 
  %cloptr21118 = inttoptr i64 %cont7272 to i64* 
  store volatile i64* %cloptr21118, i64** %vptr21123, align 8 ; closure/env cast; i64 -> i64*
  %vptr21124 = alloca i64*, align 8 
  %i0ptr21119 = getelementptr inbounds i64, i64* %cloptr21118, i64 1 
  store volatile i64* %i0ptr21119, i64** %vptr21124, align 8 ; &cloptr21118[1]
 %vptr21125 = alloca i64, align 8 
  %f21121 = load i64, i64* %i0ptr21119, align 8 
  store volatile i64 %f21121, i64* %vptr21125, align 8 ; load; *i0ptr21119
  %fptr21120 = inttoptr i64 %f21121 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21120(i64 %cont7272, i64 %rva9784)                  ; tail call
  ret void
}


define void @lam11990(i64 %env11991, i64 %rvp10655) {
 %vptr21128 = alloca i64, align 8 
  %envptr21126 = inttoptr i64 %env11991 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr21128, align 8 ; closure/env cast; i64 -> i64*
  %vptr21129 = alloca i64*, align 8 
  %envptr21127 = getelementptr inbounds i64, i64* %envptr21126, i64 7 
  store volatile i64* %envptr21127, i64** %vptr21129, align 8 ; &envptr21126[6]
 %vptr21130 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr21127, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr21130, align 8 ; load; *envptr21127
 %vptr21133 = alloca i64, align 8 
  %envptr21131 = inttoptr i64 %env11991 to i64* 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr21133, align 8 ; closure/env cast; i64 -> i64*
  %vptr21134 = alloca i64*, align 8 
  %envptr21132 = getelementptr inbounds i64, i64* %envptr21131, i64 6 
  store volatile i64* %envptr21132, i64** %vptr21134, align 8 ; &envptr21131[5]
 %vptr21135 = alloca i64, align 8 
  %Iic$peano_45_62nat = load i64, i64* %envptr21132, align 8 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr21135, align 8 ; load; *envptr21132
 %vptr21138 = alloca i64, align 8 
  %envptr21136 = inttoptr i64 %env11991 to i64* 
  store volatile i64 %emsg08636, i64* %vptr21138, align 8 ; closure/env cast; i64 -> i64*
  %vptr21139 = alloca i64*, align 8 
  %envptr21137 = getelementptr inbounds i64, i64* %envptr21136, i64 5 
  store volatile i64* %envptr21137, i64** %vptr21139, align 8 ; &envptr21136[4]
 %vptr21140 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr21137, align 8 
  store volatile i64 %emsg08636, i64* %vptr21140, align 8 ; load; *envptr21137
 %vptr21143 = alloca i64, align 8 
  %envptr21141 = inttoptr i64 %env11991 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr21143, align 8 ; closure/env cast; i64 -> i64*
  %vptr21144 = alloca i64*, align 8 
  %envptr21142 = getelementptr inbounds i64, i64* %envptr21141, i64 4 
  store volatile i64* %envptr21142, i64** %vptr21144, align 8 ; &envptr21141[3]
 %vptr21145 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr21142, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr21145, align 8 ; load; *envptr21142
 %vptr21148 = alloca i64, align 8 
  %envptr21146 = inttoptr i64 %env11991 to i64* 
  store volatile i64 %emsg18637, i64* %vptr21148, align 8 ; closure/env cast; i64 -> i64*
  %vptr21149 = alloca i64*, align 8 
  %envptr21147 = getelementptr inbounds i64, i64* %envptr21146, i64 3 
  store volatile i64* %envptr21147, i64** %vptr21149, align 8 ; &envptr21146[2]
 %vptr21150 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr21147, align 8 
  store volatile i64 %emsg18637, i64* %vptr21150, align 8 ; load; *envptr21147
 %vptr21153 = alloca i64, align 8 
  %envptr21151 = inttoptr i64 %env11991 to i64* 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr21153, align 8 ; closure/env cast; i64 -> i64*
  %vptr21154 = alloca i64*, align 8 
  %envptr21152 = getelementptr inbounds i64, i64* %envptr21151, i64 2 
  store volatile i64* %envptr21152, i64** %vptr21154, align 8 ; &envptr21151[1]
 %vptr21155 = alloca i64, align 8 
  %bmP$nat_45_62peano = load i64, i64* %envptr21152, align 8 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr21155, align 8 ; load; *envptr21152
 %vptr21156 = alloca i64, align 8 
  %_957270 = call i64 @prim_car(i64 %rvp10655) 
  store volatile i64 %_957270, i64* %vptr21156, align 8 ; call prim_car
 %vptr21157 = alloca i64, align 8 
  %rvp10651 = call i64 @prim_cdr(i64 %rvp10655) 
  store volatile i64 %rvp10651, i64* %vptr21157, align 8 ; call prim_cdr
 %vptr21158 = alloca i64, align 8 
  %n_6310656 = call i64 @prim_null_63(i64 %rvp10651) 
  store volatile i64 %n_6310656, i64* %vptr21158, align 8 ; call prim_null_63
  %cmpptr21162 = alloca i1, align 8  %cmp21159 = icmp eq i64 %n_6310656, 15 store volatile i1 %cmp21159, i1* %cmpptr21162, align 8; false?
  br i1 %cmp21159, label %else21161, label %then21160                                ; if

then21160:
 %vptr21163 = alloca i64, align 8 
  %h10657 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10657, i64* %vptr21163, align 8 ; call prim_halt
  %vptr21169 = alloca i64*, align 8 
  %cloptr21164 = inttoptr i64 %h10657 to i64* 
  store volatile i64* %cloptr21164, i64** %vptr21169, align 8 ; closure/env cast; i64 -> i64*
  %vptr21170 = alloca i64*, align 8 
  %i0ptr21165 = getelementptr inbounds i64, i64* %cloptr21164, i64 1 
  store volatile i64* %i0ptr21165, i64** %vptr21170, align 8 ; &cloptr21164[1]
 %vptr21171 = alloca i64, align 8 
  %f21167 = load i64, i64* %i0ptr21165, align 8 
  store volatile i64 %f21167, i64* %vptr21171, align 8 ; load; *i0ptr21165
  %fptr21166 = inttoptr i64 %f21167 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21166(i64 %h10657, i64 %h10657)                     ; tail call
  ret void

else21161:
 %vptr21172 = alloca i64, align 8 
  %a7033 = call i64 @prim_car(i64 %rvp10651) 
  store volatile i64 %a7033, i64* %vptr21172, align 8 ; call prim_car
 %vptr21173 = alloca i64, align 8 
  %na9788 = call i64 @prim_cdr(i64 %rvp10651) 
  store volatile i64 %na9788, i64* %vptr21173, align 8 ; call prim_cdr
 %vptr21174 = alloca i64, align 8 
  %n_6310652 = call i64 @prim_null_63(i64 %na9788) 
  store volatile i64 %n_6310652, i64* %vptr21174, align 8 ; call prim_null_63
  %cmpptr21178 = alloca i1, align 8  %cmp21175 = icmp eq i64 %n_6310652, 15 store volatile i1 %cmp21175, i1* %cmpptr21178, align 8; false?
  br i1 %cmp21175, label %else21177, label %then21176                                ; if

then21176:
 %vptr21179 = alloca i64, align 8 
  %arg8021 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg8021, i64* %vptr21179, align 8 ; quoted int
 %vptr21180 = alloca i64, align 8 
  %retprim7271 = call i64 @prim_make_45vector(i64 %arg8021, i64 %a7033) 
  store volatile i64 %retprim7271, i64* %vptr21180, align 8 ; call prim_make_45vector
  %vptr21190 = alloca i64*, align 8 
  %cloptr21181 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr21181, i64** %vptr21190, align 8 ; malloc
  %vptr21191 = alloca i64*, align 8 
  %eptr21183 = getelementptr inbounds i64, i64* %cloptr21181, i64 2 
  store volatile i64* %eptr21183, i64** %vptr21191, align 8 ; &eptr21183[1]
  %vptr21192 = alloca i64*, align 8 
  %eptr21184 = getelementptr inbounds i64, i64* %cloptr21181, i64 3 
  store volatile i64* %eptr21184, i64** %vptr21192, align 8 ; &eptr21184[2]
  %vptr21193 = alloca i64*, align 8 
  %eptr21185 = getelementptr inbounds i64, i64* %cloptr21181, i64 4 
  store volatile i64* %eptr21185, i64** %vptr21193, align 8 ; &eptr21185[3]
  %vptr21194 = alloca i64*, align 8 
  %eptr21186 = getelementptr inbounds i64, i64* %cloptr21181, i64 5 
  store volatile i64* %eptr21186, i64** %vptr21194, align 8 ; &eptr21186[4]
  %vptr21195 = alloca i64*, align 8 
  %eptr21187 = getelementptr inbounds i64, i64* %cloptr21181, i64 6 
  store volatile i64* %eptr21187, i64** %vptr21195, align 8 ; &eptr21187[5]
  %vptr21196 = alloca i64*, align 8 
  %eptr21188 = getelementptr inbounds i64, i64* %cloptr21181, i64 7 
  store volatile i64* %eptr21188, i64** %vptr21196, align 8 ; &eptr21188[6]
  store i64 %bmP$nat_45_62peano, i64* %eptr21183                                     ; *eptr21183 = %bmP$nat_45_62peano
  store i64 %emsg18637, i64* %eptr21184                                              ; *eptr21184 = %emsg18637
  store i64 %SdC$_37wind_45stack, i64* %eptr21185                                    ; *eptr21185 = %SdC$_37wind_45stack
  store i64 %emsg08636, i64* %eptr21186                                              ; *eptr21186 = %emsg08636
  store i64 %Iic$peano_45_62nat, i64* %eptr21187                                     ; *eptr21187 = %Iic$peano_45_62nat
  store i64 %U8g$_37do_45wind, i64* %eptr21188                                       ; *eptr21188 = %U8g$_37do_45wind
  %vptr21197 = alloca i64*, align 8 
  %eptr21182 = getelementptr inbounds i64, i64* %cloptr21181, i64 1 
  store volatile i64* %eptr21182, i64** %vptr21197, align 8 ; &cloptr21181[1]
 %vptr21198 = alloca i64, align 8 
  %f21189 = ptrtoint void(i64,i64)* @lam11987 to i64 
  store volatile i64 %f21189, i64* %vptr21198, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f21189, i64* %eptr21182                                                 ; store fptr
 %vptr21199 = alloca i64, align 8 
  %arg8024 = ptrtoint i64* %cloptr21181 to i64 
  store volatile i64 %arg8024, i64* %vptr21199, align 8 ; closure cast; i64* -> i64
 %vptr21200 = alloca i64, align 8 
  %arg8023 = add i64 0, 0 
  store volatile i64 %arg8023, i64* %vptr21200, align 8 ; quoted ()
 %vptr21201 = alloca i64, align 8 
  %rva10650 = add i64 0, 0 
  store volatile i64 %rva10650, i64* %vptr21201, align 8 ; quoted ()
 %vptr21202 = alloca i64, align 8 
  %rva10649 = call i64 @prim_cons(i64 %retprim7271, i64 %rva10650) 
  store volatile i64 %rva10649, i64* %vptr21202, align 8 ; call prim_cons
 %vptr21203 = alloca i64, align 8 
  %rva10648 = call i64 @prim_cons(i64 %arg8023, i64 %rva10649) 
  store volatile i64 %rva10648, i64* %vptr21203, align 8 ; call prim_cons
  %vptr21209 = alloca i64*, align 8 
  %cloptr21204 = inttoptr i64 %arg8024 to i64* 
  store volatile i64* %cloptr21204, i64** %vptr21209, align 8 ; closure/env cast; i64 -> i64*
  %vptr21210 = alloca i64*, align 8 
  %i0ptr21205 = getelementptr inbounds i64, i64* %cloptr21204, i64 1 
  store volatile i64* %i0ptr21205, i64** %vptr21210, align 8 ; &cloptr21204[1]
 %vptr21211 = alloca i64, align 8 
  %f21207 = load i64, i64* %i0ptr21205, align 8 
  store volatile i64 %f21207, i64* %vptr21211, align 8 ; load; *i0ptr21205
  %fptr21206 = inttoptr i64 %f21207 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21206(i64 %arg8024, i64 %rva10648)                  ; tail call
  ret void

else21177:
 %vptr21212 = alloca i64, align 8 
  %h10653 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10653, i64* %vptr21212, align 8 ; call prim_halt
  %vptr21218 = alloca i64*, align 8 
  %cloptr21213 = inttoptr i64 %h10653 to i64* 
  store volatile i64* %cloptr21213, i64** %vptr21218, align 8 ; closure/env cast; i64 -> i64*
  %vptr21219 = alloca i64*, align 8 
  %i0ptr21214 = getelementptr inbounds i64, i64* %cloptr21213, i64 1 
  store volatile i64* %i0ptr21214, i64** %vptr21219, align 8 ; &cloptr21213[1]
 %vptr21220 = alloca i64, align 8 
  %f21216 = load i64, i64* %i0ptr21214, align 8 
  store volatile i64 %f21216, i64* %vptr21220, align 8 ; load; *i0ptr21214
  %fptr21215 = inttoptr i64 %f21216 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21215(i64 %h10653, i64 %h10653)                     ; tail call
  ret void
}


define void @lam11987(i64 %env11988, i64 %rvp10644) {
 %vptr21223 = alloca i64, align 8 
  %envptr21221 = inttoptr i64 %env11988 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr21223, align 8 ; closure/env cast; i64 -> i64*
  %vptr21224 = alloca i64*, align 8 
  %envptr21222 = getelementptr inbounds i64, i64* %envptr21221, i64 7 
  store volatile i64* %envptr21222, i64** %vptr21224, align 8 ; &envptr21221[6]
 %vptr21225 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr21222, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr21225, align 8 ; load; *envptr21222
 %vptr21228 = alloca i64, align 8 
  %envptr21226 = inttoptr i64 %env11988 to i64* 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr21228, align 8 ; closure/env cast; i64 -> i64*
  %vptr21229 = alloca i64*, align 8 
  %envptr21227 = getelementptr inbounds i64, i64* %envptr21226, i64 6 
  store volatile i64* %envptr21227, i64** %vptr21229, align 8 ; &envptr21226[5]
 %vptr21230 = alloca i64, align 8 
  %Iic$peano_45_62nat = load i64, i64* %envptr21227, align 8 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr21230, align 8 ; load; *envptr21227
 %vptr21233 = alloca i64, align 8 
  %envptr21231 = inttoptr i64 %env11988 to i64* 
  store volatile i64 %emsg08636, i64* %vptr21233, align 8 ; closure/env cast; i64 -> i64*
  %vptr21234 = alloca i64*, align 8 
  %envptr21232 = getelementptr inbounds i64, i64* %envptr21231, i64 5 
  store volatile i64* %envptr21232, i64** %vptr21234, align 8 ; &envptr21231[4]
 %vptr21235 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr21232, align 8 
  store volatile i64 %emsg08636, i64* %vptr21235, align 8 ; load; *envptr21232
 %vptr21238 = alloca i64, align 8 
  %envptr21236 = inttoptr i64 %env11988 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr21238, align 8 ; closure/env cast; i64 -> i64*
  %vptr21239 = alloca i64*, align 8 
  %envptr21237 = getelementptr inbounds i64, i64* %envptr21236, i64 4 
  store volatile i64* %envptr21237, i64** %vptr21239, align 8 ; &envptr21236[3]
 %vptr21240 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr21237, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr21240, align 8 ; load; *envptr21237
 %vptr21243 = alloca i64, align 8 
  %envptr21241 = inttoptr i64 %env11988 to i64* 
  store volatile i64 %emsg18637, i64* %vptr21243, align 8 ; closure/env cast; i64 -> i64*
  %vptr21244 = alloca i64*, align 8 
  %envptr21242 = getelementptr inbounds i64, i64* %envptr21241, i64 3 
  store volatile i64* %envptr21242, i64** %vptr21244, align 8 ; &envptr21241[2]
 %vptr21245 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr21242, align 8 
  store volatile i64 %emsg18637, i64* %vptr21245, align 8 ; load; *envptr21242
 %vptr21248 = alloca i64, align 8 
  %envptr21246 = inttoptr i64 %env11988 to i64* 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr21248, align 8 ; closure/env cast; i64 -> i64*
  %vptr21249 = alloca i64*, align 8 
  %envptr21247 = getelementptr inbounds i64, i64* %envptr21246, i64 2 
  store volatile i64* %envptr21247, i64** %vptr21249, align 8 ; &envptr21246[1]
 %vptr21250 = alloca i64, align 8 
  %bmP$nat_45_62peano = load i64, i64* %envptr21247, align 8 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr21250, align 8 ; load; *envptr21247
 %vptr21251 = alloca i64, align 8 
  %_957197 = call i64 @prim_car(i64 %rvp10644) 
  store volatile i64 %_957197, i64* %vptr21251, align 8 ; call prim_car
 %vptr21252 = alloca i64, align 8 
  %rvp10640 = call i64 @prim_cdr(i64 %rvp10644) 
  store volatile i64 %rvp10640, i64* %vptr21252, align 8 ; call prim_cdr
 %vptr21253 = alloca i64, align 8 
  %n_6310645 = call i64 @prim_null_63(i64 %rvp10640) 
  store volatile i64 %n_6310645, i64* %vptr21253, align 8 ; call prim_null_63
  %cmpptr21257 = alloca i1, align 8  %cmp21254 = icmp eq i64 %n_6310645, 15 store volatile i1 %cmp21254, i1* %cmpptr21257, align 8; false?
  br i1 %cmp21254, label %else21256, label %then21255                                ; if

then21255:
 %vptr21258 = alloca i64, align 8 
  %h10646 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10646, i64* %vptr21258, align 8 ; call prim_halt
  %vptr21264 = alloca i64*, align 8 
  %cloptr21259 = inttoptr i64 %h10646 to i64* 
  store volatile i64* %cloptr21259, i64** %vptr21264, align 8 ; closure/env cast; i64 -> i64*
  %vptr21265 = alloca i64*, align 8 
  %i0ptr21260 = getelementptr inbounds i64, i64* %cloptr21259, i64 1 
  store volatile i64* %i0ptr21260, i64** %vptr21265, align 8 ; &cloptr21259[1]
 %vptr21266 = alloca i64, align 8 
  %f21262 = load i64, i64* %i0ptr21260, align 8 
  store volatile i64 %f21262, i64* %vptr21266, align 8 ; load; *i0ptr21260
  %fptr21261 = inttoptr i64 %f21262 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21261(i64 %h10646, i64 %h10646)                     ; tail call
  ret void

else21256:
 %vptr21267 = alloca i64, align 8 
  %gYG$succ = call i64 @prim_car(i64 %rvp10640) 
  store volatile i64 %gYG$succ, i64* %vptr21267, align 8 ; call prim_car
 %vptr21268 = alloca i64, align 8 
  %na9790 = call i64 @prim_cdr(i64 %rvp10640) 
  store volatile i64 %na9790, i64* %vptr21268, align 8 ; call prim_cdr
 %vptr21269 = alloca i64, align 8 
  %n_6310641 = call i64 @prim_null_63(i64 %na9790) 
  store volatile i64 %n_6310641, i64* %vptr21269, align 8 ; call prim_null_63
  %cmpptr21273 = alloca i1, align 8  %cmp21270 = icmp eq i64 %n_6310641, 15 store volatile i1 %cmp21270, i1* %cmpptr21273, align 8; false?
  br i1 %cmp21270, label %else21272, label %then21271                                ; if

then21271:
  %vptr21277 = alloca i64*, align 8 
  %cloptr21274 = call i64* @make_closure(i64 8) 
  store volatile i64* %cloptr21274, i64** %vptr21277, align 8 ; malloc
  %vptr21278 = alloca i64*, align 8 
  %eptr21275 = getelementptr inbounds i64, i64* %cloptr21274, i64 1 
  store volatile i64* %eptr21275, i64** %vptr21278, align 8 ; &cloptr21274[1]
 %vptr21279 = alloca i64, align 8 
  %f21276 = ptrtoint void(i64,i64)* @lam11985 to i64 
  store volatile i64 %f21276, i64* %vptr21279, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f21276, i64* %eptr21275                                                 ; store fptr
 %vptr21280 = alloca i64, align 8 
  %arg8026 = ptrtoint i64* %cloptr21274 to i64 
  store volatile i64 %arg8026, i64* %vptr21280, align 8 ; closure cast; i64* -> i64
  %vptr21291 = alloca i64*, align 8 
  %cloptr21281 = call i64* @make_closure(i64 64) 
  store volatile i64* %cloptr21281, i64** %vptr21291, align 8 ; malloc
  %vptr21292 = alloca i64*, align 8 
  %eptr21283 = getelementptr inbounds i64, i64* %cloptr21281, i64 2 
  store volatile i64* %eptr21283, i64** %vptr21292, align 8 ; &eptr21283[1]
  %vptr21293 = alloca i64*, align 8 
  %eptr21284 = getelementptr inbounds i64, i64* %cloptr21281, i64 3 
  store volatile i64* %eptr21284, i64** %vptr21293, align 8 ; &eptr21284[2]
  %vptr21294 = alloca i64*, align 8 
  %eptr21285 = getelementptr inbounds i64, i64* %cloptr21281, i64 4 
  store volatile i64* %eptr21285, i64** %vptr21294, align 8 ; &eptr21285[3]
  %vptr21295 = alloca i64*, align 8 
  %eptr21286 = getelementptr inbounds i64, i64* %cloptr21281, i64 5 
  store volatile i64* %eptr21286, i64** %vptr21295, align 8 ; &eptr21286[4]
  %vptr21296 = alloca i64*, align 8 
  %eptr21287 = getelementptr inbounds i64, i64* %cloptr21281, i64 6 
  store volatile i64* %eptr21287, i64** %vptr21296, align 8 ; &eptr21287[5]
  %vptr21297 = alloca i64*, align 8 
  %eptr21288 = getelementptr inbounds i64, i64* %cloptr21281, i64 7 
  store volatile i64* %eptr21288, i64** %vptr21297, align 8 ; &eptr21288[6]
  %vptr21298 = alloca i64*, align 8 
  %eptr21289 = getelementptr inbounds i64, i64* %cloptr21281, i64 8 
  store volatile i64* %eptr21289, i64** %vptr21298, align 8 ; &eptr21289[7]
  store i64 %bmP$nat_45_62peano, i64* %eptr21283                                     ; *eptr21283 = %bmP$nat_45_62peano
  store i64 %emsg18637, i64* %eptr21284                                              ; *eptr21284 = %emsg18637
  store i64 %SdC$_37wind_45stack, i64* %eptr21285                                    ; *eptr21285 = %SdC$_37wind_45stack
  store i64 %gYG$succ, i64* %eptr21286                                               ; *eptr21286 = %gYG$succ
  store i64 %emsg08636, i64* %eptr21287                                              ; *eptr21287 = %emsg08636
  store i64 %Iic$peano_45_62nat, i64* %eptr21288                                     ; *eptr21288 = %Iic$peano_45_62nat
  store i64 %U8g$_37do_45wind, i64* %eptr21289                                       ; *eptr21289 = %U8g$_37do_45wind
  %vptr21299 = alloca i64*, align 8 
  %eptr21282 = getelementptr inbounds i64, i64* %cloptr21281, i64 1 
  store volatile i64* %eptr21282, i64** %vptr21299, align 8 ; &cloptr21281[1]
 %vptr21300 = alloca i64, align 8 
  %f21290 = ptrtoint void(i64,i64)* @lam11981 to i64 
  store volatile i64 %f21290, i64* %vptr21300, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f21290, i64* %eptr21282                                                 ; store fptr
 %vptr21301 = alloca i64, align 8 
  %arg8025 = ptrtoint i64* %cloptr21281 to i64 
  store volatile i64 %arg8025, i64* %vptr21301, align 8 ; closure cast; i64* -> i64
 %vptr21302 = alloca i64, align 8 
  %rva10639 = add i64 0, 0 
  store volatile i64 %rva10639, i64* %vptr21302, align 8 ; quoted ()
 %vptr21303 = alloca i64, align 8 
  %rva10638 = call i64 @prim_cons(i64 %arg8025, i64 %rva10639) 
  store volatile i64 %rva10638, i64* %vptr21303, align 8 ; call prim_cons
  %vptr21309 = alloca i64*, align 8 
  %cloptr21304 = inttoptr i64 %arg8026 to i64* 
  store volatile i64* %cloptr21304, i64** %vptr21309, align 8 ; closure/env cast; i64 -> i64*
  %vptr21310 = alloca i64*, align 8 
  %i0ptr21305 = getelementptr inbounds i64, i64* %cloptr21304, i64 1 
  store volatile i64* %i0ptr21305, i64** %vptr21310, align 8 ; &cloptr21304[1]
 %vptr21311 = alloca i64, align 8 
  %f21307 = load i64, i64* %i0ptr21305, align 8 
  store volatile i64 %f21307, i64* %vptr21311, align 8 ; load; *i0ptr21305
  %fptr21306 = inttoptr i64 %f21307 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21306(i64 %arg8026, i64 %rva10638)                  ; tail call
  ret void

else21272:
 %vptr21312 = alloca i64, align 8 
  %h10642 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10642, i64* %vptr21312, align 8 ; call prim_halt
  %vptr21318 = alloca i64*, align 8 
  %cloptr21313 = inttoptr i64 %h10642 to i64* 
  store volatile i64* %cloptr21313, i64** %vptr21318, align 8 ; closure/env cast; i64 -> i64*
  %vptr21319 = alloca i64*, align 8 
  %i0ptr21314 = getelementptr inbounds i64, i64* %cloptr21313, i64 1 
  store volatile i64* %i0ptr21314, i64** %vptr21319, align 8 ; &cloptr21313[1]
 %vptr21320 = alloca i64, align 8 
  %f21316 = load i64, i64* %i0ptr21314, align 8 
  store volatile i64 %f21316, i64* %vptr21320, align 8 ; load; *i0ptr21314
  %fptr21315 = inttoptr i64 %f21316 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21315(i64 %h10642, i64 %h10642)                     ; tail call
  ret void
}


define void @lam11985(i64 %env11986, i64 %Z6p$lst7269) {
 %vptr21321 = alloca i64, align 8 
  %cont7268 = call i64 @prim_car(i64 %Z6p$lst7269) 
  store volatile i64 %cont7268, i64* %vptr21321, align 8 ; call prim_car
 %vptr21322 = alloca i64, align 8 
  %Z6p$lst = call i64 @prim_cdr(i64 %Z6p$lst7269) 
  store volatile i64 %Z6p$lst, i64* %vptr21322, align 8 ; call prim_cdr
 %vptr21323 = alloca i64, align 8 
  %arg8030 = add i64 0, 0 
  store volatile i64 %arg8030, i64* %vptr21323, align 8 ; quoted ()
 %vptr21324 = alloca i64, align 8 
  %rva9793 = add i64 0, 0 
  store volatile i64 %rva9793, i64* %vptr21324, align 8 ; quoted ()
 %vptr21325 = alloca i64, align 8 
  %rva9792 = call i64 @prim_cons(i64 %Z6p$lst, i64 %rva9793) 
  store volatile i64 %rva9792, i64* %vptr21325, align 8 ; call prim_cons
 %vptr21326 = alloca i64, align 8 
  %rva9791 = call i64 @prim_cons(i64 %arg8030, i64 %rva9792) 
  store volatile i64 %rva9791, i64* %vptr21326, align 8 ; call prim_cons
  %vptr21332 = alloca i64*, align 8 
  %cloptr21327 = inttoptr i64 %cont7268 to i64* 
  store volatile i64* %cloptr21327, i64** %vptr21332, align 8 ; closure/env cast; i64 -> i64*
  %vptr21333 = alloca i64*, align 8 
  %i0ptr21328 = getelementptr inbounds i64, i64* %cloptr21327, i64 1 
  store volatile i64* %i0ptr21328, i64** %vptr21333, align 8 ; &cloptr21327[1]
 %vptr21334 = alloca i64, align 8 
  %f21330 = load i64, i64* %i0ptr21328, align 8 
  store volatile i64 %f21330, i64* %vptr21334, align 8 ; load; *i0ptr21328
  %fptr21329 = inttoptr i64 %f21330 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21329(i64 %cont7268, i64 %rva9791)                  ; tail call
  ret void
}


define void @lam11981(i64 %env11982, i64 %rvp10634) {
 %vptr21337 = alloca i64, align 8 
  %envptr21335 = inttoptr i64 %env11982 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr21337, align 8 ; closure/env cast; i64 -> i64*
  %vptr21338 = alloca i64*, align 8 
  %envptr21336 = getelementptr inbounds i64, i64* %envptr21335, i64 8 
  store volatile i64* %envptr21336, i64** %vptr21338, align 8 ; &envptr21335[7]
 %vptr21339 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr21336, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr21339, align 8 ; load; *envptr21336
 %vptr21342 = alloca i64, align 8 
  %envptr21340 = inttoptr i64 %env11982 to i64* 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr21342, align 8 ; closure/env cast; i64 -> i64*
  %vptr21343 = alloca i64*, align 8 
  %envptr21341 = getelementptr inbounds i64, i64* %envptr21340, i64 7 
  store volatile i64* %envptr21341, i64** %vptr21343, align 8 ; &envptr21340[6]
 %vptr21344 = alloca i64, align 8 
  %Iic$peano_45_62nat = load i64, i64* %envptr21341, align 8 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr21344, align 8 ; load; *envptr21341
 %vptr21347 = alloca i64, align 8 
  %envptr21345 = inttoptr i64 %env11982 to i64* 
  store volatile i64 %emsg08636, i64* %vptr21347, align 8 ; closure/env cast; i64 -> i64*
  %vptr21348 = alloca i64*, align 8 
  %envptr21346 = getelementptr inbounds i64, i64* %envptr21345, i64 6 
  store volatile i64* %envptr21346, i64** %vptr21348, align 8 ; &envptr21345[5]
 %vptr21349 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr21346, align 8 
  store volatile i64 %emsg08636, i64* %vptr21349, align 8 ; load; *envptr21346
 %vptr21352 = alloca i64, align 8 
  %envptr21350 = inttoptr i64 %env11982 to i64* 
  store volatile i64 %gYG$succ, i64* %vptr21352, align 8 ; closure/env cast; i64 -> i64*
  %vptr21353 = alloca i64*, align 8 
  %envptr21351 = getelementptr inbounds i64, i64* %envptr21350, i64 5 
  store volatile i64* %envptr21351, i64** %vptr21353, align 8 ; &envptr21350[4]
 %vptr21354 = alloca i64, align 8 
  %gYG$succ = load i64, i64* %envptr21351, align 8 
  store volatile i64 %gYG$succ, i64* %vptr21354, align 8 ; load; *envptr21351
 %vptr21357 = alloca i64, align 8 
  %envptr21355 = inttoptr i64 %env11982 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr21357, align 8 ; closure/env cast; i64 -> i64*
  %vptr21358 = alloca i64*, align 8 
  %envptr21356 = getelementptr inbounds i64, i64* %envptr21355, i64 4 
  store volatile i64* %envptr21356, i64** %vptr21358, align 8 ; &envptr21355[3]
 %vptr21359 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr21356, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr21359, align 8 ; load; *envptr21356
 %vptr21362 = alloca i64, align 8 
  %envptr21360 = inttoptr i64 %env11982 to i64* 
  store volatile i64 %emsg18637, i64* %vptr21362, align 8 ; closure/env cast; i64 -> i64*
  %vptr21363 = alloca i64*, align 8 
  %envptr21361 = getelementptr inbounds i64, i64* %envptr21360, i64 3 
  store volatile i64* %envptr21361, i64** %vptr21363, align 8 ; &envptr21360[2]
 %vptr21364 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr21361, align 8 
  store volatile i64 %emsg18637, i64* %vptr21364, align 8 ; load; *envptr21361
 %vptr21367 = alloca i64, align 8 
  %envptr21365 = inttoptr i64 %env11982 to i64* 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr21367, align 8 ; closure/env cast; i64 -> i64*
  %vptr21368 = alloca i64*, align 8 
  %envptr21366 = getelementptr inbounds i64, i64* %envptr21365, i64 2 
  store volatile i64* %envptr21366, i64** %vptr21368, align 8 ; &envptr21365[1]
 %vptr21369 = alloca i64, align 8 
  %bmP$nat_45_62peano = load i64, i64* %envptr21366, align 8 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr21369, align 8 ; load; *envptr21366
 %vptr21370 = alloca i64, align 8 
  %_957266 = call i64 @prim_car(i64 %rvp10634) 
  store volatile i64 %_957266, i64* %vptr21370, align 8 ; call prim_car
 %vptr21371 = alloca i64, align 8 
  %rvp10630 = call i64 @prim_cdr(i64 %rvp10634) 
  store volatile i64 %rvp10630, i64* %vptr21371, align 8 ; call prim_cdr
 %vptr21372 = alloca i64, align 8 
  %n_6310635 = call i64 @prim_null_63(i64 %rvp10630) 
  store volatile i64 %n_6310635, i64* %vptr21372, align 8 ; call prim_null_63
  %cmpptr21376 = alloca i1, align 8  %cmp21373 = icmp eq i64 %n_6310635, 15 store volatile i1 %cmp21373, i1* %cmpptr21376, align 8; false?
  br i1 %cmp21373, label %else21375, label %then21374                                ; if

then21374:
 %vptr21377 = alloca i64, align 8 
  %h10636 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10636, i64* %vptr21377, align 8 ; call prim_halt
  %vptr21383 = alloca i64*, align 8 
  %cloptr21378 = inttoptr i64 %h10636 to i64* 
  store volatile i64* %cloptr21378, i64** %vptr21383, align 8 ; closure/env cast; i64 -> i64*
  %vptr21384 = alloca i64*, align 8 
  %i0ptr21379 = getelementptr inbounds i64, i64* %cloptr21378, i64 1 
  store volatile i64* %i0ptr21379, i64** %vptr21384, align 8 ; &cloptr21378[1]
 %vptr21385 = alloca i64, align 8 
  %f21381 = load i64, i64* %i0ptr21379, align 8 
  store volatile i64 %f21381, i64* %vptr21385, align 8 ; load; *i0ptr21379
  %fptr21380 = inttoptr i64 %f21381 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21380(i64 %h10636, i64 %h10636)                     ; tail call
  ret void

else21375:
 %vptr21386 = alloca i64, align 8 
  %a7034 = call i64 @prim_car(i64 %rvp10630) 
  store volatile i64 %a7034, i64* %vptr21386, align 8 ; call prim_car
 %vptr21387 = alloca i64, align 8 
  %na9795 = call i64 @prim_cdr(i64 %rvp10630) 
  store volatile i64 %na9795, i64* %vptr21387, align 8 ; call prim_cdr
 %vptr21388 = alloca i64, align 8 
  %n_6310631 = call i64 @prim_null_63(i64 %na9795) 
  store volatile i64 %n_6310631, i64* %vptr21388, align 8 ; call prim_null_63
  %cmpptr21392 = alloca i1, align 8  %cmp21389 = icmp eq i64 %n_6310631, 15 store volatile i1 %cmp21389, i1* %cmpptr21392, align 8; false?
  br i1 %cmp21389, label %else21391, label %then21390                                ; if

then21390:
 %vptr21393 = alloca i64, align 8 
  %arg8033 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg8033, i64* %vptr21393, align 8 ; quoted int
 %vptr21394 = alloca i64, align 8 
  %retprim7267 = call i64 @prim_make_45vector(i64 %arg8033, i64 %a7034) 
  store volatile i64 %retprim7267, i64* %vptr21394, align 8 ; call prim_make_45vector
  %vptr21405 = alloca i64*, align 8 
  %cloptr21395 = call i64* @make_closure(i64 64) 
  store volatile i64* %cloptr21395, i64** %vptr21405, align 8 ; malloc
  %vptr21406 = alloca i64*, align 8 
  %eptr21397 = getelementptr inbounds i64, i64* %cloptr21395, i64 2 
  store volatile i64* %eptr21397, i64** %vptr21406, align 8 ; &eptr21397[1]
  %vptr21407 = alloca i64*, align 8 
  %eptr21398 = getelementptr inbounds i64, i64* %cloptr21395, i64 3 
  store volatile i64* %eptr21398, i64** %vptr21407, align 8 ; &eptr21398[2]
  %vptr21408 = alloca i64*, align 8 
  %eptr21399 = getelementptr inbounds i64, i64* %cloptr21395, i64 4 
  store volatile i64* %eptr21399, i64** %vptr21408, align 8 ; &eptr21399[3]
  %vptr21409 = alloca i64*, align 8 
  %eptr21400 = getelementptr inbounds i64, i64* %cloptr21395, i64 5 
  store volatile i64* %eptr21400, i64** %vptr21409, align 8 ; &eptr21400[4]
  %vptr21410 = alloca i64*, align 8 
  %eptr21401 = getelementptr inbounds i64, i64* %cloptr21395, i64 6 
  store volatile i64* %eptr21401, i64** %vptr21410, align 8 ; &eptr21401[5]
  %vptr21411 = alloca i64*, align 8 
  %eptr21402 = getelementptr inbounds i64, i64* %cloptr21395, i64 7 
  store volatile i64* %eptr21402, i64** %vptr21411, align 8 ; &eptr21402[6]
  %vptr21412 = alloca i64*, align 8 
  %eptr21403 = getelementptr inbounds i64, i64* %cloptr21395, i64 8 
  store volatile i64* %eptr21403, i64** %vptr21412, align 8 ; &eptr21403[7]
  store i64 %bmP$nat_45_62peano, i64* %eptr21397                                     ; *eptr21397 = %bmP$nat_45_62peano
  store i64 %emsg18637, i64* %eptr21398                                              ; *eptr21398 = %emsg18637
  store i64 %SdC$_37wind_45stack, i64* %eptr21399                                    ; *eptr21399 = %SdC$_37wind_45stack
  store i64 %gYG$succ, i64* %eptr21400                                               ; *eptr21400 = %gYG$succ
  store i64 %emsg08636, i64* %eptr21401                                              ; *eptr21401 = %emsg08636
  store i64 %Iic$peano_45_62nat, i64* %eptr21402                                     ; *eptr21402 = %Iic$peano_45_62nat
  store i64 %U8g$_37do_45wind, i64* %eptr21403                                       ; *eptr21403 = %U8g$_37do_45wind
  %vptr21413 = alloca i64*, align 8 
  %eptr21396 = getelementptr inbounds i64, i64* %cloptr21395, i64 1 
  store volatile i64* %eptr21396, i64** %vptr21413, align 8 ; &cloptr21395[1]
 %vptr21414 = alloca i64, align 8 
  %f21404 = ptrtoint void(i64,i64)* @lam11978 to i64 
  store volatile i64 %f21404, i64* %vptr21414, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f21404, i64* %eptr21396                                                 ; store fptr
 %vptr21415 = alloca i64, align 8 
  %arg8036 = ptrtoint i64* %cloptr21395 to i64 
  store volatile i64 %arg8036, i64* %vptr21415, align 8 ; closure cast; i64* -> i64
 %vptr21416 = alloca i64, align 8 
  %arg8035 = add i64 0, 0 
  store volatile i64 %arg8035, i64* %vptr21416, align 8 ; quoted ()
 %vptr21417 = alloca i64, align 8 
  %rva10629 = add i64 0, 0 
  store volatile i64 %rva10629, i64* %vptr21417, align 8 ; quoted ()
 %vptr21418 = alloca i64, align 8 
  %rva10628 = call i64 @prim_cons(i64 %retprim7267, i64 %rva10629) 
  store volatile i64 %rva10628, i64* %vptr21418, align 8 ; call prim_cons
 %vptr21419 = alloca i64, align 8 
  %rva10627 = call i64 @prim_cons(i64 %arg8035, i64 %rva10628) 
  store volatile i64 %rva10627, i64* %vptr21419, align 8 ; call prim_cons
  %vptr21425 = alloca i64*, align 8 
  %cloptr21420 = inttoptr i64 %arg8036 to i64* 
  store volatile i64* %cloptr21420, i64** %vptr21425, align 8 ; closure/env cast; i64 -> i64*
  %vptr21426 = alloca i64*, align 8 
  %i0ptr21421 = getelementptr inbounds i64, i64* %cloptr21420, i64 1 
  store volatile i64* %i0ptr21421, i64** %vptr21426, align 8 ; &cloptr21420[1]
 %vptr21427 = alloca i64, align 8 
  %f21423 = load i64, i64* %i0ptr21421, align 8 
  store volatile i64 %f21423, i64* %vptr21427, align 8 ; load; *i0ptr21421
  %fptr21422 = inttoptr i64 %f21423 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21422(i64 %arg8036, i64 %rva10627)                  ; tail call
  ret void

else21391:
 %vptr21428 = alloca i64, align 8 
  %h10632 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10632, i64* %vptr21428, align 8 ; call prim_halt
  %vptr21434 = alloca i64*, align 8 
  %cloptr21429 = inttoptr i64 %h10632 to i64* 
  store volatile i64* %cloptr21429, i64** %vptr21434, align 8 ; closure/env cast; i64 -> i64*
  %vptr21435 = alloca i64*, align 8 
  %i0ptr21430 = getelementptr inbounds i64, i64* %cloptr21429, i64 1 
  store volatile i64* %i0ptr21430, i64** %vptr21435, align 8 ; &cloptr21429[1]
 %vptr21436 = alloca i64, align 8 
  %f21432 = load i64, i64* %i0ptr21430, align 8 
  store volatile i64 %f21432, i64* %vptr21436, align 8 ; load; *i0ptr21430
  %fptr21431 = inttoptr i64 %f21432 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21431(i64 %h10632, i64 %h10632)                     ; tail call
  ret void
}


define void @lam11978(i64 %env11979, i64 %rvp10623) {
 %vptr21439 = alloca i64, align 8 
  %envptr21437 = inttoptr i64 %env11979 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr21439, align 8 ; closure/env cast; i64 -> i64*
  %vptr21440 = alloca i64*, align 8 
  %envptr21438 = getelementptr inbounds i64, i64* %envptr21437, i64 8 
  store volatile i64* %envptr21438, i64** %vptr21440, align 8 ; &envptr21437[7]
 %vptr21441 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr21438, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr21441, align 8 ; load; *envptr21438
 %vptr21444 = alloca i64, align 8 
  %envptr21442 = inttoptr i64 %env11979 to i64* 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr21444, align 8 ; closure/env cast; i64 -> i64*
  %vptr21445 = alloca i64*, align 8 
  %envptr21443 = getelementptr inbounds i64, i64* %envptr21442, i64 7 
  store volatile i64* %envptr21443, i64** %vptr21445, align 8 ; &envptr21442[6]
 %vptr21446 = alloca i64, align 8 
  %Iic$peano_45_62nat = load i64, i64* %envptr21443, align 8 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr21446, align 8 ; load; *envptr21443
 %vptr21449 = alloca i64, align 8 
  %envptr21447 = inttoptr i64 %env11979 to i64* 
  store volatile i64 %emsg08636, i64* %vptr21449, align 8 ; closure/env cast; i64 -> i64*
  %vptr21450 = alloca i64*, align 8 
  %envptr21448 = getelementptr inbounds i64, i64* %envptr21447, i64 6 
  store volatile i64* %envptr21448, i64** %vptr21450, align 8 ; &envptr21447[5]
 %vptr21451 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr21448, align 8 
  store volatile i64 %emsg08636, i64* %vptr21451, align 8 ; load; *envptr21448
 %vptr21454 = alloca i64, align 8 
  %envptr21452 = inttoptr i64 %env11979 to i64* 
  store volatile i64 %gYG$succ, i64* %vptr21454, align 8 ; closure/env cast; i64 -> i64*
  %vptr21455 = alloca i64*, align 8 
  %envptr21453 = getelementptr inbounds i64, i64* %envptr21452, i64 5 
  store volatile i64* %envptr21453, i64** %vptr21455, align 8 ; &envptr21452[4]
 %vptr21456 = alloca i64, align 8 
  %gYG$succ = load i64, i64* %envptr21453, align 8 
  store volatile i64 %gYG$succ, i64* %vptr21456, align 8 ; load; *envptr21453
 %vptr21459 = alloca i64, align 8 
  %envptr21457 = inttoptr i64 %env11979 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr21459, align 8 ; closure/env cast; i64 -> i64*
  %vptr21460 = alloca i64*, align 8 
  %envptr21458 = getelementptr inbounds i64, i64* %envptr21457, i64 4 
  store volatile i64* %envptr21458, i64** %vptr21460, align 8 ; &envptr21457[3]
 %vptr21461 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr21458, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr21461, align 8 ; load; *envptr21458
 %vptr21464 = alloca i64, align 8 
  %envptr21462 = inttoptr i64 %env11979 to i64* 
  store volatile i64 %emsg18637, i64* %vptr21464, align 8 ; closure/env cast; i64 -> i64*
  %vptr21465 = alloca i64*, align 8 
  %envptr21463 = getelementptr inbounds i64, i64* %envptr21462, i64 3 
  store volatile i64* %envptr21463, i64** %vptr21465, align 8 ; &envptr21462[2]
 %vptr21466 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr21463, align 8 
  store volatile i64 %emsg18637, i64* %vptr21466, align 8 ; load; *envptr21463
 %vptr21469 = alloca i64, align 8 
  %envptr21467 = inttoptr i64 %env11979 to i64* 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr21469, align 8 ; closure/env cast; i64 -> i64*
  %vptr21470 = alloca i64*, align 8 
  %envptr21468 = getelementptr inbounds i64, i64* %envptr21467, i64 2 
  store volatile i64* %envptr21468, i64** %vptr21470, align 8 ; &envptr21467[1]
 %vptr21471 = alloca i64, align 8 
  %bmP$nat_45_62peano = load i64, i64* %envptr21468, align 8 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr21471, align 8 ; load; *envptr21468
 %vptr21472 = alloca i64, align 8 
  %_957198 = call i64 @prim_car(i64 %rvp10623) 
  store volatile i64 %_957198, i64* %vptr21472, align 8 ; call prim_car
 %vptr21473 = alloca i64, align 8 
  %rvp10619 = call i64 @prim_cdr(i64 %rvp10623) 
  store volatile i64 %rvp10619, i64* %vptr21473, align 8 ; call prim_cdr
 %vptr21474 = alloca i64, align 8 
  %n_6310624 = call i64 @prim_null_63(i64 %rvp10619) 
  store volatile i64 %n_6310624, i64* %vptr21474, align 8 ; call prim_null_63
  %cmpptr21478 = alloca i1, align 8  %cmp21475 = icmp eq i64 %n_6310624, 15 store volatile i1 %cmp21475, i1* %cmpptr21478, align 8; false?
  br i1 %cmp21475, label %else21477, label %then21476                                ; if

then21476:
 %vptr21479 = alloca i64, align 8 
  %h10625 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10625, i64* %vptr21479, align 8 ; call prim_halt
  %vptr21485 = alloca i64*, align 8 
  %cloptr21480 = inttoptr i64 %h10625 to i64* 
  store volatile i64* %cloptr21480, i64** %vptr21485, align 8 ; closure/env cast; i64 -> i64*
  %vptr21486 = alloca i64*, align 8 
  %i0ptr21481 = getelementptr inbounds i64, i64* %cloptr21480, i64 1 
  store volatile i64* %i0ptr21481, i64** %vptr21486, align 8 ; &cloptr21480[1]
 %vptr21487 = alloca i64, align 8 
  %f21483 = load i64, i64* %i0ptr21481, align 8 
  store volatile i64 %f21483, i64* %vptr21487, align 8 ; load; *i0ptr21481
  %fptr21482 = inttoptr i64 %f21483 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21482(i64 %h10625, i64 %h10625)                     ; tail call
  ret void

else21477:
 %vptr21488 = alloca i64, align 8 
  %Pll$pred = call i64 @prim_car(i64 %rvp10619) 
  store volatile i64 %Pll$pred, i64* %vptr21488, align 8 ; call prim_car
 %vptr21489 = alloca i64, align 8 
  %na9797 = call i64 @prim_cdr(i64 %rvp10619) 
  store volatile i64 %na9797, i64* %vptr21489, align 8 ; call prim_cdr
 %vptr21490 = alloca i64, align 8 
  %n_6310620 = call i64 @prim_null_63(i64 %na9797) 
  store volatile i64 %n_6310620, i64* %vptr21490, align 8 ; call prim_null_63
  %cmpptr21494 = alloca i1, align 8  %cmp21491 = icmp eq i64 %n_6310620, 15 store volatile i1 %cmp21491, i1* %cmpptr21494, align 8; false?
  br i1 %cmp21491, label %else21493, label %then21492                                ; if

then21492:
  %vptr21498 = alloca i64*, align 8 
  %cloptr21495 = call i64* @make_closure(i64 8) 
  store volatile i64* %cloptr21495, i64** %vptr21498, align 8 ; malloc
  %vptr21499 = alloca i64*, align 8 
  %eptr21496 = getelementptr inbounds i64, i64* %cloptr21495, i64 1 
  store volatile i64* %eptr21496, i64** %vptr21499, align 8 ; &cloptr21495[1]
 %vptr21500 = alloca i64, align 8 
  %f21497 = ptrtoint void(i64,i64)* @lam11976 to i64 
  store volatile i64 %f21497, i64* %vptr21500, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f21497, i64* %eptr21496                                                 ; store fptr
 %vptr21501 = alloca i64, align 8 
  %arg8038 = ptrtoint i64* %cloptr21495 to i64 
  store volatile i64 %arg8038, i64* %vptr21501, align 8 ; closure cast; i64* -> i64
  %vptr21513 = alloca i64*, align 8 
  %cloptr21502 = call i64* @make_closure(i64 72) 
  store volatile i64* %cloptr21502, i64** %vptr21513, align 8 ; malloc
  %vptr21514 = alloca i64*, align 8 
  %eptr21504 = getelementptr inbounds i64, i64* %cloptr21502, i64 2 
  store volatile i64* %eptr21504, i64** %vptr21514, align 8 ; &eptr21504[1]
  %vptr21515 = alloca i64*, align 8 
  %eptr21505 = getelementptr inbounds i64, i64* %cloptr21502, i64 3 
  store volatile i64* %eptr21505, i64** %vptr21515, align 8 ; &eptr21505[2]
  %vptr21516 = alloca i64*, align 8 
  %eptr21506 = getelementptr inbounds i64, i64* %cloptr21502, i64 4 
  store volatile i64* %eptr21506, i64** %vptr21516, align 8 ; &eptr21506[3]
  %vptr21517 = alloca i64*, align 8 
  %eptr21507 = getelementptr inbounds i64, i64* %cloptr21502, i64 5 
  store volatile i64* %eptr21507, i64** %vptr21517, align 8 ; &eptr21507[4]
  %vptr21518 = alloca i64*, align 8 
  %eptr21508 = getelementptr inbounds i64, i64* %cloptr21502, i64 6 
  store volatile i64* %eptr21508, i64** %vptr21518, align 8 ; &eptr21508[5]
  %vptr21519 = alloca i64*, align 8 
  %eptr21509 = getelementptr inbounds i64, i64* %cloptr21502, i64 7 
  store volatile i64* %eptr21509, i64** %vptr21519, align 8 ; &eptr21509[6]
  %vptr21520 = alloca i64*, align 8 
  %eptr21510 = getelementptr inbounds i64, i64* %cloptr21502, i64 8 
  store volatile i64* %eptr21510, i64** %vptr21520, align 8 ; &eptr21510[7]
  %vptr21521 = alloca i64*, align 8 
  %eptr21511 = getelementptr inbounds i64, i64* %cloptr21502, i64 9 
  store volatile i64* %eptr21511, i64** %vptr21521, align 8 ; &eptr21511[8]
  store i64 %bmP$nat_45_62peano, i64* %eptr21504                                     ; *eptr21504 = %bmP$nat_45_62peano
  store i64 %emsg18637, i64* %eptr21505                                              ; *eptr21505 = %emsg18637
  store i64 %SdC$_37wind_45stack, i64* %eptr21506                                    ; *eptr21506 = %SdC$_37wind_45stack
  store i64 %Pll$pred, i64* %eptr21507                                               ; *eptr21507 = %Pll$pred
  store i64 %gYG$succ, i64* %eptr21508                                               ; *eptr21508 = %gYG$succ
  store i64 %emsg08636, i64* %eptr21509                                              ; *eptr21509 = %emsg08636
  store i64 %Iic$peano_45_62nat, i64* %eptr21510                                     ; *eptr21510 = %Iic$peano_45_62nat
  store i64 %U8g$_37do_45wind, i64* %eptr21511                                       ; *eptr21511 = %U8g$_37do_45wind
  %vptr21522 = alloca i64*, align 8 
  %eptr21503 = getelementptr inbounds i64, i64* %cloptr21502, i64 1 
  store volatile i64* %eptr21503, i64** %vptr21522, align 8 ; &cloptr21502[1]
 %vptr21523 = alloca i64, align 8 
  %f21512 = ptrtoint void(i64,i64)* @lam11972 to i64 
  store volatile i64 %f21512, i64* %vptr21523, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f21512, i64* %eptr21503                                                 ; store fptr
 %vptr21524 = alloca i64, align 8 
  %arg8037 = ptrtoint i64* %cloptr21502 to i64 
  store volatile i64 %arg8037, i64* %vptr21524, align 8 ; closure cast; i64* -> i64
 %vptr21525 = alloca i64, align 8 
  %rva10618 = add i64 0, 0 
  store volatile i64 %rva10618, i64* %vptr21525, align 8 ; quoted ()
 %vptr21526 = alloca i64, align 8 
  %rva10617 = call i64 @prim_cons(i64 %arg8037, i64 %rva10618) 
  store volatile i64 %rva10617, i64* %vptr21526, align 8 ; call prim_cons
  %vptr21532 = alloca i64*, align 8 
  %cloptr21527 = inttoptr i64 %arg8038 to i64* 
  store volatile i64* %cloptr21527, i64** %vptr21532, align 8 ; closure/env cast; i64 -> i64*
  %vptr21533 = alloca i64*, align 8 
  %i0ptr21528 = getelementptr inbounds i64, i64* %cloptr21527, i64 1 
  store volatile i64* %i0ptr21528, i64** %vptr21533, align 8 ; &cloptr21527[1]
 %vptr21534 = alloca i64, align 8 
  %f21530 = load i64, i64* %i0ptr21528, align 8 
  store volatile i64 %f21530, i64* %vptr21534, align 8 ; load; *i0ptr21528
  %fptr21529 = inttoptr i64 %f21530 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21529(i64 %arg8038, i64 %rva10617)                  ; tail call
  ret void

else21493:
 %vptr21535 = alloca i64, align 8 
  %h10621 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10621, i64* %vptr21535, align 8 ; call prim_halt
  %vptr21541 = alloca i64*, align 8 
  %cloptr21536 = inttoptr i64 %h10621 to i64* 
  store volatile i64* %cloptr21536, i64** %vptr21541, align 8 ; closure/env cast; i64 -> i64*
  %vptr21542 = alloca i64*, align 8 
  %i0ptr21537 = getelementptr inbounds i64, i64* %cloptr21536, i64 1 
  store volatile i64* %i0ptr21537, i64** %vptr21542, align 8 ; &cloptr21536[1]
 %vptr21543 = alloca i64, align 8 
  %f21539 = load i64, i64* %i0ptr21537, align 8 
  store volatile i64 %f21539, i64* %vptr21543, align 8 ; load; *i0ptr21537
  %fptr21538 = inttoptr i64 %f21539 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21538(i64 %h10621, i64 %h10621)                     ; tail call
  ret void
}


define void @lam11976(i64 %env11977, i64 %XQG$lst7265) {
 %vptr21544 = alloca i64, align 8 
  %cont7264 = call i64 @prim_car(i64 %XQG$lst7265) 
  store volatile i64 %cont7264, i64* %vptr21544, align 8 ; call prim_car
 %vptr21545 = alloca i64, align 8 
  %XQG$lst = call i64 @prim_cdr(i64 %XQG$lst7265) 
  store volatile i64 %XQG$lst, i64* %vptr21545, align 8 ; call prim_cdr
 %vptr21546 = alloca i64, align 8 
  %arg8042 = add i64 0, 0 
  store volatile i64 %arg8042, i64* %vptr21546, align 8 ; quoted ()
 %vptr21547 = alloca i64, align 8 
  %rva9800 = add i64 0, 0 
  store volatile i64 %rva9800, i64* %vptr21547, align 8 ; quoted ()
 %vptr21548 = alloca i64, align 8 
  %rva9799 = call i64 @prim_cons(i64 %XQG$lst, i64 %rva9800) 
  store volatile i64 %rva9799, i64* %vptr21548, align 8 ; call prim_cons
 %vptr21549 = alloca i64, align 8 
  %rva9798 = call i64 @prim_cons(i64 %arg8042, i64 %rva9799) 
  store volatile i64 %rva9798, i64* %vptr21549, align 8 ; call prim_cons
  %vptr21555 = alloca i64*, align 8 
  %cloptr21550 = inttoptr i64 %cont7264 to i64* 
  store volatile i64* %cloptr21550, i64** %vptr21555, align 8 ; closure/env cast; i64 -> i64*
  %vptr21556 = alloca i64*, align 8 
  %i0ptr21551 = getelementptr inbounds i64, i64* %cloptr21550, i64 1 
  store volatile i64* %i0ptr21551, i64** %vptr21556, align 8 ; &cloptr21550[1]
 %vptr21557 = alloca i64, align 8 
  %f21553 = load i64, i64* %i0ptr21551, align 8 
  store volatile i64 %f21553, i64* %vptr21557, align 8 ; load; *i0ptr21551
  %fptr21552 = inttoptr i64 %f21553 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21552(i64 %cont7264, i64 %rva9798)                  ; tail call
  ret void
}


define void @lam11972(i64 %env11973, i64 %rvp10613) {
 %vptr21560 = alloca i64, align 8 
  %envptr21558 = inttoptr i64 %env11973 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr21560, align 8 ; closure/env cast; i64 -> i64*
  %vptr21561 = alloca i64*, align 8 
  %envptr21559 = getelementptr inbounds i64, i64* %envptr21558, i64 9 
  store volatile i64* %envptr21559, i64** %vptr21561, align 8 ; &envptr21558[8]
 %vptr21562 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr21559, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr21562, align 8 ; load; *envptr21559
 %vptr21565 = alloca i64, align 8 
  %envptr21563 = inttoptr i64 %env11973 to i64* 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr21565, align 8 ; closure/env cast; i64 -> i64*
  %vptr21566 = alloca i64*, align 8 
  %envptr21564 = getelementptr inbounds i64, i64* %envptr21563, i64 8 
  store volatile i64* %envptr21564, i64** %vptr21566, align 8 ; &envptr21563[7]
 %vptr21567 = alloca i64, align 8 
  %Iic$peano_45_62nat = load i64, i64* %envptr21564, align 8 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr21567, align 8 ; load; *envptr21564
 %vptr21570 = alloca i64, align 8 
  %envptr21568 = inttoptr i64 %env11973 to i64* 
  store volatile i64 %emsg08636, i64* %vptr21570, align 8 ; closure/env cast; i64 -> i64*
  %vptr21571 = alloca i64*, align 8 
  %envptr21569 = getelementptr inbounds i64, i64* %envptr21568, i64 7 
  store volatile i64* %envptr21569, i64** %vptr21571, align 8 ; &envptr21568[6]
 %vptr21572 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr21569, align 8 
  store volatile i64 %emsg08636, i64* %vptr21572, align 8 ; load; *envptr21569
 %vptr21575 = alloca i64, align 8 
  %envptr21573 = inttoptr i64 %env11973 to i64* 
  store volatile i64 %gYG$succ, i64* %vptr21575, align 8 ; closure/env cast; i64 -> i64*
  %vptr21576 = alloca i64*, align 8 
  %envptr21574 = getelementptr inbounds i64, i64* %envptr21573, i64 6 
  store volatile i64* %envptr21574, i64** %vptr21576, align 8 ; &envptr21573[5]
 %vptr21577 = alloca i64, align 8 
  %gYG$succ = load i64, i64* %envptr21574, align 8 
  store volatile i64 %gYG$succ, i64* %vptr21577, align 8 ; load; *envptr21574
 %vptr21580 = alloca i64, align 8 
  %envptr21578 = inttoptr i64 %env11973 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr21580, align 8 ; closure/env cast; i64 -> i64*
  %vptr21581 = alloca i64*, align 8 
  %envptr21579 = getelementptr inbounds i64, i64* %envptr21578, i64 5 
  store volatile i64* %envptr21579, i64** %vptr21581, align 8 ; &envptr21578[4]
 %vptr21582 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr21579, align 8 
  store volatile i64 %Pll$pred, i64* %vptr21582, align 8 ; load; *envptr21579
 %vptr21585 = alloca i64, align 8 
  %envptr21583 = inttoptr i64 %env11973 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr21585, align 8 ; closure/env cast; i64 -> i64*
  %vptr21586 = alloca i64*, align 8 
  %envptr21584 = getelementptr inbounds i64, i64* %envptr21583, i64 4 
  store volatile i64* %envptr21584, i64** %vptr21586, align 8 ; &envptr21583[3]
 %vptr21587 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr21584, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr21587, align 8 ; load; *envptr21584
 %vptr21590 = alloca i64, align 8 
  %envptr21588 = inttoptr i64 %env11973 to i64* 
  store volatile i64 %emsg18637, i64* %vptr21590, align 8 ; closure/env cast; i64 -> i64*
  %vptr21591 = alloca i64*, align 8 
  %envptr21589 = getelementptr inbounds i64, i64* %envptr21588, i64 3 
  store volatile i64* %envptr21589, i64** %vptr21591, align 8 ; &envptr21588[2]
 %vptr21592 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr21589, align 8 
  store volatile i64 %emsg18637, i64* %vptr21592, align 8 ; load; *envptr21589
 %vptr21595 = alloca i64, align 8 
  %envptr21593 = inttoptr i64 %env11973 to i64* 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr21595, align 8 ; closure/env cast; i64 -> i64*
  %vptr21596 = alloca i64*, align 8 
  %envptr21594 = getelementptr inbounds i64, i64* %envptr21593, i64 2 
  store volatile i64* %envptr21594, i64** %vptr21596, align 8 ; &envptr21593[1]
 %vptr21597 = alloca i64, align 8 
  %bmP$nat_45_62peano = load i64, i64* %envptr21594, align 8 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr21597, align 8 ; load; *envptr21594
 %vptr21598 = alloca i64, align 8 
  %_957262 = call i64 @prim_car(i64 %rvp10613) 
  store volatile i64 %_957262, i64* %vptr21598, align 8 ; call prim_car
 %vptr21599 = alloca i64, align 8 
  %rvp10609 = call i64 @prim_cdr(i64 %rvp10613) 
  store volatile i64 %rvp10609, i64* %vptr21599, align 8 ; call prim_cdr
 %vptr21600 = alloca i64, align 8 
  %n_6310614 = call i64 @prim_null_63(i64 %rvp10609) 
  store volatile i64 %n_6310614, i64* %vptr21600, align 8 ; call prim_null_63
  %cmpptr21604 = alloca i1, align 8  %cmp21601 = icmp eq i64 %n_6310614, 15 store volatile i1 %cmp21601, i1* %cmpptr21604, align 8; false?
  br i1 %cmp21601, label %else21603, label %then21602                                ; if

then21602:
 %vptr21605 = alloca i64, align 8 
  %h10615 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10615, i64* %vptr21605, align 8 ; call prim_halt
  %vptr21611 = alloca i64*, align 8 
  %cloptr21606 = inttoptr i64 %h10615 to i64* 
  store volatile i64* %cloptr21606, i64** %vptr21611, align 8 ; closure/env cast; i64 -> i64*
  %vptr21612 = alloca i64*, align 8 
  %i0ptr21607 = getelementptr inbounds i64, i64* %cloptr21606, i64 1 
  store volatile i64* %i0ptr21607, i64** %vptr21612, align 8 ; &cloptr21606[1]
 %vptr21613 = alloca i64, align 8 
  %f21609 = load i64, i64* %i0ptr21607, align 8 
  store volatile i64 %f21609, i64* %vptr21613, align 8 ; load; *i0ptr21607
  %fptr21608 = inttoptr i64 %f21609 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21608(i64 %h10615, i64 %h10615)                     ; tail call
  ret void

else21603:
 %vptr21614 = alloca i64, align 8 
  %a7035 = call i64 @prim_car(i64 %rvp10609) 
  store volatile i64 %a7035, i64* %vptr21614, align 8 ; call prim_car
 %vptr21615 = alloca i64, align 8 
  %na9802 = call i64 @prim_cdr(i64 %rvp10609) 
  store volatile i64 %na9802, i64* %vptr21615, align 8 ; call prim_cdr
 %vptr21616 = alloca i64, align 8 
  %n_6310610 = call i64 @prim_null_63(i64 %na9802) 
  store volatile i64 %n_6310610, i64* %vptr21616, align 8 ; call prim_null_63
  %cmpptr21620 = alloca i1, align 8  %cmp21617 = icmp eq i64 %n_6310610, 15 store volatile i1 %cmp21617, i1* %cmpptr21620, align 8; false?
  br i1 %cmp21617, label %else21619, label %then21618                                ; if

then21618:
 %vptr21621 = alloca i64, align 8 
  %arg8045 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg8045, i64* %vptr21621, align 8 ; quoted int
 %vptr21622 = alloca i64, align 8 
  %retprim7263 = call i64 @prim_make_45vector(i64 %arg8045, i64 %a7035) 
  store volatile i64 %retprim7263, i64* %vptr21622, align 8 ; call prim_make_45vector
  %vptr21634 = alloca i64*, align 8 
  %cloptr21623 = call i64* @make_closure(i64 72) 
  store volatile i64* %cloptr21623, i64** %vptr21634, align 8 ; malloc
  %vptr21635 = alloca i64*, align 8 
  %eptr21625 = getelementptr inbounds i64, i64* %cloptr21623, i64 2 
  store volatile i64* %eptr21625, i64** %vptr21635, align 8 ; &eptr21625[1]
  %vptr21636 = alloca i64*, align 8 
  %eptr21626 = getelementptr inbounds i64, i64* %cloptr21623, i64 3 
  store volatile i64* %eptr21626, i64** %vptr21636, align 8 ; &eptr21626[2]
  %vptr21637 = alloca i64*, align 8 
  %eptr21627 = getelementptr inbounds i64, i64* %cloptr21623, i64 4 
  store volatile i64* %eptr21627, i64** %vptr21637, align 8 ; &eptr21627[3]
  %vptr21638 = alloca i64*, align 8 
  %eptr21628 = getelementptr inbounds i64, i64* %cloptr21623, i64 5 
  store volatile i64* %eptr21628, i64** %vptr21638, align 8 ; &eptr21628[4]
  %vptr21639 = alloca i64*, align 8 
  %eptr21629 = getelementptr inbounds i64, i64* %cloptr21623, i64 6 
  store volatile i64* %eptr21629, i64** %vptr21639, align 8 ; &eptr21629[5]
  %vptr21640 = alloca i64*, align 8 
  %eptr21630 = getelementptr inbounds i64, i64* %cloptr21623, i64 7 
  store volatile i64* %eptr21630, i64** %vptr21640, align 8 ; &eptr21630[6]
  %vptr21641 = alloca i64*, align 8 
  %eptr21631 = getelementptr inbounds i64, i64* %cloptr21623, i64 8 
  store volatile i64* %eptr21631, i64** %vptr21641, align 8 ; &eptr21631[7]
  %vptr21642 = alloca i64*, align 8 
  %eptr21632 = getelementptr inbounds i64, i64* %cloptr21623, i64 9 
  store volatile i64* %eptr21632, i64** %vptr21642, align 8 ; &eptr21632[8]
  store i64 %bmP$nat_45_62peano, i64* %eptr21625                                     ; *eptr21625 = %bmP$nat_45_62peano
  store i64 %emsg18637, i64* %eptr21626                                              ; *eptr21626 = %emsg18637
  store i64 %SdC$_37wind_45stack, i64* %eptr21627                                    ; *eptr21627 = %SdC$_37wind_45stack
  store i64 %Pll$pred, i64* %eptr21628                                               ; *eptr21628 = %Pll$pred
  store i64 %gYG$succ, i64* %eptr21629                                               ; *eptr21629 = %gYG$succ
  store i64 %emsg08636, i64* %eptr21630                                              ; *eptr21630 = %emsg08636
  store i64 %Iic$peano_45_62nat, i64* %eptr21631                                     ; *eptr21631 = %Iic$peano_45_62nat
  store i64 %U8g$_37do_45wind, i64* %eptr21632                                       ; *eptr21632 = %U8g$_37do_45wind
  %vptr21643 = alloca i64*, align 8 
  %eptr21624 = getelementptr inbounds i64, i64* %cloptr21623, i64 1 
  store volatile i64* %eptr21624, i64** %vptr21643, align 8 ; &cloptr21623[1]
 %vptr21644 = alloca i64, align 8 
  %f21633 = ptrtoint void(i64,i64)* @lam11969 to i64 
  store volatile i64 %f21633, i64* %vptr21644, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f21633, i64* %eptr21624                                                 ; store fptr
 %vptr21645 = alloca i64, align 8 
  %arg8048 = ptrtoint i64* %cloptr21623 to i64 
  store volatile i64 %arg8048, i64* %vptr21645, align 8 ; closure cast; i64* -> i64
 %vptr21646 = alloca i64, align 8 
  %arg8047 = add i64 0, 0 
  store volatile i64 %arg8047, i64* %vptr21646, align 8 ; quoted ()
 %vptr21647 = alloca i64, align 8 
  %rva10608 = add i64 0, 0 
  store volatile i64 %rva10608, i64* %vptr21647, align 8 ; quoted ()
 %vptr21648 = alloca i64, align 8 
  %rva10607 = call i64 @prim_cons(i64 %retprim7263, i64 %rva10608) 
  store volatile i64 %rva10607, i64* %vptr21648, align 8 ; call prim_cons
 %vptr21649 = alloca i64, align 8 
  %rva10606 = call i64 @prim_cons(i64 %arg8047, i64 %rva10607) 
  store volatile i64 %rva10606, i64* %vptr21649, align 8 ; call prim_cons
  %vptr21655 = alloca i64*, align 8 
  %cloptr21650 = inttoptr i64 %arg8048 to i64* 
  store volatile i64* %cloptr21650, i64** %vptr21655, align 8 ; closure/env cast; i64 -> i64*
  %vptr21656 = alloca i64*, align 8 
  %i0ptr21651 = getelementptr inbounds i64, i64* %cloptr21650, i64 1 
  store volatile i64* %i0ptr21651, i64** %vptr21656, align 8 ; &cloptr21650[1]
 %vptr21657 = alloca i64, align 8 
  %f21653 = load i64, i64* %i0ptr21651, align 8 
  store volatile i64 %f21653, i64* %vptr21657, align 8 ; load; *i0ptr21651
  %fptr21652 = inttoptr i64 %f21653 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21652(i64 %arg8048, i64 %rva10606)                  ; tail call
  ret void

else21619:
 %vptr21658 = alloca i64, align 8 
  %h10611 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10611, i64* %vptr21658, align 8 ; call prim_halt
  %vptr21664 = alloca i64*, align 8 
  %cloptr21659 = inttoptr i64 %h10611 to i64* 
  store volatile i64* %cloptr21659, i64** %vptr21664, align 8 ; closure/env cast; i64 -> i64*
  %vptr21665 = alloca i64*, align 8 
  %i0ptr21660 = getelementptr inbounds i64, i64* %cloptr21659, i64 1 
  store volatile i64* %i0ptr21660, i64** %vptr21665, align 8 ; &cloptr21659[1]
 %vptr21666 = alloca i64, align 8 
  %f21662 = load i64, i64* %i0ptr21660, align 8 
  store volatile i64 %f21662, i64* %vptr21666, align 8 ; load; *i0ptr21660
  %fptr21661 = inttoptr i64 %f21662 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21661(i64 %h10611, i64 %h10611)                     ; tail call
  ret void
}


define void @lam11969(i64 %env11970, i64 %rvp10602) {
 %vptr21669 = alloca i64, align 8 
  %envptr21667 = inttoptr i64 %env11970 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr21669, align 8 ; closure/env cast; i64 -> i64*
  %vptr21670 = alloca i64*, align 8 
  %envptr21668 = getelementptr inbounds i64, i64* %envptr21667, i64 9 
  store volatile i64* %envptr21668, i64** %vptr21670, align 8 ; &envptr21667[8]
 %vptr21671 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr21668, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr21671, align 8 ; load; *envptr21668
 %vptr21674 = alloca i64, align 8 
  %envptr21672 = inttoptr i64 %env11970 to i64* 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr21674, align 8 ; closure/env cast; i64 -> i64*
  %vptr21675 = alloca i64*, align 8 
  %envptr21673 = getelementptr inbounds i64, i64* %envptr21672, i64 8 
  store volatile i64* %envptr21673, i64** %vptr21675, align 8 ; &envptr21672[7]
 %vptr21676 = alloca i64, align 8 
  %Iic$peano_45_62nat = load i64, i64* %envptr21673, align 8 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr21676, align 8 ; load; *envptr21673
 %vptr21679 = alloca i64, align 8 
  %envptr21677 = inttoptr i64 %env11970 to i64* 
  store volatile i64 %emsg08636, i64* %vptr21679, align 8 ; closure/env cast; i64 -> i64*
  %vptr21680 = alloca i64*, align 8 
  %envptr21678 = getelementptr inbounds i64, i64* %envptr21677, i64 7 
  store volatile i64* %envptr21678, i64** %vptr21680, align 8 ; &envptr21677[6]
 %vptr21681 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr21678, align 8 
  store volatile i64 %emsg08636, i64* %vptr21681, align 8 ; load; *envptr21678
 %vptr21684 = alloca i64, align 8 
  %envptr21682 = inttoptr i64 %env11970 to i64* 
  store volatile i64 %gYG$succ, i64* %vptr21684, align 8 ; closure/env cast; i64 -> i64*
  %vptr21685 = alloca i64*, align 8 
  %envptr21683 = getelementptr inbounds i64, i64* %envptr21682, i64 6 
  store volatile i64* %envptr21683, i64** %vptr21685, align 8 ; &envptr21682[5]
 %vptr21686 = alloca i64, align 8 
  %gYG$succ = load i64, i64* %envptr21683, align 8 
  store volatile i64 %gYG$succ, i64* %vptr21686, align 8 ; load; *envptr21683
 %vptr21689 = alloca i64, align 8 
  %envptr21687 = inttoptr i64 %env11970 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr21689, align 8 ; closure/env cast; i64 -> i64*
  %vptr21690 = alloca i64*, align 8 
  %envptr21688 = getelementptr inbounds i64, i64* %envptr21687, i64 5 
  store volatile i64* %envptr21688, i64** %vptr21690, align 8 ; &envptr21687[4]
 %vptr21691 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr21688, align 8 
  store volatile i64 %Pll$pred, i64* %vptr21691, align 8 ; load; *envptr21688
 %vptr21694 = alloca i64, align 8 
  %envptr21692 = inttoptr i64 %env11970 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr21694, align 8 ; closure/env cast; i64 -> i64*
  %vptr21695 = alloca i64*, align 8 
  %envptr21693 = getelementptr inbounds i64, i64* %envptr21692, i64 4 
  store volatile i64* %envptr21693, i64** %vptr21695, align 8 ; &envptr21692[3]
 %vptr21696 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr21693, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr21696, align 8 ; load; *envptr21693
 %vptr21699 = alloca i64, align 8 
  %envptr21697 = inttoptr i64 %env11970 to i64* 
  store volatile i64 %emsg18637, i64* %vptr21699, align 8 ; closure/env cast; i64 -> i64*
  %vptr21700 = alloca i64*, align 8 
  %envptr21698 = getelementptr inbounds i64, i64* %envptr21697, i64 3 
  store volatile i64* %envptr21698, i64** %vptr21700, align 8 ; &envptr21697[2]
 %vptr21701 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr21698, align 8 
  store volatile i64 %emsg18637, i64* %vptr21701, align 8 ; load; *envptr21698
 %vptr21704 = alloca i64, align 8 
  %envptr21702 = inttoptr i64 %env11970 to i64* 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr21704, align 8 ; closure/env cast; i64 -> i64*
  %vptr21705 = alloca i64*, align 8 
  %envptr21703 = getelementptr inbounds i64, i64* %envptr21702, i64 2 
  store volatile i64* %envptr21703, i64** %vptr21705, align 8 ; &envptr21702[1]
 %vptr21706 = alloca i64, align 8 
  %bmP$nat_45_62peano = load i64, i64* %envptr21703, align 8 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr21706, align 8 ; load; *envptr21703
 %vptr21707 = alloca i64, align 8 
  %_957199 = call i64 @prim_car(i64 %rvp10602) 
  store volatile i64 %_957199, i64* %vptr21707, align 8 ; call prim_car
 %vptr21708 = alloca i64, align 8 
  %rvp10598 = call i64 @prim_cdr(i64 %rvp10602) 
  store volatile i64 %rvp10598, i64* %vptr21708, align 8 ; call prim_cdr
 %vptr21709 = alloca i64, align 8 
  %n_6310603 = call i64 @prim_null_63(i64 %rvp10598) 
  store volatile i64 %n_6310603, i64* %vptr21709, align 8 ; call prim_null_63
  %cmpptr21713 = alloca i1, align 8  %cmp21710 = icmp eq i64 %n_6310603, 15 store volatile i1 %cmp21710, i1* %cmpptr21713, align 8; false?
  br i1 %cmp21710, label %else21712, label %then21711                                ; if

then21711:
 %vptr21714 = alloca i64, align 8 
  %h10604 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10604, i64* %vptr21714, align 8 ; call prim_halt
  %vptr21720 = alloca i64*, align 8 
  %cloptr21715 = inttoptr i64 %h10604 to i64* 
  store volatile i64* %cloptr21715, i64** %vptr21720, align 8 ; closure/env cast; i64 -> i64*
  %vptr21721 = alloca i64*, align 8 
  %i0ptr21716 = getelementptr inbounds i64, i64* %cloptr21715, i64 1 
  store volatile i64* %i0ptr21716, i64** %vptr21721, align 8 ; &cloptr21715[1]
 %vptr21722 = alloca i64, align 8 
  %f21718 = load i64, i64* %i0ptr21716, align 8 
  store volatile i64 %f21718, i64* %vptr21722, align 8 ; load; *i0ptr21716
  %fptr21717 = inttoptr i64 %f21718 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21717(i64 %h10604, i64 %h10604)                     ; tail call
  ret void

else21712:
 %vptr21723 = alloca i64, align 8 
  %bbE$z_63 = call i64 @prim_car(i64 %rvp10598) 
  store volatile i64 %bbE$z_63, i64* %vptr21723, align 8 ; call prim_car
 %vptr21724 = alloca i64, align 8 
  %na9804 = call i64 @prim_cdr(i64 %rvp10598) 
  store volatile i64 %na9804, i64* %vptr21724, align 8 ; call prim_cdr
 %vptr21725 = alloca i64, align 8 
  %n_6310599 = call i64 @prim_null_63(i64 %na9804) 
  store volatile i64 %n_6310599, i64* %vptr21725, align 8 ; call prim_null_63
  %cmpptr21729 = alloca i1, align 8  %cmp21726 = icmp eq i64 %n_6310599, 15 store volatile i1 %cmp21726, i1* %cmpptr21729, align 8; false?
  br i1 %cmp21726, label %else21728, label %then21727                                ; if

then21727:
  %vptr21733 = alloca i64*, align 8 
  %cloptr21730 = call i64* @make_closure(i64 8) 
  store volatile i64* %cloptr21730, i64** %vptr21733, align 8 ; malloc
  %vptr21734 = alloca i64*, align 8 
  %eptr21731 = getelementptr inbounds i64, i64* %cloptr21730, i64 1 
  store volatile i64* %eptr21731, i64** %vptr21734, align 8 ; &cloptr21730[1]
 %vptr21735 = alloca i64, align 8 
  %f21732 = ptrtoint void(i64,i64)* @lam11967 to i64 
  store volatile i64 %f21732, i64* %vptr21735, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f21732, i64* %eptr21731                                                 ; store fptr
 %vptr21736 = alloca i64, align 8 
  %arg8050 = ptrtoint i64* %cloptr21730 to i64 
  store volatile i64 %arg8050, i64* %vptr21736, align 8 ; closure cast; i64* -> i64
  %vptr21749 = alloca i64*, align 8 
  %cloptr21737 = call i64* @make_closure(i64 80) 
  store volatile i64* %cloptr21737, i64** %vptr21749, align 8 ; malloc
  %vptr21750 = alloca i64*, align 8 
  %eptr21739 = getelementptr inbounds i64, i64* %cloptr21737, i64 2 
  store volatile i64* %eptr21739, i64** %vptr21750, align 8 ; &eptr21739[1]
  %vptr21751 = alloca i64*, align 8 
  %eptr21740 = getelementptr inbounds i64, i64* %cloptr21737, i64 3 
  store volatile i64* %eptr21740, i64** %vptr21751, align 8 ; &eptr21740[2]
  %vptr21752 = alloca i64*, align 8 
  %eptr21741 = getelementptr inbounds i64, i64* %cloptr21737, i64 4 
  store volatile i64* %eptr21741, i64** %vptr21752, align 8 ; &eptr21741[3]
  %vptr21753 = alloca i64*, align 8 
  %eptr21742 = getelementptr inbounds i64, i64* %cloptr21737, i64 5 
  store volatile i64* %eptr21742, i64** %vptr21753, align 8 ; &eptr21742[4]
  %vptr21754 = alloca i64*, align 8 
  %eptr21743 = getelementptr inbounds i64, i64* %cloptr21737, i64 6 
  store volatile i64* %eptr21743, i64** %vptr21754, align 8 ; &eptr21743[5]
  %vptr21755 = alloca i64*, align 8 
  %eptr21744 = getelementptr inbounds i64, i64* %cloptr21737, i64 7 
  store volatile i64* %eptr21744, i64** %vptr21755, align 8 ; &eptr21744[6]
  %vptr21756 = alloca i64*, align 8 
  %eptr21745 = getelementptr inbounds i64, i64* %cloptr21737, i64 8 
  store volatile i64* %eptr21745, i64** %vptr21756, align 8 ; &eptr21745[7]
  %vptr21757 = alloca i64*, align 8 
  %eptr21746 = getelementptr inbounds i64, i64* %cloptr21737, i64 9 
  store volatile i64* %eptr21746, i64** %vptr21757, align 8 ; &eptr21746[8]
  %vptr21758 = alloca i64*, align 8 
  %eptr21747 = getelementptr inbounds i64, i64* %cloptr21737, i64 10 
  store volatile i64* %eptr21747, i64** %vptr21758, align 8 ; &eptr21747[9]
  store i64 %bmP$nat_45_62peano, i64* %eptr21739                                     ; *eptr21739 = %bmP$nat_45_62peano
  store i64 %emsg18637, i64* %eptr21740                                              ; *eptr21740 = %emsg18637
  store i64 %SdC$_37wind_45stack, i64* %eptr21741                                    ; *eptr21741 = %SdC$_37wind_45stack
  store i64 %Pll$pred, i64* %eptr21742                                               ; *eptr21742 = %Pll$pred
  store i64 %gYG$succ, i64* %eptr21743                                               ; *eptr21743 = %gYG$succ
  store i64 %emsg08636, i64* %eptr21744                                              ; *eptr21744 = %emsg08636
  store i64 %Iic$peano_45_62nat, i64* %eptr21745                                     ; *eptr21745 = %Iic$peano_45_62nat
  store i64 %bbE$z_63, i64* %eptr21746                                               ; *eptr21746 = %bbE$z_63
  store i64 %U8g$_37do_45wind, i64* %eptr21747                                       ; *eptr21747 = %U8g$_37do_45wind
  %vptr21759 = alloca i64*, align 8 
  %eptr21738 = getelementptr inbounds i64, i64* %cloptr21737, i64 1 
  store volatile i64* %eptr21738, i64** %vptr21759, align 8 ; &cloptr21737[1]
 %vptr21760 = alloca i64, align 8 
  %f21748 = ptrtoint void(i64,i64)* @lam11963 to i64 
  store volatile i64 %f21748, i64* %vptr21760, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f21748, i64* %eptr21738                                                 ; store fptr
 %vptr21761 = alloca i64, align 8 
  %arg8049 = ptrtoint i64* %cloptr21737 to i64 
  store volatile i64 %arg8049, i64* %vptr21761, align 8 ; closure cast; i64* -> i64
 %vptr21762 = alloca i64, align 8 
  %rva10597 = add i64 0, 0 
  store volatile i64 %rva10597, i64* %vptr21762, align 8 ; quoted ()
 %vptr21763 = alloca i64, align 8 
  %rva10596 = call i64 @prim_cons(i64 %arg8049, i64 %rva10597) 
  store volatile i64 %rva10596, i64* %vptr21763, align 8 ; call prim_cons
  %vptr21769 = alloca i64*, align 8 
  %cloptr21764 = inttoptr i64 %arg8050 to i64* 
  store volatile i64* %cloptr21764, i64** %vptr21769, align 8 ; closure/env cast; i64 -> i64*
  %vptr21770 = alloca i64*, align 8 
  %i0ptr21765 = getelementptr inbounds i64, i64* %cloptr21764, i64 1 
  store volatile i64* %i0ptr21765, i64** %vptr21770, align 8 ; &cloptr21764[1]
 %vptr21771 = alloca i64, align 8 
  %f21767 = load i64, i64* %i0ptr21765, align 8 
  store volatile i64 %f21767, i64* %vptr21771, align 8 ; load; *i0ptr21765
  %fptr21766 = inttoptr i64 %f21767 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21766(i64 %arg8050, i64 %rva10596)                  ; tail call
  ret void

else21728:
 %vptr21772 = alloca i64, align 8 
  %h10600 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10600, i64* %vptr21772, align 8 ; call prim_halt
  %vptr21778 = alloca i64*, align 8 
  %cloptr21773 = inttoptr i64 %h10600 to i64* 
  store volatile i64* %cloptr21773, i64** %vptr21778, align 8 ; closure/env cast; i64 -> i64*
  %vptr21779 = alloca i64*, align 8 
  %i0ptr21774 = getelementptr inbounds i64, i64* %cloptr21773, i64 1 
  store volatile i64* %i0ptr21774, i64** %vptr21779, align 8 ; &cloptr21773[1]
 %vptr21780 = alloca i64, align 8 
  %f21776 = load i64, i64* %i0ptr21774, align 8 
  store volatile i64 %f21776, i64* %vptr21780, align 8 ; load; *i0ptr21774
  %fptr21775 = inttoptr i64 %f21776 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21775(i64 %h10600, i64 %h10600)                     ; tail call
  ret void
}


define void @lam11967(i64 %env11968, i64 %vGp$lst7261) {
 %vptr21781 = alloca i64, align 8 
  %cont7260 = call i64 @prim_car(i64 %vGp$lst7261) 
  store volatile i64 %cont7260, i64* %vptr21781, align 8 ; call prim_car
 %vptr21782 = alloca i64, align 8 
  %vGp$lst = call i64 @prim_cdr(i64 %vGp$lst7261) 
  store volatile i64 %vGp$lst, i64* %vptr21782, align 8 ; call prim_cdr
 %vptr21783 = alloca i64, align 8 
  %arg8054 = add i64 0, 0 
  store volatile i64 %arg8054, i64* %vptr21783, align 8 ; quoted ()
 %vptr21784 = alloca i64, align 8 
  %rva9807 = add i64 0, 0 
  store volatile i64 %rva9807, i64* %vptr21784, align 8 ; quoted ()
 %vptr21785 = alloca i64, align 8 
  %rva9806 = call i64 @prim_cons(i64 %vGp$lst, i64 %rva9807) 
  store volatile i64 %rva9806, i64* %vptr21785, align 8 ; call prim_cons
 %vptr21786 = alloca i64, align 8 
  %rva9805 = call i64 @prim_cons(i64 %arg8054, i64 %rva9806) 
  store volatile i64 %rva9805, i64* %vptr21786, align 8 ; call prim_cons
  %vptr21792 = alloca i64*, align 8 
  %cloptr21787 = inttoptr i64 %cont7260 to i64* 
  store volatile i64* %cloptr21787, i64** %vptr21792, align 8 ; closure/env cast; i64 -> i64*
  %vptr21793 = alloca i64*, align 8 
  %i0ptr21788 = getelementptr inbounds i64, i64* %cloptr21787, i64 1 
  store volatile i64* %i0ptr21788, i64** %vptr21793, align 8 ; &cloptr21787[1]
 %vptr21794 = alloca i64, align 8 
  %f21790 = load i64, i64* %i0ptr21788, align 8 
  store volatile i64 %f21790, i64* %vptr21794, align 8 ; load; *i0ptr21788
  %fptr21789 = inttoptr i64 %f21790 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21789(i64 %cont7260, i64 %rva9805)                  ; tail call
  ret void
}


define void @lam11963(i64 %env11964, i64 %rvp10592) {
 %vptr21797 = alloca i64, align 8 
  %envptr21795 = inttoptr i64 %env11964 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr21797, align 8 ; closure/env cast; i64 -> i64*
  %vptr21798 = alloca i64*, align 8 
  %envptr21796 = getelementptr inbounds i64, i64* %envptr21795, i64 10 
  store volatile i64* %envptr21796, i64** %vptr21798, align 8 ; &envptr21795[9]
 %vptr21799 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr21796, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr21799, align 8 ; load; *envptr21796
 %vptr21802 = alloca i64, align 8 
  %envptr21800 = inttoptr i64 %env11964 to i64* 
  store volatile i64 %bbE$z_63, i64* %vptr21802, align 8 ; closure/env cast; i64 -> i64*
  %vptr21803 = alloca i64*, align 8 
  %envptr21801 = getelementptr inbounds i64, i64* %envptr21800, i64 9 
  store volatile i64* %envptr21801, i64** %vptr21803, align 8 ; &envptr21800[8]
 %vptr21804 = alloca i64, align 8 
  %bbE$z_63 = load i64, i64* %envptr21801, align 8 
  store volatile i64 %bbE$z_63, i64* %vptr21804, align 8 ; load; *envptr21801
 %vptr21807 = alloca i64, align 8 
  %envptr21805 = inttoptr i64 %env11964 to i64* 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr21807, align 8 ; closure/env cast; i64 -> i64*
  %vptr21808 = alloca i64*, align 8 
  %envptr21806 = getelementptr inbounds i64, i64* %envptr21805, i64 8 
  store volatile i64* %envptr21806, i64** %vptr21808, align 8 ; &envptr21805[7]
 %vptr21809 = alloca i64, align 8 
  %Iic$peano_45_62nat = load i64, i64* %envptr21806, align 8 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr21809, align 8 ; load; *envptr21806
 %vptr21812 = alloca i64, align 8 
  %envptr21810 = inttoptr i64 %env11964 to i64* 
  store volatile i64 %emsg08636, i64* %vptr21812, align 8 ; closure/env cast; i64 -> i64*
  %vptr21813 = alloca i64*, align 8 
  %envptr21811 = getelementptr inbounds i64, i64* %envptr21810, i64 7 
  store volatile i64* %envptr21811, i64** %vptr21813, align 8 ; &envptr21810[6]
 %vptr21814 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr21811, align 8 
  store volatile i64 %emsg08636, i64* %vptr21814, align 8 ; load; *envptr21811
 %vptr21817 = alloca i64, align 8 
  %envptr21815 = inttoptr i64 %env11964 to i64* 
  store volatile i64 %gYG$succ, i64* %vptr21817, align 8 ; closure/env cast; i64 -> i64*
  %vptr21818 = alloca i64*, align 8 
  %envptr21816 = getelementptr inbounds i64, i64* %envptr21815, i64 6 
  store volatile i64* %envptr21816, i64** %vptr21818, align 8 ; &envptr21815[5]
 %vptr21819 = alloca i64, align 8 
  %gYG$succ = load i64, i64* %envptr21816, align 8 
  store volatile i64 %gYG$succ, i64* %vptr21819, align 8 ; load; *envptr21816
 %vptr21822 = alloca i64, align 8 
  %envptr21820 = inttoptr i64 %env11964 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr21822, align 8 ; closure/env cast; i64 -> i64*
  %vptr21823 = alloca i64*, align 8 
  %envptr21821 = getelementptr inbounds i64, i64* %envptr21820, i64 5 
  store volatile i64* %envptr21821, i64** %vptr21823, align 8 ; &envptr21820[4]
 %vptr21824 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr21821, align 8 
  store volatile i64 %Pll$pred, i64* %vptr21824, align 8 ; load; *envptr21821
 %vptr21827 = alloca i64, align 8 
  %envptr21825 = inttoptr i64 %env11964 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr21827, align 8 ; closure/env cast; i64 -> i64*
  %vptr21828 = alloca i64*, align 8 
  %envptr21826 = getelementptr inbounds i64, i64* %envptr21825, i64 4 
  store volatile i64* %envptr21826, i64** %vptr21828, align 8 ; &envptr21825[3]
 %vptr21829 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr21826, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr21829, align 8 ; load; *envptr21826
 %vptr21832 = alloca i64, align 8 
  %envptr21830 = inttoptr i64 %env11964 to i64* 
  store volatile i64 %emsg18637, i64* %vptr21832, align 8 ; closure/env cast; i64 -> i64*
  %vptr21833 = alloca i64*, align 8 
  %envptr21831 = getelementptr inbounds i64, i64* %envptr21830, i64 3 
  store volatile i64* %envptr21831, i64** %vptr21833, align 8 ; &envptr21830[2]
 %vptr21834 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr21831, align 8 
  store volatile i64 %emsg18637, i64* %vptr21834, align 8 ; load; *envptr21831
 %vptr21837 = alloca i64, align 8 
  %envptr21835 = inttoptr i64 %env11964 to i64* 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr21837, align 8 ; closure/env cast; i64 -> i64*
  %vptr21838 = alloca i64*, align 8 
  %envptr21836 = getelementptr inbounds i64, i64* %envptr21835, i64 2 
  store volatile i64* %envptr21836, i64** %vptr21838, align 8 ; &envptr21835[1]
 %vptr21839 = alloca i64, align 8 
  %bmP$nat_45_62peano = load i64, i64* %envptr21836, align 8 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr21839, align 8 ; load; *envptr21836
 %vptr21840 = alloca i64, align 8 
  %_957258 = call i64 @prim_car(i64 %rvp10592) 
  store volatile i64 %_957258, i64* %vptr21840, align 8 ; call prim_car
 %vptr21841 = alloca i64, align 8 
  %rvp10588 = call i64 @prim_cdr(i64 %rvp10592) 
  store volatile i64 %rvp10588, i64* %vptr21841, align 8 ; call prim_cdr
 %vptr21842 = alloca i64, align 8 
  %n_6310593 = call i64 @prim_null_63(i64 %rvp10588) 
  store volatile i64 %n_6310593, i64* %vptr21842, align 8 ; call prim_null_63
  %cmpptr21846 = alloca i1, align 8  %cmp21843 = icmp eq i64 %n_6310593, 15 store volatile i1 %cmp21843, i1* %cmpptr21846, align 8; false?
  br i1 %cmp21843, label %else21845, label %then21844                                ; if

then21844:
 %vptr21847 = alloca i64, align 8 
  %h10594 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10594, i64* %vptr21847, align 8 ; call prim_halt
  %vptr21853 = alloca i64*, align 8 
  %cloptr21848 = inttoptr i64 %h10594 to i64* 
  store volatile i64* %cloptr21848, i64** %vptr21853, align 8 ; closure/env cast; i64 -> i64*
  %vptr21854 = alloca i64*, align 8 
  %i0ptr21849 = getelementptr inbounds i64, i64* %cloptr21848, i64 1 
  store volatile i64* %i0ptr21849, i64** %vptr21854, align 8 ; &cloptr21848[1]
 %vptr21855 = alloca i64, align 8 
  %f21851 = load i64, i64* %i0ptr21849, align 8 
  store volatile i64 %f21851, i64* %vptr21855, align 8 ; load; *i0ptr21849
  %fptr21850 = inttoptr i64 %f21851 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21850(i64 %h10594, i64 %h10594)                     ; tail call
  ret void

else21845:
 %vptr21856 = alloca i64, align 8 
  %a7036 = call i64 @prim_car(i64 %rvp10588) 
  store volatile i64 %a7036, i64* %vptr21856, align 8 ; call prim_car
 %vptr21857 = alloca i64, align 8 
  %na9809 = call i64 @prim_cdr(i64 %rvp10588) 
  store volatile i64 %na9809, i64* %vptr21857, align 8 ; call prim_cdr
 %vptr21858 = alloca i64, align 8 
  %n_6310589 = call i64 @prim_null_63(i64 %na9809) 
  store volatile i64 %n_6310589, i64* %vptr21858, align 8 ; call prim_null_63
  %cmpptr21862 = alloca i1, align 8  %cmp21859 = icmp eq i64 %n_6310589, 15 store volatile i1 %cmp21859, i1* %cmpptr21862, align 8; false?
  br i1 %cmp21859, label %else21861, label %then21860                                ; if

then21860:
 %vptr21863 = alloca i64, align 8 
  %arg8057 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg8057, i64* %vptr21863, align 8 ; quoted int
 %vptr21864 = alloca i64, align 8 
  %retprim7259 = call i64 @prim_make_45vector(i64 %arg8057, i64 %a7036) 
  store volatile i64 %retprim7259, i64* %vptr21864, align 8 ; call prim_make_45vector
  %vptr21877 = alloca i64*, align 8 
  %cloptr21865 = call i64* @make_closure(i64 80) 
  store volatile i64* %cloptr21865, i64** %vptr21877, align 8 ; malloc
  %vptr21878 = alloca i64*, align 8 
  %eptr21867 = getelementptr inbounds i64, i64* %cloptr21865, i64 2 
  store volatile i64* %eptr21867, i64** %vptr21878, align 8 ; &eptr21867[1]
  %vptr21879 = alloca i64*, align 8 
  %eptr21868 = getelementptr inbounds i64, i64* %cloptr21865, i64 3 
  store volatile i64* %eptr21868, i64** %vptr21879, align 8 ; &eptr21868[2]
  %vptr21880 = alloca i64*, align 8 
  %eptr21869 = getelementptr inbounds i64, i64* %cloptr21865, i64 4 
  store volatile i64* %eptr21869, i64** %vptr21880, align 8 ; &eptr21869[3]
  %vptr21881 = alloca i64*, align 8 
  %eptr21870 = getelementptr inbounds i64, i64* %cloptr21865, i64 5 
  store volatile i64* %eptr21870, i64** %vptr21881, align 8 ; &eptr21870[4]
  %vptr21882 = alloca i64*, align 8 
  %eptr21871 = getelementptr inbounds i64, i64* %cloptr21865, i64 6 
  store volatile i64* %eptr21871, i64** %vptr21882, align 8 ; &eptr21871[5]
  %vptr21883 = alloca i64*, align 8 
  %eptr21872 = getelementptr inbounds i64, i64* %cloptr21865, i64 7 
  store volatile i64* %eptr21872, i64** %vptr21883, align 8 ; &eptr21872[6]
  %vptr21884 = alloca i64*, align 8 
  %eptr21873 = getelementptr inbounds i64, i64* %cloptr21865, i64 8 
  store volatile i64* %eptr21873, i64** %vptr21884, align 8 ; &eptr21873[7]
  %vptr21885 = alloca i64*, align 8 
  %eptr21874 = getelementptr inbounds i64, i64* %cloptr21865, i64 9 
  store volatile i64* %eptr21874, i64** %vptr21885, align 8 ; &eptr21874[8]
  %vptr21886 = alloca i64*, align 8 
  %eptr21875 = getelementptr inbounds i64, i64* %cloptr21865, i64 10 
  store volatile i64* %eptr21875, i64** %vptr21886, align 8 ; &eptr21875[9]
  store i64 %bmP$nat_45_62peano, i64* %eptr21867                                     ; *eptr21867 = %bmP$nat_45_62peano
  store i64 %emsg18637, i64* %eptr21868                                              ; *eptr21868 = %emsg18637
  store i64 %SdC$_37wind_45stack, i64* %eptr21869                                    ; *eptr21869 = %SdC$_37wind_45stack
  store i64 %Pll$pred, i64* %eptr21870                                               ; *eptr21870 = %Pll$pred
  store i64 %gYG$succ, i64* %eptr21871                                               ; *eptr21871 = %gYG$succ
  store i64 %emsg08636, i64* %eptr21872                                              ; *eptr21872 = %emsg08636
  store i64 %Iic$peano_45_62nat, i64* %eptr21873                                     ; *eptr21873 = %Iic$peano_45_62nat
  store i64 %bbE$z_63, i64* %eptr21874                                               ; *eptr21874 = %bbE$z_63
  store i64 %U8g$_37do_45wind, i64* %eptr21875                                       ; *eptr21875 = %U8g$_37do_45wind
  %vptr21887 = alloca i64*, align 8 
  %eptr21866 = getelementptr inbounds i64, i64* %cloptr21865, i64 1 
  store volatile i64* %eptr21866, i64** %vptr21887, align 8 ; &cloptr21865[1]
 %vptr21888 = alloca i64, align 8 
  %f21876 = ptrtoint void(i64,i64)* @lam11960 to i64 
  store volatile i64 %f21876, i64* %vptr21888, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f21876, i64* %eptr21866                                                 ; store fptr
 %vptr21889 = alloca i64, align 8 
  %arg8060 = ptrtoint i64* %cloptr21865 to i64 
  store volatile i64 %arg8060, i64* %vptr21889, align 8 ; closure cast; i64* -> i64
 %vptr21890 = alloca i64, align 8 
  %arg8059 = add i64 0, 0 
  store volatile i64 %arg8059, i64* %vptr21890, align 8 ; quoted ()
 %vptr21891 = alloca i64, align 8 
  %rva10587 = add i64 0, 0 
  store volatile i64 %rva10587, i64* %vptr21891, align 8 ; quoted ()
 %vptr21892 = alloca i64, align 8 
  %rva10586 = call i64 @prim_cons(i64 %retprim7259, i64 %rva10587) 
  store volatile i64 %rva10586, i64* %vptr21892, align 8 ; call prim_cons
 %vptr21893 = alloca i64, align 8 
  %rva10585 = call i64 @prim_cons(i64 %arg8059, i64 %rva10586) 
  store volatile i64 %rva10585, i64* %vptr21893, align 8 ; call prim_cons
  %vptr21899 = alloca i64*, align 8 
  %cloptr21894 = inttoptr i64 %arg8060 to i64* 
  store volatile i64* %cloptr21894, i64** %vptr21899, align 8 ; closure/env cast; i64 -> i64*
  %vptr21900 = alloca i64*, align 8 
  %i0ptr21895 = getelementptr inbounds i64, i64* %cloptr21894, i64 1 
  store volatile i64* %i0ptr21895, i64** %vptr21900, align 8 ; &cloptr21894[1]
 %vptr21901 = alloca i64, align 8 
  %f21897 = load i64, i64* %i0ptr21895, align 8 
  store volatile i64 %f21897, i64* %vptr21901, align 8 ; load; *i0ptr21895
  %fptr21896 = inttoptr i64 %f21897 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21896(i64 %arg8060, i64 %rva10585)                  ; tail call
  ret void

else21861:
 %vptr21902 = alloca i64, align 8 
  %h10590 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10590, i64* %vptr21902, align 8 ; call prim_halt
  %vptr21908 = alloca i64*, align 8 
  %cloptr21903 = inttoptr i64 %h10590 to i64* 
  store volatile i64* %cloptr21903, i64** %vptr21908, align 8 ; closure/env cast; i64 -> i64*
  %vptr21909 = alloca i64*, align 8 
  %i0ptr21904 = getelementptr inbounds i64, i64* %cloptr21903, i64 1 
  store volatile i64* %i0ptr21904, i64** %vptr21909, align 8 ; &cloptr21903[1]
 %vptr21910 = alloca i64, align 8 
  %f21906 = load i64, i64* %i0ptr21904, align 8 
  store volatile i64 %f21906, i64* %vptr21910, align 8 ; load; *i0ptr21904
  %fptr21905 = inttoptr i64 %f21906 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21905(i64 %h10590, i64 %h10590)                     ; tail call
  ret void
}


define void @lam11960(i64 %env11961, i64 %rvp10581) {
 %vptr21913 = alloca i64, align 8 
  %envptr21911 = inttoptr i64 %env11961 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr21913, align 8 ; closure/env cast; i64 -> i64*
  %vptr21914 = alloca i64*, align 8 
  %envptr21912 = getelementptr inbounds i64, i64* %envptr21911, i64 10 
  store volatile i64* %envptr21912, i64** %vptr21914, align 8 ; &envptr21911[9]
 %vptr21915 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr21912, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr21915, align 8 ; load; *envptr21912
 %vptr21918 = alloca i64, align 8 
  %envptr21916 = inttoptr i64 %env11961 to i64* 
  store volatile i64 %bbE$z_63, i64* %vptr21918, align 8 ; closure/env cast; i64 -> i64*
  %vptr21919 = alloca i64*, align 8 
  %envptr21917 = getelementptr inbounds i64, i64* %envptr21916, i64 9 
  store volatile i64* %envptr21917, i64** %vptr21919, align 8 ; &envptr21916[8]
 %vptr21920 = alloca i64, align 8 
  %bbE$z_63 = load i64, i64* %envptr21917, align 8 
  store volatile i64 %bbE$z_63, i64* %vptr21920, align 8 ; load; *envptr21917
 %vptr21923 = alloca i64, align 8 
  %envptr21921 = inttoptr i64 %env11961 to i64* 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr21923, align 8 ; closure/env cast; i64 -> i64*
  %vptr21924 = alloca i64*, align 8 
  %envptr21922 = getelementptr inbounds i64, i64* %envptr21921, i64 8 
  store volatile i64* %envptr21922, i64** %vptr21924, align 8 ; &envptr21921[7]
 %vptr21925 = alloca i64, align 8 
  %Iic$peano_45_62nat = load i64, i64* %envptr21922, align 8 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr21925, align 8 ; load; *envptr21922
 %vptr21928 = alloca i64, align 8 
  %envptr21926 = inttoptr i64 %env11961 to i64* 
  store volatile i64 %emsg08636, i64* %vptr21928, align 8 ; closure/env cast; i64 -> i64*
  %vptr21929 = alloca i64*, align 8 
  %envptr21927 = getelementptr inbounds i64, i64* %envptr21926, i64 7 
  store volatile i64* %envptr21927, i64** %vptr21929, align 8 ; &envptr21926[6]
 %vptr21930 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr21927, align 8 
  store volatile i64 %emsg08636, i64* %vptr21930, align 8 ; load; *envptr21927
 %vptr21933 = alloca i64, align 8 
  %envptr21931 = inttoptr i64 %env11961 to i64* 
  store volatile i64 %gYG$succ, i64* %vptr21933, align 8 ; closure/env cast; i64 -> i64*
  %vptr21934 = alloca i64*, align 8 
  %envptr21932 = getelementptr inbounds i64, i64* %envptr21931, i64 6 
  store volatile i64* %envptr21932, i64** %vptr21934, align 8 ; &envptr21931[5]
 %vptr21935 = alloca i64, align 8 
  %gYG$succ = load i64, i64* %envptr21932, align 8 
  store volatile i64 %gYG$succ, i64* %vptr21935, align 8 ; load; *envptr21932
 %vptr21938 = alloca i64, align 8 
  %envptr21936 = inttoptr i64 %env11961 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr21938, align 8 ; closure/env cast; i64 -> i64*
  %vptr21939 = alloca i64*, align 8 
  %envptr21937 = getelementptr inbounds i64, i64* %envptr21936, i64 5 
  store volatile i64* %envptr21937, i64** %vptr21939, align 8 ; &envptr21936[4]
 %vptr21940 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr21937, align 8 
  store volatile i64 %Pll$pred, i64* %vptr21940, align 8 ; load; *envptr21937
 %vptr21943 = alloca i64, align 8 
  %envptr21941 = inttoptr i64 %env11961 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr21943, align 8 ; closure/env cast; i64 -> i64*
  %vptr21944 = alloca i64*, align 8 
  %envptr21942 = getelementptr inbounds i64, i64* %envptr21941, i64 4 
  store volatile i64* %envptr21942, i64** %vptr21944, align 8 ; &envptr21941[3]
 %vptr21945 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr21942, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr21945, align 8 ; load; *envptr21942
 %vptr21948 = alloca i64, align 8 
  %envptr21946 = inttoptr i64 %env11961 to i64* 
  store volatile i64 %emsg18637, i64* %vptr21948, align 8 ; closure/env cast; i64 -> i64*
  %vptr21949 = alloca i64*, align 8 
  %envptr21947 = getelementptr inbounds i64, i64* %envptr21946, i64 3 
  store volatile i64* %envptr21947, i64** %vptr21949, align 8 ; &envptr21946[2]
 %vptr21950 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr21947, align 8 
  store volatile i64 %emsg18637, i64* %vptr21950, align 8 ; load; *envptr21947
 %vptr21953 = alloca i64, align 8 
  %envptr21951 = inttoptr i64 %env11961 to i64* 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr21953, align 8 ; closure/env cast; i64 -> i64*
  %vptr21954 = alloca i64*, align 8 
  %envptr21952 = getelementptr inbounds i64, i64* %envptr21951, i64 2 
  store volatile i64* %envptr21952, i64** %vptr21954, align 8 ; &envptr21951[1]
 %vptr21955 = alloca i64, align 8 
  %bmP$nat_45_62peano = load i64, i64* %envptr21952, align 8 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr21955, align 8 ; load; *envptr21952
 %vptr21956 = alloca i64, align 8 
  %_957200 = call i64 @prim_car(i64 %rvp10581) 
  store volatile i64 %_957200, i64* %vptr21956, align 8 ; call prim_car
 %vptr21957 = alloca i64, align 8 
  %rvp10577 = call i64 @prim_cdr(i64 %rvp10581) 
  store volatile i64 %rvp10577, i64* %vptr21957, align 8 ; call prim_cdr
 %vptr21958 = alloca i64, align 8 
  %n_6310582 = call i64 @prim_null_63(i64 %rvp10577) 
  store volatile i64 %n_6310582, i64* %vptr21958, align 8 ; call prim_null_63
  %cmpptr21962 = alloca i1, align 8  %cmp21959 = icmp eq i64 %n_6310582, 15 store volatile i1 %cmp21959, i1* %cmpptr21962, align 8; false?
  br i1 %cmp21959, label %else21961, label %then21960                                ; if

then21960:
 %vptr21963 = alloca i64, align 8 
  %h10583 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10583, i64* %vptr21963, align 8 ; call prim_halt
  %vptr21969 = alloca i64*, align 8 
  %cloptr21964 = inttoptr i64 %h10583 to i64* 
  store volatile i64* %cloptr21964, i64** %vptr21969, align 8 ; closure/env cast; i64 -> i64*
  %vptr21970 = alloca i64*, align 8 
  %i0ptr21965 = getelementptr inbounds i64, i64* %cloptr21964, i64 1 
  store volatile i64* %i0ptr21965, i64** %vptr21970, align 8 ; &cloptr21964[1]
 %vptr21971 = alloca i64, align 8 
  %f21967 = load i64, i64* %i0ptr21965, align 8 
  store volatile i64 %f21967, i64* %vptr21971, align 8 ; load; *i0ptr21965
  %fptr21966 = inttoptr i64 %f21967 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr21966(i64 %h10583, i64 %h10583)                     ; tail call
  ret void

else21961:
 %vptr21972 = alloca i64, align 8 
  %Ttp$addc = call i64 @prim_car(i64 %rvp10577) 
  store volatile i64 %Ttp$addc, i64* %vptr21972, align 8 ; call prim_car
 %vptr21973 = alloca i64, align 8 
  %na9811 = call i64 @prim_cdr(i64 %rvp10577) 
  store volatile i64 %na9811, i64* %vptr21973, align 8 ; call prim_cdr
 %vptr21974 = alloca i64, align 8 
  %n_6310578 = call i64 @prim_null_63(i64 %na9811) 
  store volatile i64 %n_6310578, i64* %vptr21974, align 8 ; call prim_null_63
  %cmpptr21978 = alloca i1, align 8  %cmp21975 = icmp eq i64 %n_6310578, 15 store volatile i1 %cmp21975, i1* %cmpptr21978, align 8; false?
  br i1 %cmp21975, label %else21977, label %then21976                                ; if

then21976:
  %vptr21982 = alloca i64*, align 8 
  %cloptr21979 = call i64* @make_closure(i64 8) 
  store volatile i64* %cloptr21979, i64** %vptr21982, align 8 ; malloc
  %vptr21983 = alloca i64*, align 8 
  %eptr21980 = getelementptr inbounds i64, i64* %cloptr21979, i64 1 
  store volatile i64* %eptr21980, i64** %vptr21983, align 8 ; &cloptr21979[1]
 %vptr21984 = alloca i64, align 8 
  %f21981 = ptrtoint void(i64,i64)* @lam11958 to i64 
  store volatile i64 %f21981, i64* %vptr21984, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f21981, i64* %eptr21980                                                 ; store fptr
 %vptr21985 = alloca i64, align 8 
  %arg8062 = ptrtoint i64* %cloptr21979 to i64 
  store volatile i64 %arg8062, i64* %vptr21985, align 8 ; closure cast; i64* -> i64
  %vptr21999 = alloca i64*, align 8 
  %cloptr21986 = call i64* @make_closure(i64 88) 
  store volatile i64* %cloptr21986, i64** %vptr21999, align 8 ; malloc
  %vptr22000 = alloca i64*, align 8 
  %eptr21988 = getelementptr inbounds i64, i64* %cloptr21986, i64 2 
  store volatile i64* %eptr21988, i64** %vptr22000, align 8 ; &eptr21988[1]
  %vptr22001 = alloca i64*, align 8 
  %eptr21989 = getelementptr inbounds i64, i64* %cloptr21986, i64 3 
  store volatile i64* %eptr21989, i64** %vptr22001, align 8 ; &eptr21989[2]
  %vptr22002 = alloca i64*, align 8 
  %eptr21990 = getelementptr inbounds i64, i64* %cloptr21986, i64 4 
  store volatile i64* %eptr21990, i64** %vptr22002, align 8 ; &eptr21990[3]
  %vptr22003 = alloca i64*, align 8 
  %eptr21991 = getelementptr inbounds i64, i64* %cloptr21986, i64 5 
  store volatile i64* %eptr21991, i64** %vptr22003, align 8 ; &eptr21991[4]
  %vptr22004 = alloca i64*, align 8 
  %eptr21992 = getelementptr inbounds i64, i64* %cloptr21986, i64 6 
  store volatile i64* %eptr21992, i64** %vptr22004, align 8 ; &eptr21992[5]
  %vptr22005 = alloca i64*, align 8 
  %eptr21993 = getelementptr inbounds i64, i64* %cloptr21986, i64 7 
  store volatile i64* %eptr21993, i64** %vptr22005, align 8 ; &eptr21993[6]
  %vptr22006 = alloca i64*, align 8 
  %eptr21994 = getelementptr inbounds i64, i64* %cloptr21986, i64 8 
  store volatile i64* %eptr21994, i64** %vptr22006, align 8 ; &eptr21994[7]
  %vptr22007 = alloca i64*, align 8 
  %eptr21995 = getelementptr inbounds i64, i64* %cloptr21986, i64 9 
  store volatile i64* %eptr21995, i64** %vptr22007, align 8 ; &eptr21995[8]
  %vptr22008 = alloca i64*, align 8 
  %eptr21996 = getelementptr inbounds i64, i64* %cloptr21986, i64 10 
  store volatile i64* %eptr21996, i64** %vptr22008, align 8 ; &eptr21996[9]
  %vptr22009 = alloca i64*, align 8 
  %eptr21997 = getelementptr inbounds i64, i64* %cloptr21986, i64 11 
  store volatile i64* %eptr21997, i64** %vptr22009, align 8 ; &eptr21997[10]
  store i64 %bmP$nat_45_62peano, i64* %eptr21988                                     ; *eptr21988 = %bmP$nat_45_62peano
  store i64 %emsg18637, i64* %eptr21989                                              ; *eptr21989 = %emsg18637
  store i64 %Ttp$addc, i64* %eptr21990                                               ; *eptr21990 = %Ttp$addc
  store i64 %SdC$_37wind_45stack, i64* %eptr21991                                    ; *eptr21991 = %SdC$_37wind_45stack
  store i64 %Pll$pred, i64* %eptr21992                                               ; *eptr21992 = %Pll$pred
  store i64 %gYG$succ, i64* %eptr21993                                               ; *eptr21993 = %gYG$succ
  store i64 %emsg08636, i64* %eptr21994                                              ; *eptr21994 = %emsg08636
  store i64 %Iic$peano_45_62nat, i64* %eptr21995                                     ; *eptr21995 = %Iic$peano_45_62nat
  store i64 %bbE$z_63, i64* %eptr21996                                               ; *eptr21996 = %bbE$z_63
  store i64 %U8g$_37do_45wind, i64* %eptr21997                                       ; *eptr21997 = %U8g$_37do_45wind
  %vptr22010 = alloca i64*, align 8 
  %eptr21987 = getelementptr inbounds i64, i64* %cloptr21986, i64 1 
  store volatile i64* %eptr21987, i64** %vptr22010, align 8 ; &cloptr21986[1]
 %vptr22011 = alloca i64, align 8 
  %f21998 = ptrtoint void(i64,i64)* @lam11954 to i64 
  store volatile i64 %f21998, i64* %vptr22011, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f21998, i64* %eptr21987                                                 ; store fptr
 %vptr22012 = alloca i64, align 8 
  %arg8061 = ptrtoint i64* %cloptr21986 to i64 
  store volatile i64 %arg8061, i64* %vptr22012, align 8 ; closure cast; i64* -> i64
 %vptr22013 = alloca i64, align 8 
  %rva10576 = add i64 0, 0 
  store volatile i64 %rva10576, i64* %vptr22013, align 8 ; quoted ()
 %vptr22014 = alloca i64, align 8 
  %rva10575 = call i64 @prim_cons(i64 %arg8061, i64 %rva10576) 
  store volatile i64 %rva10575, i64* %vptr22014, align 8 ; call prim_cons
  %vptr22020 = alloca i64*, align 8 
  %cloptr22015 = inttoptr i64 %arg8062 to i64* 
  store volatile i64* %cloptr22015, i64** %vptr22020, align 8 ; closure/env cast; i64 -> i64*
  %vptr22021 = alloca i64*, align 8 
  %i0ptr22016 = getelementptr inbounds i64, i64* %cloptr22015, i64 1 
  store volatile i64* %i0ptr22016, i64** %vptr22021, align 8 ; &cloptr22015[1]
 %vptr22022 = alloca i64, align 8 
  %f22018 = load i64, i64* %i0ptr22016, align 8 
  store volatile i64 %f22018, i64* %vptr22022, align 8 ; load; *i0ptr22016
  %fptr22017 = inttoptr i64 %f22018 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22017(i64 %arg8062, i64 %rva10575)                  ; tail call
  ret void

else21977:
 %vptr22023 = alloca i64, align 8 
  %h10579 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10579, i64* %vptr22023, align 8 ; call prim_halt
  %vptr22029 = alloca i64*, align 8 
  %cloptr22024 = inttoptr i64 %h10579 to i64* 
  store volatile i64* %cloptr22024, i64** %vptr22029, align 8 ; closure/env cast; i64 -> i64*
  %vptr22030 = alloca i64*, align 8 
  %i0ptr22025 = getelementptr inbounds i64, i64* %cloptr22024, i64 1 
  store volatile i64* %i0ptr22025, i64** %vptr22030, align 8 ; &cloptr22024[1]
 %vptr22031 = alloca i64, align 8 
  %f22027 = load i64, i64* %i0ptr22025, align 8 
  store volatile i64 %f22027, i64* %vptr22031, align 8 ; load; *i0ptr22025
  %fptr22026 = inttoptr i64 %f22027 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22026(i64 %h10579, i64 %h10579)                     ; tail call
  ret void
}


define void @lam11958(i64 %env11959, i64 %v5F$lst7257) {
 %vptr22032 = alloca i64, align 8 
  %cont7256 = call i64 @prim_car(i64 %v5F$lst7257) 
  store volatile i64 %cont7256, i64* %vptr22032, align 8 ; call prim_car
 %vptr22033 = alloca i64, align 8 
  %v5F$lst = call i64 @prim_cdr(i64 %v5F$lst7257) 
  store volatile i64 %v5F$lst, i64* %vptr22033, align 8 ; call prim_cdr
 %vptr22034 = alloca i64, align 8 
  %arg8066 = add i64 0, 0 
  store volatile i64 %arg8066, i64* %vptr22034, align 8 ; quoted ()
 %vptr22035 = alloca i64, align 8 
  %rva9814 = add i64 0, 0 
  store volatile i64 %rva9814, i64* %vptr22035, align 8 ; quoted ()
 %vptr22036 = alloca i64, align 8 
  %rva9813 = call i64 @prim_cons(i64 %v5F$lst, i64 %rva9814) 
  store volatile i64 %rva9813, i64* %vptr22036, align 8 ; call prim_cons
 %vptr22037 = alloca i64, align 8 
  %rva9812 = call i64 @prim_cons(i64 %arg8066, i64 %rva9813) 
  store volatile i64 %rva9812, i64* %vptr22037, align 8 ; call prim_cons
  %vptr22043 = alloca i64*, align 8 
  %cloptr22038 = inttoptr i64 %cont7256 to i64* 
  store volatile i64* %cloptr22038, i64** %vptr22043, align 8 ; closure/env cast; i64 -> i64*
  %vptr22044 = alloca i64*, align 8 
  %i0ptr22039 = getelementptr inbounds i64, i64* %cloptr22038, i64 1 
  store volatile i64* %i0ptr22039, i64** %vptr22044, align 8 ; &cloptr22038[1]
 %vptr22045 = alloca i64, align 8 
  %f22041 = load i64, i64* %i0ptr22039, align 8 
  store volatile i64 %f22041, i64* %vptr22045, align 8 ; load; *i0ptr22039
  %fptr22040 = inttoptr i64 %f22041 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22040(i64 %cont7256, i64 %rva9812)                  ; tail call
  ret void
}


define void @lam11954(i64 %env11955, i64 %rvp10571) {
 %vptr22048 = alloca i64, align 8 
  %envptr22046 = inttoptr i64 %env11955 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr22048, align 8 ; closure/env cast; i64 -> i64*
  %vptr22049 = alloca i64*, align 8 
  %envptr22047 = getelementptr inbounds i64, i64* %envptr22046, i64 11 
  store volatile i64* %envptr22047, i64** %vptr22049, align 8 ; &envptr22046[10]
 %vptr22050 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr22047, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr22050, align 8 ; load; *envptr22047
 %vptr22053 = alloca i64, align 8 
  %envptr22051 = inttoptr i64 %env11955 to i64* 
  store volatile i64 %bbE$z_63, i64* %vptr22053, align 8 ; closure/env cast; i64 -> i64*
  %vptr22054 = alloca i64*, align 8 
  %envptr22052 = getelementptr inbounds i64, i64* %envptr22051, i64 10 
  store volatile i64* %envptr22052, i64** %vptr22054, align 8 ; &envptr22051[9]
 %vptr22055 = alloca i64, align 8 
  %bbE$z_63 = load i64, i64* %envptr22052, align 8 
  store volatile i64 %bbE$z_63, i64* %vptr22055, align 8 ; load; *envptr22052
 %vptr22058 = alloca i64, align 8 
  %envptr22056 = inttoptr i64 %env11955 to i64* 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr22058, align 8 ; closure/env cast; i64 -> i64*
  %vptr22059 = alloca i64*, align 8 
  %envptr22057 = getelementptr inbounds i64, i64* %envptr22056, i64 9 
  store volatile i64* %envptr22057, i64** %vptr22059, align 8 ; &envptr22056[8]
 %vptr22060 = alloca i64, align 8 
  %Iic$peano_45_62nat = load i64, i64* %envptr22057, align 8 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr22060, align 8 ; load; *envptr22057
 %vptr22063 = alloca i64, align 8 
  %envptr22061 = inttoptr i64 %env11955 to i64* 
  store volatile i64 %emsg08636, i64* %vptr22063, align 8 ; closure/env cast; i64 -> i64*
  %vptr22064 = alloca i64*, align 8 
  %envptr22062 = getelementptr inbounds i64, i64* %envptr22061, i64 8 
  store volatile i64* %envptr22062, i64** %vptr22064, align 8 ; &envptr22061[7]
 %vptr22065 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr22062, align 8 
  store volatile i64 %emsg08636, i64* %vptr22065, align 8 ; load; *envptr22062
 %vptr22068 = alloca i64, align 8 
  %envptr22066 = inttoptr i64 %env11955 to i64* 
  store volatile i64 %gYG$succ, i64* %vptr22068, align 8 ; closure/env cast; i64 -> i64*
  %vptr22069 = alloca i64*, align 8 
  %envptr22067 = getelementptr inbounds i64, i64* %envptr22066, i64 7 
  store volatile i64* %envptr22067, i64** %vptr22069, align 8 ; &envptr22066[6]
 %vptr22070 = alloca i64, align 8 
  %gYG$succ = load i64, i64* %envptr22067, align 8 
  store volatile i64 %gYG$succ, i64* %vptr22070, align 8 ; load; *envptr22067
 %vptr22073 = alloca i64, align 8 
  %envptr22071 = inttoptr i64 %env11955 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr22073, align 8 ; closure/env cast; i64 -> i64*
  %vptr22074 = alloca i64*, align 8 
  %envptr22072 = getelementptr inbounds i64, i64* %envptr22071, i64 6 
  store volatile i64* %envptr22072, i64** %vptr22074, align 8 ; &envptr22071[5]
 %vptr22075 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr22072, align 8 
  store volatile i64 %Pll$pred, i64* %vptr22075, align 8 ; load; *envptr22072
 %vptr22078 = alloca i64, align 8 
  %envptr22076 = inttoptr i64 %env11955 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr22078, align 8 ; closure/env cast; i64 -> i64*
  %vptr22079 = alloca i64*, align 8 
  %envptr22077 = getelementptr inbounds i64, i64* %envptr22076, i64 5 
  store volatile i64* %envptr22077, i64** %vptr22079, align 8 ; &envptr22076[4]
 %vptr22080 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr22077, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr22080, align 8 ; load; *envptr22077
 %vptr22083 = alloca i64, align 8 
  %envptr22081 = inttoptr i64 %env11955 to i64* 
  store volatile i64 %Ttp$addc, i64* %vptr22083, align 8 ; closure/env cast; i64 -> i64*
  %vptr22084 = alloca i64*, align 8 
  %envptr22082 = getelementptr inbounds i64, i64* %envptr22081, i64 4 
  store volatile i64* %envptr22082, i64** %vptr22084, align 8 ; &envptr22081[3]
 %vptr22085 = alloca i64, align 8 
  %Ttp$addc = load i64, i64* %envptr22082, align 8 
  store volatile i64 %Ttp$addc, i64* %vptr22085, align 8 ; load; *envptr22082
 %vptr22088 = alloca i64, align 8 
  %envptr22086 = inttoptr i64 %env11955 to i64* 
  store volatile i64 %emsg18637, i64* %vptr22088, align 8 ; closure/env cast; i64 -> i64*
  %vptr22089 = alloca i64*, align 8 
  %envptr22087 = getelementptr inbounds i64, i64* %envptr22086, i64 3 
  store volatile i64* %envptr22087, i64** %vptr22089, align 8 ; &envptr22086[2]
 %vptr22090 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr22087, align 8 
  store volatile i64 %emsg18637, i64* %vptr22090, align 8 ; load; *envptr22087
 %vptr22093 = alloca i64, align 8 
  %envptr22091 = inttoptr i64 %env11955 to i64* 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr22093, align 8 ; closure/env cast; i64 -> i64*
  %vptr22094 = alloca i64*, align 8 
  %envptr22092 = getelementptr inbounds i64, i64* %envptr22091, i64 2 
  store volatile i64* %envptr22092, i64** %vptr22094, align 8 ; &envptr22091[1]
 %vptr22095 = alloca i64, align 8 
  %bmP$nat_45_62peano = load i64, i64* %envptr22092, align 8 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr22095, align 8 ; load; *envptr22092
 %vptr22096 = alloca i64, align 8 
  %_957254 = call i64 @prim_car(i64 %rvp10571) 
  store volatile i64 %_957254, i64* %vptr22096, align 8 ; call prim_car
 %vptr22097 = alloca i64, align 8 
  %rvp10567 = call i64 @prim_cdr(i64 %rvp10571) 
  store volatile i64 %rvp10567, i64* %vptr22097, align 8 ; call prim_cdr
 %vptr22098 = alloca i64, align 8 
  %n_6310572 = call i64 @prim_null_63(i64 %rvp10567) 
  store volatile i64 %n_6310572, i64* %vptr22098, align 8 ; call prim_null_63
  %cmpptr22102 = alloca i1, align 8  %cmp22099 = icmp eq i64 %n_6310572, 15 store volatile i1 %cmp22099, i1* %cmpptr22102, align 8; false?
  br i1 %cmp22099, label %else22101, label %then22100                                ; if

then22100:
 %vptr22103 = alloca i64, align 8 
  %h10573 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10573, i64* %vptr22103, align 8 ; call prim_halt
  %vptr22109 = alloca i64*, align 8 
  %cloptr22104 = inttoptr i64 %h10573 to i64* 
  store volatile i64* %cloptr22104, i64** %vptr22109, align 8 ; closure/env cast; i64 -> i64*
  %vptr22110 = alloca i64*, align 8 
  %i0ptr22105 = getelementptr inbounds i64, i64* %cloptr22104, i64 1 
  store volatile i64* %i0ptr22105, i64** %vptr22110, align 8 ; &cloptr22104[1]
 %vptr22111 = alloca i64, align 8 
  %f22107 = load i64, i64* %i0ptr22105, align 8 
  store volatile i64 %f22107, i64* %vptr22111, align 8 ; load; *i0ptr22105
  %fptr22106 = inttoptr i64 %f22107 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22106(i64 %h10573, i64 %h10573)                     ; tail call
  ret void

else22101:
 %vptr22112 = alloca i64, align 8 
  %a7037 = call i64 @prim_car(i64 %rvp10567) 
  store volatile i64 %a7037, i64* %vptr22112, align 8 ; call prim_car
 %vptr22113 = alloca i64, align 8 
  %na9816 = call i64 @prim_cdr(i64 %rvp10567) 
  store volatile i64 %na9816, i64* %vptr22113, align 8 ; call prim_cdr
 %vptr22114 = alloca i64, align 8 
  %n_6310568 = call i64 @prim_null_63(i64 %na9816) 
  store volatile i64 %n_6310568, i64* %vptr22114, align 8 ; call prim_null_63
  %cmpptr22118 = alloca i1, align 8  %cmp22115 = icmp eq i64 %n_6310568, 15 store volatile i1 %cmp22115, i1* %cmpptr22118, align 8; false?
  br i1 %cmp22115, label %else22117, label %then22116                                ; if

then22116:
 %vptr22119 = alloca i64, align 8 
  %arg8069 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg8069, i64* %vptr22119, align 8 ; quoted int
 %vptr22120 = alloca i64, align 8 
  %retprim7255 = call i64 @prim_make_45vector(i64 %arg8069, i64 %a7037) 
  store volatile i64 %retprim7255, i64* %vptr22120, align 8 ; call prim_make_45vector
  %vptr22134 = alloca i64*, align 8 
  %cloptr22121 = call i64* @make_closure(i64 88) 
  store volatile i64* %cloptr22121, i64** %vptr22134, align 8 ; malloc
  %vptr22135 = alloca i64*, align 8 
  %eptr22123 = getelementptr inbounds i64, i64* %cloptr22121, i64 2 
  store volatile i64* %eptr22123, i64** %vptr22135, align 8 ; &eptr22123[1]
  %vptr22136 = alloca i64*, align 8 
  %eptr22124 = getelementptr inbounds i64, i64* %cloptr22121, i64 3 
  store volatile i64* %eptr22124, i64** %vptr22136, align 8 ; &eptr22124[2]
  %vptr22137 = alloca i64*, align 8 
  %eptr22125 = getelementptr inbounds i64, i64* %cloptr22121, i64 4 
  store volatile i64* %eptr22125, i64** %vptr22137, align 8 ; &eptr22125[3]
  %vptr22138 = alloca i64*, align 8 
  %eptr22126 = getelementptr inbounds i64, i64* %cloptr22121, i64 5 
  store volatile i64* %eptr22126, i64** %vptr22138, align 8 ; &eptr22126[4]
  %vptr22139 = alloca i64*, align 8 
  %eptr22127 = getelementptr inbounds i64, i64* %cloptr22121, i64 6 
  store volatile i64* %eptr22127, i64** %vptr22139, align 8 ; &eptr22127[5]
  %vptr22140 = alloca i64*, align 8 
  %eptr22128 = getelementptr inbounds i64, i64* %cloptr22121, i64 7 
  store volatile i64* %eptr22128, i64** %vptr22140, align 8 ; &eptr22128[6]
  %vptr22141 = alloca i64*, align 8 
  %eptr22129 = getelementptr inbounds i64, i64* %cloptr22121, i64 8 
  store volatile i64* %eptr22129, i64** %vptr22141, align 8 ; &eptr22129[7]
  %vptr22142 = alloca i64*, align 8 
  %eptr22130 = getelementptr inbounds i64, i64* %cloptr22121, i64 9 
  store volatile i64* %eptr22130, i64** %vptr22142, align 8 ; &eptr22130[8]
  %vptr22143 = alloca i64*, align 8 
  %eptr22131 = getelementptr inbounds i64, i64* %cloptr22121, i64 10 
  store volatile i64* %eptr22131, i64** %vptr22143, align 8 ; &eptr22131[9]
  %vptr22144 = alloca i64*, align 8 
  %eptr22132 = getelementptr inbounds i64, i64* %cloptr22121, i64 11 
  store volatile i64* %eptr22132, i64** %vptr22144, align 8 ; &eptr22132[10]
  store i64 %bmP$nat_45_62peano, i64* %eptr22123                                     ; *eptr22123 = %bmP$nat_45_62peano
  store i64 %emsg18637, i64* %eptr22124                                              ; *eptr22124 = %emsg18637
  store i64 %Ttp$addc, i64* %eptr22125                                               ; *eptr22125 = %Ttp$addc
  store i64 %SdC$_37wind_45stack, i64* %eptr22126                                    ; *eptr22126 = %SdC$_37wind_45stack
  store i64 %Pll$pred, i64* %eptr22127                                               ; *eptr22127 = %Pll$pred
  store i64 %gYG$succ, i64* %eptr22128                                               ; *eptr22128 = %gYG$succ
  store i64 %emsg08636, i64* %eptr22129                                              ; *eptr22129 = %emsg08636
  store i64 %Iic$peano_45_62nat, i64* %eptr22130                                     ; *eptr22130 = %Iic$peano_45_62nat
  store i64 %bbE$z_63, i64* %eptr22131                                               ; *eptr22131 = %bbE$z_63
  store i64 %U8g$_37do_45wind, i64* %eptr22132                                       ; *eptr22132 = %U8g$_37do_45wind
  %vptr22145 = alloca i64*, align 8 
  %eptr22122 = getelementptr inbounds i64, i64* %cloptr22121, i64 1 
  store volatile i64* %eptr22122, i64** %vptr22145, align 8 ; &cloptr22121[1]
 %vptr22146 = alloca i64, align 8 
  %f22133 = ptrtoint void(i64,i64)* @lam11951 to i64 
  store volatile i64 %f22133, i64* %vptr22146, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f22133, i64* %eptr22122                                                 ; store fptr
 %vptr22147 = alloca i64, align 8 
  %arg8072 = ptrtoint i64* %cloptr22121 to i64 
  store volatile i64 %arg8072, i64* %vptr22147, align 8 ; closure cast; i64* -> i64
 %vptr22148 = alloca i64, align 8 
  %arg8071 = add i64 0, 0 
  store volatile i64 %arg8071, i64* %vptr22148, align 8 ; quoted ()
 %vptr22149 = alloca i64, align 8 
  %rva10566 = add i64 0, 0 
  store volatile i64 %rva10566, i64* %vptr22149, align 8 ; quoted ()
 %vptr22150 = alloca i64, align 8 
  %rva10565 = call i64 @prim_cons(i64 %retprim7255, i64 %rva10566) 
  store volatile i64 %rva10565, i64* %vptr22150, align 8 ; call prim_cons
 %vptr22151 = alloca i64, align 8 
  %rva10564 = call i64 @prim_cons(i64 %arg8071, i64 %rva10565) 
  store volatile i64 %rva10564, i64* %vptr22151, align 8 ; call prim_cons
  %vptr22157 = alloca i64*, align 8 
  %cloptr22152 = inttoptr i64 %arg8072 to i64* 
  store volatile i64* %cloptr22152, i64** %vptr22157, align 8 ; closure/env cast; i64 -> i64*
  %vptr22158 = alloca i64*, align 8 
  %i0ptr22153 = getelementptr inbounds i64, i64* %cloptr22152, i64 1 
  store volatile i64* %i0ptr22153, i64** %vptr22158, align 8 ; &cloptr22152[1]
 %vptr22159 = alloca i64, align 8 
  %f22155 = load i64, i64* %i0ptr22153, align 8 
  store volatile i64 %f22155, i64* %vptr22159, align 8 ; load; *i0ptr22153
  %fptr22154 = inttoptr i64 %f22155 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22154(i64 %arg8072, i64 %rva10564)                  ; tail call
  ret void

else22117:
 %vptr22160 = alloca i64, align 8 
  %h10569 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10569, i64* %vptr22160, align 8 ; call prim_halt
  %vptr22166 = alloca i64*, align 8 
  %cloptr22161 = inttoptr i64 %h10569 to i64* 
  store volatile i64* %cloptr22161, i64** %vptr22166, align 8 ; closure/env cast; i64 -> i64*
  %vptr22167 = alloca i64*, align 8 
  %i0ptr22162 = getelementptr inbounds i64, i64* %cloptr22161, i64 1 
  store volatile i64* %i0ptr22162, i64** %vptr22167, align 8 ; &cloptr22161[1]
 %vptr22168 = alloca i64, align 8 
  %f22164 = load i64, i64* %i0ptr22162, align 8 
  store volatile i64 %f22164, i64* %vptr22168, align 8 ; load; *i0ptr22162
  %fptr22163 = inttoptr i64 %f22164 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22163(i64 %h10569, i64 %h10569)                     ; tail call
  ret void
}


define void @lam11951(i64 %env11952, i64 %rvp10560) {
 %vptr22171 = alloca i64, align 8 
  %envptr22169 = inttoptr i64 %env11952 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr22171, align 8 ; closure/env cast; i64 -> i64*
  %vptr22172 = alloca i64*, align 8 
  %envptr22170 = getelementptr inbounds i64, i64* %envptr22169, i64 11 
  store volatile i64* %envptr22170, i64** %vptr22172, align 8 ; &envptr22169[10]
 %vptr22173 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr22170, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr22173, align 8 ; load; *envptr22170
 %vptr22176 = alloca i64, align 8 
  %envptr22174 = inttoptr i64 %env11952 to i64* 
  store volatile i64 %bbE$z_63, i64* %vptr22176, align 8 ; closure/env cast; i64 -> i64*
  %vptr22177 = alloca i64*, align 8 
  %envptr22175 = getelementptr inbounds i64, i64* %envptr22174, i64 10 
  store volatile i64* %envptr22175, i64** %vptr22177, align 8 ; &envptr22174[9]
 %vptr22178 = alloca i64, align 8 
  %bbE$z_63 = load i64, i64* %envptr22175, align 8 
  store volatile i64 %bbE$z_63, i64* %vptr22178, align 8 ; load; *envptr22175
 %vptr22181 = alloca i64, align 8 
  %envptr22179 = inttoptr i64 %env11952 to i64* 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr22181, align 8 ; closure/env cast; i64 -> i64*
  %vptr22182 = alloca i64*, align 8 
  %envptr22180 = getelementptr inbounds i64, i64* %envptr22179, i64 9 
  store volatile i64* %envptr22180, i64** %vptr22182, align 8 ; &envptr22179[8]
 %vptr22183 = alloca i64, align 8 
  %Iic$peano_45_62nat = load i64, i64* %envptr22180, align 8 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr22183, align 8 ; load; *envptr22180
 %vptr22186 = alloca i64, align 8 
  %envptr22184 = inttoptr i64 %env11952 to i64* 
  store volatile i64 %emsg08636, i64* %vptr22186, align 8 ; closure/env cast; i64 -> i64*
  %vptr22187 = alloca i64*, align 8 
  %envptr22185 = getelementptr inbounds i64, i64* %envptr22184, i64 8 
  store volatile i64* %envptr22185, i64** %vptr22187, align 8 ; &envptr22184[7]
 %vptr22188 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr22185, align 8 
  store volatile i64 %emsg08636, i64* %vptr22188, align 8 ; load; *envptr22185
 %vptr22191 = alloca i64, align 8 
  %envptr22189 = inttoptr i64 %env11952 to i64* 
  store volatile i64 %gYG$succ, i64* %vptr22191, align 8 ; closure/env cast; i64 -> i64*
  %vptr22192 = alloca i64*, align 8 
  %envptr22190 = getelementptr inbounds i64, i64* %envptr22189, i64 7 
  store volatile i64* %envptr22190, i64** %vptr22192, align 8 ; &envptr22189[6]
 %vptr22193 = alloca i64, align 8 
  %gYG$succ = load i64, i64* %envptr22190, align 8 
  store volatile i64 %gYG$succ, i64* %vptr22193, align 8 ; load; *envptr22190
 %vptr22196 = alloca i64, align 8 
  %envptr22194 = inttoptr i64 %env11952 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr22196, align 8 ; closure/env cast; i64 -> i64*
  %vptr22197 = alloca i64*, align 8 
  %envptr22195 = getelementptr inbounds i64, i64* %envptr22194, i64 6 
  store volatile i64* %envptr22195, i64** %vptr22197, align 8 ; &envptr22194[5]
 %vptr22198 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr22195, align 8 
  store volatile i64 %Pll$pred, i64* %vptr22198, align 8 ; load; *envptr22195
 %vptr22201 = alloca i64, align 8 
  %envptr22199 = inttoptr i64 %env11952 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr22201, align 8 ; closure/env cast; i64 -> i64*
  %vptr22202 = alloca i64*, align 8 
  %envptr22200 = getelementptr inbounds i64, i64* %envptr22199, i64 5 
  store volatile i64* %envptr22200, i64** %vptr22202, align 8 ; &envptr22199[4]
 %vptr22203 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr22200, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr22203, align 8 ; load; *envptr22200
 %vptr22206 = alloca i64, align 8 
  %envptr22204 = inttoptr i64 %env11952 to i64* 
  store volatile i64 %Ttp$addc, i64* %vptr22206, align 8 ; closure/env cast; i64 -> i64*
  %vptr22207 = alloca i64*, align 8 
  %envptr22205 = getelementptr inbounds i64, i64* %envptr22204, i64 4 
  store volatile i64* %envptr22205, i64** %vptr22207, align 8 ; &envptr22204[3]
 %vptr22208 = alloca i64, align 8 
  %Ttp$addc = load i64, i64* %envptr22205, align 8 
  store volatile i64 %Ttp$addc, i64* %vptr22208, align 8 ; load; *envptr22205
 %vptr22211 = alloca i64, align 8 
  %envptr22209 = inttoptr i64 %env11952 to i64* 
  store volatile i64 %emsg18637, i64* %vptr22211, align 8 ; closure/env cast; i64 -> i64*
  %vptr22212 = alloca i64*, align 8 
  %envptr22210 = getelementptr inbounds i64, i64* %envptr22209, i64 3 
  store volatile i64* %envptr22210, i64** %vptr22212, align 8 ; &envptr22209[2]
 %vptr22213 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr22210, align 8 
  store volatile i64 %emsg18637, i64* %vptr22213, align 8 ; load; *envptr22210
 %vptr22216 = alloca i64, align 8 
  %envptr22214 = inttoptr i64 %env11952 to i64* 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr22216, align 8 ; closure/env cast; i64 -> i64*
  %vptr22217 = alloca i64*, align 8 
  %envptr22215 = getelementptr inbounds i64, i64* %envptr22214, i64 2 
  store volatile i64* %envptr22215, i64** %vptr22217, align 8 ; &envptr22214[1]
 %vptr22218 = alloca i64, align 8 
  %bmP$nat_45_62peano = load i64, i64* %envptr22215, align 8 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr22218, align 8 ; load; *envptr22215
 %vptr22219 = alloca i64, align 8 
  %_957201 = call i64 @prim_car(i64 %rvp10560) 
  store volatile i64 %_957201, i64* %vptr22219, align 8 ; call prim_car
 %vptr22220 = alloca i64, align 8 
  %rvp10556 = call i64 @prim_cdr(i64 %rvp10560) 
  store volatile i64 %rvp10556, i64* %vptr22220, align 8 ; call prim_cdr
 %vptr22221 = alloca i64, align 8 
  %n_6310561 = call i64 @prim_null_63(i64 %rvp10556) 
  store volatile i64 %n_6310561, i64* %vptr22221, align 8 ; call prim_null_63
  %cmpptr22225 = alloca i1, align 8  %cmp22222 = icmp eq i64 %n_6310561, 15 store volatile i1 %cmp22222, i1* %cmpptr22225, align 8; false?
  br i1 %cmp22222, label %else22224, label %then22223                                ; if

then22223:
 %vptr22226 = alloca i64, align 8 
  %h10562 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10562, i64* %vptr22226, align 8 ; call prim_halt
  %vptr22232 = alloca i64*, align 8 
  %cloptr22227 = inttoptr i64 %h10562 to i64* 
  store volatile i64* %cloptr22227, i64** %vptr22232, align 8 ; closure/env cast; i64 -> i64*
  %vptr22233 = alloca i64*, align 8 
  %i0ptr22228 = getelementptr inbounds i64, i64* %cloptr22227, i64 1 
  store volatile i64* %i0ptr22228, i64** %vptr22233, align 8 ; &cloptr22227[1]
 %vptr22234 = alloca i64, align 8 
  %f22230 = load i64, i64* %i0ptr22228, align 8 
  store volatile i64 %f22230, i64* %vptr22234, align 8 ; load; *i0ptr22228
  %fptr22229 = inttoptr i64 %f22230 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22229(i64 %h10562, i64 %h10562)                     ; tail call
  ret void

else22224:
 %vptr22235 = alloca i64, align 8 
  %YxK$fibc = call i64 @prim_car(i64 %rvp10556) 
  store volatile i64 %YxK$fibc, i64* %vptr22235, align 8 ; call prim_car
 %vptr22236 = alloca i64, align 8 
  %na9818 = call i64 @prim_cdr(i64 %rvp10556) 
  store volatile i64 %na9818, i64* %vptr22236, align 8 ; call prim_cdr
 %vptr22237 = alloca i64, align 8 
  %n_6310557 = call i64 @prim_null_63(i64 %na9818) 
  store volatile i64 %n_6310557, i64* %vptr22237, align 8 ; call prim_null_63
  %cmpptr22241 = alloca i1, align 8  %cmp22238 = icmp eq i64 %n_6310557, 15 store volatile i1 %cmp22238, i1* %cmpptr22241, align 8; false?
  br i1 %cmp22238, label %else22240, label %then22239                                ; if

then22239:
  %vptr22248 = alloca i64*, align 8 
  %cloptr22242 = call i64* @make_closure(i64 32) 
  store volatile i64* %cloptr22242, i64** %vptr22248, align 8 ; malloc
  %vptr22249 = alloca i64*, align 8 
  %eptr22244 = getelementptr inbounds i64, i64* %cloptr22242, i64 2 
  store volatile i64* %eptr22244, i64** %vptr22249, align 8 ; &eptr22244[1]
  %vptr22250 = alloca i64*, align 8 
  %eptr22245 = getelementptr inbounds i64, i64* %cloptr22242, i64 3 
  store volatile i64* %eptr22245, i64** %vptr22250, align 8 ; &eptr22245[2]
  %vptr22251 = alloca i64*, align 8 
  %eptr22246 = getelementptr inbounds i64, i64* %cloptr22242, i64 4 
  store volatile i64* %eptr22246, i64** %vptr22251, align 8 ; &eptr22246[3]
  store i64 %bmP$nat_45_62peano, i64* %eptr22244                                     ; *eptr22244 = %bmP$nat_45_62peano
  store i64 %emsg18637, i64* %eptr22245                                              ; *eptr22245 = %emsg18637
  store i64 %emsg08636, i64* %eptr22246                                              ; *eptr22246 = %emsg08636
  %vptr22252 = alloca i64*, align 8 
  %eptr22243 = getelementptr inbounds i64, i64* %cloptr22242, i64 1 
  store volatile i64* %eptr22243, i64** %vptr22252, align 8 ; &cloptr22242[1]
 %vptr22253 = alloca i64, align 8 
  %f22247 = ptrtoint void(i64,i64)* @lam11949 to i64 
  store volatile i64 %f22247, i64* %vptr22253, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f22247, i64* %eptr22243                                                 ; store fptr
 %vptr22254 = alloca i64, align 8 
  %gSe$letrec6891 = ptrtoint i64* %cloptr22242 to i64 
  store volatile i64 %gSe$letrec6891, i64* %vptr22254, align 8 ; closure cast; i64* -> i64
  %vptr22263 = alloca i64*, align 8 
  %cloptr22255 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr22255, i64** %vptr22263, align 8 ; malloc
  %vptr22264 = alloca i64*, align 8 
  %eptr22257 = getelementptr inbounds i64, i64* %cloptr22255, i64 2 
  store volatile i64* %eptr22257, i64** %vptr22264, align 8 ; &eptr22257[1]
  %vptr22265 = alloca i64*, align 8 
  %eptr22258 = getelementptr inbounds i64, i64* %cloptr22255, i64 3 
  store volatile i64* %eptr22258, i64** %vptr22265, align 8 ; &eptr22258[2]
  %vptr22266 = alloca i64*, align 8 
  %eptr22259 = getelementptr inbounds i64, i64* %cloptr22255, i64 4 
  store volatile i64* %eptr22259, i64** %vptr22266, align 8 ; &eptr22259[3]
  %vptr22267 = alloca i64*, align 8 
  %eptr22260 = getelementptr inbounds i64, i64* %cloptr22255, i64 5 
  store volatile i64* %eptr22260, i64** %vptr22267, align 8 ; &eptr22260[4]
  %vptr22268 = alloca i64*, align 8 
  %eptr22261 = getelementptr inbounds i64, i64* %cloptr22255, i64 6 
  store volatile i64* %eptr22261, i64** %vptr22268, align 8 ; &eptr22261[5]
  store i64 %emsg18637, i64* %eptr22257                                              ; *eptr22257 = %emsg18637
  store i64 %Pll$pred, i64* %eptr22258                                               ; *eptr22258 = %Pll$pred
  store i64 %emsg08636, i64* %eptr22259                                              ; *eptr22259 = %emsg08636
  store i64 %Iic$peano_45_62nat, i64* %eptr22260                                     ; *eptr22260 = %Iic$peano_45_62nat
  store i64 %bbE$z_63, i64* %eptr22261                                               ; *eptr22261 = %bbE$z_63
  %vptr22269 = alloca i64*, align 8 
  %eptr22256 = getelementptr inbounds i64, i64* %cloptr22255, i64 1 
  store volatile i64* %eptr22256, i64** %vptr22269, align 8 ; &cloptr22255[1]
 %vptr22270 = alloca i64, align 8 
  %f22262 = ptrtoint void(i64,i64)* @lam11927 to i64 
  store volatile i64 %f22262, i64* %vptr22270, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f22262, i64* %eptr22256                                                 ; store fptr
 %vptr22271 = alloca i64, align 8 
  %DCJ$letrec6892 = ptrtoint i64* %cloptr22255 to i64 
  store volatile i64 %DCJ$letrec6892, i64* %vptr22271, align 8 ; closure cast; i64* -> i64
  %vptr22277 = alloca i64*, align 8 
  %cloptr22272 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr22272, i64** %vptr22277, align 8 ; malloc
  %vptr22278 = alloca i64*, align 8 
  %eptr22274 = getelementptr inbounds i64, i64* %cloptr22272, i64 2 
  store volatile i64* %eptr22274, i64** %vptr22278, align 8 ; &eptr22274[1]
  %vptr22279 = alloca i64*, align 8 
  %eptr22275 = getelementptr inbounds i64, i64* %cloptr22272, i64 3 
  store volatile i64* %eptr22275, i64** %vptr22279, align 8 ; &eptr22275[2]
  store i64 %emsg18637, i64* %eptr22274                                              ; *eptr22274 = %emsg18637
  store i64 %emsg08636, i64* %eptr22275                                              ; *eptr22275 = %emsg08636
  %vptr22280 = alloca i64*, align 8 
  %eptr22273 = getelementptr inbounds i64, i64* %cloptr22272, i64 1 
  store volatile i64* %eptr22273, i64** %vptr22280, align 8 ; &cloptr22272[1]
 %vptr22281 = alloca i64, align 8 
  %f22276 = ptrtoint void(i64,i64)* @lam11907 to i64 
  store volatile i64 %f22276, i64* %vptr22281, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f22276, i64* %eptr22273                                                 ; store fptr
 %vptr22282 = alloca i64, align 8 
  %yjq$letrec6893 = ptrtoint i64* %cloptr22272 to i64 
  store volatile i64 %yjq$letrec6893, i64* %vptr22282, align 8 ; closure cast; i64* -> i64
  %vptr22286 = alloca i64*, align 8 
  %cloptr22283 = call i64* @make_closure(i64 8) 
  store volatile i64* %cloptr22283, i64** %vptr22286, align 8 ; malloc
  %vptr22287 = alloca i64*, align 8 
  %eptr22284 = getelementptr inbounds i64, i64* %cloptr22283, i64 1 
  store volatile i64* %eptr22284, i64** %vptr22287, align 8 ; &cloptr22283[1]
 %vptr22288 = alloca i64, align 8 
  %f22285 = ptrtoint void(i64,i64)* @lam11896 to i64 
  store volatile i64 %f22285, i64* %vptr22288, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f22285, i64* %eptr22284                                                 ; store fptr
 %vptr22289 = alloca i64, align 8 
  %JjA$letrec6894 = ptrtoint i64* %cloptr22283 to i64 
  store volatile i64 %JjA$letrec6894, i64* %vptr22289, align 8 ; closure cast; i64* -> i64
  %vptr22295 = alloca i64*, align 8 
  %cloptr22290 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr22290, i64** %vptr22295, align 8 ; malloc
  %vptr22296 = alloca i64*, align 8 
  %eptr22292 = getelementptr inbounds i64, i64* %cloptr22290, i64 2 
  store volatile i64* %eptr22292, i64** %vptr22296, align 8 ; &eptr22292[1]
  %vptr22297 = alloca i64*, align 8 
  %eptr22293 = getelementptr inbounds i64, i64* %cloptr22290, i64 3 
  store volatile i64* %eptr22293, i64** %vptr22297, align 8 ; &eptr22293[2]
  store i64 %emsg18637, i64* %eptr22292                                              ; *eptr22292 = %emsg18637
  store i64 %emsg08636, i64* %eptr22293                                              ; *eptr22293 = %emsg08636
  %vptr22298 = alloca i64*, align 8 
  %eptr22291 = getelementptr inbounds i64, i64* %cloptr22290, i64 1 
  store volatile i64* %eptr22291, i64** %vptr22298, align 8 ; &cloptr22290[1]
 %vptr22299 = alloca i64, align 8 
  %f22294 = ptrtoint void(i64,i64)* @lam11892 to i64 
  store volatile i64 %f22294, i64* %vptr22299, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f22294, i64* %eptr22291                                                 ; store fptr
 %vptr22300 = alloca i64, align 8 
  %oXN$letrec6895 = ptrtoint i64* %cloptr22290 to i64 
  store volatile i64 %oXN$letrec6895, i64* %vptr22300, align 8 ; closure cast; i64* -> i64
  %vptr22310 = alloca i64*, align 8 
  %cloptr22301 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr22301, i64** %vptr22310, align 8 ; malloc
  %vptr22311 = alloca i64*, align 8 
  %eptr22303 = getelementptr inbounds i64, i64* %cloptr22301, i64 2 
  store volatile i64* %eptr22303, i64** %vptr22311, align 8 ; &eptr22303[1]
  %vptr22312 = alloca i64*, align 8 
  %eptr22304 = getelementptr inbounds i64, i64* %cloptr22301, i64 3 
  store volatile i64* %eptr22304, i64** %vptr22312, align 8 ; &eptr22304[2]
  %vptr22313 = alloca i64*, align 8 
  %eptr22305 = getelementptr inbounds i64, i64* %cloptr22301, i64 4 
  store volatile i64* %eptr22305, i64** %vptr22313, align 8 ; &eptr22305[3]
  %vptr22314 = alloca i64*, align 8 
  %eptr22306 = getelementptr inbounds i64, i64* %cloptr22301, i64 5 
  store volatile i64* %eptr22306, i64** %vptr22314, align 8 ; &eptr22306[4]
  %vptr22315 = alloca i64*, align 8 
  %eptr22307 = getelementptr inbounds i64, i64* %cloptr22301, i64 6 
  store volatile i64* %eptr22307, i64** %vptr22315, align 8 ; &eptr22307[5]
  %vptr22316 = alloca i64*, align 8 
  %eptr22308 = getelementptr inbounds i64, i64* %cloptr22301, i64 7 
  store volatile i64* %eptr22308, i64** %vptr22316, align 8 ; &eptr22308[6]
  store i64 %emsg18637, i64* %eptr22303                                              ; *eptr22303 = %emsg18637
  store i64 %Ttp$addc, i64* %eptr22304                                               ; *eptr22304 = %Ttp$addc
  store i64 %Pll$pred, i64* %eptr22305                                               ; *eptr22305 = %Pll$pred
  store i64 %gYG$succ, i64* %eptr22306                                               ; *eptr22306 = %gYG$succ
  store i64 %emsg08636, i64* %eptr22307                                              ; *eptr22307 = %emsg08636
  store i64 %bbE$z_63, i64* %eptr22308                                               ; *eptr22308 = %bbE$z_63
  %vptr22317 = alloca i64*, align 8 
  %eptr22302 = getelementptr inbounds i64, i64* %cloptr22301, i64 1 
  store volatile i64* %eptr22302, i64** %vptr22317, align 8 ; &cloptr22301[1]
 %vptr22318 = alloca i64, align 8 
  %f22309 = ptrtoint void(i64,i64)* @lam11888 to i64 
  store volatile i64 %f22309, i64* %vptr22318, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f22309, i64* %eptr22302                                                 ; store fptr
 %vptr22319 = alloca i64, align 8 
  %d6O$letrec6896 = ptrtoint i64* %cloptr22301 to i64 
  store volatile i64 %d6O$letrec6896, i64* %vptr22319, align 8 ; closure cast; i64* -> i64
  %vptr22332 = alloca i64*, align 8 
  %cloptr22320 = call i64* @make_closure(i64 80) 
  store volatile i64* %cloptr22320, i64** %vptr22332, align 8 ; malloc
  %vptr22333 = alloca i64*, align 8 
  %eptr22322 = getelementptr inbounds i64, i64* %cloptr22320, i64 2 
  store volatile i64* %eptr22322, i64** %vptr22333, align 8 ; &eptr22322[1]
  %vptr22334 = alloca i64*, align 8 
  %eptr22323 = getelementptr inbounds i64, i64* %cloptr22320, i64 3 
  store volatile i64* %eptr22323, i64** %vptr22334, align 8 ; &eptr22323[2]
  %vptr22335 = alloca i64*, align 8 
  %eptr22324 = getelementptr inbounds i64, i64* %cloptr22320, i64 4 
  store volatile i64* %eptr22324, i64** %vptr22335, align 8 ; &eptr22324[3]
  %vptr22336 = alloca i64*, align 8 
  %eptr22325 = getelementptr inbounds i64, i64* %cloptr22320, i64 5 
  store volatile i64* %eptr22325, i64** %vptr22336, align 8 ; &eptr22325[4]
  %vptr22337 = alloca i64*, align 8 
  %eptr22326 = getelementptr inbounds i64, i64* %cloptr22320, i64 6 
  store volatile i64* %eptr22326, i64** %vptr22337, align 8 ; &eptr22326[5]
  %vptr22338 = alloca i64*, align 8 
  %eptr22327 = getelementptr inbounds i64, i64* %cloptr22320, i64 7 
  store volatile i64* %eptr22327, i64** %vptr22338, align 8 ; &eptr22327[6]
  %vptr22339 = alloca i64*, align 8 
  %eptr22328 = getelementptr inbounds i64, i64* %cloptr22320, i64 8 
  store volatile i64* %eptr22328, i64** %vptr22339, align 8 ; &eptr22328[7]
  %vptr22340 = alloca i64*, align 8 
  %eptr22329 = getelementptr inbounds i64, i64* %cloptr22320, i64 9 
  store volatile i64* %eptr22329, i64** %vptr22340, align 8 ; &eptr22329[8]
  %vptr22341 = alloca i64*, align 8 
  %eptr22330 = getelementptr inbounds i64, i64* %cloptr22320, i64 10 
  store volatile i64* %eptr22330, i64** %vptr22341, align 8 ; &eptr22330[9]
  store i64 %bmP$nat_45_62peano, i64* %eptr22322                                     ; *eptr22322 = %bmP$nat_45_62peano
  store i64 %emsg18637, i64* %eptr22323                                              ; *eptr22323 = %emsg18637
  store i64 %YxK$fibc, i64* %eptr22324                                               ; *eptr22324 = %YxK$fibc
  store i64 %Ttp$addc, i64* %eptr22325                                               ; *eptr22325 = %Ttp$addc
  store i64 %SdC$_37wind_45stack, i64* %eptr22326                                    ; *eptr22326 = %SdC$_37wind_45stack
  store i64 %Pll$pred, i64* %eptr22327                                               ; *eptr22327 = %Pll$pred
  store i64 %emsg08636, i64* %eptr22328                                              ; *eptr22328 = %emsg08636
  store i64 %bbE$z_63, i64* %eptr22329                                               ; *eptr22329 = %bbE$z_63
  store i64 %U8g$_37do_45wind, i64* %eptr22330                                       ; *eptr22330 = %U8g$_37do_45wind
  %vptr22342 = alloca i64*, align 8 
  %eptr22321 = getelementptr inbounds i64, i64* %cloptr22320, i64 1 
  store volatile i64* %eptr22321, i64** %vptr22342, align 8 ; &cloptr22320[1]
 %vptr22343 = alloca i64, align 8 
  %f22331 = ptrtoint void(i64,i64)* @lam11871 to i64 
  store volatile i64 %f22331, i64* %vptr22343, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f22331, i64* %eptr22321                                                 ; store fptr
 %vptr22344 = alloca i64, align 8 
  %ISJ$letrec6897 = ptrtoint i64* %cloptr22320 to i64 
  store volatile i64 %ISJ$letrec6897, i64* %vptr22344, align 8 ; closure cast; i64* -> i64
 %vptr22345 = alloca i64, align 8 
  %arg8349 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8349, i64* %vptr22345, align 8 ; quoted int
 %vptr22346 = alloca i64, align 8 
  %UW5$_956900 = call i64 @prim_vector_45set_33(i64 %bmP$nat_45_62peano, i64 %arg8349, i64 %gSe$letrec6891) 
  store volatile i64 %UW5$_956900, i64* %vptr22346, align 8 ; call prim_vector_45set_33
 %vptr22347 = alloca i64, align 8 
  %arg8352 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8352, i64* %vptr22347, align 8 ; quoted int
 %vptr22348 = alloca i64, align 8 
  %YqB$_956901 = call i64 @prim_vector_45set_33(i64 %Iic$peano_45_62nat, i64 %arg8352, i64 %DCJ$letrec6892) 
  store volatile i64 %YqB$_956901, i64* %vptr22348, align 8 ; call prim_vector_45set_33
 %vptr22349 = alloca i64, align 8 
  %arg8355 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8355, i64* %vptr22349, align 8 ; quoted int
 %vptr22350 = alloca i64, align 8 
  %B2B$_956902 = call i64 @prim_vector_45set_33(i64 %gYG$succ, i64 %arg8355, i64 %yjq$letrec6893) 
  store volatile i64 %B2B$_956902, i64* %vptr22350, align 8 ; call prim_vector_45set_33
 %vptr22351 = alloca i64, align 8 
  %arg8358 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8358, i64* %vptr22351, align 8 ; quoted int
 %vptr22352 = alloca i64, align 8 
  %uiV$_956903 = call i64 @prim_vector_45set_33(i64 %Pll$pred, i64 %arg8358, i64 %JjA$letrec6894) 
  store volatile i64 %uiV$_956903, i64* %vptr22352, align 8 ; call prim_vector_45set_33
 %vptr22353 = alloca i64, align 8 
  %arg8361 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8361, i64* %vptr22353, align 8 ; quoted int
 %vptr22354 = alloca i64, align 8 
  %DXL$_956904 = call i64 @prim_vector_45set_33(i64 %bbE$z_63, i64 %arg8361, i64 %oXN$letrec6895) 
  store volatile i64 %DXL$_956904, i64* %vptr22354, align 8 ; call prim_vector_45set_33
 %vptr22355 = alloca i64, align 8 
  %arg8364 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8364, i64* %vptr22355, align 8 ; quoted int
 %vptr22356 = alloca i64, align 8 
  %pCt$_956905 = call i64 @prim_vector_45set_33(i64 %Ttp$addc, i64 %arg8364, i64 %d6O$letrec6896) 
  store volatile i64 %pCt$_956905, i64* %vptr22356, align 8 ; call prim_vector_45set_33
 %vptr22357 = alloca i64, align 8 
  %arg8367 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8367, i64* %vptr22357, align 8 ; quoted int
 %vptr22358 = alloca i64, align 8 
  %oGG$_956906 = call i64 @prim_vector_45set_33(i64 %YxK$fibc, i64 %arg8367, i64 %ISJ$letrec6897) 
  store volatile i64 %oGG$_956906, i64* %vptr22358, align 8 ; call prim_vector_45set_33
 %vptr22359 = alloca i64, align 8 
  %arg8369 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8369, i64* %vptr22359, align 8 ; quoted int
 %vptr22360 = alloca i64, align 8 
  %a7084 = call i64 @prim_vector_45ref(i64 %YxK$fibc, i64 %arg8369) 
  store volatile i64 %a7084, i64* %vptr22360, align 8 ; call prim_vector_45ref
 %vptr22361 = alloca i64, align 8 
  %arg8371 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8371, i64* %vptr22361, align 8 ; quoted int
 %vptr22362 = alloca i64, align 8 
  %a7085 = call i64 @prim_vector_45ref(i64 %bmP$nat_45_62peano, i64 %arg8371) 
  store volatile i64 %a7085, i64* %vptr22362, align 8 ; call prim_vector_45ref
  %vptr22370 = alloca i64*, align 8 
  %cloptr22363 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr22363, i64** %vptr22370, align 8 ; malloc
  %vptr22371 = alloca i64*, align 8 
  %eptr22365 = getelementptr inbounds i64, i64* %cloptr22363, i64 2 
  store volatile i64* %eptr22365, i64** %vptr22371, align 8 ; &eptr22365[1]
  %vptr22372 = alloca i64*, align 8 
  %eptr22366 = getelementptr inbounds i64, i64* %cloptr22363, i64 3 
  store volatile i64* %eptr22366, i64** %vptr22372, align 8 ; &eptr22366[2]
  %vptr22373 = alloca i64*, align 8 
  %eptr22367 = getelementptr inbounds i64, i64* %cloptr22363, i64 4 
  store volatile i64* %eptr22367, i64** %vptr22373, align 8 ; &eptr22367[3]
  %vptr22374 = alloca i64*, align 8 
  %eptr22368 = getelementptr inbounds i64, i64* %cloptr22363, i64 5 
  store volatile i64* %eptr22368, i64** %vptr22374, align 8 ; &eptr22368[4]
  store i64 %emsg18637, i64* %eptr22365                                              ; *eptr22365 = %emsg18637
  store i64 %emsg08636, i64* %eptr22366                                              ; *eptr22366 = %emsg08636
  store i64 %a7084, i64* %eptr22367                                                  ; *eptr22367 = %a7084
  store i64 %Iic$peano_45_62nat, i64* %eptr22368                                     ; *eptr22368 = %Iic$peano_45_62nat
  %vptr22375 = alloca i64*, align 8 
  %eptr22364 = getelementptr inbounds i64, i64* %cloptr22363, i64 1 
  store volatile i64* %eptr22364, i64** %vptr22375, align 8 ; &cloptr22363[1]
 %vptr22376 = alloca i64, align 8 
  %f22369 = ptrtoint void(i64,i64)* @lam11724 to i64 
  store volatile i64 %f22369, i64* %vptr22376, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f22369, i64* %eptr22364                                                 ; store fptr
 %vptr22377 = alloca i64, align 8 
  %arg8374 = ptrtoint i64* %cloptr22363 to i64 
  store volatile i64 %arg8374, i64* %vptr22377, align 8 ; closure cast; i64* -> i64
 %vptr22378 = alloca i64, align 8 
  %arg8373 = call i64 @const_init_int(i64 13) 
  store volatile i64 %arg8373, i64* %vptr22378, align 8 ; quoted int
 %vptr22379 = alloca i64, align 8 
  %rva10555 = add i64 0, 0 
  store volatile i64 %rva10555, i64* %vptr22379, align 8 ; quoted ()
 %vptr22380 = alloca i64, align 8 
  %rva10554 = call i64 @prim_cons(i64 %arg8373, i64 %rva10555) 
  store volatile i64 %rva10554, i64* %vptr22380, align 8 ; call prim_cons
 %vptr22381 = alloca i64, align 8 
  %rva10553 = call i64 @prim_cons(i64 %arg8374, i64 %rva10554) 
  store volatile i64 %rva10553, i64* %vptr22381, align 8 ; call prim_cons
  %vptr22387 = alloca i64*, align 8 
  %cloptr22382 = inttoptr i64 %a7085 to i64* 
  store volatile i64* %cloptr22382, i64** %vptr22387, align 8 ; closure/env cast; i64 -> i64*
  %vptr22388 = alloca i64*, align 8 
  %i0ptr22383 = getelementptr inbounds i64, i64* %cloptr22382, i64 1 
  store volatile i64* %i0ptr22383, i64** %vptr22388, align 8 ; &cloptr22382[1]
 %vptr22389 = alloca i64, align 8 
  %f22385 = load i64, i64* %i0ptr22383, align 8 
  store volatile i64 %f22385, i64* %vptr22389, align 8 ; load; *i0ptr22383
  %fptr22384 = inttoptr i64 %f22385 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22384(i64 %a7085, i64 %rva10553)                    ; tail call
  ret void

else22240:
 %vptr22390 = alloca i64, align 8 
  %h10558 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10558, i64* %vptr22390, align 8 ; call prim_halt
  %vptr22396 = alloca i64*, align 8 
  %cloptr22391 = inttoptr i64 %h10558 to i64* 
  store volatile i64* %cloptr22391, i64** %vptr22396, align 8 ; closure/env cast; i64 -> i64*
  %vptr22397 = alloca i64*, align 8 
  %i0ptr22392 = getelementptr inbounds i64, i64* %cloptr22391, i64 1 
  store volatile i64* %i0ptr22392, i64** %vptr22397, align 8 ; &cloptr22391[1]
 %vptr22398 = alloca i64, align 8 
  %f22394 = load i64, i64* %i0ptr22392, align 8 
  store volatile i64 %f22394, i64* %vptr22398, align 8 ; load; *i0ptr22392
  %fptr22393 = inttoptr i64 %f22394 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22393(i64 %h10558, i64 %h10558)                     ; tail call
  ret void
}


define void @lam11949(i64 %env11950, i64 %rvp9861) {
 %vptr22401 = alloca i64, align 8 
  %envptr22399 = inttoptr i64 %env11950 to i64* 
  store volatile i64 %emsg08636, i64* %vptr22401, align 8 ; closure/env cast; i64 -> i64*
  %vptr22402 = alloca i64*, align 8 
  %envptr22400 = getelementptr inbounds i64, i64* %envptr22399, i64 4 
  store volatile i64* %envptr22400, i64** %vptr22402, align 8 ; &envptr22399[3]
 %vptr22403 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr22400, align 8 
  store volatile i64 %emsg08636, i64* %vptr22403, align 8 ; load; *envptr22400
 %vptr22406 = alloca i64, align 8 
  %envptr22404 = inttoptr i64 %env11950 to i64* 
  store volatile i64 %emsg18637, i64* %vptr22406, align 8 ; closure/env cast; i64 -> i64*
  %vptr22407 = alloca i64*, align 8 
  %envptr22405 = getelementptr inbounds i64, i64* %envptr22404, i64 3 
  store volatile i64* %envptr22405, i64** %vptr22407, align 8 ; &envptr22404[2]
 %vptr22408 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr22405, align 8 
  store volatile i64 %emsg18637, i64* %vptr22408, align 8 ; load; *envptr22405
 %vptr22411 = alloca i64, align 8 
  %envptr22409 = inttoptr i64 %env11950 to i64* 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr22411, align 8 ; closure/env cast; i64 -> i64*
  %vptr22412 = alloca i64*, align 8 
  %envptr22410 = getelementptr inbounds i64, i64* %envptr22409, i64 2 
  store volatile i64* %envptr22410, i64** %vptr22412, align 8 ; &envptr22409[1]
 %vptr22413 = alloca i64, align 8 
  %bmP$nat_45_62peano = load i64, i64* %envptr22410, align 8 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr22413, align 8 ; load; *envptr22410
 %vptr22414 = alloca i64, align 8 
  %cont7202 = call i64 @prim_car(i64 %rvp9861) 
  store volatile i64 %cont7202, i64* %vptr22414, align 8 ; call prim_car
 %vptr22415 = alloca i64, align 8 
  %rvp9857 = call i64 @prim_cdr(i64 %rvp9861) 
  store volatile i64 %rvp9857, i64* %vptr22415, align 8 ; call prim_cdr
 %vptr22416 = alloca i64, align 8 
  %n_639862 = call i64 @prim_null_63(i64 %rvp9857) 
  store volatile i64 %n_639862, i64* %vptr22416, align 8 ; call prim_null_63
  %cmpptr22420 = alloca i1, align 8  %cmp22417 = icmp eq i64 %n_639862, 15 store volatile i1 %cmp22417, i1* %cmpptr22420, align 8; false?
  br i1 %cmp22417, label %else22419, label %then22418                                ; if

then22418:
 %vptr22421 = alloca i64, align 8 
  %h9863 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9863, i64* %vptr22421, align 8 ; call prim_halt
  %vptr22427 = alloca i64*, align 8 
  %cloptr22422 = inttoptr i64 %h9863 to i64* 
  store volatile i64* %cloptr22422, i64** %vptr22427, align 8 ; closure/env cast; i64 -> i64*
  %vptr22428 = alloca i64*, align 8 
  %i0ptr22423 = getelementptr inbounds i64, i64* %cloptr22422, i64 1 
  store volatile i64* %i0ptr22423, i64** %vptr22428, align 8 ; &cloptr22422[1]
 %vptr22429 = alloca i64, align 8 
  %f22425 = load i64, i64* %i0ptr22423, align 8 
  store volatile i64 %f22425, i64* %vptr22429, align 8 ; load; *i0ptr22423
  %fptr22424 = inttoptr i64 %f22425 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22424(i64 %h9863, i64 %h9863)                       ; tail call
  ret void

else22419:
 %vptr22430 = alloca i64, align 8 
  %G1K$n = call i64 @prim_car(i64 %rvp9857) 
  store volatile i64 %G1K$n, i64* %vptr22430, align 8 ; call prim_car
 %vptr22431 = alloca i64, align 8 
  %na9820 = call i64 @prim_cdr(i64 %rvp9857) 
  store volatile i64 %na9820, i64* %vptr22431, align 8 ; call prim_cdr
 %vptr22432 = alloca i64, align 8 
  %n_639858 = call i64 @prim_null_63(i64 %na9820) 
  store volatile i64 %n_639858, i64* %vptr22432, align 8 ; call prim_null_63
  %cmpptr22436 = alloca i1, align 8  %cmp22433 = icmp eq i64 %n_639858, 15 store volatile i1 %cmp22433, i1* %cmpptr22436, align 8; false?
  br i1 %cmp22433, label %else22435, label %then22434                                ; if

then22434:
 %vptr22437 = alloca i64, align 8 
  %arg8074 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8074, i64* %vptr22437, align 8 ; quoted int
 %vptr22438 = alloca i64, align 8 
  %a7038 = call i64 @prim__61(i64 %arg8074, i64 %G1K$n) 
  store volatile i64 %a7038, i64* %vptr22438, align 8 ; call prim__61
  %cmpptr22442 = alloca i1, align 8  %cmp22439 = icmp eq i64 %a7038, 15 store volatile i1 %cmp22439, i1* %cmpptr22442, align 8; false?
  br i1 %cmp22439, label %else22441, label %then22440                                ; if

then22440:
  %vptr22446 = alloca i64*, align 8 
  %cloptr22443 = call i64* @make_closure(i64 8) 
  store volatile i64* %cloptr22443, i64** %vptr22446, align 8 ; malloc
  %vptr22447 = alloca i64*, align 8 
  %eptr22444 = getelementptr inbounds i64, i64* %cloptr22443, i64 1 
  store volatile i64* %eptr22444, i64** %vptr22447, align 8 ; &cloptr22443[1]
 %vptr22448 = alloca i64, align 8 
  %f22445 = ptrtoint void(i64,i64)* @lam11932 to i64 
  store volatile i64 %f22445, i64* %vptr22448, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f22445, i64* %eptr22444                                                 ; store fptr
 %vptr22449 = alloca i64, align 8 
  %arg8076 = ptrtoint i64* %cloptr22443 to i64 
  store volatile i64 %arg8076, i64* %vptr22449, align 8 ; closure cast; i64* -> i64
 %vptr22450 = alloca i64, align 8 
  %rva9825 = add i64 0, 0 
  store volatile i64 %rva9825, i64* %vptr22450, align 8 ; quoted ()
 %vptr22451 = alloca i64, align 8 
  %rva9824 = call i64 @prim_cons(i64 %cont7202, i64 %rva9825) 
  store volatile i64 %rva9824, i64* %vptr22451, align 8 ; call prim_cons
  %vptr22457 = alloca i64*, align 8 
  %cloptr22452 = inttoptr i64 %arg8076 to i64* 
  store volatile i64* %cloptr22452, i64** %vptr22457, align 8 ; closure/env cast; i64 -> i64*
  %vptr22458 = alloca i64*, align 8 
  %i0ptr22453 = getelementptr inbounds i64, i64* %cloptr22452, i64 1 
  store volatile i64* %i0ptr22453, i64** %vptr22458, align 8 ; &cloptr22452[1]
 %vptr22459 = alloca i64, align 8 
  %f22455 = load i64, i64* %i0ptr22453, align 8 
  store volatile i64 %f22455, i64* %vptr22459, align 8 ; load; *i0ptr22453
  %fptr22454 = inttoptr i64 %f22455 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22454(i64 %arg8076, i64 %rva9824)                   ; tail call
  ret void

else22441:
 %vptr22460 = alloca i64, align 8 
  %arg8082 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8082, i64* %vptr22460, align 8 ; quoted int
 %vptr22461 = alloca i64, align 8 
  %a7039 = call i64 @prim_vector_45ref(i64 %bmP$nat_45_62peano, i64 %arg8082) 
  store volatile i64 %a7039, i64* %vptr22461, align 8 ; call prim_vector_45ref
 %vptr22462 = alloca i64, align 8 
  %arg8084 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg8084, i64* %vptr22462, align 8 ; quoted int
 %vptr22463 = alloca i64, align 8 
  %a7040 = call i64 @prim__45(i64 %G1K$n, i64 %arg8084) 
  store volatile i64 %a7040, i64* %vptr22463, align 8 ; call prim__45
  %vptr22470 = alloca i64*, align 8 
  %cloptr22464 = call i64* @make_closure(i64 32) 
  store volatile i64* %cloptr22464, i64** %vptr22470, align 8 ; malloc
  %vptr22471 = alloca i64*, align 8 
  %eptr22466 = getelementptr inbounds i64, i64* %cloptr22464, i64 2 
  store volatile i64* %eptr22466, i64** %vptr22471, align 8 ; &eptr22466[1]
  %vptr22472 = alloca i64*, align 8 
  %eptr22467 = getelementptr inbounds i64, i64* %cloptr22464, i64 3 
  store volatile i64* %eptr22467, i64** %vptr22472, align 8 ; &eptr22467[2]
  %vptr22473 = alloca i64*, align 8 
  %eptr22468 = getelementptr inbounds i64, i64* %cloptr22464, i64 4 
  store volatile i64* %eptr22468, i64** %vptr22473, align 8 ; &eptr22468[3]
  store i64 %emsg18637, i64* %eptr22466                                              ; *eptr22466 = %emsg18637
  store i64 %emsg08636, i64* %eptr22467                                              ; *eptr22467 = %emsg08636
  store i64 %cont7202, i64* %eptr22468                                               ; *eptr22468 = %cont7202
  %vptr22474 = alloca i64*, align 8 
  %eptr22465 = getelementptr inbounds i64, i64* %cloptr22464, i64 1 
  store volatile i64* %eptr22465, i64** %vptr22474, align 8 ; &cloptr22464[1]
 %vptr22475 = alloca i64, align 8 
  %f22469 = ptrtoint void(i64,i64)* @lam11944 to i64 
  store volatile i64 %f22469, i64* %vptr22475, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f22469, i64* %eptr22465                                                 ; store fptr
 %vptr22476 = alloca i64, align 8 
  %arg8087 = ptrtoint i64* %cloptr22464 to i64 
  store volatile i64 %arg8087, i64* %vptr22476, align 8 ; closure cast; i64* -> i64
 %vptr22477 = alloca i64, align 8 
  %rva9856 = add i64 0, 0 
  store volatile i64 %rva9856, i64* %vptr22477, align 8 ; quoted ()
 %vptr22478 = alloca i64, align 8 
  %rva9855 = call i64 @prim_cons(i64 %a7040, i64 %rva9856) 
  store volatile i64 %rva9855, i64* %vptr22478, align 8 ; call prim_cons
 %vptr22479 = alloca i64, align 8 
  %rva9854 = call i64 @prim_cons(i64 %arg8087, i64 %rva9855) 
  store volatile i64 %rva9854, i64* %vptr22479, align 8 ; call prim_cons
  %vptr22485 = alloca i64*, align 8 
  %cloptr22480 = inttoptr i64 %a7039 to i64* 
  store volatile i64* %cloptr22480, i64** %vptr22485, align 8 ; closure/env cast; i64 -> i64*
  %vptr22486 = alloca i64*, align 8 
  %i0ptr22481 = getelementptr inbounds i64, i64* %cloptr22480, i64 1 
  store volatile i64* %i0ptr22481, i64** %vptr22486, align 8 ; &cloptr22480[1]
 %vptr22487 = alloca i64, align 8 
  %f22483 = load i64, i64* %i0ptr22481, align 8 
  store volatile i64 %f22483, i64* %vptr22487, align 8 ; load; *i0ptr22481
  %fptr22482 = inttoptr i64 %f22483 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22482(i64 %a7039, i64 %rva9854)                     ; tail call
  ret void

else22435:
 %vptr22488 = alloca i64, align 8 
  %h9859 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9859, i64* %vptr22488, align 8 ; call prim_halt
  %vptr22494 = alloca i64*, align 8 
  %cloptr22489 = inttoptr i64 %h9859 to i64* 
  store volatile i64* %cloptr22489, i64** %vptr22494, align 8 ; closure/env cast; i64 -> i64*
  %vptr22495 = alloca i64*, align 8 
  %i0ptr22490 = getelementptr inbounds i64, i64* %cloptr22489, i64 1 
  store volatile i64* %i0ptr22490, i64** %vptr22495, align 8 ; &cloptr22489[1]
 %vptr22496 = alloca i64, align 8 
  %f22492 = load i64, i64* %i0ptr22490, align 8 
  store volatile i64 %f22492, i64* %vptr22496, align 8 ; load; *i0ptr22490
  %fptr22491 = inttoptr i64 %f22492 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22491(i64 %h9859, i64 %h9859)                       ; tail call
  ret void
}


define void @lam11944(i64 %env11945, i64 %rvp9850) {
 %vptr22499 = alloca i64, align 8 
  %envptr22497 = inttoptr i64 %env11945 to i64* 
  store volatile i64 %cont7202, i64* %vptr22499, align 8 ; closure/env cast; i64 -> i64*
  %vptr22500 = alloca i64*, align 8 
  %envptr22498 = getelementptr inbounds i64, i64* %envptr22497, i64 4 
  store volatile i64* %envptr22498, i64** %vptr22500, align 8 ; &envptr22497[3]
 %vptr22501 = alloca i64, align 8 
  %cont7202 = load i64, i64* %envptr22498, align 8 
  store volatile i64 %cont7202, i64* %vptr22501, align 8 ; load; *envptr22498
 %vptr22504 = alloca i64, align 8 
  %envptr22502 = inttoptr i64 %env11945 to i64* 
  store volatile i64 %emsg08636, i64* %vptr22504, align 8 ; closure/env cast; i64 -> i64*
  %vptr22505 = alloca i64*, align 8 
  %envptr22503 = getelementptr inbounds i64, i64* %envptr22502, i64 3 
  store volatile i64* %envptr22503, i64** %vptr22505, align 8 ; &envptr22502[2]
 %vptr22506 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr22503, align 8 
  store volatile i64 %emsg08636, i64* %vptr22506, align 8 ; load; *envptr22503
 %vptr22509 = alloca i64, align 8 
  %envptr22507 = inttoptr i64 %env11945 to i64* 
  store volatile i64 %emsg18637, i64* %vptr22509, align 8 ; closure/env cast; i64 -> i64*
  %vptr22510 = alloca i64*, align 8 
  %envptr22508 = getelementptr inbounds i64, i64* %envptr22507, i64 2 
  store volatile i64* %envptr22508, i64** %vptr22510, align 8 ; &envptr22507[1]
 %vptr22511 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr22508, align 8 
  store volatile i64 %emsg18637, i64* %vptr22511, align 8 ; load; *envptr22508
 %vptr22512 = alloca i64, align 8 
  %_957205 = call i64 @prim_car(i64 %rvp9850) 
  store volatile i64 %_957205, i64* %vptr22512, align 8 ; call prim_car
 %vptr22513 = alloca i64, align 8 
  %rvp9846 = call i64 @prim_cdr(i64 %rvp9850) 
  store volatile i64 %rvp9846, i64* %vptr22513, align 8 ; call prim_cdr
 %vptr22514 = alloca i64, align 8 
  %n_639851 = call i64 @prim_null_63(i64 %rvp9846) 
  store volatile i64 %n_639851, i64* %vptr22514, align 8 ; call prim_null_63
  %cmpptr22518 = alloca i1, align 8  %cmp22515 = icmp eq i64 %n_639851, 15 store volatile i1 %cmp22515, i1* %cmpptr22518, align 8; false?
  br i1 %cmp22515, label %else22517, label %then22516                                ; if

then22516:
 %vptr22519 = alloca i64, align 8 
  %h9852 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9852, i64* %vptr22519, align 8 ; call prim_halt
  %vptr22525 = alloca i64*, align 8 
  %cloptr22520 = inttoptr i64 %h9852 to i64* 
  store volatile i64* %cloptr22520, i64** %vptr22525, align 8 ; closure/env cast; i64 -> i64*
  %vptr22526 = alloca i64*, align 8 
  %i0ptr22521 = getelementptr inbounds i64, i64* %cloptr22520, i64 1 
  store volatile i64* %i0ptr22521, i64** %vptr22526, align 8 ; &cloptr22520[1]
 %vptr22527 = alloca i64, align 8 
  %f22523 = load i64, i64* %i0ptr22521, align 8 
  store volatile i64 %f22523, i64* %vptr22527, align 8 ; load; *i0ptr22521
  %fptr22522 = inttoptr i64 %f22523 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22522(i64 %h9852, i64 %h9852)                       ; tail call
  ret void

else22517:
 %vptr22528 = alloca i64, align 8 
  %a7041 = call i64 @prim_car(i64 %rvp9846) 
  store volatile i64 %a7041, i64* %vptr22528, align 8 ; call prim_car
 %vptr22529 = alloca i64, align 8 
  %na9827 = call i64 @prim_cdr(i64 %rvp9846) 
  store volatile i64 %na9827, i64* %vptr22529, align 8 ; call prim_cdr
 %vptr22530 = alloca i64, align 8 
  %n_639847 = call i64 @prim_null_63(i64 %na9827) 
  store volatile i64 %n_639847, i64* %vptr22530, align 8 ; call prim_null_63
  %cmpptr22534 = alloca i1, align 8  %cmp22531 = icmp eq i64 %n_639847, 15 store volatile i1 %cmp22531, i1* %cmpptr22534, align 8; false?
  br i1 %cmp22531, label %else22533, label %then22532                                ; if

then22532:
  %vptr22538 = alloca i64*, align 8 
  %cloptr22535 = call i64* @make_closure(i64 8) 
  store volatile i64* %cloptr22535, i64** %vptr22538, align 8 ; malloc
  %vptr22539 = alloca i64*, align 8 
  %eptr22536 = getelementptr inbounds i64, i64* %cloptr22535, i64 1 
  store volatile i64* %eptr22536, i64** %vptr22539, align 8 ; &cloptr22535[1]
 %vptr22540 = alloca i64, align 8 
  %f22537 = ptrtoint void(i64,i64)* @lam11942 to i64 
  store volatile i64 %f22537, i64* %vptr22540, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f22537, i64* %eptr22536                                                 ; store fptr
 %vptr22541 = alloca i64, align 8 
  %arg8090 = ptrtoint i64* %cloptr22535 to i64 
  store volatile i64 %arg8090, i64* %vptr22541, align 8 ; closure cast; i64* -> i64
  %vptr22549 = alloca i64*, align 8 
  %cloptr22542 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr22542, i64** %vptr22549, align 8 ; malloc
  %vptr22550 = alloca i64*, align 8 
  %eptr22544 = getelementptr inbounds i64, i64* %cloptr22542, i64 2 
  store volatile i64* %eptr22544, i64** %vptr22550, align 8 ; &eptr22544[1]
  %vptr22551 = alloca i64*, align 8 
  %eptr22545 = getelementptr inbounds i64, i64* %cloptr22542, i64 3 
  store volatile i64* %eptr22545, i64** %vptr22551, align 8 ; &eptr22545[2]
  %vptr22552 = alloca i64*, align 8 
  %eptr22546 = getelementptr inbounds i64, i64* %cloptr22542, i64 4 
  store volatile i64* %eptr22546, i64** %vptr22552, align 8 ; &eptr22546[3]
  %vptr22553 = alloca i64*, align 8 
  %eptr22547 = getelementptr inbounds i64, i64* %cloptr22542, i64 5 
  store volatile i64* %eptr22547, i64** %vptr22553, align 8 ; &eptr22547[4]
  store i64 %emsg18637, i64* %eptr22544                                              ; *eptr22544 = %emsg18637
  store i64 %a7041, i64* %eptr22545                                                  ; *eptr22545 = %a7041
  store i64 %emsg08636, i64* %eptr22546                                              ; *eptr22546 = %emsg08636
  store i64 %cont7202, i64* %eptr22547                                               ; *eptr22547 = %cont7202
  %vptr22554 = alloca i64*, align 8 
  %eptr22543 = getelementptr inbounds i64, i64* %cloptr22542, i64 1 
  store volatile i64* %eptr22543, i64** %vptr22554, align 8 ; &cloptr22542[1]
 %vptr22555 = alloca i64, align 8 
  %f22548 = ptrtoint void(i64,i64)* @lam11938 to i64 
  store volatile i64 %f22548, i64* %vptr22555, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f22548, i64* %eptr22543                                                 ; store fptr
 %vptr22556 = alloca i64, align 8 
  %arg8089 = ptrtoint i64* %cloptr22542 to i64 
  store volatile i64 %arg8089, i64* %vptr22556, align 8 ; closure cast; i64* -> i64
 %vptr22557 = alloca i64, align 8 
  %rva9845 = add i64 0, 0 
  store volatile i64 %rva9845, i64* %vptr22557, align 8 ; quoted ()
 %vptr22558 = alloca i64, align 8 
  %rva9844 = call i64 @prim_cons(i64 %arg8089, i64 %rva9845) 
  store volatile i64 %rva9844, i64* %vptr22558, align 8 ; call prim_cons
  %vptr22564 = alloca i64*, align 8 
  %cloptr22559 = inttoptr i64 %arg8090 to i64* 
  store volatile i64* %cloptr22559, i64** %vptr22564, align 8 ; closure/env cast; i64 -> i64*
  %vptr22565 = alloca i64*, align 8 
  %i0ptr22560 = getelementptr inbounds i64, i64* %cloptr22559, i64 1 
  store volatile i64* %i0ptr22560, i64** %vptr22565, align 8 ; &cloptr22559[1]
 %vptr22566 = alloca i64, align 8 
  %f22562 = load i64, i64* %i0ptr22560, align 8 
  store volatile i64 %f22562, i64* %vptr22566, align 8 ; load; *i0ptr22560
  %fptr22561 = inttoptr i64 %f22562 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22561(i64 %arg8090, i64 %rva9844)                   ; tail call
  ret void

else22533:
 %vptr22567 = alloca i64, align 8 
  %h9848 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9848, i64* %vptr22567, align 8 ; call prim_halt
  %vptr22573 = alloca i64*, align 8 
  %cloptr22568 = inttoptr i64 %h9848 to i64* 
  store volatile i64* %cloptr22568, i64** %vptr22573, align 8 ; closure/env cast; i64 -> i64*
  %vptr22574 = alloca i64*, align 8 
  %i0ptr22569 = getelementptr inbounds i64, i64* %cloptr22568, i64 1 
  store volatile i64* %i0ptr22569, i64** %vptr22574, align 8 ; &cloptr22568[1]
 %vptr22575 = alloca i64, align 8 
  %f22571 = load i64, i64* %i0ptr22569, align 8 
  store volatile i64 %f22571, i64* %vptr22575, align 8 ; load; *i0ptr22569
  %fptr22570 = inttoptr i64 %f22571 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22570(i64 %h9848, i64 %h9848)                       ; tail call
  ret void
}


define void @lam11942(i64 %env11943, i64 %TzG$lst7209) {
 %vptr22576 = alloca i64, align 8 
  %cont7208 = call i64 @prim_car(i64 %TzG$lst7209) 
  store volatile i64 %cont7208, i64* %vptr22576, align 8 ; call prim_car
 %vptr22577 = alloca i64, align 8 
  %TzG$lst = call i64 @prim_cdr(i64 %TzG$lst7209) 
  store volatile i64 %TzG$lst, i64* %vptr22577, align 8 ; call prim_cdr
 %vptr22578 = alloca i64, align 8 
  %arg8094 = add i64 0, 0 
  store volatile i64 %arg8094, i64* %vptr22578, align 8 ; quoted ()
 %vptr22579 = alloca i64, align 8 
  %rva9830 = add i64 0, 0 
  store volatile i64 %rva9830, i64* %vptr22579, align 8 ; quoted ()
 %vptr22580 = alloca i64, align 8 
  %rva9829 = call i64 @prim_cons(i64 %TzG$lst, i64 %rva9830) 
  store volatile i64 %rva9829, i64* %vptr22580, align 8 ; call prim_cons
 %vptr22581 = alloca i64, align 8 
  %rva9828 = call i64 @prim_cons(i64 %arg8094, i64 %rva9829) 
  store volatile i64 %rva9828, i64* %vptr22581, align 8 ; call prim_cons
  %vptr22587 = alloca i64*, align 8 
  %cloptr22582 = inttoptr i64 %cont7208 to i64* 
  store volatile i64* %cloptr22582, i64** %vptr22587, align 8 ; closure/env cast; i64 -> i64*
  %vptr22588 = alloca i64*, align 8 
  %i0ptr22583 = getelementptr inbounds i64, i64* %cloptr22582, i64 1 
  store volatile i64* %i0ptr22583, i64** %vptr22588, align 8 ; &cloptr22582[1]
 %vptr22589 = alloca i64, align 8 
  %f22585 = load i64, i64* %i0ptr22583, align 8 
  store volatile i64 %f22585, i64* %vptr22589, align 8 ; load; *i0ptr22583
  %fptr22584 = inttoptr i64 %f22585 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22584(i64 %cont7208, i64 %rva9828)                  ; tail call
  ret void
}


define void @lam11938(i64 %env11939, i64 %rvp9840) {
 %vptr22592 = alloca i64, align 8 
  %envptr22590 = inttoptr i64 %env11939 to i64* 
  store volatile i64 %cont7202, i64* %vptr22592, align 8 ; closure/env cast; i64 -> i64*
  %vptr22593 = alloca i64*, align 8 
  %envptr22591 = getelementptr inbounds i64, i64* %envptr22590, i64 5 
  store volatile i64* %envptr22591, i64** %vptr22593, align 8 ; &envptr22590[4]
 %vptr22594 = alloca i64, align 8 
  %cont7202 = load i64, i64* %envptr22591, align 8 
  store volatile i64 %cont7202, i64* %vptr22594, align 8 ; load; *envptr22591
 %vptr22597 = alloca i64, align 8 
  %envptr22595 = inttoptr i64 %env11939 to i64* 
  store volatile i64 %emsg08636, i64* %vptr22597, align 8 ; closure/env cast; i64 -> i64*
  %vptr22598 = alloca i64*, align 8 
  %envptr22596 = getelementptr inbounds i64, i64* %envptr22595, i64 4 
  store volatile i64* %envptr22596, i64** %vptr22598, align 8 ; &envptr22595[3]
 %vptr22599 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr22596, align 8 
  store volatile i64 %emsg08636, i64* %vptr22599, align 8 ; load; *envptr22596
 %vptr22602 = alloca i64, align 8 
  %envptr22600 = inttoptr i64 %env11939 to i64* 
  store volatile i64 %a7041, i64* %vptr22602, align 8 ; closure/env cast; i64 -> i64*
  %vptr22603 = alloca i64*, align 8 
  %envptr22601 = getelementptr inbounds i64, i64* %envptr22600, i64 3 
  store volatile i64* %envptr22601, i64** %vptr22603, align 8 ; &envptr22600[2]
 %vptr22604 = alloca i64, align 8 
  %a7041 = load i64, i64* %envptr22601, align 8 
  store volatile i64 %a7041, i64* %vptr22604, align 8 ; load; *envptr22601
 %vptr22607 = alloca i64, align 8 
  %envptr22605 = inttoptr i64 %env11939 to i64* 
  store volatile i64 %emsg18637, i64* %vptr22607, align 8 ; closure/env cast; i64 -> i64*
  %vptr22608 = alloca i64*, align 8 
  %envptr22606 = getelementptr inbounds i64, i64* %envptr22605, i64 2 
  store volatile i64* %envptr22606, i64** %vptr22608, align 8 ; &envptr22605[1]
 %vptr22609 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr22606, align 8 
  store volatile i64 %emsg18637, i64* %vptr22609, align 8 ; load; *envptr22606
 %vptr22610 = alloca i64, align 8 
  %_957206 = call i64 @prim_car(i64 %rvp9840) 
  store volatile i64 %_957206, i64* %vptr22610, align 8 ; call prim_car
 %vptr22611 = alloca i64, align 8 
  %rvp9836 = call i64 @prim_cdr(i64 %rvp9840) 
  store volatile i64 %rvp9836, i64* %vptr22611, align 8 ; call prim_cdr
 %vptr22612 = alloca i64, align 8 
  %n_639841 = call i64 @prim_null_63(i64 %rvp9836) 
  store volatile i64 %n_639841, i64* %vptr22612, align 8 ; call prim_null_63
  %cmpptr22616 = alloca i1, align 8  %cmp22613 = icmp eq i64 %n_639841, 15 store volatile i1 %cmp22613, i1* %cmpptr22616, align 8; false?
  br i1 %cmp22613, label %else22615, label %then22614                                ; if

then22614:
 %vptr22617 = alloca i64, align 8 
  %h9842 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9842, i64* %vptr22617, align 8 ; call prim_halt
  %vptr22623 = alloca i64*, align 8 
  %cloptr22618 = inttoptr i64 %h9842 to i64* 
  store volatile i64* %cloptr22618, i64** %vptr22623, align 8 ; closure/env cast; i64 -> i64*
  %vptr22624 = alloca i64*, align 8 
  %i0ptr22619 = getelementptr inbounds i64, i64* %cloptr22618, i64 1 
  store volatile i64* %i0ptr22619, i64** %vptr22624, align 8 ; &cloptr22618[1]
 %vptr22625 = alloca i64, align 8 
  %f22621 = load i64, i64* %i0ptr22619, align 8 
  store volatile i64 %f22621, i64* %vptr22625, align 8 ; load; *i0ptr22619
  %fptr22620 = inttoptr i64 %f22621 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22620(i64 %h9842, i64 %h9842)                       ; tail call
  ret void

else22615:
 %vptr22626 = alloca i64, align 8 
  %a7042 = call i64 @prim_car(i64 %rvp9836) 
  store volatile i64 %a7042, i64* %vptr22626, align 8 ; call prim_car
 %vptr22627 = alloca i64, align 8 
  %na9832 = call i64 @prim_cdr(i64 %rvp9836) 
  store volatile i64 %na9832, i64* %vptr22627, align 8 ; call prim_cdr
 %vptr22628 = alloca i64, align 8 
  %n_639837 = call i64 @prim_null_63(i64 %na9832) 
  store volatile i64 %n_639837, i64* %vptr22628, align 8 ; call prim_null_63
  %cmpptr22632 = alloca i1, align 8  %cmp22629 = icmp eq i64 %n_639837, 15 store volatile i1 %cmp22629, i1* %cmpptr22632, align 8; false?
  br i1 %cmp22629, label %else22631, label %then22630                                ; if

then22630:
 %vptr22633 = alloca i64, align 8 
  %retprim7207 = call i64 @prim_cons(i64 %a7041, i64 %a7042) 
  store volatile i64 %retprim7207, i64* %vptr22633, align 8 ; call prim_cons
 %vptr22634 = alloca i64, align 8 
  %arg8099 = add i64 0, 0 
  store volatile i64 %arg8099, i64* %vptr22634, align 8 ; quoted ()
 %vptr22635 = alloca i64, align 8 
  %rva9835 = add i64 0, 0 
  store volatile i64 %rva9835, i64* %vptr22635, align 8 ; quoted ()
 %vptr22636 = alloca i64, align 8 
  %rva9834 = call i64 @prim_cons(i64 %retprim7207, i64 %rva9835) 
  store volatile i64 %rva9834, i64* %vptr22636, align 8 ; call prim_cons
 %vptr22637 = alloca i64, align 8 
  %rva9833 = call i64 @prim_cons(i64 %arg8099, i64 %rva9834) 
  store volatile i64 %rva9833, i64* %vptr22637, align 8 ; call prim_cons
  %vptr22643 = alloca i64*, align 8 
  %cloptr22638 = inttoptr i64 %cont7202 to i64* 
  store volatile i64* %cloptr22638, i64** %vptr22643, align 8 ; closure/env cast; i64 -> i64*
  %vptr22644 = alloca i64*, align 8 
  %i0ptr22639 = getelementptr inbounds i64, i64* %cloptr22638, i64 1 
  store volatile i64* %i0ptr22639, i64** %vptr22644, align 8 ; &cloptr22638[1]
 %vptr22645 = alloca i64, align 8 
  %f22641 = load i64, i64* %i0ptr22639, align 8 
  store volatile i64 %f22641, i64* %vptr22645, align 8 ; load; *i0ptr22639
  %fptr22640 = inttoptr i64 %f22641 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22640(i64 %cont7202, i64 %rva9833)                  ; tail call
  ret void

else22631:
 %vptr22646 = alloca i64, align 8 
  %h9838 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9838, i64* %vptr22646, align 8 ; call prim_halt
  %vptr22652 = alloca i64*, align 8 
  %cloptr22647 = inttoptr i64 %h9838 to i64* 
  store volatile i64* %cloptr22647, i64** %vptr22652, align 8 ; closure/env cast; i64 -> i64*
  %vptr22653 = alloca i64*, align 8 
  %i0ptr22648 = getelementptr inbounds i64, i64* %cloptr22647, i64 1 
  store volatile i64* %i0ptr22648, i64** %vptr22653, align 8 ; &cloptr22647[1]
 %vptr22654 = alloca i64, align 8 
  %f22650 = load i64, i64* %i0ptr22648, align 8 
  store volatile i64 %f22650, i64* %vptr22654, align 8 ; load; *i0ptr22648
  %fptr22649 = inttoptr i64 %f22650 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22649(i64 %h9838, i64 %h9838)                       ; tail call
  ret void
}


define void @lam11932(i64 %env11933, i64 %yVF$lst7204) {
 %vptr22655 = alloca i64, align 8 
  %cont7203 = call i64 @prim_car(i64 %yVF$lst7204) 
  store volatile i64 %cont7203, i64* %vptr22655, align 8 ; call prim_car
 %vptr22656 = alloca i64, align 8 
  %yVF$lst = call i64 @prim_cdr(i64 %yVF$lst7204) 
  store volatile i64 %yVF$lst, i64* %vptr22656, align 8 ; call prim_cdr
 %vptr22657 = alloca i64, align 8 
  %arg8080 = add i64 0, 0 
  store volatile i64 %arg8080, i64* %vptr22657, align 8 ; quoted ()
 %vptr22658 = alloca i64, align 8 
  %rva9823 = add i64 0, 0 
  store volatile i64 %rva9823, i64* %vptr22658, align 8 ; quoted ()
 %vptr22659 = alloca i64, align 8 
  %rva9822 = call i64 @prim_cons(i64 %yVF$lst, i64 %rva9823) 
  store volatile i64 %rva9822, i64* %vptr22659, align 8 ; call prim_cons
 %vptr22660 = alloca i64, align 8 
  %rva9821 = call i64 @prim_cons(i64 %arg8080, i64 %rva9822) 
  store volatile i64 %rva9821, i64* %vptr22660, align 8 ; call prim_cons
  %vptr22666 = alloca i64*, align 8 
  %cloptr22661 = inttoptr i64 %cont7203 to i64* 
  store volatile i64* %cloptr22661, i64** %vptr22666, align 8 ; closure/env cast; i64 -> i64*
  %vptr22667 = alloca i64*, align 8 
  %i0ptr22662 = getelementptr inbounds i64, i64* %cloptr22661, i64 1 
  store volatile i64* %i0ptr22662, i64** %vptr22667, align 8 ; &cloptr22661[1]
 %vptr22668 = alloca i64, align 8 
  %f22664 = load i64, i64* %i0ptr22662, align 8 
  store volatile i64 %f22664, i64* %vptr22668, align 8 ; load; *i0ptr22662
  %fptr22663 = inttoptr i64 %f22664 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22663(i64 %cont7203, i64 %rva9821)                  ; tail call
  ret void
}


define void @lam11927(i64 %env11928, i64 %rvp9916) {
 %vptr22671 = alloca i64, align 8 
  %envptr22669 = inttoptr i64 %env11928 to i64* 
  store volatile i64 %bbE$z_63, i64* %vptr22671, align 8 ; closure/env cast; i64 -> i64*
  %vptr22672 = alloca i64*, align 8 
  %envptr22670 = getelementptr inbounds i64, i64* %envptr22669, i64 6 
  store volatile i64* %envptr22670, i64** %vptr22672, align 8 ; &envptr22669[5]
 %vptr22673 = alloca i64, align 8 
  %bbE$z_63 = load i64, i64* %envptr22670, align 8 
  store volatile i64 %bbE$z_63, i64* %vptr22673, align 8 ; load; *envptr22670
 %vptr22676 = alloca i64, align 8 
  %envptr22674 = inttoptr i64 %env11928 to i64* 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr22676, align 8 ; closure/env cast; i64 -> i64*
  %vptr22677 = alloca i64*, align 8 
  %envptr22675 = getelementptr inbounds i64, i64* %envptr22674, i64 5 
  store volatile i64* %envptr22675, i64** %vptr22677, align 8 ; &envptr22674[4]
 %vptr22678 = alloca i64, align 8 
  %Iic$peano_45_62nat = load i64, i64* %envptr22675, align 8 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr22678, align 8 ; load; *envptr22675
 %vptr22681 = alloca i64, align 8 
  %envptr22679 = inttoptr i64 %env11928 to i64* 
  store volatile i64 %emsg08636, i64* %vptr22681, align 8 ; closure/env cast; i64 -> i64*
  %vptr22682 = alloca i64*, align 8 
  %envptr22680 = getelementptr inbounds i64, i64* %envptr22679, i64 4 
  store volatile i64* %envptr22680, i64** %vptr22682, align 8 ; &envptr22679[3]
 %vptr22683 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr22680, align 8 
  store volatile i64 %emsg08636, i64* %vptr22683, align 8 ; load; *envptr22680
 %vptr22686 = alloca i64, align 8 
  %envptr22684 = inttoptr i64 %env11928 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr22686, align 8 ; closure/env cast; i64 -> i64*
  %vptr22687 = alloca i64*, align 8 
  %envptr22685 = getelementptr inbounds i64, i64* %envptr22684, i64 3 
  store volatile i64* %envptr22685, i64** %vptr22687, align 8 ; &envptr22684[2]
 %vptr22688 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr22685, align 8 
  store volatile i64 %Pll$pred, i64* %vptr22688, align 8 ; load; *envptr22685
 %vptr22691 = alloca i64, align 8 
  %envptr22689 = inttoptr i64 %env11928 to i64* 
  store volatile i64 %emsg18637, i64* %vptr22691, align 8 ; closure/env cast; i64 -> i64*
  %vptr22692 = alloca i64*, align 8 
  %envptr22690 = getelementptr inbounds i64, i64* %envptr22689, i64 2 
  store volatile i64* %envptr22690, i64** %vptr22692, align 8 ; &envptr22689[1]
 %vptr22693 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr22690, align 8 
  store volatile i64 %emsg18637, i64* %vptr22693, align 8 ; load; *envptr22690
 %vptr22694 = alloca i64, align 8 
  %cont7210 = call i64 @prim_car(i64 %rvp9916) 
  store volatile i64 %cont7210, i64* %vptr22694, align 8 ; call prim_car
 %vptr22695 = alloca i64, align 8 
  %rvp9912 = call i64 @prim_cdr(i64 %rvp9916) 
  store volatile i64 %rvp9912, i64* %vptr22695, align 8 ; call prim_cdr
 %vptr22696 = alloca i64, align 8 
  %n_639917 = call i64 @prim_null_63(i64 %rvp9912) 
  store volatile i64 %n_639917, i64* %vptr22696, align 8 ; call prim_null_63
  %cmpptr22700 = alloca i1, align 8  %cmp22697 = icmp eq i64 %n_639917, 15 store volatile i1 %cmp22697, i1* %cmpptr22700, align 8; false?
  br i1 %cmp22697, label %else22699, label %then22698                                ; if

then22698:
 %vptr22701 = alloca i64, align 8 
  %h9918 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9918, i64* %vptr22701, align 8 ; call prim_halt
  %vptr22707 = alloca i64*, align 8 
  %cloptr22702 = inttoptr i64 %h9918 to i64* 
  store volatile i64* %cloptr22702, i64** %vptr22707, align 8 ; closure/env cast; i64 -> i64*
  %vptr22708 = alloca i64*, align 8 
  %i0ptr22703 = getelementptr inbounds i64, i64* %cloptr22702, i64 1 
  store volatile i64* %i0ptr22703, i64** %vptr22708, align 8 ; &cloptr22702[1]
 %vptr22709 = alloca i64, align 8 
  %f22705 = load i64, i64* %i0ptr22703, align 8 
  store volatile i64 %f22705, i64* %vptr22709, align 8 ; load; *i0ptr22703
  %fptr22704 = inttoptr i64 %f22705 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22704(i64 %h9918, i64 %h9918)                       ; tail call
  ret void

else22699:
 %vptr22710 = alloca i64, align 8 
  %zR0$n = call i64 @prim_car(i64 %rvp9912) 
  store volatile i64 %zR0$n, i64* %vptr22710, align 8 ; call prim_car
 %vptr22711 = alloca i64, align 8 
  %na9866 = call i64 @prim_cdr(i64 %rvp9912) 
  store volatile i64 %na9866, i64* %vptr22711, align 8 ; call prim_cdr
 %vptr22712 = alloca i64, align 8 
  %n_639913 = call i64 @prim_null_63(i64 %na9866) 
  store volatile i64 %n_639913, i64* %vptr22712, align 8 ; call prim_null_63
  %cmpptr22716 = alloca i1, align 8  %cmp22713 = icmp eq i64 %n_639913, 15 store volatile i1 %cmp22713, i1* %cmpptr22716, align 8; false?
  br i1 %cmp22713, label %else22715, label %then22714                                ; if

then22714:
 %vptr22717 = alloca i64, align 8 
  %arg8101 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8101, i64* %vptr22717, align 8 ; quoted int
 %vptr22718 = alloca i64, align 8 
  %a7043 = call i64 @prim_vector_45ref(i64 %bbE$z_63, i64 %arg8101) 
  store volatile i64 %a7043, i64* %vptr22718, align 8 ; call prim_vector_45ref
  %vptr22728 = alloca i64*, align 8 
  %cloptr22719 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr22719, i64** %vptr22728, align 8 ; malloc
  %vptr22729 = alloca i64*, align 8 
  %eptr22721 = getelementptr inbounds i64, i64* %cloptr22719, i64 2 
  store volatile i64* %eptr22721, i64** %vptr22729, align 8 ; &eptr22721[1]
  %vptr22730 = alloca i64*, align 8 
  %eptr22722 = getelementptr inbounds i64, i64* %cloptr22719, i64 3 
  store volatile i64* %eptr22722, i64** %vptr22730, align 8 ; &eptr22722[2]
  %vptr22731 = alloca i64*, align 8 
  %eptr22723 = getelementptr inbounds i64, i64* %cloptr22719, i64 4 
  store volatile i64* %eptr22723, i64** %vptr22731, align 8 ; &eptr22723[3]
  %vptr22732 = alloca i64*, align 8 
  %eptr22724 = getelementptr inbounds i64, i64* %cloptr22719, i64 5 
  store volatile i64* %eptr22724, i64** %vptr22732, align 8 ; &eptr22724[4]
  %vptr22733 = alloca i64*, align 8 
  %eptr22725 = getelementptr inbounds i64, i64* %cloptr22719, i64 6 
  store volatile i64* %eptr22725, i64** %vptr22733, align 8 ; &eptr22725[5]
  %vptr22734 = alloca i64*, align 8 
  %eptr22726 = getelementptr inbounds i64, i64* %cloptr22719, i64 7 
  store volatile i64* %eptr22726, i64** %vptr22734, align 8 ; &eptr22726[6]
  store i64 %emsg18637, i64* %eptr22721                                              ; *eptr22721 = %emsg18637
  store i64 %Pll$pred, i64* %eptr22722                                               ; *eptr22722 = %Pll$pred
  store i64 %zR0$n, i64* %eptr22723                                                  ; *eptr22723 = %zR0$n
  store i64 %cont7210, i64* %eptr22724                                               ; *eptr22724 = %cont7210
  store i64 %emsg08636, i64* %eptr22725                                              ; *eptr22725 = %emsg08636
  store i64 %Iic$peano_45_62nat, i64* %eptr22726                                     ; *eptr22726 = %Iic$peano_45_62nat
  %vptr22735 = alloca i64*, align 8 
  %eptr22720 = getelementptr inbounds i64, i64* %cloptr22719, i64 1 
  store volatile i64* %eptr22720, i64** %vptr22735, align 8 ; &cloptr22719[1]
 %vptr22736 = alloca i64, align 8 
  %f22727 = ptrtoint void(i64,i64)* @lam11924 to i64 
  store volatile i64 %f22727, i64* %vptr22736, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f22727, i64* %eptr22720                                                 ; store fptr
 %vptr22737 = alloca i64, align 8 
  %arg8104 = ptrtoint i64* %cloptr22719 to i64 
  store volatile i64 %arg8104, i64* %vptr22737, align 8 ; closure cast; i64* -> i64
 %vptr22738 = alloca i64, align 8 
  %rva9911 = add i64 0, 0 
  store volatile i64 %rva9911, i64* %vptr22738, align 8 ; quoted ()
 %vptr22739 = alloca i64, align 8 
  %rva9910 = call i64 @prim_cons(i64 %zR0$n, i64 %rva9911) 
  store volatile i64 %rva9910, i64* %vptr22739, align 8 ; call prim_cons
 %vptr22740 = alloca i64, align 8 
  %rva9909 = call i64 @prim_cons(i64 %arg8104, i64 %rva9910) 
  store volatile i64 %rva9909, i64* %vptr22740, align 8 ; call prim_cons
  %vptr22746 = alloca i64*, align 8 
  %cloptr22741 = inttoptr i64 %a7043 to i64* 
  store volatile i64* %cloptr22741, i64** %vptr22746, align 8 ; closure/env cast; i64 -> i64*
  %vptr22747 = alloca i64*, align 8 
  %i0ptr22742 = getelementptr inbounds i64, i64* %cloptr22741, i64 1 
  store volatile i64* %i0ptr22742, i64** %vptr22747, align 8 ; &cloptr22741[1]
 %vptr22748 = alloca i64, align 8 
  %f22744 = load i64, i64* %i0ptr22742, align 8 
  store volatile i64 %f22744, i64* %vptr22748, align 8 ; load; *i0ptr22742
  %fptr22743 = inttoptr i64 %f22744 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22743(i64 %a7043, i64 %rva9909)                     ; tail call
  ret void

else22715:
 %vptr22749 = alloca i64, align 8 
  %h9914 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9914, i64* %vptr22749, align 8 ; call prim_halt
  %vptr22755 = alloca i64*, align 8 
  %cloptr22750 = inttoptr i64 %h9914 to i64* 
  store volatile i64* %cloptr22750, i64** %vptr22755, align 8 ; closure/env cast; i64 -> i64*
  %vptr22756 = alloca i64*, align 8 
  %i0ptr22751 = getelementptr inbounds i64, i64* %cloptr22750, i64 1 
  store volatile i64* %i0ptr22751, i64** %vptr22756, align 8 ; &cloptr22750[1]
 %vptr22757 = alloca i64, align 8 
  %f22753 = load i64, i64* %i0ptr22751, align 8 
  store volatile i64 %f22753, i64* %vptr22757, align 8 ; load; *i0ptr22751
  %fptr22752 = inttoptr i64 %f22753 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22752(i64 %h9914, i64 %h9914)                       ; tail call
  ret void
}


define void @lam11924(i64 %env11925, i64 %rvp9905) {
 %vptr22760 = alloca i64, align 8 
  %envptr22758 = inttoptr i64 %env11925 to i64* 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr22760, align 8 ; closure/env cast; i64 -> i64*
  %vptr22761 = alloca i64*, align 8 
  %envptr22759 = getelementptr inbounds i64, i64* %envptr22758, i64 7 
  store volatile i64* %envptr22759, i64** %vptr22761, align 8 ; &envptr22758[6]
 %vptr22762 = alloca i64, align 8 
  %Iic$peano_45_62nat = load i64, i64* %envptr22759, align 8 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr22762, align 8 ; load; *envptr22759
 %vptr22765 = alloca i64, align 8 
  %envptr22763 = inttoptr i64 %env11925 to i64* 
  store volatile i64 %emsg08636, i64* %vptr22765, align 8 ; closure/env cast; i64 -> i64*
  %vptr22766 = alloca i64*, align 8 
  %envptr22764 = getelementptr inbounds i64, i64* %envptr22763, i64 6 
  store volatile i64* %envptr22764, i64** %vptr22766, align 8 ; &envptr22763[5]
 %vptr22767 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr22764, align 8 
  store volatile i64 %emsg08636, i64* %vptr22767, align 8 ; load; *envptr22764
 %vptr22770 = alloca i64, align 8 
  %envptr22768 = inttoptr i64 %env11925 to i64* 
  store volatile i64 %cont7210, i64* %vptr22770, align 8 ; closure/env cast; i64 -> i64*
  %vptr22771 = alloca i64*, align 8 
  %envptr22769 = getelementptr inbounds i64, i64* %envptr22768, i64 5 
  store volatile i64* %envptr22769, i64** %vptr22771, align 8 ; &envptr22768[4]
 %vptr22772 = alloca i64, align 8 
  %cont7210 = load i64, i64* %envptr22769, align 8 
  store volatile i64 %cont7210, i64* %vptr22772, align 8 ; load; *envptr22769
 %vptr22775 = alloca i64, align 8 
  %envptr22773 = inttoptr i64 %env11925 to i64* 
  store volatile i64 %zR0$n, i64* %vptr22775, align 8 ; closure/env cast; i64 -> i64*
  %vptr22776 = alloca i64*, align 8 
  %envptr22774 = getelementptr inbounds i64, i64* %envptr22773, i64 4 
  store volatile i64* %envptr22774, i64** %vptr22776, align 8 ; &envptr22773[3]
 %vptr22777 = alloca i64, align 8 
  %zR0$n = load i64, i64* %envptr22774, align 8 
  store volatile i64 %zR0$n, i64* %vptr22777, align 8 ; load; *envptr22774
 %vptr22780 = alloca i64, align 8 
  %envptr22778 = inttoptr i64 %env11925 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr22780, align 8 ; closure/env cast; i64 -> i64*
  %vptr22781 = alloca i64*, align 8 
  %envptr22779 = getelementptr inbounds i64, i64* %envptr22778, i64 3 
  store volatile i64* %envptr22779, i64** %vptr22781, align 8 ; &envptr22778[2]
 %vptr22782 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr22779, align 8 
  store volatile i64 %Pll$pred, i64* %vptr22782, align 8 ; load; *envptr22779
 %vptr22785 = alloca i64, align 8 
  %envptr22783 = inttoptr i64 %env11925 to i64* 
  store volatile i64 %emsg18637, i64* %vptr22785, align 8 ; closure/env cast; i64 -> i64*
  %vptr22786 = alloca i64*, align 8 
  %envptr22784 = getelementptr inbounds i64, i64* %envptr22783, i64 2 
  store volatile i64* %envptr22784, i64** %vptr22786, align 8 ; &envptr22783[1]
 %vptr22787 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr22784, align 8 
  store volatile i64 %emsg18637, i64* %vptr22787, align 8 ; load; *envptr22784
 %vptr22788 = alloca i64, align 8 
  %_957211 = call i64 @prim_car(i64 %rvp9905) 
  store volatile i64 %_957211, i64* %vptr22788, align 8 ; call prim_car
 %vptr22789 = alloca i64, align 8 
  %rvp9901 = call i64 @prim_cdr(i64 %rvp9905) 
  store volatile i64 %rvp9901, i64* %vptr22789, align 8 ; call prim_cdr
 %vptr22790 = alloca i64, align 8 
  %n_639906 = call i64 @prim_null_63(i64 %rvp9901) 
  store volatile i64 %n_639906, i64* %vptr22790, align 8 ; call prim_null_63
  %cmpptr22794 = alloca i1, align 8  %cmp22791 = icmp eq i64 %n_639906, 15 store volatile i1 %cmp22791, i1* %cmpptr22794, align 8; false?
  br i1 %cmp22791, label %else22793, label %then22792                                ; if

then22792:
 %vptr22795 = alloca i64, align 8 
  %h9907 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9907, i64* %vptr22795, align 8 ; call prim_halt
  %vptr22801 = alloca i64*, align 8 
  %cloptr22796 = inttoptr i64 %h9907 to i64* 
  store volatile i64* %cloptr22796, i64** %vptr22801, align 8 ; closure/env cast; i64 -> i64*
  %vptr22802 = alloca i64*, align 8 
  %i0ptr22797 = getelementptr inbounds i64, i64* %cloptr22796, i64 1 
  store volatile i64* %i0ptr22797, i64** %vptr22802, align 8 ; &cloptr22796[1]
 %vptr22803 = alloca i64, align 8 
  %f22799 = load i64, i64* %i0ptr22797, align 8 
  store volatile i64 %f22799, i64* %vptr22803, align 8 ; load; *i0ptr22797
  %fptr22798 = inttoptr i64 %f22799 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22798(i64 %h9907, i64 %h9907)                       ; tail call
  ret void

else22793:
 %vptr22804 = alloca i64, align 8 
  %a7044 = call i64 @prim_car(i64 %rvp9901) 
  store volatile i64 %a7044, i64* %vptr22804, align 8 ; call prim_car
 %vptr22805 = alloca i64, align 8 
  %na9868 = call i64 @prim_cdr(i64 %rvp9901) 
  store volatile i64 %na9868, i64* %vptr22805, align 8 ; call prim_cdr
 %vptr22806 = alloca i64, align 8 
  %n_639902 = call i64 @prim_null_63(i64 %na9868) 
  store volatile i64 %n_639902, i64* %vptr22806, align 8 ; call prim_null_63
  %cmpptr22810 = alloca i1, align 8  %cmp22807 = icmp eq i64 %n_639902, 15 store volatile i1 %cmp22807, i1* %cmpptr22810, align 8; false?
  br i1 %cmp22807, label %else22809, label %then22808                                ; if

then22808:
  %cmpptr22814 = alloca i1, align 8  %cmp22811 = icmp eq i64 %a7044, 15 store volatile i1 %cmp22811, i1* %cmpptr22814, align 8; false?
  br i1 %cmp22811, label %else22813, label %then22812                                ; if

then22812:
 %vptr22815 = alloca i64, align 8 
  %arg8107 = add i64 0, 0 
  store volatile i64 %arg8107, i64* %vptr22815, align 8 ; quoted ()
 %vptr22816 = alloca i64, align 8 
  %arg8106 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8106, i64* %vptr22816, align 8 ; quoted int
 %vptr22817 = alloca i64, align 8 
  %rva9871 = add i64 0, 0 
  store volatile i64 %rva9871, i64* %vptr22817, align 8 ; quoted ()
 %vptr22818 = alloca i64, align 8 
  %rva9870 = call i64 @prim_cons(i64 %arg8106, i64 %rva9871) 
  store volatile i64 %rva9870, i64* %vptr22818, align 8 ; call prim_cons
 %vptr22819 = alloca i64, align 8 
  %rva9869 = call i64 @prim_cons(i64 %arg8107, i64 %rva9870) 
  store volatile i64 %rva9869, i64* %vptr22819, align 8 ; call prim_cons
  %vptr22825 = alloca i64*, align 8 
  %cloptr22820 = inttoptr i64 %cont7210 to i64* 
  store volatile i64* %cloptr22820, i64** %vptr22825, align 8 ; closure/env cast; i64 -> i64*
  %vptr22826 = alloca i64*, align 8 
  %i0ptr22821 = getelementptr inbounds i64, i64* %cloptr22820, i64 1 
  store volatile i64* %i0ptr22821, i64** %vptr22826, align 8 ; &cloptr22820[1]
 %vptr22827 = alloca i64, align 8 
  %f22823 = load i64, i64* %i0ptr22821, align 8 
  store volatile i64 %f22823, i64* %vptr22827, align 8 ; load; *i0ptr22821
  %fptr22822 = inttoptr i64 %f22823 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22822(i64 %cont7210, i64 %rva9869)                  ; tail call
  ret void

else22813:
 %vptr22828 = alloca i64, align 8 
  %arg8109 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8109, i64* %vptr22828, align 8 ; quoted int
 %vptr22829 = alloca i64, align 8 
  %a7045 = call i64 @prim_vector_45ref(i64 %Iic$peano_45_62nat, i64 %arg8109) 
  store volatile i64 %a7045, i64* %vptr22829, align 8 ; call prim_vector_45ref
 %vptr22830 = alloca i64, align 8 
  %arg8111 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8111, i64* %vptr22830, align 8 ; quoted int
 %vptr22831 = alloca i64, align 8 
  %a7046 = call i64 @prim_vector_45ref(i64 %Pll$pred, i64 %arg8111) 
  store volatile i64 %a7046, i64* %vptr22831, align 8 ; call prim_vector_45ref
  %vptr22839 = alloca i64*, align 8 
  %cloptr22832 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr22832, i64** %vptr22839, align 8 ; malloc
  %vptr22840 = alloca i64*, align 8 
  %eptr22834 = getelementptr inbounds i64, i64* %cloptr22832, i64 2 
  store volatile i64* %eptr22834, i64** %vptr22840, align 8 ; &eptr22834[1]
  %vptr22841 = alloca i64*, align 8 
  %eptr22835 = getelementptr inbounds i64, i64* %cloptr22832, i64 3 
  store volatile i64* %eptr22835, i64** %vptr22841, align 8 ; &eptr22835[2]
  %vptr22842 = alloca i64*, align 8 
  %eptr22836 = getelementptr inbounds i64, i64* %cloptr22832, i64 4 
  store volatile i64* %eptr22836, i64** %vptr22842, align 8 ; &eptr22836[3]
  %vptr22843 = alloca i64*, align 8 
  %eptr22837 = getelementptr inbounds i64, i64* %cloptr22832, i64 5 
  store volatile i64* %eptr22837, i64** %vptr22843, align 8 ; &eptr22837[4]
  store i64 %emsg18637, i64* %eptr22834                                              ; *eptr22834 = %emsg18637
  store i64 %a7045, i64* %eptr22835                                                  ; *eptr22835 = %a7045
  store i64 %cont7210, i64* %eptr22836                                               ; *eptr22836 = %cont7210
  store i64 %emsg08636, i64* %eptr22837                                              ; *eptr22837 = %emsg08636
  %vptr22844 = alloca i64*, align 8 
  %eptr22833 = getelementptr inbounds i64, i64* %cloptr22832, i64 1 
  store volatile i64* %eptr22833, i64** %vptr22844, align 8 ; &cloptr22832[1]
 %vptr22845 = alloca i64, align 8 
  %f22838 = ptrtoint void(i64,i64)* @lam11920 to i64 
  store volatile i64 %f22838, i64* %vptr22845, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f22838, i64* %eptr22833                                                 ; store fptr
 %vptr22846 = alloca i64, align 8 
  %arg8114 = ptrtoint i64* %cloptr22832 to i64 
  store volatile i64 %arg8114, i64* %vptr22846, align 8 ; closure cast; i64* -> i64
 %vptr22847 = alloca i64, align 8 
  %rva9900 = add i64 0, 0 
  store volatile i64 %rva9900, i64* %vptr22847, align 8 ; quoted ()
 %vptr22848 = alloca i64, align 8 
  %rva9899 = call i64 @prim_cons(i64 %zR0$n, i64 %rva9900) 
  store volatile i64 %rva9899, i64* %vptr22848, align 8 ; call prim_cons
 %vptr22849 = alloca i64, align 8 
  %rva9898 = call i64 @prim_cons(i64 %arg8114, i64 %rva9899) 
  store volatile i64 %rva9898, i64* %vptr22849, align 8 ; call prim_cons
  %vptr22855 = alloca i64*, align 8 
  %cloptr22850 = inttoptr i64 %a7046 to i64* 
  store volatile i64* %cloptr22850, i64** %vptr22855, align 8 ; closure/env cast; i64 -> i64*
  %vptr22856 = alloca i64*, align 8 
  %i0ptr22851 = getelementptr inbounds i64, i64* %cloptr22850, i64 1 
  store volatile i64* %i0ptr22851, i64** %vptr22856, align 8 ; &cloptr22850[1]
 %vptr22857 = alloca i64, align 8 
  %f22853 = load i64, i64* %i0ptr22851, align 8 
  store volatile i64 %f22853, i64* %vptr22857, align 8 ; load; *i0ptr22851
  %fptr22852 = inttoptr i64 %f22853 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22852(i64 %a7046, i64 %rva9898)                     ; tail call
  ret void

else22809:
 %vptr22858 = alloca i64, align 8 
  %h9903 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9903, i64* %vptr22858, align 8 ; call prim_halt
  %vptr22864 = alloca i64*, align 8 
  %cloptr22859 = inttoptr i64 %h9903 to i64* 
  store volatile i64* %cloptr22859, i64** %vptr22864, align 8 ; closure/env cast; i64 -> i64*
  %vptr22865 = alloca i64*, align 8 
  %i0ptr22860 = getelementptr inbounds i64, i64* %cloptr22859, i64 1 
  store volatile i64* %i0ptr22860, i64** %vptr22865, align 8 ; &cloptr22859[1]
 %vptr22866 = alloca i64, align 8 
  %f22862 = load i64, i64* %i0ptr22860, align 8 
  store volatile i64 %f22862, i64* %vptr22866, align 8 ; load; *i0ptr22860
  %fptr22861 = inttoptr i64 %f22862 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22861(i64 %h9903, i64 %h9903)                       ; tail call
  ret void
}


define void @lam11920(i64 %env11921, i64 %rvp9894) {
 %vptr22869 = alloca i64, align 8 
  %envptr22867 = inttoptr i64 %env11921 to i64* 
  store volatile i64 %emsg08636, i64* %vptr22869, align 8 ; closure/env cast; i64 -> i64*
  %vptr22870 = alloca i64*, align 8 
  %envptr22868 = getelementptr inbounds i64, i64* %envptr22867, i64 5 
  store volatile i64* %envptr22868, i64** %vptr22870, align 8 ; &envptr22867[4]
 %vptr22871 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr22868, align 8 
  store volatile i64 %emsg08636, i64* %vptr22871, align 8 ; load; *envptr22868
 %vptr22874 = alloca i64, align 8 
  %envptr22872 = inttoptr i64 %env11921 to i64* 
  store volatile i64 %cont7210, i64* %vptr22874, align 8 ; closure/env cast; i64 -> i64*
  %vptr22875 = alloca i64*, align 8 
  %envptr22873 = getelementptr inbounds i64, i64* %envptr22872, i64 4 
  store volatile i64* %envptr22873, i64** %vptr22875, align 8 ; &envptr22872[3]
 %vptr22876 = alloca i64, align 8 
  %cont7210 = load i64, i64* %envptr22873, align 8 
  store volatile i64 %cont7210, i64* %vptr22876, align 8 ; load; *envptr22873
 %vptr22879 = alloca i64, align 8 
  %envptr22877 = inttoptr i64 %env11921 to i64* 
  store volatile i64 %a7045, i64* %vptr22879, align 8 ; closure/env cast; i64 -> i64*
  %vptr22880 = alloca i64*, align 8 
  %envptr22878 = getelementptr inbounds i64, i64* %envptr22877, i64 3 
  store volatile i64* %envptr22878, i64** %vptr22880, align 8 ; &envptr22877[2]
 %vptr22881 = alloca i64, align 8 
  %a7045 = load i64, i64* %envptr22878, align 8 
  store volatile i64 %a7045, i64* %vptr22881, align 8 ; load; *envptr22878
 %vptr22884 = alloca i64, align 8 
  %envptr22882 = inttoptr i64 %env11921 to i64* 
  store volatile i64 %emsg18637, i64* %vptr22884, align 8 ; closure/env cast; i64 -> i64*
  %vptr22885 = alloca i64*, align 8 
  %envptr22883 = getelementptr inbounds i64, i64* %envptr22882, i64 2 
  store volatile i64* %envptr22883, i64** %vptr22885, align 8 ; &envptr22882[1]
 %vptr22886 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr22883, align 8 
  store volatile i64 %emsg18637, i64* %vptr22886, align 8 ; load; *envptr22883
 %vptr22887 = alloca i64, align 8 
  %_957212 = call i64 @prim_car(i64 %rvp9894) 
  store volatile i64 %_957212, i64* %vptr22887, align 8 ; call prim_car
 %vptr22888 = alloca i64, align 8 
  %rvp9890 = call i64 @prim_cdr(i64 %rvp9894) 
  store volatile i64 %rvp9890, i64* %vptr22888, align 8 ; call prim_cdr
 %vptr22889 = alloca i64, align 8 
  %n_639895 = call i64 @prim_null_63(i64 %rvp9890) 
  store volatile i64 %n_639895, i64* %vptr22889, align 8 ; call prim_null_63
  %cmpptr22893 = alloca i1, align 8  %cmp22890 = icmp eq i64 %n_639895, 15 store volatile i1 %cmp22890, i1* %cmpptr22893, align 8; false?
  br i1 %cmp22890, label %else22892, label %then22891                                ; if

then22891:
 %vptr22894 = alloca i64, align 8 
  %h9896 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9896, i64* %vptr22894, align 8 ; call prim_halt
  %vptr22900 = alloca i64*, align 8 
  %cloptr22895 = inttoptr i64 %h9896 to i64* 
  store volatile i64* %cloptr22895, i64** %vptr22900, align 8 ; closure/env cast; i64 -> i64*
  %vptr22901 = alloca i64*, align 8 
  %i0ptr22896 = getelementptr inbounds i64, i64* %cloptr22895, i64 1 
  store volatile i64* %i0ptr22896, i64** %vptr22901, align 8 ; &cloptr22895[1]
 %vptr22902 = alloca i64, align 8 
  %f22898 = load i64, i64* %i0ptr22896, align 8 
  store volatile i64 %f22898, i64* %vptr22902, align 8 ; load; *i0ptr22896
  %fptr22897 = inttoptr i64 %f22898 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22897(i64 %h9896, i64 %h9896)                       ; tail call
  ret void

else22892:
 %vptr22903 = alloca i64, align 8 
  %a7047 = call i64 @prim_car(i64 %rvp9890) 
  store volatile i64 %a7047, i64* %vptr22903, align 8 ; call prim_car
 %vptr22904 = alloca i64, align 8 
  %na9873 = call i64 @prim_cdr(i64 %rvp9890) 
  store volatile i64 %na9873, i64* %vptr22904, align 8 ; call prim_cdr
 %vptr22905 = alloca i64, align 8 
  %n_639891 = call i64 @prim_null_63(i64 %na9873) 
  store volatile i64 %n_639891, i64* %vptr22905, align 8 ; call prim_null_63
  %cmpptr22909 = alloca i1, align 8  %cmp22906 = icmp eq i64 %n_639891, 15 store volatile i1 %cmp22906, i1* %cmpptr22909, align 8; false?
  br i1 %cmp22906, label %else22908, label %then22907                                ; if

then22907:
  %vptr22916 = alloca i64*, align 8 
  %cloptr22910 = call i64* @make_closure(i64 32) 
  store volatile i64* %cloptr22910, i64** %vptr22916, align 8 ; malloc
  %vptr22917 = alloca i64*, align 8 
  %eptr22912 = getelementptr inbounds i64, i64* %cloptr22910, i64 2 
  store volatile i64* %eptr22912, i64** %vptr22917, align 8 ; &eptr22912[1]
  %vptr22918 = alloca i64*, align 8 
  %eptr22913 = getelementptr inbounds i64, i64* %cloptr22910, i64 3 
  store volatile i64* %eptr22913, i64** %vptr22918, align 8 ; &eptr22913[2]
  %vptr22919 = alloca i64*, align 8 
  %eptr22914 = getelementptr inbounds i64, i64* %cloptr22910, i64 4 
  store volatile i64* %eptr22914, i64** %vptr22919, align 8 ; &eptr22914[3]
  store i64 %emsg18637, i64* %eptr22912                                              ; *eptr22912 = %emsg18637
  store i64 %cont7210, i64* %eptr22913                                               ; *eptr22913 = %cont7210
  store i64 %emsg08636, i64* %eptr22914                                              ; *eptr22914 = %emsg08636
  %vptr22920 = alloca i64*, align 8 
  %eptr22911 = getelementptr inbounds i64, i64* %cloptr22910, i64 1 
  store volatile i64* %eptr22911, i64** %vptr22920, align 8 ; &cloptr22910[1]
 %vptr22921 = alloca i64, align 8 
  %f22915 = ptrtoint void(i64,i64)* @lam11918 to i64 
  store volatile i64 %f22915, i64* %vptr22921, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f22915, i64* %eptr22911                                                 ; store fptr
 %vptr22922 = alloca i64, align 8 
  %arg8117 = ptrtoint i64* %cloptr22910 to i64 
  store volatile i64 %arg8117, i64* %vptr22922, align 8 ; closure cast; i64* -> i64
 %vptr22923 = alloca i64, align 8 
  %rva9889 = add i64 0, 0 
  store volatile i64 %rva9889, i64* %vptr22923, align 8 ; quoted ()
 %vptr22924 = alloca i64, align 8 
  %rva9888 = call i64 @prim_cons(i64 %a7047, i64 %rva9889) 
  store volatile i64 %rva9888, i64* %vptr22924, align 8 ; call prim_cons
 %vptr22925 = alloca i64, align 8 
  %rva9887 = call i64 @prim_cons(i64 %arg8117, i64 %rva9888) 
  store volatile i64 %rva9887, i64* %vptr22925, align 8 ; call prim_cons
  %vptr22931 = alloca i64*, align 8 
  %cloptr22926 = inttoptr i64 %a7045 to i64* 
  store volatile i64* %cloptr22926, i64** %vptr22931, align 8 ; closure/env cast; i64 -> i64*
  %vptr22932 = alloca i64*, align 8 
  %i0ptr22927 = getelementptr inbounds i64, i64* %cloptr22926, i64 1 
  store volatile i64* %i0ptr22927, i64** %vptr22932, align 8 ; &cloptr22926[1]
 %vptr22933 = alloca i64, align 8 
  %f22929 = load i64, i64* %i0ptr22927, align 8 
  store volatile i64 %f22929, i64* %vptr22933, align 8 ; load; *i0ptr22927
  %fptr22928 = inttoptr i64 %f22929 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22928(i64 %a7045, i64 %rva9887)                     ; tail call
  ret void

else22908:
 %vptr22934 = alloca i64, align 8 
  %h9892 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9892, i64* %vptr22934, align 8 ; call prim_halt
  %vptr22940 = alloca i64*, align 8 
  %cloptr22935 = inttoptr i64 %h9892 to i64* 
  store volatile i64* %cloptr22935, i64** %vptr22940, align 8 ; closure/env cast; i64 -> i64*
  %vptr22941 = alloca i64*, align 8 
  %i0ptr22936 = getelementptr inbounds i64, i64* %cloptr22935, i64 1 
  store volatile i64* %i0ptr22936, i64** %vptr22941, align 8 ; &cloptr22935[1]
 %vptr22942 = alloca i64, align 8 
  %f22938 = load i64, i64* %i0ptr22936, align 8 
  store volatile i64 %f22938, i64* %vptr22942, align 8 ; load; *i0ptr22936
  %fptr22937 = inttoptr i64 %f22938 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22937(i64 %h9892, i64 %h9892)                       ; tail call
  ret void
}


define void @lam11918(i64 %env11919, i64 %rvp9883) {
 %vptr22945 = alloca i64, align 8 
  %envptr22943 = inttoptr i64 %env11919 to i64* 
  store volatile i64 %emsg08636, i64* %vptr22945, align 8 ; closure/env cast; i64 -> i64*
  %vptr22946 = alloca i64*, align 8 
  %envptr22944 = getelementptr inbounds i64, i64* %envptr22943, i64 4 
  store volatile i64* %envptr22944, i64** %vptr22946, align 8 ; &envptr22943[3]
 %vptr22947 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr22944, align 8 
  store volatile i64 %emsg08636, i64* %vptr22947, align 8 ; load; *envptr22944
 %vptr22950 = alloca i64, align 8 
  %envptr22948 = inttoptr i64 %env11919 to i64* 
  store volatile i64 %cont7210, i64* %vptr22950, align 8 ; closure/env cast; i64 -> i64*
  %vptr22951 = alloca i64*, align 8 
  %envptr22949 = getelementptr inbounds i64, i64* %envptr22948, i64 3 
  store volatile i64* %envptr22949, i64** %vptr22951, align 8 ; &envptr22948[2]
 %vptr22952 = alloca i64, align 8 
  %cont7210 = load i64, i64* %envptr22949, align 8 
  store volatile i64 %cont7210, i64* %vptr22952, align 8 ; load; *envptr22949
 %vptr22955 = alloca i64, align 8 
  %envptr22953 = inttoptr i64 %env11919 to i64* 
  store volatile i64 %emsg18637, i64* %vptr22955, align 8 ; closure/env cast; i64 -> i64*
  %vptr22956 = alloca i64*, align 8 
  %envptr22954 = getelementptr inbounds i64, i64* %envptr22953, i64 2 
  store volatile i64* %envptr22954, i64** %vptr22956, align 8 ; &envptr22953[1]
 %vptr22957 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr22954, align 8 
  store volatile i64 %emsg18637, i64* %vptr22957, align 8 ; load; *envptr22954
 %vptr22958 = alloca i64, align 8 
  %_957213 = call i64 @prim_car(i64 %rvp9883) 
  store volatile i64 %_957213, i64* %vptr22958, align 8 ; call prim_car
 %vptr22959 = alloca i64, align 8 
  %rvp9879 = call i64 @prim_cdr(i64 %rvp9883) 
  store volatile i64 %rvp9879, i64* %vptr22959, align 8 ; call prim_cdr
 %vptr22960 = alloca i64, align 8 
  %n_639884 = call i64 @prim_null_63(i64 %rvp9879) 
  store volatile i64 %n_639884, i64* %vptr22960, align 8 ; call prim_null_63
  %cmpptr22964 = alloca i1, align 8  %cmp22961 = icmp eq i64 %n_639884, 15 store volatile i1 %cmp22961, i1* %cmpptr22964, align 8; false?
  br i1 %cmp22961, label %else22963, label %then22962                                ; if

then22962:
 %vptr22965 = alloca i64, align 8 
  %h9885 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9885, i64* %vptr22965, align 8 ; call prim_halt
  %vptr22971 = alloca i64*, align 8 
  %cloptr22966 = inttoptr i64 %h9885 to i64* 
  store volatile i64* %cloptr22966, i64** %vptr22971, align 8 ; closure/env cast; i64 -> i64*
  %vptr22972 = alloca i64*, align 8 
  %i0ptr22967 = getelementptr inbounds i64, i64* %cloptr22966, i64 1 
  store volatile i64* %i0ptr22967, i64** %vptr22972, align 8 ; &cloptr22966[1]
 %vptr22973 = alloca i64, align 8 
  %f22969 = load i64, i64* %i0ptr22967, align 8 
  store volatile i64 %f22969, i64* %vptr22973, align 8 ; load; *i0ptr22967
  %fptr22968 = inttoptr i64 %f22969 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22968(i64 %h9885, i64 %h9885)                       ; tail call
  ret void

else22963:
 %vptr22974 = alloca i64, align 8 
  %a7048 = call i64 @prim_car(i64 %rvp9879) 
  store volatile i64 %a7048, i64* %vptr22974, align 8 ; call prim_car
 %vptr22975 = alloca i64, align 8 
  %na9875 = call i64 @prim_cdr(i64 %rvp9879) 
  store volatile i64 %na9875, i64* %vptr22975, align 8 ; call prim_cdr
 %vptr22976 = alloca i64, align 8 
  %n_639880 = call i64 @prim_null_63(i64 %na9875) 
  store volatile i64 %n_639880, i64* %vptr22976, align 8 ; call prim_null_63
  %cmpptr22980 = alloca i1, align 8  %cmp22977 = icmp eq i64 %n_639880, 15 store volatile i1 %cmp22977, i1* %cmpptr22980, align 8; false?
  br i1 %cmp22977, label %else22979, label %then22978                                ; if

then22978:
 %vptr22981 = alloca i64, align 8 
  %arg8120 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg8120, i64* %vptr22981, align 8 ; quoted int
 %vptr22982 = alloca i64, align 8 
  %retprim7214 = call i64 @prim__43(i64 %arg8120, i64 %a7048) 
  store volatile i64 %retprim7214, i64* %vptr22982, align 8 ; call prim__43
 %vptr22983 = alloca i64, align 8 
  %arg8122 = add i64 0, 0 
  store volatile i64 %arg8122, i64* %vptr22983, align 8 ; quoted ()
 %vptr22984 = alloca i64, align 8 
  %rva9878 = add i64 0, 0 
  store volatile i64 %rva9878, i64* %vptr22984, align 8 ; quoted ()
 %vptr22985 = alloca i64, align 8 
  %rva9877 = call i64 @prim_cons(i64 %retprim7214, i64 %rva9878) 
  store volatile i64 %rva9877, i64* %vptr22985, align 8 ; call prim_cons
 %vptr22986 = alloca i64, align 8 
  %rva9876 = call i64 @prim_cons(i64 %arg8122, i64 %rva9877) 
  store volatile i64 %rva9876, i64* %vptr22986, align 8 ; call prim_cons
  %vptr22992 = alloca i64*, align 8 
  %cloptr22987 = inttoptr i64 %cont7210 to i64* 
  store volatile i64* %cloptr22987, i64** %vptr22992, align 8 ; closure/env cast; i64 -> i64*
  %vptr22993 = alloca i64*, align 8 
  %i0ptr22988 = getelementptr inbounds i64, i64* %cloptr22987, i64 1 
  store volatile i64* %i0ptr22988, i64** %vptr22993, align 8 ; &cloptr22987[1]
 %vptr22994 = alloca i64, align 8 
  %f22990 = load i64, i64* %i0ptr22988, align 8 
  store volatile i64 %f22990, i64* %vptr22994, align 8 ; load; *i0ptr22988
  %fptr22989 = inttoptr i64 %f22990 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22989(i64 %cont7210, i64 %rva9876)                  ; tail call
  ret void

else22979:
 %vptr22995 = alloca i64, align 8 
  %h9881 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9881, i64* %vptr22995, align 8 ; call prim_halt
  %vptr23001 = alloca i64*, align 8 
  %cloptr22996 = inttoptr i64 %h9881 to i64* 
  store volatile i64* %cloptr22996, i64** %vptr23001, align 8 ; closure/env cast; i64 -> i64*
  %vptr23002 = alloca i64*, align 8 
  %i0ptr22997 = getelementptr inbounds i64, i64* %cloptr22996, i64 1 
  store volatile i64* %i0ptr22997, i64** %vptr23002, align 8 ; &cloptr22996[1]
 %vptr23003 = alloca i64, align 8 
  %f22999 = load i64, i64* %i0ptr22997, align 8 
  store volatile i64 %f22999, i64* %vptr23003, align 8 ; load; *i0ptr22997
  %fptr22998 = inttoptr i64 %f22999 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr22998(i64 %h9881, i64 %h9881)                       ; tail call
  ret void
}


define void @lam11907(i64 %env11908, i64 %rvp9944) {
 %vptr23006 = alloca i64, align 8 
  %envptr23004 = inttoptr i64 %env11908 to i64* 
  store volatile i64 %emsg08636, i64* %vptr23006, align 8 ; closure/env cast; i64 -> i64*
  %vptr23007 = alloca i64*, align 8 
  %envptr23005 = getelementptr inbounds i64, i64* %envptr23004, i64 3 
  store volatile i64* %envptr23005, i64** %vptr23007, align 8 ; &envptr23004[2]
 %vptr23008 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr23005, align 8 
  store volatile i64 %emsg08636, i64* %vptr23008, align 8 ; load; *envptr23005
 %vptr23011 = alloca i64, align 8 
  %envptr23009 = inttoptr i64 %env11908 to i64* 
  store volatile i64 %emsg18637, i64* %vptr23011, align 8 ; closure/env cast; i64 -> i64*
  %vptr23012 = alloca i64*, align 8 
  %envptr23010 = getelementptr inbounds i64, i64* %envptr23009, i64 2 
  store volatile i64* %envptr23010, i64** %vptr23012, align 8 ; &envptr23009[1]
 %vptr23013 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr23010, align 8 
  store volatile i64 %emsg18637, i64* %vptr23013, align 8 ; load; *envptr23010
 %vptr23014 = alloca i64, align 8 
  %cont7215 = call i64 @prim_car(i64 %rvp9944) 
  store volatile i64 %cont7215, i64* %vptr23014, align 8 ; call prim_car
 %vptr23015 = alloca i64, align 8 
  %rvp9940 = call i64 @prim_cdr(i64 %rvp9944) 
  store volatile i64 %rvp9940, i64* %vptr23015, align 8 ; call prim_cdr
 %vptr23016 = alloca i64, align 8 
  %n_639945 = call i64 @prim_null_63(i64 %rvp9940) 
  store volatile i64 %n_639945, i64* %vptr23016, align 8 ; call prim_null_63
  %cmpptr23020 = alloca i1, align 8  %cmp23017 = icmp eq i64 %n_639945, 15 store volatile i1 %cmp23017, i1* %cmpptr23020, align 8; false?
  br i1 %cmp23017, label %else23019, label %then23018                                ; if

then23018:
 %vptr23021 = alloca i64, align 8 
  %h9946 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9946, i64* %vptr23021, align 8 ; call prim_halt
  %vptr23027 = alloca i64*, align 8 
  %cloptr23022 = inttoptr i64 %h9946 to i64* 
  store volatile i64* %cloptr23022, i64** %vptr23027, align 8 ; closure/env cast; i64 -> i64*
  %vptr23028 = alloca i64*, align 8 
  %i0ptr23023 = getelementptr inbounds i64, i64* %cloptr23022, i64 1 
  store volatile i64* %i0ptr23023, i64** %vptr23028, align 8 ; &cloptr23022[1]
 %vptr23029 = alloca i64, align 8 
  %f23025 = load i64, i64* %i0ptr23023, align 8 
  store volatile i64 %f23025, i64* %vptr23029, align 8 ; load; *i0ptr23023
  %fptr23024 = inttoptr i64 %f23025 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23024(i64 %h9946, i64 %h9946)                       ; tail call
  ret void

else23019:
 %vptr23030 = alloca i64, align 8 
  %bKk$n = call i64 @prim_car(i64 %rvp9940) 
  store volatile i64 %bKk$n, i64* %vptr23030, align 8 ; call prim_car
 %vptr23031 = alloca i64, align 8 
  %na9921 = call i64 @prim_cdr(i64 %rvp9940) 
  store volatile i64 %na9921, i64* %vptr23031, align 8 ; call prim_cdr
 %vptr23032 = alloca i64, align 8 
  %n_639941 = call i64 @prim_null_63(i64 %na9921) 
  store volatile i64 %n_639941, i64* %vptr23032, align 8 ; call prim_null_63
  %cmpptr23036 = alloca i1, align 8  %cmp23033 = icmp eq i64 %n_639941, 15 store volatile i1 %cmp23033, i1* %cmpptr23036, align 8; false?
  br i1 %cmp23033, label %else23035, label %then23034                                ; if

then23034:
  %vptr23040 = alloca i64*, align 8 
  %cloptr23037 = call i64* @make_closure(i64 8) 
  store volatile i64* %cloptr23037, i64** %vptr23040, align 8 ; malloc
  %vptr23041 = alloca i64*, align 8 
  %eptr23038 = getelementptr inbounds i64, i64* %cloptr23037, i64 1 
  store volatile i64* %eptr23038, i64** %vptr23041, align 8 ; &cloptr23037[1]
 %vptr23042 = alloca i64, align 8 
  %f23039 = ptrtoint void(i64,i64)* @lam11905 to i64 
  store volatile i64 %f23039, i64* %vptr23042, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f23039, i64* %eptr23038                                                 ; store fptr
 %vptr23043 = alloca i64, align 8 
  %arg8125 = ptrtoint i64* %cloptr23037 to i64 
  store volatile i64 %arg8125, i64* %vptr23043, align 8 ; closure cast; i64* -> i64
  %vptr23051 = alloca i64*, align 8 
  %cloptr23044 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr23044, i64** %vptr23051, align 8 ; malloc
  %vptr23052 = alloca i64*, align 8 
  %eptr23046 = getelementptr inbounds i64, i64* %cloptr23044, i64 2 
  store volatile i64* %eptr23046, i64** %vptr23052, align 8 ; &eptr23046[1]
  %vptr23053 = alloca i64*, align 8 
  %eptr23047 = getelementptr inbounds i64, i64* %cloptr23044, i64 3 
  store volatile i64* %eptr23047, i64** %vptr23053, align 8 ; &eptr23047[2]
  %vptr23054 = alloca i64*, align 8 
  %eptr23048 = getelementptr inbounds i64, i64* %cloptr23044, i64 4 
  store volatile i64* %eptr23048, i64** %vptr23054, align 8 ; &eptr23048[3]
  %vptr23055 = alloca i64*, align 8 
  %eptr23049 = getelementptr inbounds i64, i64* %cloptr23044, i64 5 
  store volatile i64* %eptr23049, i64** %vptr23055, align 8 ; &eptr23049[4]
  store i64 %emsg18637, i64* %eptr23046                                              ; *eptr23046 = %emsg18637
  store i64 %bKk$n, i64* %eptr23047                                                  ; *eptr23047 = %bKk$n
  store i64 %emsg08636, i64* %eptr23048                                              ; *eptr23048 = %emsg08636
  store i64 %cont7215, i64* %eptr23049                                               ; *eptr23049 = %cont7215
  %vptr23056 = alloca i64*, align 8 
  %eptr23045 = getelementptr inbounds i64, i64* %cloptr23044, i64 1 
  store volatile i64* %eptr23045, i64** %vptr23056, align 8 ; &cloptr23044[1]
 %vptr23057 = alloca i64, align 8 
  %f23050 = ptrtoint void(i64,i64)* @lam11901 to i64 
  store volatile i64 %f23050, i64* %vptr23057, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f23050, i64* %eptr23045                                                 ; store fptr
 %vptr23058 = alloca i64, align 8 
  %arg8124 = ptrtoint i64* %cloptr23044 to i64 
  store volatile i64 %arg8124, i64* %vptr23058, align 8 ; closure cast; i64* -> i64
 %vptr23059 = alloca i64, align 8 
  %rva9939 = add i64 0, 0 
  store volatile i64 %rva9939, i64* %vptr23059, align 8 ; quoted ()
 %vptr23060 = alloca i64, align 8 
  %rva9938 = call i64 @prim_cons(i64 %arg8124, i64 %rva9939) 
  store volatile i64 %rva9938, i64* %vptr23060, align 8 ; call prim_cons
  %vptr23066 = alloca i64*, align 8 
  %cloptr23061 = inttoptr i64 %arg8125 to i64* 
  store volatile i64* %cloptr23061, i64** %vptr23066, align 8 ; closure/env cast; i64 -> i64*
  %vptr23067 = alloca i64*, align 8 
  %i0ptr23062 = getelementptr inbounds i64, i64* %cloptr23061, i64 1 
  store volatile i64* %i0ptr23062, i64** %vptr23067, align 8 ; &cloptr23061[1]
 %vptr23068 = alloca i64, align 8 
  %f23064 = load i64, i64* %i0ptr23062, align 8 
  store volatile i64 %f23064, i64* %vptr23068, align 8 ; load; *i0ptr23062
  %fptr23063 = inttoptr i64 %f23064 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23063(i64 %arg8125, i64 %rva9938)                   ; tail call
  ret void

else23035:
 %vptr23069 = alloca i64, align 8 
  %h9942 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9942, i64* %vptr23069, align 8 ; call prim_halt
  %vptr23075 = alloca i64*, align 8 
  %cloptr23070 = inttoptr i64 %h9942 to i64* 
  store volatile i64* %cloptr23070, i64** %vptr23075, align 8 ; closure/env cast; i64 -> i64*
  %vptr23076 = alloca i64*, align 8 
  %i0ptr23071 = getelementptr inbounds i64, i64* %cloptr23070, i64 1 
  store volatile i64* %i0ptr23071, i64** %vptr23076, align 8 ; &cloptr23070[1]
 %vptr23077 = alloca i64, align 8 
  %f23073 = load i64, i64* %i0ptr23071, align 8 
  store volatile i64 %f23073, i64* %vptr23077, align 8 ; load; *i0ptr23071
  %fptr23072 = inttoptr i64 %f23073 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23072(i64 %h9942, i64 %h9942)                       ; tail call
  ret void
}


define void @lam11905(i64 %env11906, i64 %swq$lst7219) {
 %vptr23078 = alloca i64, align 8 
  %cont7218 = call i64 @prim_car(i64 %swq$lst7219) 
  store volatile i64 %cont7218, i64* %vptr23078, align 8 ; call prim_car
 %vptr23079 = alloca i64, align 8 
  %swq$lst = call i64 @prim_cdr(i64 %swq$lst7219) 
  store volatile i64 %swq$lst, i64* %vptr23079, align 8 ; call prim_cdr
 %vptr23080 = alloca i64, align 8 
  %arg8129 = add i64 0, 0 
  store volatile i64 %arg8129, i64* %vptr23080, align 8 ; quoted ()
 %vptr23081 = alloca i64, align 8 
  %rva9924 = add i64 0, 0 
  store volatile i64 %rva9924, i64* %vptr23081, align 8 ; quoted ()
 %vptr23082 = alloca i64, align 8 
  %rva9923 = call i64 @prim_cons(i64 %swq$lst, i64 %rva9924) 
  store volatile i64 %rva9923, i64* %vptr23082, align 8 ; call prim_cons
 %vptr23083 = alloca i64, align 8 
  %rva9922 = call i64 @prim_cons(i64 %arg8129, i64 %rva9923) 
  store volatile i64 %rva9922, i64* %vptr23083, align 8 ; call prim_cons
  %vptr23089 = alloca i64*, align 8 
  %cloptr23084 = inttoptr i64 %cont7218 to i64* 
  store volatile i64* %cloptr23084, i64** %vptr23089, align 8 ; closure/env cast; i64 -> i64*
  %vptr23090 = alloca i64*, align 8 
  %i0ptr23085 = getelementptr inbounds i64, i64* %cloptr23084, i64 1 
  store volatile i64* %i0ptr23085, i64** %vptr23090, align 8 ; &cloptr23084[1]
 %vptr23091 = alloca i64, align 8 
  %f23087 = load i64, i64* %i0ptr23085, align 8 
  store volatile i64 %f23087, i64* %vptr23091, align 8 ; load; *i0ptr23085
  %fptr23086 = inttoptr i64 %f23087 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23086(i64 %cont7218, i64 %rva9922)                  ; tail call
  ret void
}


define void @lam11901(i64 %env11902, i64 %rvp9934) {
 %vptr23094 = alloca i64, align 8 
  %envptr23092 = inttoptr i64 %env11902 to i64* 
  store volatile i64 %cont7215, i64* %vptr23094, align 8 ; closure/env cast; i64 -> i64*
  %vptr23095 = alloca i64*, align 8 
  %envptr23093 = getelementptr inbounds i64, i64* %envptr23092, i64 5 
  store volatile i64* %envptr23093, i64** %vptr23095, align 8 ; &envptr23092[4]
 %vptr23096 = alloca i64, align 8 
  %cont7215 = load i64, i64* %envptr23093, align 8 
  store volatile i64 %cont7215, i64* %vptr23096, align 8 ; load; *envptr23093
 %vptr23099 = alloca i64, align 8 
  %envptr23097 = inttoptr i64 %env11902 to i64* 
  store volatile i64 %emsg08636, i64* %vptr23099, align 8 ; closure/env cast; i64 -> i64*
  %vptr23100 = alloca i64*, align 8 
  %envptr23098 = getelementptr inbounds i64, i64* %envptr23097, i64 4 
  store volatile i64* %envptr23098, i64** %vptr23100, align 8 ; &envptr23097[3]
 %vptr23101 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr23098, align 8 
  store volatile i64 %emsg08636, i64* %vptr23101, align 8 ; load; *envptr23098
 %vptr23104 = alloca i64, align 8 
  %envptr23102 = inttoptr i64 %env11902 to i64* 
  store volatile i64 %bKk$n, i64* %vptr23104, align 8 ; closure/env cast; i64 -> i64*
  %vptr23105 = alloca i64*, align 8 
  %envptr23103 = getelementptr inbounds i64, i64* %envptr23102, i64 3 
  store volatile i64* %envptr23103, i64** %vptr23105, align 8 ; &envptr23102[2]
 %vptr23106 = alloca i64, align 8 
  %bKk$n = load i64, i64* %envptr23103, align 8 
  store volatile i64 %bKk$n, i64* %vptr23106, align 8 ; load; *envptr23103
 %vptr23109 = alloca i64, align 8 
  %envptr23107 = inttoptr i64 %env11902 to i64* 
  store volatile i64 %emsg18637, i64* %vptr23109, align 8 ; closure/env cast; i64 -> i64*
  %vptr23110 = alloca i64*, align 8 
  %envptr23108 = getelementptr inbounds i64, i64* %envptr23107, i64 2 
  store volatile i64* %envptr23108, i64** %vptr23110, align 8 ; &envptr23107[1]
 %vptr23111 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr23108, align 8 
  store volatile i64 %emsg18637, i64* %vptr23111, align 8 ; load; *envptr23108
 %vptr23112 = alloca i64, align 8 
  %_957216 = call i64 @prim_car(i64 %rvp9934) 
  store volatile i64 %_957216, i64* %vptr23112, align 8 ; call prim_car
 %vptr23113 = alloca i64, align 8 
  %rvp9930 = call i64 @prim_cdr(i64 %rvp9934) 
  store volatile i64 %rvp9930, i64* %vptr23113, align 8 ; call prim_cdr
 %vptr23114 = alloca i64, align 8 
  %n_639935 = call i64 @prim_null_63(i64 %rvp9930) 
  store volatile i64 %n_639935, i64* %vptr23114, align 8 ; call prim_null_63
  %cmpptr23118 = alloca i1, align 8  %cmp23115 = icmp eq i64 %n_639935, 15 store volatile i1 %cmp23115, i1* %cmpptr23118, align 8; false?
  br i1 %cmp23115, label %else23117, label %then23116                                ; if

then23116:
 %vptr23119 = alloca i64, align 8 
  %h9936 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9936, i64* %vptr23119, align 8 ; call prim_halt
  %vptr23125 = alloca i64*, align 8 
  %cloptr23120 = inttoptr i64 %h9936 to i64* 
  store volatile i64* %cloptr23120, i64** %vptr23125, align 8 ; closure/env cast; i64 -> i64*
  %vptr23126 = alloca i64*, align 8 
  %i0ptr23121 = getelementptr inbounds i64, i64* %cloptr23120, i64 1 
  store volatile i64* %i0ptr23121, i64** %vptr23126, align 8 ; &cloptr23120[1]
 %vptr23127 = alloca i64, align 8 
  %f23123 = load i64, i64* %i0ptr23121, align 8 
  store volatile i64 %f23123, i64* %vptr23127, align 8 ; load; *i0ptr23121
  %fptr23122 = inttoptr i64 %f23123 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23122(i64 %h9936, i64 %h9936)                       ; tail call
  ret void

else23117:
 %vptr23128 = alloca i64, align 8 
  %a7049 = call i64 @prim_car(i64 %rvp9930) 
  store volatile i64 %a7049, i64* %vptr23128, align 8 ; call prim_car
 %vptr23129 = alloca i64, align 8 
  %na9926 = call i64 @prim_cdr(i64 %rvp9930) 
  store volatile i64 %na9926, i64* %vptr23129, align 8 ; call prim_cdr
 %vptr23130 = alloca i64, align 8 
  %n_639931 = call i64 @prim_null_63(i64 %na9926) 
  store volatile i64 %n_639931, i64* %vptr23130, align 8 ; call prim_null_63
  %cmpptr23134 = alloca i1, align 8  %cmp23131 = icmp eq i64 %n_639931, 15 store volatile i1 %cmp23131, i1* %cmpptr23134, align 8; false?
  br i1 %cmp23131, label %else23133, label %then23132                                ; if

then23132:
 %vptr23135 = alloca i64, align 8 
  %retprim7217 = call i64 @prim_cons(i64 %bKk$n, i64 %a7049) 
  store volatile i64 %retprim7217, i64* %vptr23135, align 8 ; call prim_cons
 %vptr23136 = alloca i64, align 8 
  %arg8134 = add i64 0, 0 
  store volatile i64 %arg8134, i64* %vptr23136, align 8 ; quoted ()
 %vptr23137 = alloca i64, align 8 
  %rva9929 = add i64 0, 0 
  store volatile i64 %rva9929, i64* %vptr23137, align 8 ; quoted ()
 %vptr23138 = alloca i64, align 8 
  %rva9928 = call i64 @prim_cons(i64 %retprim7217, i64 %rva9929) 
  store volatile i64 %rva9928, i64* %vptr23138, align 8 ; call prim_cons
 %vptr23139 = alloca i64, align 8 
  %rva9927 = call i64 @prim_cons(i64 %arg8134, i64 %rva9928) 
  store volatile i64 %rva9927, i64* %vptr23139, align 8 ; call prim_cons
  %vptr23145 = alloca i64*, align 8 
  %cloptr23140 = inttoptr i64 %cont7215 to i64* 
  store volatile i64* %cloptr23140, i64** %vptr23145, align 8 ; closure/env cast; i64 -> i64*
  %vptr23146 = alloca i64*, align 8 
  %i0ptr23141 = getelementptr inbounds i64, i64* %cloptr23140, i64 1 
  store volatile i64* %i0ptr23141, i64** %vptr23146, align 8 ; &cloptr23140[1]
 %vptr23147 = alloca i64, align 8 
  %f23143 = load i64, i64* %i0ptr23141, align 8 
  store volatile i64 %f23143, i64* %vptr23147, align 8 ; load; *i0ptr23141
  %fptr23142 = inttoptr i64 %f23143 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23142(i64 %cont7215, i64 %rva9927)                  ; tail call
  ret void

else23133:
 %vptr23148 = alloca i64, align 8 
  %h9932 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9932, i64* %vptr23148, align 8 ; call prim_halt
  %vptr23154 = alloca i64*, align 8 
  %cloptr23149 = inttoptr i64 %h9932 to i64* 
  store volatile i64* %cloptr23149, i64** %vptr23154, align 8 ; closure/env cast; i64 -> i64*
  %vptr23155 = alloca i64*, align 8 
  %i0ptr23150 = getelementptr inbounds i64, i64* %cloptr23149, i64 1 
  store volatile i64* %i0ptr23150, i64** %vptr23155, align 8 ; &cloptr23149[1]
 %vptr23156 = alloca i64, align 8 
  %f23152 = load i64, i64* %i0ptr23150, align 8 
  store volatile i64 %f23152, i64* %vptr23156, align 8 ; load; *i0ptr23150
  %fptr23151 = inttoptr i64 %f23152 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23151(i64 %h9932, i64 %h9932)                       ; tail call
  ret void
}


define void @lam11896(i64 %env11897, i64 %BAg$args7221) {
 %vptr23157 = alloca i64, align 8 
  %cont7220 = call i64 @prim_car(i64 %BAg$args7221) 
  store volatile i64 %cont7220, i64* %vptr23157, align 8 ; call prim_car
 %vptr23158 = alloca i64, align 8 
  %BAg$args = call i64 @prim_cdr(i64 %BAg$args7221) 
  store volatile i64 %BAg$args, i64* %vptr23158, align 8 ; call prim_cdr
 %vptr23159 = alloca i64, align 8 
  %retprim7222 = call i64 @applyprim_car(i64 %BAg$args) 
  store volatile i64 %retprim7222, i64* %vptr23159, align 8 ; call applyprim_car
 %vptr23160 = alloca i64, align 8 
  %arg8140 = add i64 0, 0 
  store volatile i64 %arg8140, i64* %vptr23160, align 8 ; quoted ()
 %vptr23161 = alloca i64, align 8 
  %rva9950 = add i64 0, 0 
  store volatile i64 %rva9950, i64* %vptr23161, align 8 ; quoted ()
 %vptr23162 = alloca i64, align 8 
  %rva9949 = call i64 @prim_cons(i64 %retprim7222, i64 %rva9950) 
  store volatile i64 %rva9949, i64* %vptr23162, align 8 ; call prim_cons
 %vptr23163 = alloca i64, align 8 
  %rva9948 = call i64 @prim_cons(i64 %arg8140, i64 %rva9949) 
  store volatile i64 %rva9948, i64* %vptr23163, align 8 ; call prim_cons
  %vptr23169 = alloca i64*, align 8 
  %cloptr23164 = inttoptr i64 %cont7220 to i64* 
  store volatile i64* %cloptr23164, i64** %vptr23169, align 8 ; closure/env cast; i64 -> i64*
  %vptr23170 = alloca i64*, align 8 
  %i0ptr23165 = getelementptr inbounds i64, i64* %cloptr23164, i64 1 
  store volatile i64* %i0ptr23165, i64** %vptr23170, align 8 ; &cloptr23164[1]
 %vptr23171 = alloca i64, align 8 
  %f23167 = load i64, i64* %i0ptr23165, align 8 
  store volatile i64 %f23167, i64* %vptr23171, align 8 ; load; *i0ptr23165
  %fptr23166 = inttoptr i64 %f23167 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23166(i64 %cont7220, i64 %rva9948)                  ; tail call
  ret void
}


define void @lam11892(i64 %env11893, i64 %rvp9960) {
 %vptr23174 = alloca i64, align 8 
  %envptr23172 = inttoptr i64 %env11893 to i64* 
  store volatile i64 %emsg08636, i64* %vptr23174, align 8 ; closure/env cast; i64 -> i64*
  %vptr23175 = alloca i64*, align 8 
  %envptr23173 = getelementptr inbounds i64, i64* %envptr23172, i64 3 
  store volatile i64* %envptr23173, i64** %vptr23175, align 8 ; &envptr23172[2]
 %vptr23176 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr23173, align 8 
  store volatile i64 %emsg08636, i64* %vptr23176, align 8 ; load; *envptr23173
 %vptr23179 = alloca i64, align 8 
  %envptr23177 = inttoptr i64 %env11893 to i64* 
  store volatile i64 %emsg18637, i64* %vptr23179, align 8 ; closure/env cast; i64 -> i64*
  %vptr23180 = alloca i64*, align 8 
  %envptr23178 = getelementptr inbounds i64, i64* %envptr23177, i64 2 
  store volatile i64* %envptr23178, i64** %vptr23180, align 8 ; &envptr23177[1]
 %vptr23181 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr23178, align 8 
  store volatile i64 %emsg18637, i64* %vptr23181, align 8 ; load; *envptr23178
 %vptr23182 = alloca i64, align 8 
  %cont7223 = call i64 @prim_car(i64 %rvp9960) 
  store volatile i64 %cont7223, i64* %vptr23182, align 8 ; call prim_car
 %vptr23183 = alloca i64, align 8 
  %rvp9956 = call i64 @prim_cdr(i64 %rvp9960) 
  store volatile i64 %rvp9956, i64* %vptr23183, align 8 ; call prim_cdr
 %vptr23184 = alloca i64, align 8 
  %n_639961 = call i64 @prim_null_63(i64 %rvp9956) 
  store volatile i64 %n_639961, i64* %vptr23184, align 8 ; call prim_null_63
  %cmpptr23188 = alloca i1, align 8  %cmp23185 = icmp eq i64 %n_639961, 15 store volatile i1 %cmp23185, i1* %cmpptr23188, align 8; false?
  br i1 %cmp23185, label %else23187, label %then23186                                ; if

then23186:
 %vptr23189 = alloca i64, align 8 
  %h9962 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9962, i64* %vptr23189, align 8 ; call prim_halt
  %vptr23195 = alloca i64*, align 8 
  %cloptr23190 = inttoptr i64 %h9962 to i64* 
  store volatile i64* %cloptr23190, i64** %vptr23195, align 8 ; closure/env cast; i64 -> i64*
  %vptr23196 = alloca i64*, align 8 
  %i0ptr23191 = getelementptr inbounds i64, i64* %cloptr23190, i64 1 
  store volatile i64* %i0ptr23191, i64** %vptr23196, align 8 ; &cloptr23190[1]
 %vptr23197 = alloca i64, align 8 
  %f23193 = load i64, i64* %i0ptr23191, align 8 
  store volatile i64 %f23193, i64* %vptr23197, align 8 ; load; *i0ptr23191
  %fptr23192 = inttoptr i64 %f23193 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23192(i64 %h9962, i64 %h9962)                       ; tail call
  ret void

else23187:
 %vptr23198 = alloca i64, align 8 
  %eh3$n = call i64 @prim_car(i64 %rvp9956) 
  store volatile i64 %eh3$n, i64* %vptr23198, align 8 ; call prim_car
 %vptr23199 = alloca i64, align 8 
  %na9952 = call i64 @prim_cdr(i64 %rvp9956) 
  store volatile i64 %na9952, i64* %vptr23199, align 8 ; call prim_cdr
 %vptr23200 = alloca i64, align 8 
  %n_639957 = call i64 @prim_null_63(i64 %na9952) 
  store volatile i64 %n_639957, i64* %vptr23200, align 8 ; call prim_null_63
  %cmpptr23204 = alloca i1, align 8  %cmp23201 = icmp eq i64 %n_639957, 15 store volatile i1 %cmp23201, i1* %cmpptr23204, align 8; false?
  br i1 %cmp23201, label %else23203, label %then23202                                ; if

then23202:
 %vptr23205 = alloca i64, align 8 
  %retprim7224 = call i64 @prim_null_63(i64 %eh3$n) 
  store volatile i64 %retprim7224, i64* %vptr23205, align 8 ; call prim_null_63
 %vptr23206 = alloca i64, align 8 
  %arg8144 = add i64 0, 0 
  store volatile i64 %arg8144, i64* %vptr23206, align 8 ; quoted ()
 %vptr23207 = alloca i64, align 8 
  %rva9955 = add i64 0, 0 
  store volatile i64 %rva9955, i64* %vptr23207, align 8 ; quoted ()
 %vptr23208 = alloca i64, align 8 
  %rva9954 = call i64 @prim_cons(i64 %retprim7224, i64 %rva9955) 
  store volatile i64 %rva9954, i64* %vptr23208, align 8 ; call prim_cons
 %vptr23209 = alloca i64, align 8 
  %rva9953 = call i64 @prim_cons(i64 %arg8144, i64 %rva9954) 
  store volatile i64 %rva9953, i64* %vptr23209, align 8 ; call prim_cons
  %vptr23215 = alloca i64*, align 8 
  %cloptr23210 = inttoptr i64 %cont7223 to i64* 
  store volatile i64* %cloptr23210, i64** %vptr23215, align 8 ; closure/env cast; i64 -> i64*
  %vptr23216 = alloca i64*, align 8 
  %i0ptr23211 = getelementptr inbounds i64, i64* %cloptr23210, i64 1 
  store volatile i64* %i0ptr23211, i64** %vptr23216, align 8 ; &cloptr23210[1]
 %vptr23217 = alloca i64, align 8 
  %f23213 = load i64, i64* %i0ptr23211, align 8 
  store volatile i64 %f23213, i64* %vptr23217, align 8 ; load; *i0ptr23211
  %fptr23212 = inttoptr i64 %f23213 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23212(i64 %cont7223, i64 %rva9953)                  ; tail call
  ret void

else23203:
 %vptr23218 = alloca i64, align 8 
  %h9958 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9958, i64* %vptr23218, align 8 ; call prim_halt
  %vptr23224 = alloca i64*, align 8 
  %cloptr23219 = inttoptr i64 %h9958 to i64* 
  store volatile i64* %cloptr23219, i64** %vptr23224, align 8 ; closure/env cast; i64 -> i64*
  %vptr23225 = alloca i64*, align 8 
  %i0ptr23220 = getelementptr inbounds i64, i64* %cloptr23219, i64 1 
  store volatile i64* %i0ptr23220, i64** %vptr23225, align 8 ; &cloptr23219[1]
 %vptr23226 = alloca i64, align 8 
  %f23222 = load i64, i64* %i0ptr23220, align 8 
  store volatile i64 %f23222, i64* %vptr23226, align 8 ; load; *i0ptr23220
  %fptr23221 = inttoptr i64 %f23222 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23221(i64 %h9958, i64 %h9958)                       ; tail call
  ret void
}


define void @lam11888(i64 %env11889, i64 %rvp10025) {
 %vptr23229 = alloca i64, align 8 
  %envptr23227 = inttoptr i64 %env11889 to i64* 
  store volatile i64 %bbE$z_63, i64* %vptr23229, align 8 ; closure/env cast; i64 -> i64*
  %vptr23230 = alloca i64*, align 8 
  %envptr23228 = getelementptr inbounds i64, i64* %envptr23227, i64 7 
  store volatile i64* %envptr23228, i64** %vptr23230, align 8 ; &envptr23227[6]
 %vptr23231 = alloca i64, align 8 
  %bbE$z_63 = load i64, i64* %envptr23228, align 8 
  store volatile i64 %bbE$z_63, i64* %vptr23231, align 8 ; load; *envptr23228
 %vptr23234 = alloca i64, align 8 
  %envptr23232 = inttoptr i64 %env11889 to i64* 
  store volatile i64 %emsg08636, i64* %vptr23234, align 8 ; closure/env cast; i64 -> i64*
  %vptr23235 = alloca i64*, align 8 
  %envptr23233 = getelementptr inbounds i64, i64* %envptr23232, i64 6 
  store volatile i64* %envptr23233, i64** %vptr23235, align 8 ; &envptr23232[5]
 %vptr23236 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr23233, align 8 
  store volatile i64 %emsg08636, i64* %vptr23236, align 8 ; load; *envptr23233
 %vptr23239 = alloca i64, align 8 
  %envptr23237 = inttoptr i64 %env11889 to i64* 
  store volatile i64 %gYG$succ, i64* %vptr23239, align 8 ; closure/env cast; i64 -> i64*
  %vptr23240 = alloca i64*, align 8 
  %envptr23238 = getelementptr inbounds i64, i64* %envptr23237, i64 5 
  store volatile i64* %envptr23238, i64** %vptr23240, align 8 ; &envptr23237[4]
 %vptr23241 = alloca i64, align 8 
  %gYG$succ = load i64, i64* %envptr23238, align 8 
  store volatile i64 %gYG$succ, i64* %vptr23241, align 8 ; load; *envptr23238
 %vptr23244 = alloca i64, align 8 
  %envptr23242 = inttoptr i64 %env11889 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr23244, align 8 ; closure/env cast; i64 -> i64*
  %vptr23245 = alloca i64*, align 8 
  %envptr23243 = getelementptr inbounds i64, i64* %envptr23242, i64 4 
  store volatile i64* %envptr23243, i64** %vptr23245, align 8 ; &envptr23242[3]
 %vptr23246 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr23243, align 8 
  store volatile i64 %Pll$pred, i64* %vptr23246, align 8 ; load; *envptr23243
 %vptr23249 = alloca i64, align 8 
  %envptr23247 = inttoptr i64 %env11889 to i64* 
  store volatile i64 %Ttp$addc, i64* %vptr23249, align 8 ; closure/env cast; i64 -> i64*
  %vptr23250 = alloca i64*, align 8 
  %envptr23248 = getelementptr inbounds i64, i64* %envptr23247, i64 3 
  store volatile i64* %envptr23248, i64** %vptr23250, align 8 ; &envptr23247[2]
 %vptr23251 = alloca i64, align 8 
  %Ttp$addc = load i64, i64* %envptr23248, align 8 
  store volatile i64 %Ttp$addc, i64* %vptr23251, align 8 ; load; *envptr23248
 %vptr23254 = alloca i64, align 8 
  %envptr23252 = inttoptr i64 %env11889 to i64* 
  store volatile i64 %emsg18637, i64* %vptr23254, align 8 ; closure/env cast; i64 -> i64*
  %vptr23255 = alloca i64*, align 8 
  %envptr23253 = getelementptr inbounds i64, i64* %envptr23252, i64 2 
  store volatile i64* %envptr23253, i64** %vptr23255, align 8 ; &envptr23252[1]
 %vptr23256 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr23253, align 8 
  store volatile i64 %emsg18637, i64* %vptr23256, align 8 ; load; *envptr23253
 %vptr23257 = alloca i64, align 8 
  %cont7225 = call i64 @prim_car(i64 %rvp10025) 
  store volatile i64 %cont7225, i64* %vptr23257, align 8 ; call prim_car
 %vptr23258 = alloca i64, align 8 
  %rvp10021 = call i64 @prim_cdr(i64 %rvp10025) 
  store volatile i64 %rvp10021, i64* %vptr23258, align 8 ; call prim_cdr
 %vptr23259 = alloca i64, align 8 
  %n_6310026 = call i64 @prim_null_63(i64 %rvp10021) 
  store volatile i64 %n_6310026, i64* %vptr23259, align 8 ; call prim_null_63
  %cmpptr23263 = alloca i1, align 8  %cmp23260 = icmp eq i64 %n_6310026, 15 store volatile i1 %cmp23260, i1* %cmpptr23263, align 8; false?
  br i1 %cmp23260, label %else23262, label %then23261                                ; if

then23261:
 %vptr23264 = alloca i64, align 8 
  %h10027 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10027, i64* %vptr23264, align 8 ; call prim_halt
  %vptr23270 = alloca i64*, align 8 
  %cloptr23265 = inttoptr i64 %h10027 to i64* 
  store volatile i64* %cloptr23265, i64** %vptr23270, align 8 ; closure/env cast; i64 -> i64*
  %vptr23271 = alloca i64*, align 8 
  %i0ptr23266 = getelementptr inbounds i64, i64* %cloptr23265, i64 1 
  store volatile i64* %i0ptr23266, i64** %vptr23271, align 8 ; &cloptr23265[1]
 %vptr23272 = alloca i64, align 8 
  %f23268 = load i64, i64* %i0ptr23266, align 8 
  store volatile i64 %f23268, i64* %vptr23272, align 8 ; load; *i0ptr23266
  %fptr23267 = inttoptr i64 %f23268 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23267(i64 %h10027, i64 %h10027)                     ; tail call
  ret void

else23262:
 %vptr23273 = alloca i64, align 8 
  %MtO$x = call i64 @prim_car(i64 %rvp10021) 
  store volatile i64 %MtO$x, i64* %vptr23273, align 8 ; call prim_car
 %vptr23274 = alloca i64, align 8 
  %rvp10017 = call i64 @prim_cdr(i64 %rvp10021) 
  store volatile i64 %rvp10017, i64* %vptr23274, align 8 ; call prim_cdr
 %vptr23275 = alloca i64, align 8 
  %n_6310022 = call i64 @prim_null_63(i64 %rvp10017) 
  store volatile i64 %n_6310022, i64* %vptr23275, align 8 ; call prim_null_63
  %cmpptr23279 = alloca i1, align 8  %cmp23276 = icmp eq i64 %n_6310022, 15 store volatile i1 %cmp23276, i1* %cmpptr23279, align 8; false?
  br i1 %cmp23276, label %else23278, label %then23277                                ; if

then23277:
 %vptr23280 = alloca i64, align 8 
  %h10023 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10023, i64* %vptr23280, align 8 ; call prim_halt
  %vptr23286 = alloca i64*, align 8 
  %cloptr23281 = inttoptr i64 %h10023 to i64* 
  store volatile i64* %cloptr23281, i64** %vptr23286, align 8 ; closure/env cast; i64 -> i64*
  %vptr23287 = alloca i64*, align 8 
  %i0ptr23282 = getelementptr inbounds i64, i64* %cloptr23281, i64 1 
  store volatile i64* %i0ptr23282, i64** %vptr23287, align 8 ; &cloptr23281[1]
 %vptr23288 = alloca i64, align 8 
  %f23284 = load i64, i64* %i0ptr23282, align 8 
  store volatile i64 %f23284, i64* %vptr23288, align 8 ; load; *i0ptr23282
  %fptr23283 = inttoptr i64 %f23284 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23283(i64 %h10023, i64 %h10023)                     ; tail call
  ret void

else23278:
 %vptr23289 = alloca i64, align 8 
  %G5a$y = call i64 @prim_car(i64 %rvp10017) 
  store volatile i64 %G5a$y, i64* %vptr23289, align 8 ; call prim_car
 %vptr23290 = alloca i64, align 8 
  %rvp10013 = call i64 @prim_cdr(i64 %rvp10017) 
  store volatile i64 %rvp10013, i64* %vptr23290, align 8 ; call prim_cdr
 %vptr23291 = alloca i64, align 8 
  %n_6310018 = call i64 @prim_null_63(i64 %rvp10013) 
  store volatile i64 %n_6310018, i64* %vptr23291, align 8 ; call prim_null_63
  %cmpptr23295 = alloca i1, align 8  %cmp23292 = icmp eq i64 %n_6310018, 15 store volatile i1 %cmp23292, i1* %cmpptr23295, align 8; false?
  br i1 %cmp23292, label %else23294, label %then23293                                ; if

then23293:
 %vptr23296 = alloca i64, align 8 
  %h10019 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10019, i64* %vptr23296, align 8 ; call prim_halt
  %vptr23302 = alloca i64*, align 8 
  %cloptr23297 = inttoptr i64 %h10019 to i64* 
  store volatile i64* %cloptr23297, i64** %vptr23302, align 8 ; closure/env cast; i64 -> i64*
  %vptr23303 = alloca i64*, align 8 
  %i0ptr23298 = getelementptr inbounds i64, i64* %cloptr23297, i64 1 
  store volatile i64* %i0ptr23298, i64** %vptr23303, align 8 ; &cloptr23297[1]
 %vptr23304 = alloca i64, align 8 
  %f23300 = load i64, i64* %i0ptr23298, align 8 
  store volatile i64 %f23300, i64* %vptr23304, align 8 ; load; *i0ptr23298
  %fptr23299 = inttoptr i64 %f23300 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23299(i64 %h10019, i64 %h10019)                     ; tail call
  ret void

else23294:
 %vptr23305 = alloca i64, align 8 
  %Zht$k = call i64 @prim_car(i64 %rvp10013) 
  store volatile i64 %Zht$k, i64* %vptr23305, align 8 ; call prim_car
 %vptr23306 = alloca i64, align 8 
  %na9965 = call i64 @prim_cdr(i64 %rvp10013) 
  store volatile i64 %na9965, i64* %vptr23306, align 8 ; call prim_cdr
 %vptr23307 = alloca i64, align 8 
  %n_6310014 = call i64 @prim_null_63(i64 %na9965) 
  store volatile i64 %n_6310014, i64* %vptr23307, align 8 ; call prim_null_63
  %cmpptr23311 = alloca i1, align 8  %cmp23308 = icmp eq i64 %n_6310014, 15 store volatile i1 %cmp23308, i1* %cmpptr23311, align 8; false?
  br i1 %cmp23308, label %else23310, label %then23309                                ; if

then23309:
 %vptr23312 = alloca i64, align 8 
  %arg8146 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8146, i64* %vptr23312, align 8 ; quoted int
 %vptr23313 = alloca i64, align 8 
  %a7050 = call i64 @prim_vector_45ref(i64 %bbE$z_63, i64 %arg8146) 
  store volatile i64 %a7050, i64* %vptr23313, align 8 ; call prim_vector_45ref
  %vptr23326 = alloca i64*, align 8 
  %cloptr23314 = call i64* @make_closure(i64 80) 
  store volatile i64* %cloptr23314, i64** %vptr23326, align 8 ; malloc
  %vptr23327 = alloca i64*, align 8 
  %eptr23316 = getelementptr inbounds i64, i64* %cloptr23314, i64 2 
  store volatile i64* %eptr23316, i64** %vptr23327, align 8 ; &eptr23316[1]
  %vptr23328 = alloca i64*, align 8 
  %eptr23317 = getelementptr inbounds i64, i64* %cloptr23314, i64 3 
  store volatile i64* %eptr23317, i64** %vptr23328, align 8 ; &eptr23317[2]
  %vptr23329 = alloca i64*, align 8 
  %eptr23318 = getelementptr inbounds i64, i64* %cloptr23314, i64 4 
  store volatile i64* %eptr23318, i64** %vptr23329, align 8 ; &eptr23318[3]
  %vptr23330 = alloca i64*, align 8 
  %eptr23319 = getelementptr inbounds i64, i64* %cloptr23314, i64 5 
  store volatile i64* %eptr23319, i64** %vptr23330, align 8 ; &eptr23319[4]
  %vptr23331 = alloca i64*, align 8 
  %eptr23320 = getelementptr inbounds i64, i64* %cloptr23314, i64 6 
  store volatile i64* %eptr23320, i64** %vptr23331, align 8 ; &eptr23320[5]
  %vptr23332 = alloca i64*, align 8 
  %eptr23321 = getelementptr inbounds i64, i64* %cloptr23314, i64 7 
  store volatile i64* %eptr23321, i64** %vptr23332, align 8 ; &eptr23321[6]
  %vptr23333 = alloca i64*, align 8 
  %eptr23322 = getelementptr inbounds i64, i64* %cloptr23314, i64 8 
  store volatile i64* %eptr23322, i64** %vptr23333, align 8 ; &eptr23322[7]
  %vptr23334 = alloca i64*, align 8 
  %eptr23323 = getelementptr inbounds i64, i64* %cloptr23314, i64 9 
  store volatile i64* %eptr23323, i64** %vptr23334, align 8 ; &eptr23323[8]
  %vptr23335 = alloca i64*, align 8 
  %eptr23324 = getelementptr inbounds i64, i64* %cloptr23314, i64 10 
  store volatile i64* %eptr23324, i64** %vptr23335, align 8 ; &eptr23324[9]
  store i64 %emsg18637, i64* %eptr23316                                              ; *eptr23316 = %emsg18637
  store i64 %cont7225, i64* %eptr23317                                               ; *eptr23317 = %cont7225
  store i64 %Ttp$addc, i64* %eptr23318                                               ; *eptr23318 = %Ttp$addc
  store i64 %Pll$pred, i64* %eptr23319                                               ; *eptr23319 = %Pll$pred
  store i64 %G5a$y, i64* %eptr23320                                                  ; *eptr23320 = %G5a$y
  store i64 %gYG$succ, i64* %eptr23321                                               ; *eptr23321 = %gYG$succ
  store i64 %MtO$x, i64* %eptr23322                                                  ; *eptr23322 = %MtO$x
  store i64 %Zht$k, i64* %eptr23323                                                  ; *eptr23323 = %Zht$k
  store i64 %emsg08636, i64* %eptr23324                                              ; *eptr23324 = %emsg08636
  %vptr23336 = alloca i64*, align 8 
  %eptr23315 = getelementptr inbounds i64, i64* %cloptr23314, i64 1 
  store volatile i64* %eptr23315, i64** %vptr23336, align 8 ; &cloptr23314[1]
 %vptr23337 = alloca i64, align 8 
  %f23325 = ptrtoint void(i64,i64)* @lam11885 to i64 
  store volatile i64 %f23325, i64* %vptr23337, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f23325, i64* %eptr23315                                                 ; store fptr
 %vptr23338 = alloca i64, align 8 
  %arg8149 = ptrtoint i64* %cloptr23314 to i64 
  store volatile i64 %arg8149, i64* %vptr23338, align 8 ; closure cast; i64* -> i64
 %vptr23339 = alloca i64, align 8 
  %rva10012 = add i64 0, 0 
  store volatile i64 %rva10012, i64* %vptr23339, align 8 ; quoted ()
 %vptr23340 = alloca i64, align 8 
  %rva10011 = call i64 @prim_cons(i64 %G5a$y, i64 %rva10012) 
  store volatile i64 %rva10011, i64* %vptr23340, align 8 ; call prim_cons
 %vptr23341 = alloca i64, align 8 
  %rva10010 = call i64 @prim_cons(i64 %arg8149, i64 %rva10011) 
  store volatile i64 %rva10010, i64* %vptr23341, align 8 ; call prim_cons
  %vptr23347 = alloca i64*, align 8 
  %cloptr23342 = inttoptr i64 %a7050 to i64* 
  store volatile i64* %cloptr23342, i64** %vptr23347, align 8 ; closure/env cast; i64 -> i64*
  %vptr23348 = alloca i64*, align 8 
  %i0ptr23343 = getelementptr inbounds i64, i64* %cloptr23342, i64 1 
  store volatile i64* %i0ptr23343, i64** %vptr23348, align 8 ; &cloptr23342[1]
 %vptr23349 = alloca i64, align 8 
  %f23345 = load i64, i64* %i0ptr23343, align 8 
  store volatile i64 %f23345, i64* %vptr23349, align 8 ; load; *i0ptr23343
  %fptr23344 = inttoptr i64 %f23345 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23344(i64 %a7050, i64 %rva10010)                    ; tail call
  ret void

else23310:
 %vptr23350 = alloca i64, align 8 
  %h10015 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10015, i64* %vptr23350, align 8 ; call prim_halt
  %vptr23356 = alloca i64*, align 8 
  %cloptr23351 = inttoptr i64 %h10015 to i64* 
  store volatile i64* %cloptr23351, i64** %vptr23356, align 8 ; closure/env cast; i64 -> i64*
  %vptr23357 = alloca i64*, align 8 
  %i0ptr23352 = getelementptr inbounds i64, i64* %cloptr23351, i64 1 
  store volatile i64* %i0ptr23352, i64** %vptr23357, align 8 ; &cloptr23351[1]
 %vptr23358 = alloca i64, align 8 
  %f23354 = load i64, i64* %i0ptr23352, align 8 
  store volatile i64 %f23354, i64* %vptr23358, align 8 ; load; *i0ptr23352
  %fptr23353 = inttoptr i64 %f23354 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23353(i64 %h10015, i64 %h10015)                     ; tail call
  ret void
}


define void @lam11885(i64 %env11886, i64 %rvp10006) {
 %vptr23361 = alloca i64, align 8 
  %envptr23359 = inttoptr i64 %env11886 to i64* 
  store volatile i64 %emsg08636, i64* %vptr23361, align 8 ; closure/env cast; i64 -> i64*
  %vptr23362 = alloca i64*, align 8 
  %envptr23360 = getelementptr inbounds i64, i64* %envptr23359, i64 10 
  store volatile i64* %envptr23360, i64** %vptr23362, align 8 ; &envptr23359[9]
 %vptr23363 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr23360, align 8 
  store volatile i64 %emsg08636, i64* %vptr23363, align 8 ; load; *envptr23360
 %vptr23366 = alloca i64, align 8 
  %envptr23364 = inttoptr i64 %env11886 to i64* 
  store volatile i64 %Zht$k, i64* %vptr23366, align 8 ; closure/env cast; i64 -> i64*
  %vptr23367 = alloca i64*, align 8 
  %envptr23365 = getelementptr inbounds i64, i64* %envptr23364, i64 9 
  store volatile i64* %envptr23365, i64** %vptr23367, align 8 ; &envptr23364[8]
 %vptr23368 = alloca i64, align 8 
  %Zht$k = load i64, i64* %envptr23365, align 8 
  store volatile i64 %Zht$k, i64* %vptr23368, align 8 ; load; *envptr23365
 %vptr23371 = alloca i64, align 8 
  %envptr23369 = inttoptr i64 %env11886 to i64* 
  store volatile i64 %MtO$x, i64* %vptr23371, align 8 ; closure/env cast; i64 -> i64*
  %vptr23372 = alloca i64*, align 8 
  %envptr23370 = getelementptr inbounds i64, i64* %envptr23369, i64 8 
  store volatile i64* %envptr23370, i64** %vptr23372, align 8 ; &envptr23369[7]
 %vptr23373 = alloca i64, align 8 
  %MtO$x = load i64, i64* %envptr23370, align 8 
  store volatile i64 %MtO$x, i64* %vptr23373, align 8 ; load; *envptr23370
 %vptr23376 = alloca i64, align 8 
  %envptr23374 = inttoptr i64 %env11886 to i64* 
  store volatile i64 %gYG$succ, i64* %vptr23376, align 8 ; closure/env cast; i64 -> i64*
  %vptr23377 = alloca i64*, align 8 
  %envptr23375 = getelementptr inbounds i64, i64* %envptr23374, i64 7 
  store volatile i64* %envptr23375, i64** %vptr23377, align 8 ; &envptr23374[6]
 %vptr23378 = alloca i64, align 8 
  %gYG$succ = load i64, i64* %envptr23375, align 8 
  store volatile i64 %gYG$succ, i64* %vptr23378, align 8 ; load; *envptr23375
 %vptr23381 = alloca i64, align 8 
  %envptr23379 = inttoptr i64 %env11886 to i64* 
  store volatile i64 %G5a$y, i64* %vptr23381, align 8 ; closure/env cast; i64 -> i64*
  %vptr23382 = alloca i64*, align 8 
  %envptr23380 = getelementptr inbounds i64, i64* %envptr23379, i64 6 
  store volatile i64* %envptr23380, i64** %vptr23382, align 8 ; &envptr23379[5]
 %vptr23383 = alloca i64, align 8 
  %G5a$y = load i64, i64* %envptr23380, align 8 
  store volatile i64 %G5a$y, i64* %vptr23383, align 8 ; load; *envptr23380
 %vptr23386 = alloca i64, align 8 
  %envptr23384 = inttoptr i64 %env11886 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr23386, align 8 ; closure/env cast; i64 -> i64*
  %vptr23387 = alloca i64*, align 8 
  %envptr23385 = getelementptr inbounds i64, i64* %envptr23384, i64 5 
  store volatile i64* %envptr23385, i64** %vptr23387, align 8 ; &envptr23384[4]
 %vptr23388 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr23385, align 8 
  store volatile i64 %Pll$pred, i64* %vptr23388, align 8 ; load; *envptr23385
 %vptr23391 = alloca i64, align 8 
  %envptr23389 = inttoptr i64 %env11886 to i64* 
  store volatile i64 %Ttp$addc, i64* %vptr23391, align 8 ; closure/env cast; i64 -> i64*
  %vptr23392 = alloca i64*, align 8 
  %envptr23390 = getelementptr inbounds i64, i64* %envptr23389, i64 4 
  store volatile i64* %envptr23390, i64** %vptr23392, align 8 ; &envptr23389[3]
 %vptr23393 = alloca i64, align 8 
  %Ttp$addc = load i64, i64* %envptr23390, align 8 
  store volatile i64 %Ttp$addc, i64* %vptr23393, align 8 ; load; *envptr23390
 %vptr23396 = alloca i64, align 8 
  %envptr23394 = inttoptr i64 %env11886 to i64* 
  store volatile i64 %cont7225, i64* %vptr23396, align 8 ; closure/env cast; i64 -> i64*
  %vptr23397 = alloca i64*, align 8 
  %envptr23395 = getelementptr inbounds i64, i64* %envptr23394, i64 3 
  store volatile i64* %envptr23395, i64** %vptr23397, align 8 ; &envptr23394[2]
 %vptr23398 = alloca i64, align 8 
  %cont7225 = load i64, i64* %envptr23395, align 8 
  store volatile i64 %cont7225, i64* %vptr23398, align 8 ; load; *envptr23395
 %vptr23401 = alloca i64, align 8 
  %envptr23399 = inttoptr i64 %env11886 to i64* 
  store volatile i64 %emsg18637, i64* %vptr23401, align 8 ; closure/env cast; i64 -> i64*
  %vptr23402 = alloca i64*, align 8 
  %envptr23400 = getelementptr inbounds i64, i64* %envptr23399, i64 2 
  store volatile i64* %envptr23400, i64** %vptr23402, align 8 ; &envptr23399[1]
 %vptr23403 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr23400, align 8 
  store volatile i64 %emsg18637, i64* %vptr23403, align 8 ; load; *envptr23400
 %vptr23404 = alloca i64, align 8 
  %_957226 = call i64 @prim_car(i64 %rvp10006) 
  store volatile i64 %_957226, i64* %vptr23404, align 8 ; call prim_car
 %vptr23405 = alloca i64, align 8 
  %rvp10002 = call i64 @prim_cdr(i64 %rvp10006) 
  store volatile i64 %rvp10002, i64* %vptr23405, align 8 ; call prim_cdr
 %vptr23406 = alloca i64, align 8 
  %n_6310007 = call i64 @prim_null_63(i64 %rvp10002) 
  store volatile i64 %n_6310007, i64* %vptr23406, align 8 ; call prim_null_63
  %cmpptr23410 = alloca i1, align 8  %cmp23407 = icmp eq i64 %n_6310007, 15 store volatile i1 %cmp23407, i1* %cmpptr23410, align 8; false?
  br i1 %cmp23407, label %else23409, label %then23408                                ; if

then23408:
 %vptr23411 = alloca i64, align 8 
  %h10008 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10008, i64* %vptr23411, align 8 ; call prim_halt
  %vptr23417 = alloca i64*, align 8 
  %cloptr23412 = inttoptr i64 %h10008 to i64* 
  store volatile i64* %cloptr23412, i64** %vptr23417, align 8 ; closure/env cast; i64 -> i64*
  %vptr23418 = alloca i64*, align 8 
  %i0ptr23413 = getelementptr inbounds i64, i64* %cloptr23412, i64 1 
  store volatile i64* %i0ptr23413, i64** %vptr23418, align 8 ; &cloptr23412[1]
 %vptr23419 = alloca i64, align 8 
  %f23415 = load i64, i64* %i0ptr23413, align 8 
  store volatile i64 %f23415, i64* %vptr23419, align 8 ; load; *i0ptr23413
  %fptr23414 = inttoptr i64 %f23415 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23414(i64 %h10008, i64 %h10008)                     ; tail call
  ret void

else23409:
 %vptr23420 = alloca i64, align 8 
  %a7051 = call i64 @prim_car(i64 %rvp10002) 
  store volatile i64 %a7051, i64* %vptr23420, align 8 ; call prim_car
 %vptr23421 = alloca i64, align 8 
  %na9967 = call i64 @prim_cdr(i64 %rvp10002) 
  store volatile i64 %na9967, i64* %vptr23421, align 8 ; call prim_cdr
 %vptr23422 = alloca i64, align 8 
  %n_6310003 = call i64 @prim_null_63(i64 %na9967) 
  store volatile i64 %n_6310003, i64* %vptr23422, align 8 ; call prim_null_63
  %cmpptr23426 = alloca i1, align 8  %cmp23423 = icmp eq i64 %n_6310003, 15 store volatile i1 %cmp23423, i1* %cmpptr23426, align 8; false?
  br i1 %cmp23423, label %else23425, label %then23424                                ; if

then23424:
  %cmpptr23430 = alloca i1, align 8  %cmp23427 = icmp eq i64 %a7051, 15 store volatile i1 %cmp23427, i1* %cmpptr23430, align 8; false?
  br i1 %cmp23427, label %else23429, label %then23428                                ; if

then23428:
 %vptr23431 = alloca i64, align 8 
  %rva9970 = add i64 0, 0 
  store volatile i64 %rva9970, i64* %vptr23431, align 8 ; quoted ()
 %vptr23432 = alloca i64, align 8 
  %rva9969 = call i64 @prim_cons(i64 %MtO$x, i64 %rva9970) 
  store volatile i64 %rva9969, i64* %vptr23432, align 8 ; call prim_cons
 %vptr23433 = alloca i64, align 8 
  %rva9968 = call i64 @prim_cons(i64 %cont7225, i64 %rva9969) 
  store volatile i64 %rva9968, i64* %vptr23433, align 8 ; call prim_cons
  %vptr23439 = alloca i64*, align 8 
  %cloptr23434 = inttoptr i64 %Zht$k to i64* 
  store volatile i64* %cloptr23434, i64** %vptr23439, align 8 ; closure/env cast; i64 -> i64*
  %vptr23440 = alloca i64*, align 8 
  %i0ptr23435 = getelementptr inbounds i64, i64* %cloptr23434, i64 1 
  store volatile i64* %i0ptr23435, i64** %vptr23440, align 8 ; &cloptr23434[1]
 %vptr23441 = alloca i64, align 8 
  %f23437 = load i64, i64* %i0ptr23435, align 8 
  store volatile i64 %f23437, i64* %vptr23441, align 8 ; load; *i0ptr23435
  %fptr23436 = inttoptr i64 %f23437 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23436(i64 %Zht$k, i64 %rva9968)                     ; tail call
  ret void

else23429:
 %vptr23442 = alloca i64, align 8 
  %arg8154 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8154, i64* %vptr23442, align 8 ; quoted int
 %vptr23443 = alloca i64, align 8 
  %a7052 = call i64 @prim_vector_45ref(i64 %Ttp$addc, i64 %arg8154) 
  store volatile i64 %a7052, i64* %vptr23443, align 8 ; call prim_vector_45ref
 %vptr23444 = alloca i64, align 8 
  %arg8156 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8156, i64* %vptr23444, align 8 ; quoted int
 %vptr23445 = alloca i64, align 8 
  %a7053 = call i64 @prim_vector_45ref(i64 %gYG$succ, i64 %arg8156) 
  store volatile i64 %a7053, i64* %vptr23445, align 8 ; call prim_vector_45ref
  %vptr23456 = alloca i64*, align 8 
  %cloptr23446 = call i64* @make_closure(i64 64) 
  store volatile i64* %cloptr23446, i64** %vptr23456, align 8 ; malloc
  %vptr23457 = alloca i64*, align 8 
  %eptr23448 = getelementptr inbounds i64, i64* %cloptr23446, i64 2 
  store volatile i64* %eptr23448, i64** %vptr23457, align 8 ; &eptr23448[1]
  %vptr23458 = alloca i64*, align 8 
  %eptr23449 = getelementptr inbounds i64, i64* %cloptr23446, i64 3 
  store volatile i64* %eptr23449, i64** %vptr23458, align 8 ; &eptr23449[2]
  %vptr23459 = alloca i64*, align 8 
  %eptr23450 = getelementptr inbounds i64, i64* %cloptr23446, i64 4 
  store volatile i64* %eptr23450, i64** %vptr23459, align 8 ; &eptr23450[3]
  %vptr23460 = alloca i64*, align 8 
  %eptr23451 = getelementptr inbounds i64, i64* %cloptr23446, i64 5 
  store volatile i64* %eptr23451, i64** %vptr23460, align 8 ; &eptr23451[4]
  %vptr23461 = alloca i64*, align 8 
  %eptr23452 = getelementptr inbounds i64, i64* %cloptr23446, i64 6 
  store volatile i64* %eptr23452, i64** %vptr23461, align 8 ; &eptr23452[5]
  %vptr23462 = alloca i64*, align 8 
  %eptr23453 = getelementptr inbounds i64, i64* %cloptr23446, i64 7 
  store volatile i64* %eptr23453, i64** %vptr23462, align 8 ; &eptr23453[6]
  %vptr23463 = alloca i64*, align 8 
  %eptr23454 = getelementptr inbounds i64, i64* %cloptr23446, i64 8 
  store volatile i64* %eptr23454, i64** %vptr23463, align 8 ; &eptr23454[7]
  store i64 %emsg18637, i64* %eptr23448                                              ; *eptr23448 = %emsg18637
  store i64 %cont7225, i64* %eptr23449                                               ; *eptr23449 = %cont7225
  store i64 %Pll$pred, i64* %eptr23450                                               ; *eptr23450 = %Pll$pred
  store i64 %G5a$y, i64* %eptr23451                                                  ; *eptr23451 = %G5a$y
  store i64 %Zht$k, i64* %eptr23452                                                  ; *eptr23452 = %Zht$k
  store i64 %a7052, i64* %eptr23453                                                  ; *eptr23453 = %a7052
  store i64 %emsg08636, i64* %eptr23454                                              ; *eptr23454 = %emsg08636
  %vptr23464 = alloca i64*, align 8 
  %eptr23447 = getelementptr inbounds i64, i64* %cloptr23446, i64 1 
  store volatile i64* %eptr23447, i64** %vptr23464, align 8 ; &cloptr23446[1]
 %vptr23465 = alloca i64, align 8 
  %f23455 = ptrtoint void(i64,i64)* @lam11881 to i64 
  store volatile i64 %f23455, i64* %vptr23465, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f23455, i64* %eptr23447                                                 ; store fptr
 %vptr23466 = alloca i64, align 8 
  %arg8159 = ptrtoint i64* %cloptr23446 to i64 
  store volatile i64 %arg8159, i64* %vptr23466, align 8 ; closure cast; i64* -> i64
 %vptr23467 = alloca i64, align 8 
  %rva10001 = add i64 0, 0 
  store volatile i64 %rva10001, i64* %vptr23467, align 8 ; quoted ()
 %vptr23468 = alloca i64, align 8 
  %rva10000 = call i64 @prim_cons(i64 %MtO$x, i64 %rva10001) 
  store volatile i64 %rva10000, i64* %vptr23468, align 8 ; call prim_cons
 %vptr23469 = alloca i64, align 8 
  %rva9999 = call i64 @prim_cons(i64 %arg8159, i64 %rva10000) 
  store volatile i64 %rva9999, i64* %vptr23469, align 8 ; call prim_cons
  %vptr23475 = alloca i64*, align 8 
  %cloptr23470 = inttoptr i64 %a7053 to i64* 
  store volatile i64* %cloptr23470, i64** %vptr23475, align 8 ; closure/env cast; i64 -> i64*
  %vptr23476 = alloca i64*, align 8 
  %i0ptr23471 = getelementptr inbounds i64, i64* %cloptr23470, i64 1 
  store volatile i64* %i0ptr23471, i64** %vptr23476, align 8 ; &cloptr23470[1]
 %vptr23477 = alloca i64, align 8 
  %f23473 = load i64, i64* %i0ptr23471, align 8 
  store volatile i64 %f23473, i64* %vptr23477, align 8 ; load; *i0ptr23471
  %fptr23472 = inttoptr i64 %f23473 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23472(i64 %a7053, i64 %rva9999)                     ; tail call
  ret void

else23425:
 %vptr23478 = alloca i64, align 8 
  %h10004 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10004, i64* %vptr23478, align 8 ; call prim_halt
  %vptr23484 = alloca i64*, align 8 
  %cloptr23479 = inttoptr i64 %h10004 to i64* 
  store volatile i64* %cloptr23479, i64** %vptr23484, align 8 ; closure/env cast; i64 -> i64*
  %vptr23485 = alloca i64*, align 8 
  %i0ptr23480 = getelementptr inbounds i64, i64* %cloptr23479, i64 1 
  store volatile i64* %i0ptr23480, i64** %vptr23485, align 8 ; &cloptr23479[1]
 %vptr23486 = alloca i64, align 8 
  %f23482 = load i64, i64* %i0ptr23480, align 8 
  store volatile i64 %f23482, i64* %vptr23486, align 8 ; load; *i0ptr23480
  %fptr23481 = inttoptr i64 %f23482 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23481(i64 %h10004, i64 %h10004)                     ; tail call
  ret void
}


define void @lam11881(i64 %env11882, i64 %rvp9995) {
 %vptr23489 = alloca i64, align 8 
  %envptr23487 = inttoptr i64 %env11882 to i64* 
  store volatile i64 %emsg08636, i64* %vptr23489, align 8 ; closure/env cast; i64 -> i64*
  %vptr23490 = alloca i64*, align 8 
  %envptr23488 = getelementptr inbounds i64, i64* %envptr23487, i64 8 
  store volatile i64* %envptr23488, i64** %vptr23490, align 8 ; &envptr23487[7]
 %vptr23491 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr23488, align 8 
  store volatile i64 %emsg08636, i64* %vptr23491, align 8 ; load; *envptr23488
 %vptr23494 = alloca i64, align 8 
  %envptr23492 = inttoptr i64 %env11882 to i64* 
  store volatile i64 %a7052, i64* %vptr23494, align 8 ; closure/env cast; i64 -> i64*
  %vptr23495 = alloca i64*, align 8 
  %envptr23493 = getelementptr inbounds i64, i64* %envptr23492, i64 7 
  store volatile i64* %envptr23493, i64** %vptr23495, align 8 ; &envptr23492[6]
 %vptr23496 = alloca i64, align 8 
  %a7052 = load i64, i64* %envptr23493, align 8 
  store volatile i64 %a7052, i64* %vptr23496, align 8 ; load; *envptr23493
 %vptr23499 = alloca i64, align 8 
  %envptr23497 = inttoptr i64 %env11882 to i64* 
  store volatile i64 %Zht$k, i64* %vptr23499, align 8 ; closure/env cast; i64 -> i64*
  %vptr23500 = alloca i64*, align 8 
  %envptr23498 = getelementptr inbounds i64, i64* %envptr23497, i64 6 
  store volatile i64* %envptr23498, i64** %vptr23500, align 8 ; &envptr23497[5]
 %vptr23501 = alloca i64, align 8 
  %Zht$k = load i64, i64* %envptr23498, align 8 
  store volatile i64 %Zht$k, i64* %vptr23501, align 8 ; load; *envptr23498
 %vptr23504 = alloca i64, align 8 
  %envptr23502 = inttoptr i64 %env11882 to i64* 
  store volatile i64 %G5a$y, i64* %vptr23504, align 8 ; closure/env cast; i64 -> i64*
  %vptr23505 = alloca i64*, align 8 
  %envptr23503 = getelementptr inbounds i64, i64* %envptr23502, i64 5 
  store volatile i64* %envptr23503, i64** %vptr23505, align 8 ; &envptr23502[4]
 %vptr23506 = alloca i64, align 8 
  %G5a$y = load i64, i64* %envptr23503, align 8 
  store volatile i64 %G5a$y, i64* %vptr23506, align 8 ; load; *envptr23503
 %vptr23509 = alloca i64, align 8 
  %envptr23507 = inttoptr i64 %env11882 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr23509, align 8 ; closure/env cast; i64 -> i64*
  %vptr23510 = alloca i64*, align 8 
  %envptr23508 = getelementptr inbounds i64, i64* %envptr23507, i64 4 
  store volatile i64* %envptr23508, i64** %vptr23510, align 8 ; &envptr23507[3]
 %vptr23511 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr23508, align 8 
  store volatile i64 %Pll$pred, i64* %vptr23511, align 8 ; load; *envptr23508
 %vptr23514 = alloca i64, align 8 
  %envptr23512 = inttoptr i64 %env11882 to i64* 
  store volatile i64 %cont7225, i64* %vptr23514, align 8 ; closure/env cast; i64 -> i64*
  %vptr23515 = alloca i64*, align 8 
  %envptr23513 = getelementptr inbounds i64, i64* %envptr23512, i64 3 
  store volatile i64* %envptr23513, i64** %vptr23515, align 8 ; &envptr23512[2]
 %vptr23516 = alloca i64, align 8 
  %cont7225 = load i64, i64* %envptr23513, align 8 
  store volatile i64 %cont7225, i64* %vptr23516, align 8 ; load; *envptr23513
 %vptr23519 = alloca i64, align 8 
  %envptr23517 = inttoptr i64 %env11882 to i64* 
  store volatile i64 %emsg18637, i64* %vptr23519, align 8 ; closure/env cast; i64 -> i64*
  %vptr23520 = alloca i64*, align 8 
  %envptr23518 = getelementptr inbounds i64, i64* %envptr23517, i64 2 
  store volatile i64* %envptr23518, i64** %vptr23520, align 8 ; &envptr23517[1]
 %vptr23521 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr23518, align 8 
  store volatile i64 %emsg18637, i64* %vptr23521, align 8 ; load; *envptr23518
 %vptr23522 = alloca i64, align 8 
  %_957227 = call i64 @prim_car(i64 %rvp9995) 
  store volatile i64 %_957227, i64* %vptr23522, align 8 ; call prim_car
 %vptr23523 = alloca i64, align 8 
  %rvp9991 = call i64 @prim_cdr(i64 %rvp9995) 
  store volatile i64 %rvp9991, i64* %vptr23523, align 8 ; call prim_cdr
 %vptr23524 = alloca i64, align 8 
  %n_639996 = call i64 @prim_null_63(i64 %rvp9991) 
  store volatile i64 %n_639996, i64* %vptr23524, align 8 ; call prim_null_63
  %cmpptr23528 = alloca i1, align 8  %cmp23525 = icmp eq i64 %n_639996, 15 store volatile i1 %cmp23525, i1* %cmpptr23528, align 8; false?
  br i1 %cmp23525, label %else23527, label %then23526                                ; if

then23526:
 %vptr23529 = alloca i64, align 8 
  %h9997 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9997, i64* %vptr23529, align 8 ; call prim_halt
  %vptr23535 = alloca i64*, align 8 
  %cloptr23530 = inttoptr i64 %h9997 to i64* 
  store volatile i64* %cloptr23530, i64** %vptr23535, align 8 ; closure/env cast; i64 -> i64*
  %vptr23536 = alloca i64*, align 8 
  %i0ptr23531 = getelementptr inbounds i64, i64* %cloptr23530, i64 1 
  store volatile i64* %i0ptr23531, i64** %vptr23536, align 8 ; &cloptr23530[1]
 %vptr23537 = alloca i64, align 8 
  %f23533 = load i64, i64* %i0ptr23531, align 8 
  store volatile i64 %f23533, i64* %vptr23537, align 8 ; load; *i0ptr23531
  %fptr23532 = inttoptr i64 %f23533 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23532(i64 %h9997, i64 %h9997)                       ; tail call
  ret void

else23527:
 %vptr23538 = alloca i64, align 8 
  %a7054 = call i64 @prim_car(i64 %rvp9991) 
  store volatile i64 %a7054, i64* %vptr23538, align 8 ; call prim_car
 %vptr23539 = alloca i64, align 8 
  %na9972 = call i64 @prim_cdr(i64 %rvp9991) 
  store volatile i64 %na9972, i64* %vptr23539, align 8 ; call prim_cdr
 %vptr23540 = alloca i64, align 8 
  %n_639992 = call i64 @prim_null_63(i64 %na9972) 
  store volatile i64 %n_639992, i64* %vptr23540, align 8 ; call prim_null_63
  %cmpptr23544 = alloca i1, align 8  %cmp23541 = icmp eq i64 %n_639992, 15 store volatile i1 %cmp23541, i1* %cmpptr23544, align 8; false?
  br i1 %cmp23541, label %else23543, label %then23542                                ; if

then23542:
 %vptr23545 = alloca i64, align 8 
  %arg8161 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8161, i64* %vptr23545, align 8 ; quoted int
 %vptr23546 = alloca i64, align 8 
  %a7055 = call i64 @prim_vector_45ref(i64 %Pll$pred, i64 %arg8161) 
  store volatile i64 %a7055, i64* %vptr23546, align 8 ; call prim_vector_45ref
  %vptr23556 = alloca i64*, align 8 
  %cloptr23547 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr23547, i64** %vptr23556, align 8 ; malloc
  %vptr23557 = alloca i64*, align 8 
  %eptr23549 = getelementptr inbounds i64, i64* %cloptr23547, i64 2 
  store volatile i64* %eptr23549, i64** %vptr23557, align 8 ; &eptr23549[1]
  %vptr23558 = alloca i64*, align 8 
  %eptr23550 = getelementptr inbounds i64, i64* %cloptr23547, i64 3 
  store volatile i64* %eptr23550, i64** %vptr23558, align 8 ; &eptr23550[2]
  %vptr23559 = alloca i64*, align 8 
  %eptr23551 = getelementptr inbounds i64, i64* %cloptr23547, i64 4 
  store volatile i64* %eptr23551, i64** %vptr23559, align 8 ; &eptr23551[3]
  %vptr23560 = alloca i64*, align 8 
  %eptr23552 = getelementptr inbounds i64, i64* %cloptr23547, i64 5 
  store volatile i64* %eptr23552, i64** %vptr23560, align 8 ; &eptr23552[4]
  %vptr23561 = alloca i64*, align 8 
  %eptr23553 = getelementptr inbounds i64, i64* %cloptr23547, i64 6 
  store volatile i64* %eptr23553, i64** %vptr23561, align 8 ; &eptr23553[5]
  %vptr23562 = alloca i64*, align 8 
  %eptr23554 = getelementptr inbounds i64, i64* %cloptr23547, i64 7 
  store volatile i64* %eptr23554, i64** %vptr23562, align 8 ; &eptr23554[6]
  store i64 %emsg18637, i64* %eptr23549                                              ; *eptr23549 = %emsg18637
  store i64 %cont7225, i64* %eptr23550                                               ; *eptr23550 = %cont7225
  store i64 %Zht$k, i64* %eptr23551                                                  ; *eptr23551 = %Zht$k
  store i64 %a7052, i64* %eptr23552                                                  ; *eptr23552 = %a7052
  store i64 %emsg08636, i64* %eptr23553                                              ; *eptr23553 = %emsg08636
  store i64 %a7054, i64* %eptr23554                                                  ; *eptr23554 = %a7054
  %vptr23563 = alloca i64*, align 8 
  %eptr23548 = getelementptr inbounds i64, i64* %cloptr23547, i64 1 
  store volatile i64* %eptr23548, i64** %vptr23563, align 8 ; &cloptr23547[1]
 %vptr23564 = alloca i64, align 8 
  %f23555 = ptrtoint void(i64,i64)* @lam11878 to i64 
  store volatile i64 %f23555, i64* %vptr23564, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f23555, i64* %eptr23548                                                 ; store fptr
 %vptr23565 = alloca i64, align 8 
  %arg8164 = ptrtoint i64* %cloptr23547 to i64 
  store volatile i64 %arg8164, i64* %vptr23565, align 8 ; closure cast; i64* -> i64
 %vptr23566 = alloca i64, align 8 
  %rva9990 = add i64 0, 0 
  store volatile i64 %rva9990, i64* %vptr23566, align 8 ; quoted ()
 %vptr23567 = alloca i64, align 8 
  %rva9989 = call i64 @prim_cons(i64 %G5a$y, i64 %rva9990) 
  store volatile i64 %rva9989, i64* %vptr23567, align 8 ; call prim_cons
 %vptr23568 = alloca i64, align 8 
  %rva9988 = call i64 @prim_cons(i64 %arg8164, i64 %rva9989) 
  store volatile i64 %rva9988, i64* %vptr23568, align 8 ; call prim_cons
  %vptr23574 = alloca i64*, align 8 
  %cloptr23569 = inttoptr i64 %a7055 to i64* 
  store volatile i64* %cloptr23569, i64** %vptr23574, align 8 ; closure/env cast; i64 -> i64*
  %vptr23575 = alloca i64*, align 8 
  %i0ptr23570 = getelementptr inbounds i64, i64* %cloptr23569, i64 1 
  store volatile i64* %i0ptr23570, i64** %vptr23575, align 8 ; &cloptr23569[1]
 %vptr23576 = alloca i64, align 8 
  %f23572 = load i64, i64* %i0ptr23570, align 8 
  store volatile i64 %f23572, i64* %vptr23576, align 8 ; load; *i0ptr23570
  %fptr23571 = inttoptr i64 %f23572 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23571(i64 %a7055, i64 %rva9988)                     ; tail call
  ret void

else23543:
 %vptr23577 = alloca i64, align 8 
  %h9993 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9993, i64* %vptr23577, align 8 ; call prim_halt
  %vptr23583 = alloca i64*, align 8 
  %cloptr23578 = inttoptr i64 %h9993 to i64* 
  store volatile i64* %cloptr23578, i64** %vptr23583, align 8 ; closure/env cast; i64 -> i64*
  %vptr23584 = alloca i64*, align 8 
  %i0ptr23579 = getelementptr inbounds i64, i64* %cloptr23578, i64 1 
  store volatile i64* %i0ptr23579, i64** %vptr23584, align 8 ; &cloptr23578[1]
 %vptr23585 = alloca i64, align 8 
  %f23581 = load i64, i64* %i0ptr23579, align 8 
  store volatile i64 %f23581, i64* %vptr23585, align 8 ; load; *i0ptr23579
  %fptr23580 = inttoptr i64 %f23581 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23580(i64 %h9993, i64 %h9993)                       ; tail call
  ret void
}


define void @lam11878(i64 %env11879, i64 %rvp9984) {
 %vptr23588 = alloca i64, align 8 
  %envptr23586 = inttoptr i64 %env11879 to i64* 
  store volatile i64 %a7054, i64* %vptr23588, align 8 ; closure/env cast; i64 -> i64*
  %vptr23589 = alloca i64*, align 8 
  %envptr23587 = getelementptr inbounds i64, i64* %envptr23586, i64 7 
  store volatile i64* %envptr23587, i64** %vptr23589, align 8 ; &envptr23586[6]
 %vptr23590 = alloca i64, align 8 
  %a7054 = load i64, i64* %envptr23587, align 8 
  store volatile i64 %a7054, i64* %vptr23590, align 8 ; load; *envptr23587
 %vptr23593 = alloca i64, align 8 
  %envptr23591 = inttoptr i64 %env11879 to i64* 
  store volatile i64 %emsg08636, i64* %vptr23593, align 8 ; closure/env cast; i64 -> i64*
  %vptr23594 = alloca i64*, align 8 
  %envptr23592 = getelementptr inbounds i64, i64* %envptr23591, i64 6 
  store volatile i64* %envptr23592, i64** %vptr23594, align 8 ; &envptr23591[5]
 %vptr23595 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr23592, align 8 
  store volatile i64 %emsg08636, i64* %vptr23595, align 8 ; load; *envptr23592
 %vptr23598 = alloca i64, align 8 
  %envptr23596 = inttoptr i64 %env11879 to i64* 
  store volatile i64 %a7052, i64* %vptr23598, align 8 ; closure/env cast; i64 -> i64*
  %vptr23599 = alloca i64*, align 8 
  %envptr23597 = getelementptr inbounds i64, i64* %envptr23596, i64 5 
  store volatile i64* %envptr23597, i64** %vptr23599, align 8 ; &envptr23596[4]
 %vptr23600 = alloca i64, align 8 
  %a7052 = load i64, i64* %envptr23597, align 8 
  store volatile i64 %a7052, i64* %vptr23600, align 8 ; load; *envptr23597
 %vptr23603 = alloca i64, align 8 
  %envptr23601 = inttoptr i64 %env11879 to i64* 
  store volatile i64 %Zht$k, i64* %vptr23603, align 8 ; closure/env cast; i64 -> i64*
  %vptr23604 = alloca i64*, align 8 
  %envptr23602 = getelementptr inbounds i64, i64* %envptr23601, i64 4 
  store volatile i64* %envptr23602, i64** %vptr23604, align 8 ; &envptr23601[3]
 %vptr23605 = alloca i64, align 8 
  %Zht$k = load i64, i64* %envptr23602, align 8 
  store volatile i64 %Zht$k, i64* %vptr23605, align 8 ; load; *envptr23602
 %vptr23608 = alloca i64, align 8 
  %envptr23606 = inttoptr i64 %env11879 to i64* 
  store volatile i64 %cont7225, i64* %vptr23608, align 8 ; closure/env cast; i64 -> i64*
  %vptr23609 = alloca i64*, align 8 
  %envptr23607 = getelementptr inbounds i64, i64* %envptr23606, i64 3 
  store volatile i64* %envptr23607, i64** %vptr23609, align 8 ; &envptr23606[2]
 %vptr23610 = alloca i64, align 8 
  %cont7225 = load i64, i64* %envptr23607, align 8 
  store volatile i64 %cont7225, i64* %vptr23610, align 8 ; load; *envptr23607
 %vptr23613 = alloca i64, align 8 
  %envptr23611 = inttoptr i64 %env11879 to i64* 
  store volatile i64 %emsg18637, i64* %vptr23613, align 8 ; closure/env cast; i64 -> i64*
  %vptr23614 = alloca i64*, align 8 
  %envptr23612 = getelementptr inbounds i64, i64* %envptr23611, i64 2 
  store volatile i64* %envptr23612, i64** %vptr23614, align 8 ; &envptr23611[1]
 %vptr23615 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr23612, align 8 
  store volatile i64 %emsg18637, i64* %vptr23615, align 8 ; load; *envptr23612
 %vptr23616 = alloca i64, align 8 
  %_957228 = call i64 @prim_car(i64 %rvp9984) 
  store volatile i64 %_957228, i64* %vptr23616, align 8 ; call prim_car
 %vptr23617 = alloca i64, align 8 
  %rvp9980 = call i64 @prim_cdr(i64 %rvp9984) 
  store volatile i64 %rvp9980, i64* %vptr23617, align 8 ; call prim_cdr
 %vptr23618 = alloca i64, align 8 
  %n_639985 = call i64 @prim_null_63(i64 %rvp9980) 
  store volatile i64 %n_639985, i64* %vptr23618, align 8 ; call prim_null_63
  %cmpptr23622 = alloca i1, align 8  %cmp23619 = icmp eq i64 %n_639985, 15 store volatile i1 %cmp23619, i1* %cmpptr23622, align 8; false?
  br i1 %cmp23619, label %else23621, label %then23620                                ; if

then23620:
 %vptr23623 = alloca i64, align 8 
  %h9986 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h9986, i64* %vptr23623, align 8 ; call prim_halt
  %vptr23629 = alloca i64*, align 8 
  %cloptr23624 = inttoptr i64 %h9986 to i64* 
  store volatile i64* %cloptr23624, i64** %vptr23629, align 8 ; closure/env cast; i64 -> i64*
  %vptr23630 = alloca i64*, align 8 
  %i0ptr23625 = getelementptr inbounds i64, i64* %cloptr23624, i64 1 
  store volatile i64* %i0ptr23625, i64** %vptr23630, align 8 ; &cloptr23624[1]
 %vptr23631 = alloca i64, align 8 
  %f23627 = load i64, i64* %i0ptr23625, align 8 
  store volatile i64 %f23627, i64* %vptr23631, align 8 ; load; *i0ptr23625
  %fptr23626 = inttoptr i64 %f23627 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23626(i64 %h9986, i64 %h9986)                       ; tail call
  ret void

else23621:
 %vptr23632 = alloca i64, align 8 
  %a7056 = call i64 @prim_car(i64 %rvp9980) 
  store volatile i64 %a7056, i64* %vptr23632, align 8 ; call prim_car
 %vptr23633 = alloca i64, align 8 
  %na9974 = call i64 @prim_cdr(i64 %rvp9980) 
  store volatile i64 %na9974, i64* %vptr23633, align 8 ; call prim_cdr
 %vptr23634 = alloca i64, align 8 
  %n_639981 = call i64 @prim_null_63(i64 %na9974) 
  store volatile i64 %n_639981, i64* %vptr23634, align 8 ; call prim_null_63
  %cmpptr23638 = alloca i1, align 8  %cmp23635 = icmp eq i64 %n_639981, 15 store volatile i1 %cmp23635, i1* %cmpptr23638, align 8; false?
  br i1 %cmp23635, label %else23637, label %then23636                                ; if

then23636:
 %vptr23639 = alloca i64, align 8 
  %rva9979 = add i64 0, 0 
  store volatile i64 %rva9979, i64* %vptr23639, align 8 ; quoted ()
 %vptr23640 = alloca i64, align 8 
  %rva9978 = call i64 @prim_cons(i64 %Zht$k, i64 %rva9979) 
  store volatile i64 %rva9978, i64* %vptr23640, align 8 ; call prim_cons
 %vptr23641 = alloca i64, align 8 
  %rva9977 = call i64 @prim_cons(i64 %a7056, i64 %rva9978) 
  store volatile i64 %rva9977, i64* %vptr23641, align 8 ; call prim_cons
 %vptr23642 = alloca i64, align 8 
  %rva9976 = call i64 @prim_cons(i64 %a7054, i64 %rva9977) 
  store volatile i64 %rva9976, i64* %vptr23642, align 8 ; call prim_cons
 %vptr23643 = alloca i64, align 8 
  %rva9975 = call i64 @prim_cons(i64 %cont7225, i64 %rva9976) 
  store volatile i64 %rva9975, i64* %vptr23643, align 8 ; call prim_cons
  %vptr23649 = alloca i64*, align 8 
  %cloptr23644 = inttoptr i64 %a7052 to i64* 
  store volatile i64* %cloptr23644, i64** %vptr23649, align 8 ; closure/env cast; i64 -> i64*
  %vptr23650 = alloca i64*, align 8 
  %i0ptr23645 = getelementptr inbounds i64, i64* %cloptr23644, i64 1 
  store volatile i64* %i0ptr23645, i64** %vptr23650, align 8 ; &cloptr23644[1]
 %vptr23651 = alloca i64, align 8 
  %f23647 = load i64, i64* %i0ptr23645, align 8 
  store volatile i64 %f23647, i64* %vptr23651, align 8 ; load; *i0ptr23645
  %fptr23646 = inttoptr i64 %f23647 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23646(i64 %a7052, i64 %rva9975)                     ; tail call
  ret void

else23637:
 %vptr23652 = alloca i64, align 8 
  %h9982 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h9982, i64* %vptr23652, align 8 ; call prim_halt
  %vptr23658 = alloca i64*, align 8 
  %cloptr23653 = inttoptr i64 %h9982 to i64* 
  store volatile i64* %cloptr23653, i64** %vptr23658, align 8 ; closure/env cast; i64 -> i64*
  %vptr23659 = alloca i64*, align 8 
  %i0ptr23654 = getelementptr inbounds i64, i64* %cloptr23653, i64 1 
  store volatile i64* %i0ptr23654, i64** %vptr23659, align 8 ; &cloptr23653[1]
 %vptr23660 = alloca i64, align 8 
  %f23656 = load i64, i64* %i0ptr23654, align 8 
  store volatile i64 %f23656, i64* %vptr23660, align 8 ; load; *i0ptr23654
  %fptr23655 = inttoptr i64 %f23656 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23655(i64 %h9982, i64 %h9982)                       ; tail call
  ret void
}


define void @lam11871(i64 %env11872, i64 %rvp10510) {
 %vptr23663 = alloca i64, align 8 
  %envptr23661 = inttoptr i64 %env11872 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr23663, align 8 ; closure/env cast; i64 -> i64*
  %vptr23664 = alloca i64*, align 8 
  %envptr23662 = getelementptr inbounds i64, i64* %envptr23661, i64 10 
  store volatile i64* %envptr23662, i64** %vptr23664, align 8 ; &envptr23661[9]
 %vptr23665 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr23662, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr23665, align 8 ; load; *envptr23662
 %vptr23668 = alloca i64, align 8 
  %envptr23666 = inttoptr i64 %env11872 to i64* 
  store volatile i64 %bbE$z_63, i64* %vptr23668, align 8 ; closure/env cast; i64 -> i64*
  %vptr23669 = alloca i64*, align 8 
  %envptr23667 = getelementptr inbounds i64, i64* %envptr23666, i64 9 
  store volatile i64* %envptr23667, i64** %vptr23669, align 8 ; &envptr23666[8]
 %vptr23670 = alloca i64, align 8 
  %bbE$z_63 = load i64, i64* %envptr23667, align 8 
  store volatile i64 %bbE$z_63, i64* %vptr23670, align 8 ; load; *envptr23667
 %vptr23673 = alloca i64, align 8 
  %envptr23671 = inttoptr i64 %env11872 to i64* 
  store volatile i64 %emsg08636, i64* %vptr23673, align 8 ; closure/env cast; i64 -> i64*
  %vptr23674 = alloca i64*, align 8 
  %envptr23672 = getelementptr inbounds i64, i64* %envptr23671, i64 8 
  store volatile i64* %envptr23672, i64** %vptr23674, align 8 ; &envptr23671[7]
 %vptr23675 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr23672, align 8 
  store volatile i64 %emsg08636, i64* %vptr23675, align 8 ; load; *envptr23672
 %vptr23678 = alloca i64, align 8 
  %envptr23676 = inttoptr i64 %env11872 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr23678, align 8 ; closure/env cast; i64 -> i64*
  %vptr23679 = alloca i64*, align 8 
  %envptr23677 = getelementptr inbounds i64, i64* %envptr23676, i64 7 
  store volatile i64* %envptr23677, i64** %vptr23679, align 8 ; &envptr23676[6]
 %vptr23680 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr23677, align 8 
  store volatile i64 %Pll$pred, i64* %vptr23680, align 8 ; load; *envptr23677
 %vptr23683 = alloca i64, align 8 
  %envptr23681 = inttoptr i64 %env11872 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr23683, align 8 ; closure/env cast; i64 -> i64*
  %vptr23684 = alloca i64*, align 8 
  %envptr23682 = getelementptr inbounds i64, i64* %envptr23681, i64 6 
  store volatile i64* %envptr23682, i64** %vptr23684, align 8 ; &envptr23681[5]
 %vptr23685 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr23682, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr23685, align 8 ; load; *envptr23682
 %vptr23688 = alloca i64, align 8 
  %envptr23686 = inttoptr i64 %env11872 to i64* 
  store volatile i64 %Ttp$addc, i64* %vptr23688, align 8 ; closure/env cast; i64 -> i64*
  %vptr23689 = alloca i64*, align 8 
  %envptr23687 = getelementptr inbounds i64, i64* %envptr23686, i64 5 
  store volatile i64* %envptr23687, i64** %vptr23689, align 8 ; &envptr23686[4]
 %vptr23690 = alloca i64, align 8 
  %Ttp$addc = load i64, i64* %envptr23687, align 8 
  store volatile i64 %Ttp$addc, i64* %vptr23690, align 8 ; load; *envptr23687
 %vptr23693 = alloca i64, align 8 
  %envptr23691 = inttoptr i64 %env11872 to i64* 
  store volatile i64 %YxK$fibc, i64* %vptr23693, align 8 ; closure/env cast; i64 -> i64*
  %vptr23694 = alloca i64*, align 8 
  %envptr23692 = getelementptr inbounds i64, i64* %envptr23691, i64 4 
  store volatile i64* %envptr23692, i64** %vptr23694, align 8 ; &envptr23691[3]
 %vptr23695 = alloca i64, align 8 
  %YxK$fibc = load i64, i64* %envptr23692, align 8 
  store volatile i64 %YxK$fibc, i64* %vptr23695, align 8 ; load; *envptr23692
 %vptr23698 = alloca i64, align 8 
  %envptr23696 = inttoptr i64 %env11872 to i64* 
  store volatile i64 %emsg18637, i64* %vptr23698, align 8 ; closure/env cast; i64 -> i64*
  %vptr23699 = alloca i64*, align 8 
  %envptr23697 = getelementptr inbounds i64, i64* %envptr23696, i64 3 
  store volatile i64* %envptr23697, i64** %vptr23699, align 8 ; &envptr23696[2]
 %vptr23700 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr23697, align 8 
  store volatile i64 %emsg18637, i64* %vptr23700, align 8 ; load; *envptr23697
 %vptr23703 = alloca i64, align 8 
  %envptr23701 = inttoptr i64 %env11872 to i64* 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr23703, align 8 ; closure/env cast; i64 -> i64*
  %vptr23704 = alloca i64*, align 8 
  %envptr23702 = getelementptr inbounds i64, i64* %envptr23701, i64 2 
  store volatile i64* %envptr23702, i64** %vptr23704, align 8 ; &envptr23701[1]
 %vptr23705 = alloca i64, align 8 
  %bmP$nat_45_62peano = load i64, i64* %envptr23702, align 8 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr23705, align 8 ; load; *envptr23702
 %vptr23706 = alloca i64, align 8 
  %cont7229 = call i64 @prim_car(i64 %rvp10510) 
  store volatile i64 %cont7229, i64* %vptr23706, align 8 ; call prim_car
 %vptr23707 = alloca i64, align 8 
  %rvp10506 = call i64 @prim_cdr(i64 %rvp10510) 
  store volatile i64 %rvp10506, i64* %vptr23707, align 8 ; call prim_cdr
 %vptr23708 = alloca i64, align 8 
  %n_6310511 = call i64 @prim_null_63(i64 %rvp10506) 
  store volatile i64 %n_6310511, i64* %vptr23708, align 8 ; call prim_null_63
  %cmpptr23712 = alloca i1, align 8  %cmp23709 = icmp eq i64 %n_6310511, 15 store volatile i1 %cmp23709, i1* %cmpptr23712, align 8; false?
  br i1 %cmp23709, label %else23711, label %then23710                                ; if

then23710:
 %vptr23713 = alloca i64, align 8 
  %h10512 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10512, i64* %vptr23713, align 8 ; call prim_halt
  %vptr23719 = alloca i64*, align 8 
  %cloptr23714 = inttoptr i64 %h10512 to i64* 
  store volatile i64* %cloptr23714, i64** %vptr23719, align 8 ; closure/env cast; i64 -> i64*
  %vptr23720 = alloca i64*, align 8 
  %i0ptr23715 = getelementptr inbounds i64, i64* %cloptr23714, i64 1 
  store volatile i64* %i0ptr23715, i64** %vptr23720, align 8 ; &cloptr23714[1]
 %vptr23721 = alloca i64, align 8 
  %f23717 = load i64, i64* %i0ptr23715, align 8 
  store volatile i64 %f23717, i64* %vptr23721, align 8 ; load; *i0ptr23715
  %fptr23716 = inttoptr i64 %f23717 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23716(i64 %h10512, i64 %h10512)                     ; tail call
  ret void

else23711:
 %vptr23722 = alloca i64, align 8 
  %MXn$x = call i64 @prim_car(i64 %rvp10506) 
  store volatile i64 %MXn$x, i64* %vptr23722, align 8 ; call prim_car
 %vptr23723 = alloca i64, align 8 
  %rvp10502 = call i64 @prim_cdr(i64 %rvp10506) 
  store volatile i64 %rvp10502, i64* %vptr23723, align 8 ; call prim_cdr
 %vptr23724 = alloca i64, align 8 
  %n_6310507 = call i64 @prim_null_63(i64 %rvp10502) 
  store volatile i64 %n_6310507, i64* %vptr23724, align 8 ; call prim_null_63
  %cmpptr23728 = alloca i1, align 8  %cmp23725 = icmp eq i64 %n_6310507, 15 store volatile i1 %cmp23725, i1* %cmpptr23728, align 8; false?
  br i1 %cmp23725, label %else23727, label %then23726                                ; if

then23726:
 %vptr23729 = alloca i64, align 8 
  %h10508 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10508, i64* %vptr23729, align 8 ; call prim_halt
  %vptr23735 = alloca i64*, align 8 
  %cloptr23730 = inttoptr i64 %h10508 to i64* 
  store volatile i64* %cloptr23730, i64** %vptr23735, align 8 ; closure/env cast; i64 -> i64*
  %vptr23736 = alloca i64*, align 8 
  %i0ptr23731 = getelementptr inbounds i64, i64* %cloptr23730, i64 1 
  store volatile i64* %i0ptr23731, i64** %vptr23736, align 8 ; &cloptr23730[1]
 %vptr23737 = alloca i64, align 8 
  %f23733 = load i64, i64* %i0ptr23731, align 8 
  store volatile i64 %f23733, i64* %vptr23737, align 8 ; load; *i0ptr23731
  %fptr23732 = inttoptr i64 %f23733 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23732(i64 %h10508, i64 %h10508)                     ; tail call
  ret void

else23727:
 %vptr23738 = alloca i64, align 8 
  %ZpZ$c = call i64 @prim_car(i64 %rvp10502) 
  store volatile i64 %ZpZ$c, i64* %vptr23738, align 8 ; call prim_car
 %vptr23739 = alloca i64, align 8 
  %na10030 = call i64 @prim_cdr(i64 %rvp10502) 
  store volatile i64 %na10030, i64* %vptr23739, align 8 ; call prim_cdr
 %vptr23740 = alloca i64, align 8 
  %n_6310503 = call i64 @prim_null_63(i64 %na10030) 
  store volatile i64 %n_6310503, i64* %vptr23740, align 8 ; call prim_null_63
  %cmpptr23744 = alloca i1, align 8  %cmp23741 = icmp eq i64 %n_6310503, 15 store volatile i1 %cmp23741, i1* %cmpptr23744, align 8; false?
  br i1 %cmp23741, label %else23743, label %then23742                                ; if

then23742:
 %vptr23745 = alloca i64, align 8 
  %arg8171 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8171, i64* %vptr23745, align 8 ; quoted int
 %vptr23746 = alloca i64, align 8 
  %a7057 = call i64 @prim_vector_45ref(i64 %bbE$z_63, i64 %arg8171) 
  store volatile i64 %a7057, i64* %vptr23746, align 8 ; call prim_vector_45ref
  %vptr23762 = alloca i64*, align 8 
  %cloptr23747 = call i64* @make_closure(i64 104) 
  store volatile i64* %cloptr23747, i64** %vptr23762, align 8 ; malloc
  %vptr23763 = alloca i64*, align 8 
  %eptr23749 = getelementptr inbounds i64, i64* %cloptr23747, i64 2 
  store volatile i64* %eptr23749, i64** %vptr23763, align 8 ; &eptr23749[1]
  %vptr23764 = alloca i64*, align 8 
  %eptr23750 = getelementptr inbounds i64, i64* %cloptr23747, i64 3 
  store volatile i64* %eptr23750, i64** %vptr23764, align 8 ; &eptr23750[2]
  %vptr23765 = alloca i64*, align 8 
  %eptr23751 = getelementptr inbounds i64, i64* %cloptr23747, i64 4 
  store volatile i64* %eptr23751, i64** %vptr23765, align 8 ; &eptr23751[3]
  %vptr23766 = alloca i64*, align 8 
  %eptr23752 = getelementptr inbounds i64, i64* %cloptr23747, i64 5 
  store volatile i64* %eptr23752, i64** %vptr23766, align 8 ; &eptr23752[4]
  %vptr23767 = alloca i64*, align 8 
  %eptr23753 = getelementptr inbounds i64, i64* %cloptr23747, i64 6 
  store volatile i64* %eptr23753, i64** %vptr23767, align 8 ; &eptr23753[5]
  %vptr23768 = alloca i64*, align 8 
  %eptr23754 = getelementptr inbounds i64, i64* %cloptr23747, i64 7 
  store volatile i64* %eptr23754, i64** %vptr23768, align 8 ; &eptr23754[6]
  %vptr23769 = alloca i64*, align 8 
  %eptr23755 = getelementptr inbounds i64, i64* %cloptr23747, i64 8 
  store volatile i64* %eptr23755, i64** %vptr23769, align 8 ; &eptr23755[7]
  %vptr23770 = alloca i64*, align 8 
  %eptr23756 = getelementptr inbounds i64, i64* %cloptr23747, i64 9 
  store volatile i64* %eptr23756, i64** %vptr23770, align 8 ; &eptr23756[8]
  %vptr23771 = alloca i64*, align 8 
  %eptr23757 = getelementptr inbounds i64, i64* %cloptr23747, i64 10 
  store volatile i64* %eptr23757, i64** %vptr23771, align 8 ; &eptr23757[9]
  %vptr23772 = alloca i64*, align 8 
  %eptr23758 = getelementptr inbounds i64, i64* %cloptr23747, i64 11 
  store volatile i64* %eptr23758, i64** %vptr23772, align 8 ; &eptr23758[10]
  %vptr23773 = alloca i64*, align 8 
  %eptr23759 = getelementptr inbounds i64, i64* %cloptr23747, i64 12 
  store volatile i64* %eptr23759, i64** %vptr23773, align 8 ; &eptr23759[11]
  %vptr23774 = alloca i64*, align 8 
  %eptr23760 = getelementptr inbounds i64, i64* %cloptr23747, i64 13 
  store volatile i64* %eptr23760, i64** %vptr23774, align 8 ; &eptr23760[12]
  store i64 %bmP$nat_45_62peano, i64* %eptr23749                                     ; *eptr23749 = %bmP$nat_45_62peano
  store i64 %emsg18637, i64* %eptr23750                                              ; *eptr23750 = %emsg18637
  store i64 %YxK$fibc, i64* %eptr23751                                               ; *eptr23751 = %YxK$fibc
  store i64 %Ttp$addc, i64* %eptr23752                                               ; *eptr23752 = %Ttp$addc
  store i64 %SdC$_37wind_45stack, i64* %eptr23753                                    ; *eptr23753 = %SdC$_37wind_45stack
  store i64 %ZpZ$c, i64* %eptr23754                                                  ; *eptr23754 = %ZpZ$c
  store i64 %Pll$pred, i64* %eptr23755                                               ; *eptr23755 = %Pll$pred
  store i64 %MXn$x, i64* %eptr23756                                                  ; *eptr23756 = %MXn$x
  store i64 %emsg08636, i64* %eptr23757                                              ; *eptr23757 = %emsg08636
  store i64 %bbE$z_63, i64* %eptr23758                                               ; *eptr23758 = %bbE$z_63
  store i64 %U8g$_37do_45wind, i64* %eptr23759                                       ; *eptr23759 = %U8g$_37do_45wind
  store i64 %cont7229, i64* %eptr23760                                               ; *eptr23760 = %cont7229
  %vptr23775 = alloca i64*, align 8 
  %eptr23748 = getelementptr inbounds i64, i64* %cloptr23747, i64 1 
  store volatile i64* %eptr23748, i64** %vptr23775, align 8 ; &cloptr23747[1]
 %vptr23776 = alloca i64, align 8 
  %f23761 = ptrtoint void(i64,i64)* @lam11868 to i64 
  store volatile i64 %f23761, i64* %vptr23776, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f23761, i64* %eptr23748                                                 ; store fptr
 %vptr23777 = alloca i64, align 8 
  %arg8174 = ptrtoint i64* %cloptr23747 to i64 
  store volatile i64 %arg8174, i64* %vptr23777, align 8 ; closure cast; i64* -> i64
 %vptr23778 = alloca i64, align 8 
  %rva10501 = add i64 0, 0 
  store volatile i64 %rva10501, i64* %vptr23778, align 8 ; quoted ()
 %vptr23779 = alloca i64, align 8 
  %rva10500 = call i64 @prim_cons(i64 %MXn$x, i64 %rva10501) 
  store volatile i64 %rva10500, i64* %vptr23779, align 8 ; call prim_cons
 %vptr23780 = alloca i64, align 8 
  %rva10499 = call i64 @prim_cons(i64 %arg8174, i64 %rva10500) 
  store volatile i64 %rva10499, i64* %vptr23780, align 8 ; call prim_cons
  %vptr23786 = alloca i64*, align 8 
  %cloptr23781 = inttoptr i64 %a7057 to i64* 
  store volatile i64* %cloptr23781, i64** %vptr23786, align 8 ; closure/env cast; i64 -> i64*
  %vptr23787 = alloca i64*, align 8 
  %i0ptr23782 = getelementptr inbounds i64, i64* %cloptr23781, i64 1 
  store volatile i64* %i0ptr23782, i64** %vptr23787, align 8 ; &cloptr23781[1]
 %vptr23788 = alloca i64, align 8 
  %f23784 = load i64, i64* %i0ptr23782, align 8 
  store volatile i64 %f23784, i64* %vptr23788, align 8 ; load; *i0ptr23782
  %fptr23783 = inttoptr i64 %f23784 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23783(i64 %a7057, i64 %rva10499)                    ; tail call
  ret void

else23743:
 %vptr23789 = alloca i64, align 8 
  %h10504 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10504, i64* %vptr23789, align 8 ; call prim_halt
  %vptr23795 = alloca i64*, align 8 
  %cloptr23790 = inttoptr i64 %h10504 to i64* 
  store volatile i64* %cloptr23790, i64** %vptr23795, align 8 ; closure/env cast; i64 -> i64*
  %vptr23796 = alloca i64*, align 8 
  %i0ptr23791 = getelementptr inbounds i64, i64* %cloptr23790, i64 1 
  store volatile i64* %i0ptr23791, i64** %vptr23796, align 8 ; &cloptr23790[1]
 %vptr23797 = alloca i64, align 8 
  %f23793 = load i64, i64* %i0ptr23791, align 8 
  store volatile i64 %f23793, i64* %vptr23797, align 8 ; load; *i0ptr23791
  %fptr23792 = inttoptr i64 %f23793 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23792(i64 %h10504, i64 %h10504)                     ; tail call
  ret void
}


define void @lam11868(i64 %env11869, i64 %rvp10495) {
 %vptr23800 = alloca i64, align 8 
  %envptr23798 = inttoptr i64 %env11869 to i64* 
  store volatile i64 %cont7229, i64* %vptr23800, align 8 ; closure/env cast; i64 -> i64*
  %vptr23801 = alloca i64*, align 8 
  %envptr23799 = getelementptr inbounds i64, i64* %envptr23798, i64 13 
  store volatile i64* %envptr23799, i64** %vptr23801, align 8 ; &envptr23798[12]
 %vptr23802 = alloca i64, align 8 
  %cont7229 = load i64, i64* %envptr23799, align 8 
  store volatile i64 %cont7229, i64* %vptr23802, align 8 ; load; *envptr23799
 %vptr23805 = alloca i64, align 8 
  %envptr23803 = inttoptr i64 %env11869 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr23805, align 8 ; closure/env cast; i64 -> i64*
  %vptr23806 = alloca i64*, align 8 
  %envptr23804 = getelementptr inbounds i64, i64* %envptr23803, i64 12 
  store volatile i64* %envptr23804, i64** %vptr23806, align 8 ; &envptr23803[11]
 %vptr23807 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr23804, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr23807, align 8 ; load; *envptr23804
 %vptr23810 = alloca i64, align 8 
  %envptr23808 = inttoptr i64 %env11869 to i64* 
  store volatile i64 %bbE$z_63, i64* %vptr23810, align 8 ; closure/env cast; i64 -> i64*
  %vptr23811 = alloca i64*, align 8 
  %envptr23809 = getelementptr inbounds i64, i64* %envptr23808, i64 11 
  store volatile i64* %envptr23809, i64** %vptr23811, align 8 ; &envptr23808[10]
 %vptr23812 = alloca i64, align 8 
  %bbE$z_63 = load i64, i64* %envptr23809, align 8 
  store volatile i64 %bbE$z_63, i64* %vptr23812, align 8 ; load; *envptr23809
 %vptr23815 = alloca i64, align 8 
  %envptr23813 = inttoptr i64 %env11869 to i64* 
  store volatile i64 %emsg08636, i64* %vptr23815, align 8 ; closure/env cast; i64 -> i64*
  %vptr23816 = alloca i64*, align 8 
  %envptr23814 = getelementptr inbounds i64, i64* %envptr23813, i64 10 
  store volatile i64* %envptr23814, i64** %vptr23816, align 8 ; &envptr23813[9]
 %vptr23817 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr23814, align 8 
  store volatile i64 %emsg08636, i64* %vptr23817, align 8 ; load; *envptr23814
 %vptr23820 = alloca i64, align 8 
  %envptr23818 = inttoptr i64 %env11869 to i64* 
  store volatile i64 %MXn$x, i64* %vptr23820, align 8 ; closure/env cast; i64 -> i64*
  %vptr23821 = alloca i64*, align 8 
  %envptr23819 = getelementptr inbounds i64, i64* %envptr23818, i64 9 
  store volatile i64* %envptr23819, i64** %vptr23821, align 8 ; &envptr23818[8]
 %vptr23822 = alloca i64, align 8 
  %MXn$x = load i64, i64* %envptr23819, align 8 
  store volatile i64 %MXn$x, i64* %vptr23822, align 8 ; load; *envptr23819
 %vptr23825 = alloca i64, align 8 
  %envptr23823 = inttoptr i64 %env11869 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr23825, align 8 ; closure/env cast; i64 -> i64*
  %vptr23826 = alloca i64*, align 8 
  %envptr23824 = getelementptr inbounds i64, i64* %envptr23823, i64 8 
  store volatile i64* %envptr23824, i64** %vptr23826, align 8 ; &envptr23823[7]
 %vptr23827 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr23824, align 8 
  store volatile i64 %Pll$pred, i64* %vptr23827, align 8 ; load; *envptr23824
 %vptr23830 = alloca i64, align 8 
  %envptr23828 = inttoptr i64 %env11869 to i64* 
  store volatile i64 %ZpZ$c, i64* %vptr23830, align 8 ; closure/env cast; i64 -> i64*
  %vptr23831 = alloca i64*, align 8 
  %envptr23829 = getelementptr inbounds i64, i64* %envptr23828, i64 7 
  store volatile i64* %envptr23829, i64** %vptr23831, align 8 ; &envptr23828[6]
 %vptr23832 = alloca i64, align 8 
  %ZpZ$c = load i64, i64* %envptr23829, align 8 
  store volatile i64 %ZpZ$c, i64* %vptr23832, align 8 ; load; *envptr23829
 %vptr23835 = alloca i64, align 8 
  %envptr23833 = inttoptr i64 %env11869 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr23835, align 8 ; closure/env cast; i64 -> i64*
  %vptr23836 = alloca i64*, align 8 
  %envptr23834 = getelementptr inbounds i64, i64* %envptr23833, i64 6 
  store volatile i64* %envptr23834, i64** %vptr23836, align 8 ; &envptr23833[5]
 %vptr23837 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr23834, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr23837, align 8 ; load; *envptr23834
 %vptr23840 = alloca i64, align 8 
  %envptr23838 = inttoptr i64 %env11869 to i64* 
  store volatile i64 %Ttp$addc, i64* %vptr23840, align 8 ; closure/env cast; i64 -> i64*
  %vptr23841 = alloca i64*, align 8 
  %envptr23839 = getelementptr inbounds i64, i64* %envptr23838, i64 5 
  store volatile i64* %envptr23839, i64** %vptr23841, align 8 ; &envptr23838[4]
 %vptr23842 = alloca i64, align 8 
  %Ttp$addc = load i64, i64* %envptr23839, align 8 
  store volatile i64 %Ttp$addc, i64* %vptr23842, align 8 ; load; *envptr23839
 %vptr23845 = alloca i64, align 8 
  %envptr23843 = inttoptr i64 %env11869 to i64* 
  store volatile i64 %YxK$fibc, i64* %vptr23845, align 8 ; closure/env cast; i64 -> i64*
  %vptr23846 = alloca i64*, align 8 
  %envptr23844 = getelementptr inbounds i64, i64* %envptr23843, i64 4 
  store volatile i64* %envptr23844, i64** %vptr23846, align 8 ; &envptr23843[3]
 %vptr23847 = alloca i64, align 8 
  %YxK$fibc = load i64, i64* %envptr23844, align 8 
  store volatile i64 %YxK$fibc, i64* %vptr23847, align 8 ; load; *envptr23844
 %vptr23850 = alloca i64, align 8 
  %envptr23848 = inttoptr i64 %env11869 to i64* 
  store volatile i64 %emsg18637, i64* %vptr23850, align 8 ; closure/env cast; i64 -> i64*
  %vptr23851 = alloca i64*, align 8 
  %envptr23849 = getelementptr inbounds i64, i64* %envptr23848, i64 3 
  store volatile i64* %envptr23849, i64** %vptr23851, align 8 ; &envptr23848[2]
 %vptr23852 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr23849, align 8 
  store volatile i64 %emsg18637, i64* %vptr23852, align 8 ; load; *envptr23849
 %vptr23855 = alloca i64, align 8 
  %envptr23853 = inttoptr i64 %env11869 to i64* 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr23855, align 8 ; closure/env cast; i64 -> i64*
  %vptr23856 = alloca i64*, align 8 
  %envptr23854 = getelementptr inbounds i64, i64* %envptr23853, i64 2 
  store volatile i64* %envptr23854, i64** %vptr23856, align 8 ; &envptr23853[1]
 %vptr23857 = alloca i64, align 8 
  %bmP$nat_45_62peano = load i64, i64* %envptr23854, align 8 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr23857, align 8 ; load; *envptr23854
 %vptr23858 = alloca i64, align 8 
  %_957230 = call i64 @prim_car(i64 %rvp10495) 
  store volatile i64 %_957230, i64* %vptr23858, align 8 ; call prim_car
 %vptr23859 = alloca i64, align 8 
  %rvp10491 = call i64 @prim_cdr(i64 %rvp10495) 
  store volatile i64 %rvp10491, i64* %vptr23859, align 8 ; call prim_cdr
 %vptr23860 = alloca i64, align 8 
  %n_6310496 = call i64 @prim_null_63(i64 %rvp10491) 
  store volatile i64 %n_6310496, i64* %vptr23860, align 8 ; call prim_null_63
  %cmpptr23864 = alloca i1, align 8  %cmp23861 = icmp eq i64 %n_6310496, 15 store volatile i1 %cmp23861, i1* %cmpptr23864, align 8; false?
  br i1 %cmp23861, label %else23863, label %then23862                                ; if

then23862:
 %vptr23865 = alloca i64, align 8 
  %h10497 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10497, i64* %vptr23865, align 8 ; call prim_halt
  %vptr23871 = alloca i64*, align 8 
  %cloptr23866 = inttoptr i64 %h10497 to i64* 
  store volatile i64* %cloptr23866, i64** %vptr23871, align 8 ; closure/env cast; i64 -> i64*
  %vptr23872 = alloca i64*, align 8 
  %i0ptr23867 = getelementptr inbounds i64, i64* %cloptr23866, i64 1 
  store volatile i64* %i0ptr23867, i64** %vptr23872, align 8 ; &cloptr23866[1]
 %vptr23873 = alloca i64, align 8 
  %f23869 = load i64, i64* %i0ptr23867, align 8 
  store volatile i64 %f23869, i64* %vptr23873, align 8 ; load; *i0ptr23867
  %fptr23868 = inttoptr i64 %f23869 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23868(i64 %h10497, i64 %h10497)                     ; tail call
  ret void

else23863:
 %vptr23874 = alloca i64, align 8 
  %a7058 = call i64 @prim_car(i64 %rvp10491) 
  store volatile i64 %a7058, i64* %vptr23874, align 8 ; call prim_car
 %vptr23875 = alloca i64, align 8 
  %na10032 = call i64 @prim_cdr(i64 %rvp10491) 
  store volatile i64 %na10032, i64* %vptr23875, align 8 ; call prim_cdr
 %vptr23876 = alloca i64, align 8 
  %n_6310492 = call i64 @prim_null_63(i64 %na10032) 
  store volatile i64 %n_6310492, i64* %vptr23876, align 8 ; call prim_null_63
  %cmpptr23880 = alloca i1, align 8  %cmp23877 = icmp eq i64 %n_6310492, 15 store volatile i1 %cmp23877, i1* %cmpptr23880, align 8; false?
  br i1 %cmp23877, label %else23879, label %then23878                                ; if

then23878:
  %cmpptr23884 = alloca i1, align 8  %cmp23881 = icmp eq i64 %a7058, 15 store volatile i1 %cmp23881, i1* %cmpptr23884, align 8; false?
  br i1 %cmp23881, label %else23883, label %then23882                                ; if

then23882:
 %vptr23885 = alloca i64, align 8 
  %arg8176 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8176, i64* %vptr23885, align 8 ; quoted int
 %vptr23886 = alloca i64, align 8 
  %a7059 = call i64 @prim_vector_45ref(i64 %bmP$nat_45_62peano, i64 %arg8176) 
  store volatile i64 %a7059, i64* %vptr23886, align 8 ; call prim_vector_45ref
  %vptr23894 = alloca i64*, align 8 
  %cloptr23887 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr23887, i64** %vptr23894, align 8 ; malloc
  %vptr23895 = alloca i64*, align 8 
  %eptr23889 = getelementptr inbounds i64, i64* %cloptr23887, i64 2 
  store volatile i64* %eptr23889, i64** %vptr23895, align 8 ; &eptr23889[1]
  %vptr23896 = alloca i64*, align 8 
  %eptr23890 = getelementptr inbounds i64, i64* %cloptr23887, i64 3 
  store volatile i64* %eptr23890, i64** %vptr23896, align 8 ; &eptr23890[2]
  %vptr23897 = alloca i64*, align 8 
  %eptr23891 = getelementptr inbounds i64, i64* %cloptr23887, i64 4 
  store volatile i64* %eptr23891, i64** %vptr23897, align 8 ; &eptr23891[3]
  %vptr23898 = alloca i64*, align 8 
  %eptr23892 = getelementptr inbounds i64, i64* %cloptr23887, i64 5 
  store volatile i64* %eptr23892, i64** %vptr23898, align 8 ; &eptr23892[4]
  store i64 %emsg18637, i64* %eptr23889                                              ; *eptr23889 = %emsg18637
  store i64 %ZpZ$c, i64* %eptr23890                                                  ; *eptr23890 = %ZpZ$c
  store i64 %emsg08636, i64* %eptr23891                                              ; *eptr23891 = %emsg08636
  store i64 %cont7229, i64* %eptr23892                                               ; *eptr23892 = %cont7229
  %vptr23899 = alloca i64*, align 8 
  %eptr23888 = getelementptr inbounds i64, i64* %cloptr23887, i64 1 
  store volatile i64* %eptr23888, i64** %vptr23899, align 8 ; &cloptr23887[1]
 %vptr23900 = alloca i64, align 8 
  %f23893 = ptrtoint void(i64,i64)* @lam11739 to i64 
  store volatile i64 %f23893, i64* %vptr23900, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f23893, i64* %eptr23888                                                 ; store fptr
 %vptr23901 = alloca i64, align 8 
  %arg8179 = ptrtoint i64* %cloptr23887 to i64 
  store volatile i64 %arg8179, i64* %vptr23901, align 8 ; closure cast; i64* -> i64
 %vptr23902 = alloca i64, align 8 
  %arg8178 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8178, i64* %vptr23902, align 8 ; quoted int
 %vptr23903 = alloca i64, align 8 
  %rva10048 = add i64 0, 0 
  store volatile i64 %rva10048, i64* %vptr23903, align 8 ; quoted ()
 %vptr23904 = alloca i64, align 8 
  %rva10047 = call i64 @prim_cons(i64 %arg8178, i64 %rva10048) 
  store volatile i64 %rva10047, i64* %vptr23904, align 8 ; call prim_cons
 %vptr23905 = alloca i64, align 8 
  %rva10046 = call i64 @prim_cons(i64 %arg8179, i64 %rva10047) 
  store volatile i64 %rva10046, i64* %vptr23905, align 8 ; call prim_cons
  %vptr23911 = alloca i64*, align 8 
  %cloptr23906 = inttoptr i64 %a7059 to i64* 
  store volatile i64* %cloptr23906, i64** %vptr23911, align 8 ; closure/env cast; i64 -> i64*
  %vptr23912 = alloca i64*, align 8 
  %i0ptr23907 = getelementptr inbounds i64, i64* %cloptr23906, i64 1 
  store volatile i64* %i0ptr23907, i64** %vptr23912, align 8 ; &cloptr23906[1]
 %vptr23913 = alloca i64, align 8 
  %f23909 = load i64, i64* %i0ptr23907, align 8 
  store volatile i64 %f23909, i64* %vptr23913, align 8 ; load; *i0ptr23907
  %fptr23908 = inttoptr i64 %f23909 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23908(i64 %a7059, i64 %rva10046)                    ; tail call
  ret void

else23883:
 %vptr23914 = alloca i64, align 8 
  %arg8184 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8184, i64* %vptr23914, align 8 ; quoted int
 %vptr23915 = alloca i64, align 8 
  %a7061 = call i64 @prim_vector_45ref(i64 %bbE$z_63, i64 %arg8184) 
  store volatile i64 %a7061, i64* %vptr23915, align 8 ; call prim_vector_45ref
 %vptr23916 = alloca i64, align 8 
  %arg8186 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8186, i64* %vptr23916, align 8 ; quoted int
 %vptr23917 = alloca i64, align 8 
  %a7062 = call i64 @prim_vector_45ref(i64 %Pll$pred, i64 %arg8186) 
  store volatile i64 %a7062, i64* %vptr23917, align 8 ; call prim_vector_45ref
  %vptr23933 = alloca i64*, align 8 
  %cloptr23918 = call i64* @make_closure(i64 104) 
  store volatile i64* %cloptr23918, i64** %vptr23933, align 8 ; malloc
  %vptr23934 = alloca i64*, align 8 
  %eptr23920 = getelementptr inbounds i64, i64* %cloptr23918, i64 2 
  store volatile i64* %eptr23920, i64** %vptr23934, align 8 ; &eptr23920[1]
  %vptr23935 = alloca i64*, align 8 
  %eptr23921 = getelementptr inbounds i64, i64* %cloptr23918, i64 3 
  store volatile i64* %eptr23921, i64** %vptr23935, align 8 ; &eptr23921[2]
  %vptr23936 = alloca i64*, align 8 
  %eptr23922 = getelementptr inbounds i64, i64* %cloptr23918, i64 4 
  store volatile i64* %eptr23922, i64** %vptr23936, align 8 ; &eptr23922[3]
  %vptr23937 = alloca i64*, align 8 
  %eptr23923 = getelementptr inbounds i64, i64* %cloptr23918, i64 5 
  store volatile i64* %eptr23923, i64** %vptr23937, align 8 ; &eptr23923[4]
  %vptr23938 = alloca i64*, align 8 
  %eptr23924 = getelementptr inbounds i64, i64* %cloptr23918, i64 6 
  store volatile i64* %eptr23924, i64** %vptr23938, align 8 ; &eptr23924[5]
  %vptr23939 = alloca i64*, align 8 
  %eptr23925 = getelementptr inbounds i64, i64* %cloptr23918, i64 7 
  store volatile i64* %eptr23925, i64** %vptr23939, align 8 ; &eptr23925[6]
  %vptr23940 = alloca i64*, align 8 
  %eptr23926 = getelementptr inbounds i64, i64* %cloptr23918, i64 8 
  store volatile i64* %eptr23926, i64** %vptr23940, align 8 ; &eptr23926[7]
  %vptr23941 = alloca i64*, align 8 
  %eptr23927 = getelementptr inbounds i64, i64* %cloptr23918, i64 9 
  store volatile i64* %eptr23927, i64** %vptr23941, align 8 ; &eptr23927[8]
  %vptr23942 = alloca i64*, align 8 
  %eptr23928 = getelementptr inbounds i64, i64* %cloptr23918, i64 10 
  store volatile i64* %eptr23928, i64** %vptr23942, align 8 ; &eptr23928[9]
  %vptr23943 = alloca i64*, align 8 
  %eptr23929 = getelementptr inbounds i64, i64* %cloptr23918, i64 11 
  store volatile i64* %eptr23929, i64** %vptr23943, align 8 ; &eptr23929[10]
  %vptr23944 = alloca i64*, align 8 
  %eptr23930 = getelementptr inbounds i64, i64* %cloptr23918, i64 12 
  store volatile i64* %eptr23930, i64** %vptr23944, align 8 ; &eptr23930[11]
  %vptr23945 = alloca i64*, align 8 
  %eptr23931 = getelementptr inbounds i64, i64* %cloptr23918, i64 13 
  store volatile i64* %eptr23931, i64** %vptr23945, align 8 ; &eptr23931[12]
  store i64 %bmP$nat_45_62peano, i64* %eptr23920                                     ; *eptr23920 = %bmP$nat_45_62peano
  store i64 %emsg18637, i64* %eptr23921                                              ; *eptr23921 = %emsg18637
  store i64 %YxK$fibc, i64* %eptr23922                                               ; *eptr23922 = %YxK$fibc
  store i64 %a7061, i64* %eptr23923                                                  ; *eptr23923 = %a7061
  store i64 %Ttp$addc, i64* %eptr23924                                               ; *eptr23924 = %Ttp$addc
  store i64 %SdC$_37wind_45stack, i64* %eptr23925                                    ; *eptr23925 = %SdC$_37wind_45stack
  store i64 %ZpZ$c, i64* %eptr23926                                                  ; *eptr23926 = %ZpZ$c
  store i64 %Pll$pred, i64* %eptr23927                                               ; *eptr23927 = %Pll$pred
  store i64 %MXn$x, i64* %eptr23928                                                  ; *eptr23928 = %MXn$x
  store i64 %emsg08636, i64* %eptr23929                                              ; *eptr23929 = %emsg08636
  store i64 %U8g$_37do_45wind, i64* %eptr23930                                       ; *eptr23930 = %U8g$_37do_45wind
  store i64 %cont7229, i64* %eptr23931                                               ; *eptr23931 = %cont7229
  %vptr23946 = alloca i64*, align 8 
  %eptr23919 = getelementptr inbounds i64, i64* %cloptr23918, i64 1 
  store volatile i64* %eptr23919, i64** %vptr23946, align 8 ; &cloptr23918[1]
 %vptr23947 = alloca i64, align 8 
  %f23932 = ptrtoint void(i64,i64)* @lam11864 to i64 
  store volatile i64 %f23932, i64* %vptr23947, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f23932, i64* %eptr23919                                                 ; store fptr
 %vptr23948 = alloca i64, align 8 
  %arg8189 = ptrtoint i64* %cloptr23918 to i64 
  store volatile i64 %arg8189, i64* %vptr23948, align 8 ; closure cast; i64* -> i64
 %vptr23949 = alloca i64, align 8 
  %rva10490 = add i64 0, 0 
  store volatile i64 %rva10490, i64* %vptr23949, align 8 ; quoted ()
 %vptr23950 = alloca i64, align 8 
  %rva10489 = call i64 @prim_cons(i64 %MXn$x, i64 %rva10490) 
  store volatile i64 %rva10489, i64* %vptr23950, align 8 ; call prim_cons
 %vptr23951 = alloca i64, align 8 
  %rva10488 = call i64 @prim_cons(i64 %arg8189, i64 %rva10489) 
  store volatile i64 %rva10488, i64* %vptr23951, align 8 ; call prim_cons
  %vptr23957 = alloca i64*, align 8 
  %cloptr23952 = inttoptr i64 %a7062 to i64* 
  store volatile i64* %cloptr23952, i64** %vptr23957, align 8 ; closure/env cast; i64 -> i64*
  %vptr23958 = alloca i64*, align 8 
  %i0ptr23953 = getelementptr inbounds i64, i64* %cloptr23952, i64 1 
  store volatile i64* %i0ptr23953, i64** %vptr23958, align 8 ; &cloptr23952[1]
 %vptr23959 = alloca i64, align 8 
  %f23955 = load i64, i64* %i0ptr23953, align 8 
  store volatile i64 %f23955, i64* %vptr23959, align 8 ; load; *i0ptr23953
  %fptr23954 = inttoptr i64 %f23955 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23954(i64 %a7062, i64 %rva10488)                    ; tail call
  ret void

else23879:
 %vptr23960 = alloca i64, align 8 
  %h10493 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10493, i64* %vptr23960, align 8 ; call prim_halt
  %vptr23966 = alloca i64*, align 8 
  %cloptr23961 = inttoptr i64 %h10493 to i64* 
  store volatile i64* %cloptr23961, i64** %vptr23966, align 8 ; closure/env cast; i64 -> i64*
  %vptr23967 = alloca i64*, align 8 
  %i0ptr23962 = getelementptr inbounds i64, i64* %cloptr23961, i64 1 
  store volatile i64* %i0ptr23962, i64** %vptr23967, align 8 ; &cloptr23961[1]
 %vptr23968 = alloca i64, align 8 
  %f23964 = load i64, i64* %i0ptr23962, align 8 
  store volatile i64 %f23964, i64* %vptr23968, align 8 ; load; *i0ptr23962
  %fptr23963 = inttoptr i64 %f23964 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr23963(i64 %h10493, i64 %h10493)                     ; tail call
  ret void
}


define void @lam11864(i64 %env11865, i64 %rvp10484) {
 %vptr23971 = alloca i64, align 8 
  %envptr23969 = inttoptr i64 %env11865 to i64* 
  store volatile i64 %cont7229, i64* %vptr23971, align 8 ; closure/env cast; i64 -> i64*
  %vptr23972 = alloca i64*, align 8 
  %envptr23970 = getelementptr inbounds i64, i64* %envptr23969, i64 13 
  store volatile i64* %envptr23970, i64** %vptr23972, align 8 ; &envptr23969[12]
 %vptr23973 = alloca i64, align 8 
  %cont7229 = load i64, i64* %envptr23970, align 8 
  store volatile i64 %cont7229, i64* %vptr23973, align 8 ; load; *envptr23970
 %vptr23976 = alloca i64, align 8 
  %envptr23974 = inttoptr i64 %env11865 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr23976, align 8 ; closure/env cast; i64 -> i64*
  %vptr23977 = alloca i64*, align 8 
  %envptr23975 = getelementptr inbounds i64, i64* %envptr23974, i64 12 
  store volatile i64* %envptr23975, i64** %vptr23977, align 8 ; &envptr23974[11]
 %vptr23978 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr23975, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr23978, align 8 ; load; *envptr23975
 %vptr23981 = alloca i64, align 8 
  %envptr23979 = inttoptr i64 %env11865 to i64* 
  store volatile i64 %emsg08636, i64* %vptr23981, align 8 ; closure/env cast; i64 -> i64*
  %vptr23982 = alloca i64*, align 8 
  %envptr23980 = getelementptr inbounds i64, i64* %envptr23979, i64 11 
  store volatile i64* %envptr23980, i64** %vptr23982, align 8 ; &envptr23979[10]
 %vptr23983 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr23980, align 8 
  store volatile i64 %emsg08636, i64* %vptr23983, align 8 ; load; *envptr23980
 %vptr23986 = alloca i64, align 8 
  %envptr23984 = inttoptr i64 %env11865 to i64* 
  store volatile i64 %MXn$x, i64* %vptr23986, align 8 ; closure/env cast; i64 -> i64*
  %vptr23987 = alloca i64*, align 8 
  %envptr23985 = getelementptr inbounds i64, i64* %envptr23984, i64 10 
  store volatile i64* %envptr23985, i64** %vptr23987, align 8 ; &envptr23984[9]
 %vptr23988 = alloca i64, align 8 
  %MXn$x = load i64, i64* %envptr23985, align 8 
  store volatile i64 %MXn$x, i64* %vptr23988, align 8 ; load; *envptr23985
 %vptr23991 = alloca i64, align 8 
  %envptr23989 = inttoptr i64 %env11865 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr23991, align 8 ; closure/env cast; i64 -> i64*
  %vptr23992 = alloca i64*, align 8 
  %envptr23990 = getelementptr inbounds i64, i64* %envptr23989, i64 9 
  store volatile i64* %envptr23990, i64** %vptr23992, align 8 ; &envptr23989[8]
 %vptr23993 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr23990, align 8 
  store volatile i64 %Pll$pred, i64* %vptr23993, align 8 ; load; *envptr23990
 %vptr23996 = alloca i64, align 8 
  %envptr23994 = inttoptr i64 %env11865 to i64* 
  store volatile i64 %ZpZ$c, i64* %vptr23996, align 8 ; closure/env cast; i64 -> i64*
  %vptr23997 = alloca i64*, align 8 
  %envptr23995 = getelementptr inbounds i64, i64* %envptr23994, i64 8 
  store volatile i64* %envptr23995, i64** %vptr23997, align 8 ; &envptr23994[7]
 %vptr23998 = alloca i64, align 8 
  %ZpZ$c = load i64, i64* %envptr23995, align 8 
  store volatile i64 %ZpZ$c, i64* %vptr23998, align 8 ; load; *envptr23995
 %vptr24001 = alloca i64, align 8 
  %envptr23999 = inttoptr i64 %env11865 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr24001, align 8 ; closure/env cast; i64 -> i64*
  %vptr24002 = alloca i64*, align 8 
  %envptr24000 = getelementptr inbounds i64, i64* %envptr23999, i64 7 
  store volatile i64* %envptr24000, i64** %vptr24002, align 8 ; &envptr23999[6]
 %vptr24003 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr24000, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr24003, align 8 ; load; *envptr24000
 %vptr24006 = alloca i64, align 8 
  %envptr24004 = inttoptr i64 %env11865 to i64* 
  store volatile i64 %Ttp$addc, i64* %vptr24006, align 8 ; closure/env cast; i64 -> i64*
  %vptr24007 = alloca i64*, align 8 
  %envptr24005 = getelementptr inbounds i64, i64* %envptr24004, i64 6 
  store volatile i64* %envptr24005, i64** %vptr24007, align 8 ; &envptr24004[5]
 %vptr24008 = alloca i64, align 8 
  %Ttp$addc = load i64, i64* %envptr24005, align 8 
  store volatile i64 %Ttp$addc, i64* %vptr24008, align 8 ; load; *envptr24005
 %vptr24011 = alloca i64, align 8 
  %envptr24009 = inttoptr i64 %env11865 to i64* 
  store volatile i64 %a7061, i64* %vptr24011, align 8 ; closure/env cast; i64 -> i64*
  %vptr24012 = alloca i64*, align 8 
  %envptr24010 = getelementptr inbounds i64, i64* %envptr24009, i64 5 
  store volatile i64* %envptr24010, i64** %vptr24012, align 8 ; &envptr24009[4]
 %vptr24013 = alloca i64, align 8 
  %a7061 = load i64, i64* %envptr24010, align 8 
  store volatile i64 %a7061, i64* %vptr24013, align 8 ; load; *envptr24010
 %vptr24016 = alloca i64, align 8 
  %envptr24014 = inttoptr i64 %env11865 to i64* 
  store volatile i64 %YxK$fibc, i64* %vptr24016, align 8 ; closure/env cast; i64 -> i64*
  %vptr24017 = alloca i64*, align 8 
  %envptr24015 = getelementptr inbounds i64, i64* %envptr24014, i64 4 
  store volatile i64* %envptr24015, i64** %vptr24017, align 8 ; &envptr24014[3]
 %vptr24018 = alloca i64, align 8 
  %YxK$fibc = load i64, i64* %envptr24015, align 8 
  store volatile i64 %YxK$fibc, i64* %vptr24018, align 8 ; load; *envptr24015
 %vptr24021 = alloca i64, align 8 
  %envptr24019 = inttoptr i64 %env11865 to i64* 
  store volatile i64 %emsg18637, i64* %vptr24021, align 8 ; closure/env cast; i64 -> i64*
  %vptr24022 = alloca i64*, align 8 
  %envptr24020 = getelementptr inbounds i64, i64* %envptr24019, i64 3 
  store volatile i64* %envptr24020, i64** %vptr24022, align 8 ; &envptr24019[2]
 %vptr24023 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr24020, align 8 
  store volatile i64 %emsg18637, i64* %vptr24023, align 8 ; load; *envptr24020
 %vptr24026 = alloca i64, align 8 
  %envptr24024 = inttoptr i64 %env11865 to i64* 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr24026, align 8 ; closure/env cast; i64 -> i64*
  %vptr24027 = alloca i64*, align 8 
  %envptr24025 = getelementptr inbounds i64, i64* %envptr24024, i64 2 
  store volatile i64* %envptr24025, i64** %vptr24027, align 8 ; &envptr24024[1]
 %vptr24028 = alloca i64, align 8 
  %bmP$nat_45_62peano = load i64, i64* %envptr24025, align 8 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr24028, align 8 ; load; *envptr24025
 %vptr24029 = alloca i64, align 8 
  %_957232 = call i64 @prim_car(i64 %rvp10484) 
  store volatile i64 %_957232, i64* %vptr24029, align 8 ; call prim_car
 %vptr24030 = alloca i64, align 8 
  %rvp10480 = call i64 @prim_cdr(i64 %rvp10484) 
  store volatile i64 %rvp10480, i64* %vptr24030, align 8 ; call prim_cdr
 %vptr24031 = alloca i64, align 8 
  %n_6310485 = call i64 @prim_null_63(i64 %rvp10480) 
  store volatile i64 %n_6310485, i64* %vptr24031, align 8 ; call prim_null_63
  %cmpptr24035 = alloca i1, align 8  %cmp24032 = icmp eq i64 %n_6310485, 15 store volatile i1 %cmp24032, i1* %cmpptr24035, align 8; false?
  br i1 %cmp24032, label %else24034, label %then24033                                ; if

then24033:
 %vptr24036 = alloca i64, align 8 
  %h10486 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10486, i64* %vptr24036, align 8 ; call prim_halt
  %vptr24042 = alloca i64*, align 8 
  %cloptr24037 = inttoptr i64 %h10486 to i64* 
  store volatile i64* %cloptr24037, i64** %vptr24042, align 8 ; closure/env cast; i64 -> i64*
  %vptr24043 = alloca i64*, align 8 
  %i0ptr24038 = getelementptr inbounds i64, i64* %cloptr24037, i64 1 
  store volatile i64* %i0ptr24038, i64** %vptr24043, align 8 ; &cloptr24037[1]
 %vptr24044 = alloca i64, align 8 
  %f24040 = load i64, i64* %i0ptr24038, align 8 
  store volatile i64 %f24040, i64* %vptr24044, align 8 ; load; *i0ptr24038
  %fptr24039 = inttoptr i64 %f24040 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24039(i64 %h10486, i64 %h10486)                     ; tail call
  ret void

else24034:
 %vptr24045 = alloca i64, align 8 
  %a7063 = call i64 @prim_car(i64 %rvp10480) 
  store volatile i64 %a7063, i64* %vptr24045, align 8 ; call prim_car
 %vptr24046 = alloca i64, align 8 
  %na10050 = call i64 @prim_cdr(i64 %rvp10480) 
  store volatile i64 %na10050, i64* %vptr24046, align 8 ; call prim_cdr
 %vptr24047 = alloca i64, align 8 
  %n_6310481 = call i64 @prim_null_63(i64 %na10050) 
  store volatile i64 %n_6310481, i64* %vptr24047, align 8 ; call prim_null_63
  %cmpptr24051 = alloca i1, align 8  %cmp24048 = icmp eq i64 %n_6310481, 15 store volatile i1 %cmp24048, i1* %cmpptr24051, align 8; false?
  br i1 %cmp24048, label %else24050, label %then24049                                ; if

then24049:
  %vptr24066 = alloca i64*, align 8 
  %cloptr24052 = call i64* @make_closure(i64 96) 
  store volatile i64* %cloptr24052, i64** %vptr24066, align 8 ; malloc
  %vptr24067 = alloca i64*, align 8 
  %eptr24054 = getelementptr inbounds i64, i64* %cloptr24052, i64 2 
  store volatile i64* %eptr24054, i64** %vptr24067, align 8 ; &eptr24054[1]
  %vptr24068 = alloca i64*, align 8 
  %eptr24055 = getelementptr inbounds i64, i64* %cloptr24052, i64 3 
  store volatile i64* %eptr24055, i64** %vptr24068, align 8 ; &eptr24055[2]
  %vptr24069 = alloca i64*, align 8 
  %eptr24056 = getelementptr inbounds i64, i64* %cloptr24052, i64 4 
  store volatile i64* %eptr24056, i64** %vptr24069, align 8 ; &eptr24056[3]
  %vptr24070 = alloca i64*, align 8 
  %eptr24057 = getelementptr inbounds i64, i64* %cloptr24052, i64 5 
  store volatile i64* %eptr24057, i64** %vptr24070, align 8 ; &eptr24057[4]
  %vptr24071 = alloca i64*, align 8 
  %eptr24058 = getelementptr inbounds i64, i64* %cloptr24052, i64 6 
  store volatile i64* %eptr24058, i64** %vptr24071, align 8 ; &eptr24058[5]
  %vptr24072 = alloca i64*, align 8 
  %eptr24059 = getelementptr inbounds i64, i64* %cloptr24052, i64 7 
  store volatile i64* %eptr24059, i64** %vptr24072, align 8 ; &eptr24059[6]
  %vptr24073 = alloca i64*, align 8 
  %eptr24060 = getelementptr inbounds i64, i64* %cloptr24052, i64 8 
  store volatile i64* %eptr24060, i64** %vptr24073, align 8 ; &eptr24060[7]
  %vptr24074 = alloca i64*, align 8 
  %eptr24061 = getelementptr inbounds i64, i64* %cloptr24052, i64 9 
  store volatile i64* %eptr24061, i64** %vptr24074, align 8 ; &eptr24061[8]
  %vptr24075 = alloca i64*, align 8 
  %eptr24062 = getelementptr inbounds i64, i64* %cloptr24052, i64 10 
  store volatile i64* %eptr24062, i64** %vptr24075, align 8 ; &eptr24062[9]
  %vptr24076 = alloca i64*, align 8 
  %eptr24063 = getelementptr inbounds i64, i64* %cloptr24052, i64 11 
  store volatile i64* %eptr24063, i64** %vptr24076, align 8 ; &eptr24063[10]
  %vptr24077 = alloca i64*, align 8 
  %eptr24064 = getelementptr inbounds i64, i64* %cloptr24052, i64 12 
  store volatile i64* %eptr24064, i64** %vptr24077, align 8 ; &eptr24064[11]
  store i64 %bmP$nat_45_62peano, i64* %eptr24054                                     ; *eptr24054 = %bmP$nat_45_62peano
  store i64 %emsg18637, i64* %eptr24055                                              ; *eptr24055 = %emsg18637
  store i64 %YxK$fibc, i64* %eptr24056                                               ; *eptr24056 = %YxK$fibc
  store i64 %Ttp$addc, i64* %eptr24057                                               ; *eptr24057 = %Ttp$addc
  store i64 %SdC$_37wind_45stack, i64* %eptr24058                                    ; *eptr24058 = %SdC$_37wind_45stack
  store i64 %ZpZ$c, i64* %eptr24059                                                  ; *eptr24059 = %ZpZ$c
  store i64 %Pll$pred, i64* %eptr24060                                               ; *eptr24060 = %Pll$pred
  store i64 %MXn$x, i64* %eptr24061                                                  ; *eptr24061 = %MXn$x
  store i64 %emsg08636, i64* %eptr24062                                              ; *eptr24062 = %emsg08636
  store i64 %U8g$_37do_45wind, i64* %eptr24063                                       ; *eptr24063 = %U8g$_37do_45wind
  store i64 %cont7229, i64* %eptr24064                                               ; *eptr24064 = %cont7229
  %vptr24078 = alloca i64*, align 8 
  %eptr24053 = getelementptr inbounds i64, i64* %cloptr24052, i64 1 
  store volatile i64* %eptr24053, i64** %vptr24078, align 8 ; &cloptr24052[1]
 %vptr24079 = alloca i64, align 8 
  %f24065 = ptrtoint void(i64,i64)* @lam11862 to i64 
  store volatile i64 %f24065, i64* %vptr24079, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f24065, i64* %eptr24053                                                 ; store fptr
 %vptr24080 = alloca i64, align 8 
  %arg8192 = ptrtoint i64* %cloptr24052 to i64 
  store volatile i64 %arg8192, i64* %vptr24080, align 8 ; closure cast; i64* -> i64
 %vptr24081 = alloca i64, align 8 
  %rva10479 = add i64 0, 0 
  store volatile i64 %rva10479, i64* %vptr24081, align 8 ; quoted ()
 %vptr24082 = alloca i64, align 8 
  %rva10478 = call i64 @prim_cons(i64 %a7063, i64 %rva10479) 
  store volatile i64 %rva10478, i64* %vptr24082, align 8 ; call prim_cons
 %vptr24083 = alloca i64, align 8 
  %rva10477 = call i64 @prim_cons(i64 %arg8192, i64 %rva10478) 
  store volatile i64 %rva10477, i64* %vptr24083, align 8 ; call prim_cons
  %vptr24089 = alloca i64*, align 8 
  %cloptr24084 = inttoptr i64 %a7061 to i64* 
  store volatile i64* %cloptr24084, i64** %vptr24089, align 8 ; closure/env cast; i64 -> i64*
  %vptr24090 = alloca i64*, align 8 
  %i0ptr24085 = getelementptr inbounds i64, i64* %cloptr24084, i64 1 
  store volatile i64* %i0ptr24085, i64** %vptr24090, align 8 ; &cloptr24084[1]
 %vptr24091 = alloca i64, align 8 
  %f24087 = load i64, i64* %i0ptr24085, align 8 
  store volatile i64 %f24087, i64* %vptr24091, align 8 ; load; *i0ptr24085
  %fptr24086 = inttoptr i64 %f24087 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24086(i64 %a7061, i64 %rva10477)                    ; tail call
  ret void

else24050:
 %vptr24092 = alloca i64, align 8 
  %h10482 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10482, i64* %vptr24092, align 8 ; call prim_halt
  %vptr24098 = alloca i64*, align 8 
  %cloptr24093 = inttoptr i64 %h10482 to i64* 
  store volatile i64* %cloptr24093, i64** %vptr24098, align 8 ; closure/env cast; i64 -> i64*
  %vptr24099 = alloca i64*, align 8 
  %i0ptr24094 = getelementptr inbounds i64, i64* %cloptr24093, i64 1 
  store volatile i64* %i0ptr24094, i64** %vptr24099, align 8 ; &cloptr24093[1]
 %vptr24100 = alloca i64, align 8 
  %f24096 = load i64, i64* %i0ptr24094, align 8 
  store volatile i64 %f24096, i64* %vptr24100, align 8 ; load; *i0ptr24094
  %fptr24095 = inttoptr i64 %f24096 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24095(i64 %h10482, i64 %h10482)                     ; tail call
  ret void
}


define void @lam11862(i64 %env11863, i64 %rvp10473) {
 %vptr24103 = alloca i64, align 8 
  %envptr24101 = inttoptr i64 %env11863 to i64* 
  store volatile i64 %cont7229, i64* %vptr24103, align 8 ; closure/env cast; i64 -> i64*
  %vptr24104 = alloca i64*, align 8 
  %envptr24102 = getelementptr inbounds i64, i64* %envptr24101, i64 12 
  store volatile i64* %envptr24102, i64** %vptr24104, align 8 ; &envptr24101[11]
 %vptr24105 = alloca i64, align 8 
  %cont7229 = load i64, i64* %envptr24102, align 8 
  store volatile i64 %cont7229, i64* %vptr24105, align 8 ; load; *envptr24102
 %vptr24108 = alloca i64, align 8 
  %envptr24106 = inttoptr i64 %env11863 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr24108, align 8 ; closure/env cast; i64 -> i64*
  %vptr24109 = alloca i64*, align 8 
  %envptr24107 = getelementptr inbounds i64, i64* %envptr24106, i64 11 
  store volatile i64* %envptr24107, i64** %vptr24109, align 8 ; &envptr24106[10]
 %vptr24110 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr24107, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr24110, align 8 ; load; *envptr24107
 %vptr24113 = alloca i64, align 8 
  %envptr24111 = inttoptr i64 %env11863 to i64* 
  store volatile i64 %emsg08636, i64* %vptr24113, align 8 ; closure/env cast; i64 -> i64*
  %vptr24114 = alloca i64*, align 8 
  %envptr24112 = getelementptr inbounds i64, i64* %envptr24111, i64 10 
  store volatile i64* %envptr24112, i64** %vptr24114, align 8 ; &envptr24111[9]
 %vptr24115 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr24112, align 8 
  store volatile i64 %emsg08636, i64* %vptr24115, align 8 ; load; *envptr24112
 %vptr24118 = alloca i64, align 8 
  %envptr24116 = inttoptr i64 %env11863 to i64* 
  store volatile i64 %MXn$x, i64* %vptr24118, align 8 ; closure/env cast; i64 -> i64*
  %vptr24119 = alloca i64*, align 8 
  %envptr24117 = getelementptr inbounds i64, i64* %envptr24116, i64 9 
  store volatile i64* %envptr24117, i64** %vptr24119, align 8 ; &envptr24116[8]
 %vptr24120 = alloca i64, align 8 
  %MXn$x = load i64, i64* %envptr24117, align 8 
  store volatile i64 %MXn$x, i64* %vptr24120, align 8 ; load; *envptr24117
 %vptr24123 = alloca i64, align 8 
  %envptr24121 = inttoptr i64 %env11863 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr24123, align 8 ; closure/env cast; i64 -> i64*
  %vptr24124 = alloca i64*, align 8 
  %envptr24122 = getelementptr inbounds i64, i64* %envptr24121, i64 8 
  store volatile i64* %envptr24122, i64** %vptr24124, align 8 ; &envptr24121[7]
 %vptr24125 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr24122, align 8 
  store volatile i64 %Pll$pred, i64* %vptr24125, align 8 ; load; *envptr24122
 %vptr24128 = alloca i64, align 8 
  %envptr24126 = inttoptr i64 %env11863 to i64* 
  store volatile i64 %ZpZ$c, i64* %vptr24128, align 8 ; closure/env cast; i64 -> i64*
  %vptr24129 = alloca i64*, align 8 
  %envptr24127 = getelementptr inbounds i64, i64* %envptr24126, i64 7 
  store volatile i64* %envptr24127, i64** %vptr24129, align 8 ; &envptr24126[6]
 %vptr24130 = alloca i64, align 8 
  %ZpZ$c = load i64, i64* %envptr24127, align 8 
  store volatile i64 %ZpZ$c, i64* %vptr24130, align 8 ; load; *envptr24127
 %vptr24133 = alloca i64, align 8 
  %envptr24131 = inttoptr i64 %env11863 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr24133, align 8 ; closure/env cast; i64 -> i64*
  %vptr24134 = alloca i64*, align 8 
  %envptr24132 = getelementptr inbounds i64, i64* %envptr24131, i64 6 
  store volatile i64* %envptr24132, i64** %vptr24134, align 8 ; &envptr24131[5]
 %vptr24135 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr24132, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr24135, align 8 ; load; *envptr24132
 %vptr24138 = alloca i64, align 8 
  %envptr24136 = inttoptr i64 %env11863 to i64* 
  store volatile i64 %Ttp$addc, i64* %vptr24138, align 8 ; closure/env cast; i64 -> i64*
  %vptr24139 = alloca i64*, align 8 
  %envptr24137 = getelementptr inbounds i64, i64* %envptr24136, i64 5 
  store volatile i64* %envptr24137, i64** %vptr24139, align 8 ; &envptr24136[4]
 %vptr24140 = alloca i64, align 8 
  %Ttp$addc = load i64, i64* %envptr24137, align 8 
  store volatile i64 %Ttp$addc, i64* %vptr24140, align 8 ; load; *envptr24137
 %vptr24143 = alloca i64, align 8 
  %envptr24141 = inttoptr i64 %env11863 to i64* 
  store volatile i64 %YxK$fibc, i64* %vptr24143, align 8 ; closure/env cast; i64 -> i64*
  %vptr24144 = alloca i64*, align 8 
  %envptr24142 = getelementptr inbounds i64, i64* %envptr24141, i64 4 
  store volatile i64* %envptr24142, i64** %vptr24144, align 8 ; &envptr24141[3]
 %vptr24145 = alloca i64, align 8 
  %YxK$fibc = load i64, i64* %envptr24142, align 8 
  store volatile i64 %YxK$fibc, i64* %vptr24145, align 8 ; load; *envptr24142
 %vptr24148 = alloca i64, align 8 
  %envptr24146 = inttoptr i64 %env11863 to i64* 
  store volatile i64 %emsg18637, i64* %vptr24148, align 8 ; closure/env cast; i64 -> i64*
  %vptr24149 = alloca i64*, align 8 
  %envptr24147 = getelementptr inbounds i64, i64* %envptr24146, i64 3 
  store volatile i64* %envptr24147, i64** %vptr24149, align 8 ; &envptr24146[2]
 %vptr24150 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr24147, align 8 
  store volatile i64 %emsg18637, i64* %vptr24150, align 8 ; load; *envptr24147
 %vptr24153 = alloca i64, align 8 
  %envptr24151 = inttoptr i64 %env11863 to i64* 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr24153, align 8 ; closure/env cast; i64 -> i64*
  %vptr24154 = alloca i64*, align 8 
  %envptr24152 = getelementptr inbounds i64, i64* %envptr24151, i64 2 
  store volatile i64* %envptr24152, i64** %vptr24154, align 8 ; &envptr24151[1]
 %vptr24155 = alloca i64, align 8 
  %bmP$nat_45_62peano = load i64, i64* %envptr24152, align 8 
  store volatile i64 %bmP$nat_45_62peano, i64* %vptr24155, align 8 ; load; *envptr24152
 %vptr24156 = alloca i64, align 8 
  %_957233 = call i64 @prim_car(i64 %rvp10473) 
  store volatile i64 %_957233, i64* %vptr24156, align 8 ; call prim_car
 %vptr24157 = alloca i64, align 8 
  %rvp10469 = call i64 @prim_cdr(i64 %rvp10473) 
  store volatile i64 %rvp10469, i64* %vptr24157, align 8 ; call prim_cdr
 %vptr24158 = alloca i64, align 8 
  %n_6310474 = call i64 @prim_null_63(i64 %rvp10469) 
  store volatile i64 %n_6310474, i64* %vptr24158, align 8 ; call prim_null_63
  %cmpptr24162 = alloca i1, align 8  %cmp24159 = icmp eq i64 %n_6310474, 15 store volatile i1 %cmp24159, i1* %cmpptr24162, align 8; false?
  br i1 %cmp24159, label %else24161, label %then24160                                ; if

then24160:
 %vptr24163 = alloca i64, align 8 
  %h10475 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10475, i64* %vptr24163, align 8 ; call prim_halt
  %vptr24169 = alloca i64*, align 8 
  %cloptr24164 = inttoptr i64 %h10475 to i64* 
  store volatile i64* %cloptr24164, i64** %vptr24169, align 8 ; closure/env cast; i64 -> i64*
  %vptr24170 = alloca i64*, align 8 
  %i0ptr24165 = getelementptr inbounds i64, i64* %cloptr24164, i64 1 
  store volatile i64* %i0ptr24165, i64** %vptr24170, align 8 ; &cloptr24164[1]
 %vptr24171 = alloca i64, align 8 
  %f24167 = load i64, i64* %i0ptr24165, align 8 
  store volatile i64 %f24167, i64* %vptr24171, align 8 ; load; *i0ptr24165
  %fptr24166 = inttoptr i64 %f24167 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24166(i64 %h10475, i64 %h10475)                     ; tail call
  ret void

else24161:
 %vptr24172 = alloca i64, align 8 
  %a7064 = call i64 @prim_car(i64 %rvp10469) 
  store volatile i64 %a7064, i64* %vptr24172, align 8 ; call prim_car
 %vptr24173 = alloca i64, align 8 
  %na10052 = call i64 @prim_cdr(i64 %rvp10469) 
  store volatile i64 %na10052, i64* %vptr24173, align 8 ; call prim_cdr
 %vptr24174 = alloca i64, align 8 
  %n_6310470 = call i64 @prim_null_63(i64 %na10052) 
  store volatile i64 %n_6310470, i64* %vptr24174, align 8 ; call prim_null_63
  %cmpptr24178 = alloca i1, align 8  %cmp24175 = icmp eq i64 %n_6310470, 15 store volatile i1 %cmp24175, i1* %cmpptr24178, align 8; false?
  br i1 %cmp24175, label %else24177, label %then24176                                ; if

then24176:
  %cmpptr24182 = alloca i1, align 8  %cmp24179 = icmp eq i64 %a7064, 15 store volatile i1 %cmp24179, i1* %cmpptr24182, align 8; false?
  br i1 %cmp24179, label %else24181, label %then24180                                ; if

then24180:
 %vptr24183 = alloca i64, align 8 
  %arg8194 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8194, i64* %vptr24183, align 8 ; quoted int
 %vptr24184 = alloca i64, align 8 
  %a7065 = call i64 @prim_vector_45ref(i64 %bmP$nat_45_62peano, i64 %arg8194) 
  store volatile i64 %a7065, i64* %vptr24184, align 8 ; call prim_vector_45ref
  %vptr24192 = alloca i64*, align 8 
  %cloptr24185 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr24185, i64** %vptr24192, align 8 ; malloc
  %vptr24193 = alloca i64*, align 8 
  %eptr24187 = getelementptr inbounds i64, i64* %cloptr24185, i64 2 
  store volatile i64* %eptr24187, i64** %vptr24193, align 8 ; &eptr24187[1]
  %vptr24194 = alloca i64*, align 8 
  %eptr24188 = getelementptr inbounds i64, i64* %cloptr24185, i64 3 
  store volatile i64* %eptr24188, i64** %vptr24194, align 8 ; &eptr24188[2]
  %vptr24195 = alloca i64*, align 8 
  %eptr24189 = getelementptr inbounds i64, i64* %cloptr24185, i64 4 
  store volatile i64* %eptr24189, i64** %vptr24195, align 8 ; &eptr24189[3]
  %vptr24196 = alloca i64*, align 8 
  %eptr24190 = getelementptr inbounds i64, i64* %cloptr24185, i64 5 
  store volatile i64* %eptr24190, i64** %vptr24196, align 8 ; &eptr24190[4]
  store i64 %emsg18637, i64* %eptr24187                                              ; *eptr24187 = %emsg18637
  store i64 %ZpZ$c, i64* %eptr24188                                                  ; *eptr24188 = %ZpZ$c
  store i64 %emsg08636, i64* %eptr24189                                              ; *eptr24189 = %emsg08636
  store i64 %cont7229, i64* %eptr24190                                               ; *eptr24190 = %cont7229
  %vptr24197 = alloca i64*, align 8 
  %eptr24186 = getelementptr inbounds i64, i64* %cloptr24185, i64 1 
  store volatile i64* %eptr24186, i64** %vptr24197, align 8 ; &cloptr24185[1]
 %vptr24198 = alloca i64, align 8 
  %f24191 = ptrtoint void(i64,i64)* @lam11747 to i64 
  store volatile i64 %f24191, i64* %vptr24198, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f24191, i64* %eptr24186                                                 ; store fptr
 %vptr24199 = alloca i64, align 8 
  %arg8197 = ptrtoint i64* %cloptr24185 to i64 
  store volatile i64 %arg8197, i64* %vptr24199, align 8 ; closure cast; i64* -> i64
 %vptr24200 = alloca i64, align 8 
  %arg8196 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg8196, i64* %vptr24200, align 8 ; quoted int
 %vptr24201 = alloca i64, align 8 
  %rva10068 = add i64 0, 0 
  store volatile i64 %rva10068, i64* %vptr24201, align 8 ; quoted ()
 %vptr24202 = alloca i64, align 8 
  %rva10067 = call i64 @prim_cons(i64 %arg8196, i64 %rva10068) 
  store volatile i64 %rva10067, i64* %vptr24202, align 8 ; call prim_cons
 %vptr24203 = alloca i64, align 8 
  %rva10066 = call i64 @prim_cons(i64 %arg8197, i64 %rva10067) 
  store volatile i64 %rva10066, i64* %vptr24203, align 8 ; call prim_cons
  %vptr24209 = alloca i64*, align 8 
  %cloptr24204 = inttoptr i64 %a7065 to i64* 
  store volatile i64* %cloptr24204, i64** %vptr24209, align 8 ; closure/env cast; i64 -> i64*
  %vptr24210 = alloca i64*, align 8 
  %i0ptr24205 = getelementptr inbounds i64, i64* %cloptr24204, i64 1 
  store volatile i64* %i0ptr24205, i64** %vptr24210, align 8 ; &cloptr24204[1]
 %vptr24211 = alloca i64, align 8 
  %f24207 = load i64, i64* %i0ptr24205, align 8 
  store volatile i64 %f24207, i64* %vptr24211, align 8 ; load; *i0ptr24205
  %fptr24206 = inttoptr i64 %f24207 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24206(i64 %a7065, i64 %rva10066)                    ; tail call
  ret void

else24181:
 %vptr24212 = alloca i64, align 8 
  %arg8202 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8202, i64* %vptr24212, align 8 ; quoted int
 %vptr24213 = alloca i64, align 8 
  %a7067 = call i64 @prim_vector_45ref(i64 %Ttp$addc, i64 %arg8202) 
  store volatile i64 %a7067, i64* %vptr24213, align 8 ; call prim_vector_45ref
  %vptr24224 = alloca i64*, align 8 
  %cloptr24214 = call i64* @make_closure(i64 64) 
  store volatile i64* %cloptr24214, i64** %vptr24224, align 8 ; malloc
  %vptr24225 = alloca i64*, align 8 
  %eptr24216 = getelementptr inbounds i64, i64* %cloptr24214, i64 2 
  store volatile i64* %eptr24216, i64** %vptr24225, align 8 ; &eptr24216[1]
  %vptr24226 = alloca i64*, align 8 
  %eptr24217 = getelementptr inbounds i64, i64* %cloptr24214, i64 3 
  store volatile i64* %eptr24217, i64** %vptr24226, align 8 ; &eptr24217[2]
  %vptr24227 = alloca i64*, align 8 
  %eptr24218 = getelementptr inbounds i64, i64* %cloptr24214, i64 4 
  store volatile i64* %eptr24218, i64** %vptr24227, align 8 ; &eptr24218[3]
  %vptr24228 = alloca i64*, align 8 
  %eptr24219 = getelementptr inbounds i64, i64* %cloptr24214, i64 5 
  store volatile i64* %eptr24219, i64** %vptr24228, align 8 ; &eptr24219[4]
  %vptr24229 = alloca i64*, align 8 
  %eptr24220 = getelementptr inbounds i64, i64* %cloptr24214, i64 6 
  store volatile i64* %eptr24220, i64** %vptr24229, align 8 ; &eptr24220[5]
  %vptr24230 = alloca i64*, align 8 
  %eptr24221 = getelementptr inbounds i64, i64* %cloptr24214, i64 7 
  store volatile i64* %eptr24221, i64** %vptr24230, align 8 ; &eptr24221[6]
  %vptr24231 = alloca i64*, align 8 
  %eptr24222 = getelementptr inbounds i64, i64* %cloptr24214, i64 8 
  store volatile i64* %eptr24222, i64** %vptr24231, align 8 ; &eptr24222[7]
  store i64 %emsg18637, i64* %eptr24216                                              ; *eptr24216 = %emsg18637
  store i64 %YxK$fibc, i64* %eptr24217                                               ; *eptr24217 = %YxK$fibc
  store i64 %SdC$_37wind_45stack, i64* %eptr24218                                    ; *eptr24218 = %SdC$_37wind_45stack
  store i64 %Pll$pred, i64* %eptr24219                                               ; *eptr24219 = %Pll$pred
  store i64 %MXn$x, i64* %eptr24220                                                  ; *eptr24220 = %MXn$x
  store i64 %emsg08636, i64* %eptr24221                                              ; *eptr24221 = %emsg08636
  store i64 %U8g$_37do_45wind, i64* %eptr24222                                       ; *eptr24222 = %U8g$_37do_45wind
  %vptr24232 = alloca i64*, align 8 
  %eptr24215 = getelementptr inbounds i64, i64* %cloptr24214, i64 1 
  store volatile i64* %eptr24215, i64** %vptr24232, align 8 ; &cloptr24214[1]
 %vptr24233 = alloca i64, align 8 
  %f24223 = ptrtoint void(i64,i64)* @lam11859 to i64 
  store volatile i64 %f24223, i64* %vptr24233, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f24223, i64* %eptr24215                                                 ; store fptr
 %vptr24234 = alloca i64, align 8 
  %arg8206 = ptrtoint i64* %cloptr24214 to i64 
  store volatile i64 %arg8206, i64* %vptr24234, align 8 ; closure cast; i64* -> i64
  %vptr24248 = alloca i64*, align 8 
  %cloptr24235 = call i64* @make_closure(i64 88) 
  store volatile i64* %cloptr24235, i64** %vptr24248, align 8 ; malloc
  %vptr24249 = alloca i64*, align 8 
  %eptr24237 = getelementptr inbounds i64, i64* %cloptr24235, i64 2 
  store volatile i64* %eptr24237, i64** %vptr24249, align 8 ; &eptr24237[1]
  %vptr24250 = alloca i64*, align 8 
  %eptr24238 = getelementptr inbounds i64, i64* %cloptr24235, i64 3 
  store volatile i64* %eptr24238, i64** %vptr24250, align 8 ; &eptr24238[2]
  %vptr24251 = alloca i64*, align 8 
  %eptr24239 = getelementptr inbounds i64, i64* %cloptr24235, i64 4 
  store volatile i64* %eptr24239, i64** %vptr24251, align 8 ; &eptr24239[3]
  %vptr24252 = alloca i64*, align 8 
  %eptr24240 = getelementptr inbounds i64, i64* %cloptr24235, i64 5 
  store volatile i64* %eptr24240, i64** %vptr24252, align 8 ; &eptr24240[4]
  %vptr24253 = alloca i64*, align 8 
  %eptr24241 = getelementptr inbounds i64, i64* %cloptr24235, i64 6 
  store volatile i64* %eptr24241, i64** %vptr24253, align 8 ; &eptr24241[5]
  %vptr24254 = alloca i64*, align 8 
  %eptr24242 = getelementptr inbounds i64, i64* %cloptr24235, i64 7 
  store volatile i64* %eptr24242, i64** %vptr24254, align 8 ; &eptr24242[6]
  %vptr24255 = alloca i64*, align 8 
  %eptr24243 = getelementptr inbounds i64, i64* %cloptr24235, i64 8 
  store volatile i64* %eptr24243, i64** %vptr24255, align 8 ; &eptr24243[7]
  %vptr24256 = alloca i64*, align 8 
  %eptr24244 = getelementptr inbounds i64, i64* %cloptr24235, i64 9 
  store volatile i64* %eptr24244, i64** %vptr24256, align 8 ; &eptr24244[8]
  %vptr24257 = alloca i64*, align 8 
  %eptr24245 = getelementptr inbounds i64, i64* %cloptr24235, i64 10 
  store volatile i64* %eptr24245, i64** %vptr24257, align 8 ; &eptr24245[9]
  %vptr24258 = alloca i64*, align 8 
  %eptr24246 = getelementptr inbounds i64, i64* %cloptr24235, i64 11 
  store volatile i64* %eptr24246, i64** %vptr24258, align 8 ; &eptr24246[10]
  store i64 %emsg18637, i64* %eptr24237                                              ; *eptr24237 = %emsg18637
  store i64 %YxK$fibc, i64* %eptr24238                                               ; *eptr24238 = %YxK$fibc
  store i64 %SdC$_37wind_45stack, i64* %eptr24239                                    ; *eptr24239 = %SdC$_37wind_45stack
  store i64 %ZpZ$c, i64* %eptr24240                                                  ; *eptr24240 = %ZpZ$c
  store i64 %Pll$pred, i64* %eptr24241                                               ; *eptr24241 = %Pll$pred
  store i64 %MXn$x, i64* %eptr24242                                                  ; *eptr24242 = %MXn$x
  store i64 %emsg08636, i64* %eptr24243                                              ; *eptr24243 = %emsg08636
  store i64 %a7067, i64* %eptr24244                                                  ; *eptr24244 = %a7067
  store i64 %U8g$_37do_45wind, i64* %eptr24245                                       ; *eptr24245 = %U8g$_37do_45wind
  store i64 %cont7229, i64* %eptr24246                                               ; *eptr24246 = %cont7229
  %vptr24259 = alloca i64*, align 8 
  %eptr24236 = getelementptr inbounds i64, i64* %cloptr24235, i64 1 
  store volatile i64* %eptr24236, i64** %vptr24259, align 8 ; &cloptr24235[1]
 %vptr24260 = alloca i64, align 8 
  %f24247 = ptrtoint void(i64,i64)* @lam11831 to i64 
  store volatile i64 %f24247, i64* %vptr24260, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f24247, i64* %eptr24236                                                 ; store fptr
 %vptr24261 = alloca i64, align 8 
  %arg8205 = ptrtoint i64* %cloptr24235 to i64 
  store volatile i64 %arg8205, i64* %vptr24261, align 8 ; closure cast; i64* -> i64
  %vptr24275 = alloca i64*, align 8 
  %cloptr24262 = call i64* @make_closure(i64 88) 
  store volatile i64* %cloptr24262, i64** %vptr24275, align 8 ; malloc
  %vptr24276 = alloca i64*, align 8 
  %eptr24264 = getelementptr inbounds i64, i64* %cloptr24262, i64 2 
  store volatile i64* %eptr24264, i64** %vptr24276, align 8 ; &eptr24264[1]
  %vptr24277 = alloca i64*, align 8 
  %eptr24265 = getelementptr inbounds i64, i64* %cloptr24262, i64 3 
  store volatile i64* %eptr24265, i64** %vptr24277, align 8 ; &eptr24265[2]
  %vptr24278 = alloca i64*, align 8 
  %eptr24266 = getelementptr inbounds i64, i64* %cloptr24262, i64 4 
  store volatile i64* %eptr24266, i64** %vptr24278, align 8 ; &eptr24266[3]
  %vptr24279 = alloca i64*, align 8 
  %eptr24267 = getelementptr inbounds i64, i64* %cloptr24262, i64 5 
  store volatile i64* %eptr24267, i64** %vptr24279, align 8 ; &eptr24267[4]
  %vptr24280 = alloca i64*, align 8 
  %eptr24268 = getelementptr inbounds i64, i64* %cloptr24262, i64 6 
  store volatile i64* %eptr24268, i64** %vptr24280, align 8 ; &eptr24268[5]
  %vptr24281 = alloca i64*, align 8 
  %eptr24269 = getelementptr inbounds i64, i64* %cloptr24262, i64 7 
  store volatile i64* %eptr24269, i64** %vptr24281, align 8 ; &eptr24269[6]
  %vptr24282 = alloca i64*, align 8 
  %eptr24270 = getelementptr inbounds i64, i64* %cloptr24262, i64 8 
  store volatile i64* %eptr24270, i64** %vptr24282, align 8 ; &eptr24270[7]
  %vptr24283 = alloca i64*, align 8 
  %eptr24271 = getelementptr inbounds i64, i64* %cloptr24262, i64 9 
  store volatile i64* %eptr24271, i64** %vptr24283, align 8 ; &eptr24271[8]
  %vptr24284 = alloca i64*, align 8 
  %eptr24272 = getelementptr inbounds i64, i64* %cloptr24262, i64 10 
  store volatile i64* %eptr24272, i64** %vptr24284, align 8 ; &eptr24272[9]
  %vptr24285 = alloca i64*, align 8 
  %eptr24273 = getelementptr inbounds i64, i64* %cloptr24262, i64 11 
  store volatile i64* %eptr24273, i64** %vptr24285, align 8 ; &eptr24273[10]
  store i64 %emsg18637, i64* %eptr24264                                              ; *eptr24264 = %emsg18637
  store i64 %YxK$fibc, i64* %eptr24265                                               ; *eptr24265 = %YxK$fibc
  store i64 %SdC$_37wind_45stack, i64* %eptr24266                                    ; *eptr24266 = %SdC$_37wind_45stack
  store i64 %ZpZ$c, i64* %eptr24267                                                  ; *eptr24267 = %ZpZ$c
  store i64 %Pll$pred, i64* %eptr24268                                               ; *eptr24268 = %Pll$pred
  store i64 %MXn$x, i64* %eptr24269                                                  ; *eptr24269 = %MXn$x
  store i64 %emsg08636, i64* %eptr24270                                              ; *eptr24270 = %emsg08636
  store i64 %a7067, i64* %eptr24271                                                  ; *eptr24271 = %a7067
  store i64 %U8g$_37do_45wind, i64* %eptr24272                                       ; *eptr24272 = %U8g$_37do_45wind
  store i64 %cont7229, i64* %eptr24273                                               ; *eptr24273 = %cont7229
  %vptr24286 = alloca i64*, align 8 
  %eptr24263 = getelementptr inbounds i64, i64* %cloptr24262, i64 1 
  store volatile i64* %eptr24263, i64** %vptr24286, align 8 ; &cloptr24262[1]
 %vptr24287 = alloca i64, align 8 
  %f24274 = ptrtoint void(i64,i64)* @lam11790 to i64 
  store volatile i64 %f24274, i64* %vptr24287, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f24274, i64* %eptr24263                                                 ; store fptr
 %vptr24288 = alloca i64, align 8 
  %arg8204 = ptrtoint i64* %cloptr24262 to i64 
  store volatile i64 %arg8204, i64* %vptr24288, align 8 ; closure cast; i64* -> i64
 %vptr24289 = alloca i64, align 8 
  %rva10468 = add i64 0, 0 
  store volatile i64 %rva10468, i64* %vptr24289, align 8 ; quoted ()
 %vptr24290 = alloca i64, align 8 
  %rva10467 = call i64 @prim_cons(i64 %arg8204, i64 %rva10468) 
  store volatile i64 %rva10467, i64* %vptr24290, align 8 ; call prim_cons
 %vptr24291 = alloca i64, align 8 
  %rva10466 = call i64 @prim_cons(i64 %arg8205, i64 %rva10467) 
  store volatile i64 %rva10466, i64* %vptr24291, align 8 ; call prim_cons
  %vptr24297 = alloca i64*, align 8 
  %cloptr24292 = inttoptr i64 %arg8206 to i64* 
  store volatile i64* %cloptr24292, i64** %vptr24297, align 8 ; closure/env cast; i64 -> i64*
  %vptr24298 = alloca i64*, align 8 
  %i0ptr24293 = getelementptr inbounds i64, i64* %cloptr24292, i64 1 
  store volatile i64* %i0ptr24293, i64** %vptr24298, align 8 ; &cloptr24292[1]
 %vptr24299 = alloca i64, align 8 
  %f24295 = load i64, i64* %i0ptr24293, align 8 
  store volatile i64 %f24295, i64* %vptr24299, align 8 ; load; *i0ptr24293
  %fptr24294 = inttoptr i64 %f24295 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24294(i64 %arg8206, i64 %rva10466)                  ; tail call
  ret void

else24177:
 %vptr24300 = alloca i64, align 8 
  %h10471 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10471, i64* %vptr24300, align 8 ; call prim_halt
  %vptr24306 = alloca i64*, align 8 
  %cloptr24301 = inttoptr i64 %h10471 to i64* 
  store volatile i64* %cloptr24301, i64** %vptr24306, align 8 ; closure/env cast; i64 -> i64*
  %vptr24307 = alloca i64*, align 8 
  %i0ptr24302 = getelementptr inbounds i64, i64* %cloptr24301, i64 1 
  store volatile i64* %i0ptr24302, i64** %vptr24307, align 8 ; &cloptr24301[1]
 %vptr24308 = alloca i64, align 8 
  %f24304 = load i64, i64* %i0ptr24302, align 8 
  store volatile i64 %f24304, i64* %vptr24308, align 8 ; load; *i0ptr24302
  %fptr24303 = inttoptr i64 %f24304 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24303(i64 %h10471, i64 %h10471)                     ; tail call
  ret void
}


define void @lam11859(i64 %env11860, i64 %rvp10160) {
 %vptr24311 = alloca i64, align 8 
  %envptr24309 = inttoptr i64 %env11860 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr24311, align 8 ; closure/env cast; i64 -> i64*
  %vptr24312 = alloca i64*, align 8 
  %envptr24310 = getelementptr inbounds i64, i64* %envptr24309, i64 8 
  store volatile i64* %envptr24310, i64** %vptr24312, align 8 ; &envptr24309[7]
 %vptr24313 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr24310, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr24313, align 8 ; load; *envptr24310
 %vptr24316 = alloca i64, align 8 
  %envptr24314 = inttoptr i64 %env11860 to i64* 
  store volatile i64 %emsg08636, i64* %vptr24316, align 8 ; closure/env cast; i64 -> i64*
  %vptr24317 = alloca i64*, align 8 
  %envptr24315 = getelementptr inbounds i64, i64* %envptr24314, i64 7 
  store volatile i64* %envptr24315, i64** %vptr24317, align 8 ; &envptr24314[6]
 %vptr24318 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr24315, align 8 
  store volatile i64 %emsg08636, i64* %vptr24318, align 8 ; load; *envptr24315
 %vptr24321 = alloca i64, align 8 
  %envptr24319 = inttoptr i64 %env11860 to i64* 
  store volatile i64 %MXn$x, i64* %vptr24321, align 8 ; closure/env cast; i64 -> i64*
  %vptr24322 = alloca i64*, align 8 
  %envptr24320 = getelementptr inbounds i64, i64* %envptr24319, i64 6 
  store volatile i64* %envptr24320, i64** %vptr24322, align 8 ; &envptr24319[5]
 %vptr24323 = alloca i64, align 8 
  %MXn$x = load i64, i64* %envptr24320, align 8 
  store volatile i64 %MXn$x, i64* %vptr24323, align 8 ; load; *envptr24320
 %vptr24326 = alloca i64, align 8 
  %envptr24324 = inttoptr i64 %env11860 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr24326, align 8 ; closure/env cast; i64 -> i64*
  %vptr24327 = alloca i64*, align 8 
  %envptr24325 = getelementptr inbounds i64, i64* %envptr24324, i64 5 
  store volatile i64* %envptr24325, i64** %vptr24327, align 8 ; &envptr24324[4]
 %vptr24328 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr24325, align 8 
  store volatile i64 %Pll$pred, i64* %vptr24328, align 8 ; load; *envptr24325
 %vptr24331 = alloca i64, align 8 
  %envptr24329 = inttoptr i64 %env11860 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr24331, align 8 ; closure/env cast; i64 -> i64*
  %vptr24332 = alloca i64*, align 8 
  %envptr24330 = getelementptr inbounds i64, i64* %envptr24329, i64 4 
  store volatile i64* %envptr24330, i64** %vptr24332, align 8 ; &envptr24329[3]
 %vptr24333 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr24330, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr24333, align 8 ; load; *envptr24330
 %vptr24336 = alloca i64, align 8 
  %envptr24334 = inttoptr i64 %env11860 to i64* 
  store volatile i64 %YxK$fibc, i64* %vptr24336, align 8 ; closure/env cast; i64 -> i64*
  %vptr24337 = alloca i64*, align 8 
  %envptr24335 = getelementptr inbounds i64, i64* %envptr24334, i64 3 
  store volatile i64* %envptr24335, i64** %vptr24337, align 8 ; &envptr24334[2]
 %vptr24338 = alloca i64, align 8 
  %YxK$fibc = load i64, i64* %envptr24335, align 8 
  store volatile i64 %YxK$fibc, i64* %vptr24338, align 8 ; load; *envptr24335
 %vptr24341 = alloca i64, align 8 
  %envptr24339 = inttoptr i64 %env11860 to i64* 
  store volatile i64 %emsg18637, i64* %vptr24341, align 8 ; closure/env cast; i64 -> i64*
  %vptr24342 = alloca i64*, align 8 
  %envptr24340 = getelementptr inbounds i64, i64* %envptr24339, i64 2 
  store volatile i64* %envptr24340, i64** %vptr24342, align 8 ; &envptr24339[1]
 %vptr24343 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr24340, align 8 
  store volatile i64 %emsg18637, i64* %vptr24343, align 8 ; load; *envptr24340
 %vptr24344 = alloca i64, align 8 
  %cont7245 = call i64 @prim_car(i64 %rvp10160) 
  store volatile i64 %cont7245, i64* %vptr24344, align 8 ; call prim_car
 %vptr24345 = alloca i64, align 8 
  %rvp10156 = call i64 @prim_cdr(i64 %rvp10160) 
  store volatile i64 %rvp10156, i64* %vptr24345, align 8 ; call prim_cdr
 %vptr24346 = alloca i64, align 8 
  %n_6310161 = call i64 @prim_null_63(i64 %rvp10156) 
  store volatile i64 %n_6310161, i64* %vptr24346, align 8 ; call prim_null_63
  %cmpptr24350 = alloca i1, align 8  %cmp24347 = icmp eq i64 %n_6310161, 15 store volatile i1 %cmp24347, i1* %cmpptr24350, align 8; false?
  br i1 %cmp24347, label %else24349, label %then24348                                ; if

then24348:
 %vptr24351 = alloca i64, align 8 
  %h10162 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10162, i64* %vptr24351, align 8 ; call prim_halt
  %vptr24357 = alloca i64*, align 8 
  %cloptr24352 = inttoptr i64 %h10162 to i64* 
  store volatile i64* %cloptr24352, i64** %vptr24357, align 8 ; closure/env cast; i64 -> i64*
  %vptr24358 = alloca i64*, align 8 
  %i0ptr24353 = getelementptr inbounds i64, i64* %cloptr24352, i64 1 
  store volatile i64* %i0ptr24353, i64** %vptr24358, align 8 ; &cloptr24352[1]
 %vptr24359 = alloca i64, align 8 
  %f24355 = load i64, i64* %i0ptr24353, align 8 
  store volatile i64 %f24355, i64* %vptr24359, align 8 ; load; *i0ptr24353
  %fptr24354 = inttoptr i64 %f24355 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24354(i64 %h10162, i64 %h10162)                     ; tail call
  ret void

else24349:
 %vptr24360 = alloca i64, align 8 
  %s5Y$_37k = call i64 @prim_car(i64 %rvp10156) 
  store volatile i64 %s5Y$_37k, i64* %vptr24360, align 8 ; call prim_car
 %vptr24361 = alloca i64, align 8 
  %na10070 = call i64 @prim_cdr(i64 %rvp10156) 
  store volatile i64 %na10070, i64* %vptr24361, align 8 ; call prim_cdr
 %vptr24362 = alloca i64, align 8 
  %n_6310157 = call i64 @prim_null_63(i64 %na10070) 
  store volatile i64 %n_6310157, i64* %vptr24362, align 8 ; call prim_null_63
  %cmpptr24366 = alloca i1, align 8  %cmp24363 = icmp eq i64 %n_6310157, 15 store volatile i1 %cmp24363, i1* %cmpptr24366, align 8; false?
  br i1 %cmp24363, label %else24365, label %then24364                                ; if

then24364:
 %vptr24367 = alloca i64, align 8 
  %arg8207 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8207, i64* %vptr24367, align 8 ; quoted int
 %vptr24368 = alloca i64, align 8 
  %cZG$_37saved_45stack = call i64 @prim_vector_45ref(i64 %SdC$_37wind_45stack, i64 %arg8207) 
  store volatile i64 %cZG$_37saved_45stack, i64* %vptr24368, align 8 ; call prim_vector_45ref
  %vptr24378 = alloca i64*, align 8 
  %cloptr24369 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr24369, i64** %vptr24378, align 8 ; malloc
  %vptr24379 = alloca i64*, align 8 
  %eptr24371 = getelementptr inbounds i64, i64* %cloptr24369, i64 2 
  store volatile i64* %eptr24371, i64** %vptr24379, align 8 ; &eptr24371[1]
  %vptr24380 = alloca i64*, align 8 
  %eptr24372 = getelementptr inbounds i64, i64* %cloptr24369, i64 3 
  store volatile i64* %eptr24372, i64** %vptr24380, align 8 ; &eptr24372[2]
  %vptr24381 = alloca i64*, align 8 
  %eptr24373 = getelementptr inbounds i64, i64* %cloptr24369, i64 4 
  store volatile i64* %eptr24373, i64** %vptr24381, align 8 ; &eptr24373[3]
  %vptr24382 = alloca i64*, align 8 
  %eptr24374 = getelementptr inbounds i64, i64* %cloptr24369, i64 5 
  store volatile i64* %eptr24374, i64** %vptr24382, align 8 ; &eptr24374[4]
  %vptr24383 = alloca i64*, align 8 
  %eptr24375 = getelementptr inbounds i64, i64* %cloptr24369, i64 6 
  store volatile i64* %eptr24375, i64** %vptr24383, align 8 ; &eptr24375[5]
  %vptr24384 = alloca i64*, align 8 
  %eptr24376 = getelementptr inbounds i64, i64* %cloptr24369, i64 7 
  store volatile i64* %eptr24376, i64** %vptr24384, align 8 ; &eptr24376[6]
  store i64 %emsg18637, i64* %eptr24371                                              ; *eptr24371 = %emsg18637
  store i64 %cont7245, i64* %eptr24372                                               ; *eptr24372 = %cont7245
  store i64 %YxK$fibc, i64* %eptr24373                                               ; *eptr24373 = %YxK$fibc
  store i64 %Pll$pred, i64* %eptr24374                                               ; *eptr24374 = %Pll$pred
  store i64 %MXn$x, i64* %eptr24375                                                  ; *eptr24375 = %MXn$x
  store i64 %emsg08636, i64* %eptr24376                                              ; *eptr24376 = %emsg08636
  %vptr24385 = alloca i64*, align 8 
  %eptr24370 = getelementptr inbounds i64, i64* %cloptr24369, i64 1 
  store volatile i64* %eptr24370, i64** %vptr24385, align 8 ; &cloptr24369[1]
 %vptr24386 = alloca i64, align 8 
  %f24377 = ptrtoint void(i64,i64)* @lam11856 to i64 
  store volatile i64 %f24377, i64* %vptr24386, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f24377, i64* %eptr24370                                                 ; store fptr
 %vptr24387 = alloca i64, align 8 
  %arg8211 = ptrtoint i64* %cloptr24369 to i64 
  store volatile i64 %arg8211, i64* %vptr24387, align 8 ; closure cast; i64* -> i64
 %vptr24388 = alloca i64, align 8 
  %arg8210 = add i64 0, 0 
  store volatile i64 %arg8210, i64* %vptr24388, align 8 ; quoted ()
  %vptr24398 = alloca i64*, align 8 
  %cloptr24389 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr24389, i64** %vptr24398, align 8 ; malloc
  %vptr24399 = alloca i64*, align 8 
  %eptr24391 = getelementptr inbounds i64, i64* %cloptr24389, i64 2 
  store volatile i64* %eptr24391, i64** %vptr24399, align 8 ; &eptr24391[1]
  %vptr24400 = alloca i64*, align 8 
  %eptr24392 = getelementptr inbounds i64, i64* %cloptr24389, i64 3 
  store volatile i64* %eptr24392, i64** %vptr24400, align 8 ; &eptr24392[2]
  %vptr24401 = alloca i64*, align 8 
  %eptr24393 = getelementptr inbounds i64, i64* %cloptr24389, i64 4 
  store volatile i64* %eptr24393, i64** %vptr24401, align 8 ; &eptr24393[3]
  %vptr24402 = alloca i64*, align 8 
  %eptr24394 = getelementptr inbounds i64, i64* %cloptr24389, i64 5 
  store volatile i64* %eptr24394, i64** %vptr24402, align 8 ; &eptr24394[4]
  %vptr24403 = alloca i64*, align 8 
  %eptr24395 = getelementptr inbounds i64, i64* %cloptr24389, i64 6 
  store volatile i64* %eptr24395, i64** %vptr24403, align 8 ; &eptr24395[5]
  %vptr24404 = alloca i64*, align 8 
  %eptr24396 = getelementptr inbounds i64, i64* %cloptr24389, i64 7 
  store volatile i64* %eptr24396, i64** %vptr24404, align 8 ; &eptr24396[6]
  store i64 %s5Y$_37k, i64* %eptr24391                                               ; *eptr24391 = %s5Y$_37k
  store i64 %cZG$_37saved_45stack, i64* %eptr24392                                   ; *eptr24392 = %cZG$_37saved_45stack
  store i64 %emsg18637, i64* %eptr24393                                              ; *eptr24393 = %emsg18637
  store i64 %SdC$_37wind_45stack, i64* %eptr24394                                    ; *eptr24394 = %SdC$_37wind_45stack
  store i64 %emsg08636, i64* %eptr24395                                              ; *eptr24395 = %emsg08636
  store i64 %U8g$_37do_45wind, i64* %eptr24396                                       ; *eptr24396 = %U8g$_37do_45wind
  %vptr24405 = alloca i64*, align 8 
  %eptr24390 = getelementptr inbounds i64, i64* %cloptr24389, i64 1 
  store volatile i64* %eptr24390, i64** %vptr24405, align 8 ; &cloptr24389[1]
 %vptr24406 = alloca i64, align 8 
  %f24397 = ptrtoint void(i64,i64)* @lam11844 to i64 
  store volatile i64 %f24397, i64* %vptr24406, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f24397, i64* %eptr24390                                                 ; store fptr
 %vptr24407 = alloca i64, align 8 
  %arg8209 = ptrtoint i64* %cloptr24389 to i64 
  store volatile i64 %arg8209, i64* %vptr24407, align 8 ; closure cast; i64* -> i64
 %vptr24408 = alloca i64, align 8 
  %rva10155 = add i64 0, 0 
  store volatile i64 %rva10155, i64* %vptr24408, align 8 ; quoted ()
 %vptr24409 = alloca i64, align 8 
  %rva10154 = call i64 @prim_cons(i64 %arg8209, i64 %rva10155) 
  store volatile i64 %rva10154, i64* %vptr24409, align 8 ; call prim_cons
 %vptr24410 = alloca i64, align 8 
  %rva10153 = call i64 @prim_cons(i64 %arg8210, i64 %rva10154) 
  store volatile i64 %rva10153, i64* %vptr24410, align 8 ; call prim_cons
  %vptr24416 = alloca i64*, align 8 
  %cloptr24411 = inttoptr i64 %arg8211 to i64* 
  store volatile i64* %cloptr24411, i64** %vptr24416, align 8 ; closure/env cast; i64 -> i64*
  %vptr24417 = alloca i64*, align 8 
  %i0ptr24412 = getelementptr inbounds i64, i64* %cloptr24411, i64 1 
  store volatile i64* %i0ptr24412, i64** %vptr24417, align 8 ; &cloptr24411[1]
 %vptr24418 = alloca i64, align 8 
  %f24414 = load i64, i64* %i0ptr24412, align 8 
  store volatile i64 %f24414, i64* %vptr24418, align 8 ; load; *i0ptr24412
  %fptr24413 = inttoptr i64 %f24414 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24413(i64 %arg8211, i64 %rva10153)                  ; tail call
  ret void

else24365:
 %vptr24419 = alloca i64, align 8 
  %h10158 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10158, i64* %vptr24419, align 8 ; call prim_halt
  %vptr24425 = alloca i64*, align 8 
  %cloptr24420 = inttoptr i64 %h10158 to i64* 
  store volatile i64* %cloptr24420, i64** %vptr24425, align 8 ; closure/env cast; i64 -> i64*
  %vptr24426 = alloca i64*, align 8 
  %i0ptr24421 = getelementptr inbounds i64, i64* %cloptr24420, i64 1 
  store volatile i64* %i0ptr24421, i64** %vptr24426, align 8 ; &cloptr24420[1]
 %vptr24427 = alloca i64, align 8 
  %f24423 = load i64, i64* %i0ptr24421, align 8 
  store volatile i64 %f24423, i64* %vptr24427, align 8 ; load; *i0ptr24421
  %fptr24422 = inttoptr i64 %f24423 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24422(i64 %h10158, i64 %h10158)                     ; tail call
  ret void
}


define void @lam11856(i64 %env11857, i64 %rvp10107) {
 %vptr24430 = alloca i64, align 8 
  %envptr24428 = inttoptr i64 %env11857 to i64* 
  store volatile i64 %emsg08636, i64* %vptr24430, align 8 ; closure/env cast; i64 -> i64*
  %vptr24431 = alloca i64*, align 8 
  %envptr24429 = getelementptr inbounds i64, i64* %envptr24428, i64 7 
  store volatile i64* %envptr24429, i64** %vptr24431, align 8 ; &envptr24428[6]
 %vptr24432 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr24429, align 8 
  store volatile i64 %emsg08636, i64* %vptr24432, align 8 ; load; *envptr24429
 %vptr24435 = alloca i64, align 8 
  %envptr24433 = inttoptr i64 %env11857 to i64* 
  store volatile i64 %MXn$x, i64* %vptr24435, align 8 ; closure/env cast; i64 -> i64*
  %vptr24436 = alloca i64*, align 8 
  %envptr24434 = getelementptr inbounds i64, i64* %envptr24433, i64 6 
  store volatile i64* %envptr24434, i64** %vptr24436, align 8 ; &envptr24433[5]
 %vptr24437 = alloca i64, align 8 
  %MXn$x = load i64, i64* %envptr24434, align 8 
  store volatile i64 %MXn$x, i64* %vptr24437, align 8 ; load; *envptr24434
 %vptr24440 = alloca i64, align 8 
  %envptr24438 = inttoptr i64 %env11857 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr24440, align 8 ; closure/env cast; i64 -> i64*
  %vptr24441 = alloca i64*, align 8 
  %envptr24439 = getelementptr inbounds i64, i64* %envptr24438, i64 5 
  store volatile i64* %envptr24439, i64** %vptr24441, align 8 ; &envptr24438[4]
 %vptr24442 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr24439, align 8 
  store volatile i64 %Pll$pred, i64* %vptr24442, align 8 ; load; *envptr24439
 %vptr24445 = alloca i64, align 8 
  %envptr24443 = inttoptr i64 %env11857 to i64* 
  store volatile i64 %YxK$fibc, i64* %vptr24445, align 8 ; closure/env cast; i64 -> i64*
  %vptr24446 = alloca i64*, align 8 
  %envptr24444 = getelementptr inbounds i64, i64* %envptr24443, i64 4 
  store volatile i64* %envptr24444, i64** %vptr24446, align 8 ; &envptr24443[3]
 %vptr24447 = alloca i64, align 8 
  %YxK$fibc = load i64, i64* %envptr24444, align 8 
  store volatile i64 %YxK$fibc, i64* %vptr24447, align 8 ; load; *envptr24444
 %vptr24450 = alloca i64, align 8 
  %envptr24448 = inttoptr i64 %env11857 to i64* 
  store volatile i64 %cont7245, i64* %vptr24450, align 8 ; closure/env cast; i64 -> i64*
  %vptr24451 = alloca i64*, align 8 
  %envptr24449 = getelementptr inbounds i64, i64* %envptr24448, i64 3 
  store volatile i64* %envptr24449, i64** %vptr24451, align 8 ; &envptr24448[2]
 %vptr24452 = alloca i64, align 8 
  %cont7245 = load i64, i64* %envptr24449, align 8 
  store volatile i64 %cont7245, i64* %vptr24452, align 8 ; load; *envptr24449
 %vptr24455 = alloca i64, align 8 
  %envptr24453 = inttoptr i64 %env11857 to i64* 
  store volatile i64 %emsg18637, i64* %vptr24455, align 8 ; closure/env cast; i64 -> i64*
  %vptr24456 = alloca i64*, align 8 
  %envptr24454 = getelementptr inbounds i64, i64* %envptr24453, i64 2 
  store volatile i64* %envptr24454, i64** %vptr24456, align 8 ; &envptr24453[1]
 %vptr24457 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr24454, align 8 
  store volatile i64 %emsg18637, i64* %vptr24457, align 8 ; load; *envptr24454
 %vptr24458 = alloca i64, align 8 
  %_957246 = call i64 @prim_car(i64 %rvp10107) 
  store volatile i64 %_957246, i64* %vptr24458, align 8 ; call prim_car
 %vptr24459 = alloca i64, align 8 
  %rvp10103 = call i64 @prim_cdr(i64 %rvp10107) 
  store volatile i64 %rvp10103, i64* %vptr24459, align 8 ; call prim_cdr
 %vptr24460 = alloca i64, align 8 
  %n_6310108 = call i64 @prim_null_63(i64 %rvp10103) 
  store volatile i64 %n_6310108, i64* %vptr24460, align 8 ; call prim_null_63
  %cmpptr24464 = alloca i1, align 8  %cmp24461 = icmp eq i64 %n_6310108, 15 store volatile i1 %cmp24461, i1* %cmpptr24464, align 8; false?
  br i1 %cmp24461, label %else24463, label %then24462                                ; if

then24462:
 %vptr24465 = alloca i64, align 8 
  %h10109 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10109, i64* %vptr24465, align 8 ; call prim_halt
  %vptr24471 = alloca i64*, align 8 
  %cloptr24466 = inttoptr i64 %h10109 to i64* 
  store volatile i64* %cloptr24466, i64** %vptr24471, align 8 ; closure/env cast; i64 -> i64*
  %vptr24472 = alloca i64*, align 8 
  %i0ptr24467 = getelementptr inbounds i64, i64* %cloptr24466, i64 1 
  store volatile i64* %i0ptr24467, i64** %vptr24472, align 8 ; &cloptr24466[1]
 %vptr24473 = alloca i64, align 8 
  %f24469 = load i64, i64* %i0ptr24467, align 8 
  store volatile i64 %f24469, i64* %vptr24473, align 8 ; load; *i0ptr24467
  %fptr24468 = inttoptr i64 %f24469 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24468(i64 %h10109, i64 %h10109)                     ; tail call
  ret void

else24463:
 %vptr24474 = alloca i64, align 8 
  %a7073 = call i64 @prim_car(i64 %rvp10103) 
  store volatile i64 %a7073, i64* %vptr24474, align 8 ; call prim_car
 %vptr24475 = alloca i64, align 8 
  %na10072 = call i64 @prim_cdr(i64 %rvp10103) 
  store volatile i64 %na10072, i64* %vptr24475, align 8 ; call prim_cdr
 %vptr24476 = alloca i64, align 8 
  %n_6310104 = call i64 @prim_null_63(i64 %na10072) 
  store volatile i64 %n_6310104, i64* %vptr24476, align 8 ; call prim_null_63
  %cmpptr24480 = alloca i1, align 8  %cmp24477 = icmp eq i64 %n_6310104, 15 store volatile i1 %cmp24477, i1* %cmpptr24480, align 8; false?
  br i1 %cmp24477, label %else24479, label %then24478                                ; if

then24478:
  %vptr24489 = alloca i64*, align 8 
  %cloptr24481 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr24481, i64** %vptr24489, align 8 ; malloc
  %vptr24490 = alloca i64*, align 8 
  %eptr24483 = getelementptr inbounds i64, i64* %cloptr24481, i64 2 
  store volatile i64* %eptr24483, i64** %vptr24490, align 8 ; &eptr24483[1]
  %vptr24491 = alloca i64*, align 8 
  %eptr24484 = getelementptr inbounds i64, i64* %cloptr24481, i64 3 
  store volatile i64* %eptr24484, i64** %vptr24491, align 8 ; &eptr24484[2]
  %vptr24492 = alloca i64*, align 8 
  %eptr24485 = getelementptr inbounds i64, i64* %cloptr24481, i64 4 
  store volatile i64* %eptr24485, i64** %vptr24492, align 8 ; &eptr24485[3]
  %vptr24493 = alloca i64*, align 8 
  %eptr24486 = getelementptr inbounds i64, i64* %cloptr24481, i64 5 
  store volatile i64* %eptr24486, i64** %vptr24493, align 8 ; &eptr24486[4]
  %vptr24494 = alloca i64*, align 8 
  %eptr24487 = getelementptr inbounds i64, i64* %cloptr24481, i64 6 
  store volatile i64* %eptr24487, i64** %vptr24494, align 8 ; &eptr24487[5]
  store i64 %emsg18637, i64* %eptr24483                                              ; *eptr24483 = %emsg18637
  store i64 %YxK$fibc, i64* %eptr24484                                               ; *eptr24484 = %YxK$fibc
  store i64 %Pll$pred, i64* %eptr24485                                               ; *eptr24485 = %Pll$pred
  store i64 %MXn$x, i64* %eptr24486                                                  ; *eptr24486 = %MXn$x
  store i64 %emsg08636, i64* %eptr24487                                              ; *eptr24487 = %emsg08636
  %vptr24495 = alloca i64*, align 8 
  %eptr24482 = getelementptr inbounds i64, i64* %cloptr24481, i64 1 
  store volatile i64* %eptr24482, i64** %vptr24495, align 8 ; &cloptr24481[1]
 %vptr24496 = alloca i64, align 8 
  %f24488 = ptrtoint void(i64,i64)* @lam11854 to i64 
  store volatile i64 %f24488, i64* %vptr24496, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f24488, i64* %eptr24482                                                 ; store fptr
 %vptr24497 = alloca i64, align 8 
  %arg8214 = ptrtoint i64* %cloptr24481 to i64 
  store volatile i64 %arg8214, i64* %vptr24497, align 8 ; closure cast; i64* -> i64
 %vptr24498 = alloca i64, align 8 
  %rva10102 = add i64 0, 0 
  store volatile i64 %rva10102, i64* %vptr24498, align 8 ; quoted ()
 %vptr24499 = alloca i64, align 8 
  %rva10101 = call i64 @prim_cons(i64 %a7073, i64 %rva10102) 
  store volatile i64 %rva10101, i64* %vptr24499, align 8 ; call prim_cons
 %vptr24500 = alloca i64, align 8 
  %rva10100 = call i64 @prim_cons(i64 %cont7245, i64 %rva10101) 
  store volatile i64 %rva10100, i64* %vptr24500, align 8 ; call prim_cons
  %vptr24506 = alloca i64*, align 8 
  %cloptr24501 = inttoptr i64 %arg8214 to i64* 
  store volatile i64* %cloptr24501, i64** %vptr24506, align 8 ; closure/env cast; i64 -> i64*
  %vptr24507 = alloca i64*, align 8 
  %i0ptr24502 = getelementptr inbounds i64, i64* %cloptr24501, i64 1 
  store volatile i64* %i0ptr24502, i64** %vptr24507, align 8 ; &cloptr24501[1]
 %vptr24508 = alloca i64, align 8 
  %f24504 = load i64, i64* %i0ptr24502, align 8 
  store volatile i64 %f24504, i64* %vptr24508, align 8 ; load; *i0ptr24502
  %fptr24503 = inttoptr i64 %f24504 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24503(i64 %arg8214, i64 %rva10100)                  ; tail call
  ret void

else24479:
 %vptr24509 = alloca i64, align 8 
  %h10105 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10105, i64* %vptr24509, align 8 ; call prim_halt
  %vptr24515 = alloca i64*, align 8 
  %cloptr24510 = inttoptr i64 %h10105 to i64* 
  store volatile i64* %cloptr24510, i64** %vptr24515, align 8 ; closure/env cast; i64 -> i64*
  %vptr24516 = alloca i64*, align 8 
  %i0ptr24511 = getelementptr inbounds i64, i64* %cloptr24510, i64 1 
  store volatile i64* %i0ptr24511, i64** %vptr24516, align 8 ; &cloptr24510[1]
 %vptr24517 = alloca i64, align 8 
  %f24513 = load i64, i64* %i0ptr24511, align 8 
  store volatile i64 %f24513, i64* %vptr24517, align 8 ; load; *i0ptr24511
  %fptr24512 = inttoptr i64 %f24513 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24512(i64 %h10105, i64 %h10105)                     ; tail call
  ret void
}


define void @lam11854(i64 %env11855, i64 %rvp10096) {
 %vptr24520 = alloca i64, align 8 
  %envptr24518 = inttoptr i64 %env11855 to i64* 
  store volatile i64 %emsg08636, i64* %vptr24520, align 8 ; closure/env cast; i64 -> i64*
  %vptr24521 = alloca i64*, align 8 
  %envptr24519 = getelementptr inbounds i64, i64* %envptr24518, i64 6 
  store volatile i64* %envptr24519, i64** %vptr24521, align 8 ; &envptr24518[5]
 %vptr24522 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr24519, align 8 
  store volatile i64 %emsg08636, i64* %vptr24522, align 8 ; load; *envptr24519
 %vptr24525 = alloca i64, align 8 
  %envptr24523 = inttoptr i64 %env11855 to i64* 
  store volatile i64 %MXn$x, i64* %vptr24525, align 8 ; closure/env cast; i64 -> i64*
  %vptr24526 = alloca i64*, align 8 
  %envptr24524 = getelementptr inbounds i64, i64* %envptr24523, i64 5 
  store volatile i64* %envptr24524, i64** %vptr24526, align 8 ; &envptr24523[4]
 %vptr24527 = alloca i64, align 8 
  %MXn$x = load i64, i64* %envptr24524, align 8 
  store volatile i64 %MXn$x, i64* %vptr24527, align 8 ; load; *envptr24524
 %vptr24530 = alloca i64, align 8 
  %envptr24528 = inttoptr i64 %env11855 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr24530, align 8 ; closure/env cast; i64 -> i64*
  %vptr24531 = alloca i64*, align 8 
  %envptr24529 = getelementptr inbounds i64, i64* %envptr24528, i64 4 
  store volatile i64* %envptr24529, i64** %vptr24531, align 8 ; &envptr24528[3]
 %vptr24532 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr24529, align 8 
  store volatile i64 %Pll$pred, i64* %vptr24532, align 8 ; load; *envptr24529
 %vptr24535 = alloca i64, align 8 
  %envptr24533 = inttoptr i64 %env11855 to i64* 
  store volatile i64 %YxK$fibc, i64* %vptr24535, align 8 ; closure/env cast; i64 -> i64*
  %vptr24536 = alloca i64*, align 8 
  %envptr24534 = getelementptr inbounds i64, i64* %envptr24533, i64 3 
  store volatile i64* %envptr24534, i64** %vptr24536, align 8 ; &envptr24533[2]
 %vptr24537 = alloca i64, align 8 
  %YxK$fibc = load i64, i64* %envptr24534, align 8 
  store volatile i64 %YxK$fibc, i64* %vptr24537, align 8 ; load; *envptr24534
 %vptr24540 = alloca i64, align 8 
  %envptr24538 = inttoptr i64 %env11855 to i64* 
  store volatile i64 %emsg18637, i64* %vptr24540, align 8 ; closure/env cast; i64 -> i64*
  %vptr24541 = alloca i64*, align 8 
  %envptr24539 = getelementptr inbounds i64, i64* %envptr24538, i64 2 
  store volatile i64* %envptr24539, i64** %vptr24541, align 8 ; &envptr24538[1]
 %vptr24542 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr24539, align 8 
  store volatile i64 %emsg18637, i64* %vptr24542, align 8 ; load; *envptr24539
 %vptr24543 = alloca i64, align 8 
  %cont7247 = call i64 @prim_car(i64 %rvp10096) 
  store volatile i64 %cont7247, i64* %vptr24543, align 8 ; call prim_car
 %vptr24544 = alloca i64, align 8 
  %rvp10092 = call i64 @prim_cdr(i64 %rvp10096) 
  store volatile i64 %rvp10092, i64* %vptr24544, align 8 ; call prim_cdr
 %vptr24545 = alloca i64, align 8 
  %n_6310097 = call i64 @prim_null_63(i64 %rvp10092) 
  store volatile i64 %n_6310097, i64* %vptr24545, align 8 ; call prim_null_63
  %cmpptr24549 = alloca i1, align 8  %cmp24546 = icmp eq i64 %n_6310097, 15 store volatile i1 %cmp24546, i1* %cmpptr24549, align 8; false?
  br i1 %cmp24546, label %else24548, label %then24547                                ; if

then24547:
 %vptr24550 = alloca i64, align 8 
  %h10098 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10098, i64* %vptr24550, align 8 ; call prim_halt
  %vptr24556 = alloca i64*, align 8 
  %cloptr24551 = inttoptr i64 %h10098 to i64* 
  store volatile i64* %cloptr24551, i64** %vptr24556, align 8 ; closure/env cast; i64 -> i64*
  %vptr24557 = alloca i64*, align 8 
  %i0ptr24552 = getelementptr inbounds i64, i64* %cloptr24551, i64 1 
  store volatile i64* %i0ptr24552, i64** %vptr24557, align 8 ; &cloptr24551[1]
 %vptr24558 = alloca i64, align 8 
  %f24554 = load i64, i64* %i0ptr24552, align 8 
  store volatile i64 %f24554, i64* %vptr24558, align 8 ; load; *i0ptr24552
  %fptr24553 = inttoptr i64 %f24554 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24553(i64 %h10098, i64 %h10098)                     ; tail call
  ret void

else24548:
 %vptr24559 = alloca i64, align 8 
  %ci0$c = call i64 @prim_car(i64 %rvp10092) 
  store volatile i64 %ci0$c, i64* %vptr24559, align 8 ; call prim_car
 %vptr24560 = alloca i64, align 8 
  %na10074 = call i64 @prim_cdr(i64 %rvp10092) 
  store volatile i64 %na10074, i64* %vptr24560, align 8 ; call prim_cdr
 %vptr24561 = alloca i64, align 8 
  %n_6310093 = call i64 @prim_null_63(i64 %na10074) 
  store volatile i64 %n_6310093, i64* %vptr24561, align 8 ; call prim_null_63
  %cmpptr24565 = alloca i1, align 8  %cmp24562 = icmp eq i64 %n_6310093, 15 store volatile i1 %cmp24562, i1* %cmpptr24565, align 8; false?
  br i1 %cmp24562, label %else24564, label %then24563                                ; if

then24563:
 %vptr24566 = alloca i64, align 8 
  %arg8215 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8215, i64* %vptr24566, align 8 ; quoted int
 %vptr24567 = alloca i64, align 8 
  %a7068 = call i64 @prim_vector_45ref(i64 %YxK$fibc, i64 %arg8215) 
  store volatile i64 %a7068, i64* %vptr24567, align 8 ; call prim_vector_45ref
 %vptr24568 = alloca i64, align 8 
  %arg8217 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8217, i64* %vptr24568, align 8 ; quoted int
 %vptr24569 = alloca i64, align 8 
  %a7069 = call i64 @prim_vector_45ref(i64 %Pll$pred, i64 %arg8217) 
  store volatile i64 %a7069, i64* %vptr24569, align 8 ; call prim_vector_45ref
  %vptr24578 = alloca i64*, align 8 
  %cloptr24570 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr24570, i64** %vptr24578, align 8 ; malloc
  %vptr24579 = alloca i64*, align 8 
  %eptr24572 = getelementptr inbounds i64, i64* %cloptr24570, i64 2 
  store volatile i64* %eptr24572, i64** %vptr24579, align 8 ; &eptr24572[1]
  %vptr24580 = alloca i64*, align 8 
  %eptr24573 = getelementptr inbounds i64, i64* %cloptr24570, i64 3 
  store volatile i64* %eptr24573, i64** %vptr24580, align 8 ; &eptr24573[2]
  %vptr24581 = alloca i64*, align 8 
  %eptr24574 = getelementptr inbounds i64, i64* %cloptr24570, i64 4 
  store volatile i64* %eptr24574, i64** %vptr24581, align 8 ; &eptr24574[3]
  %vptr24582 = alloca i64*, align 8 
  %eptr24575 = getelementptr inbounds i64, i64* %cloptr24570, i64 5 
  store volatile i64* %eptr24575, i64** %vptr24582, align 8 ; &eptr24575[4]
  %vptr24583 = alloca i64*, align 8 
  %eptr24576 = getelementptr inbounds i64, i64* %cloptr24570, i64 6 
  store volatile i64* %eptr24576, i64** %vptr24583, align 8 ; &eptr24576[5]
  store i64 %emsg18637, i64* %eptr24572                                              ; *eptr24572 = %emsg18637
  store i64 %a7068, i64* %eptr24573                                                  ; *eptr24573 = %a7068
  store i64 %ci0$c, i64* %eptr24574                                                  ; *eptr24574 = %ci0$c
  store i64 %emsg08636, i64* %eptr24575                                              ; *eptr24575 = %emsg08636
  store i64 %cont7247, i64* %eptr24576                                               ; *eptr24576 = %cont7247
  %vptr24584 = alloca i64*, align 8 
  %eptr24571 = getelementptr inbounds i64, i64* %cloptr24570, i64 1 
  store volatile i64* %eptr24571, i64** %vptr24584, align 8 ; &cloptr24570[1]
 %vptr24585 = alloca i64, align 8 
  %f24577 = ptrtoint void(i64,i64)* @lam11850 to i64 
  store volatile i64 %f24577, i64* %vptr24585, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f24577, i64* %eptr24571                                                 ; store fptr
 %vptr24586 = alloca i64, align 8 
  %arg8220 = ptrtoint i64* %cloptr24570 to i64 
  store volatile i64 %arg8220, i64* %vptr24586, align 8 ; closure cast; i64* -> i64
 %vptr24587 = alloca i64, align 8 
  %rva10091 = add i64 0, 0 
  store volatile i64 %rva10091, i64* %vptr24587, align 8 ; quoted ()
 %vptr24588 = alloca i64, align 8 
  %rva10090 = call i64 @prim_cons(i64 %MXn$x, i64 %rva10091) 
  store volatile i64 %rva10090, i64* %vptr24588, align 8 ; call prim_cons
 %vptr24589 = alloca i64, align 8 
  %rva10089 = call i64 @prim_cons(i64 %arg8220, i64 %rva10090) 
  store volatile i64 %rva10089, i64* %vptr24589, align 8 ; call prim_cons
  %vptr24595 = alloca i64*, align 8 
  %cloptr24590 = inttoptr i64 %a7069 to i64* 
  store volatile i64* %cloptr24590, i64** %vptr24595, align 8 ; closure/env cast; i64 -> i64*
  %vptr24596 = alloca i64*, align 8 
  %i0ptr24591 = getelementptr inbounds i64, i64* %cloptr24590, i64 1 
  store volatile i64* %i0ptr24591, i64** %vptr24596, align 8 ; &cloptr24590[1]
 %vptr24597 = alloca i64, align 8 
  %f24593 = load i64, i64* %i0ptr24591, align 8 
  store volatile i64 %f24593, i64* %vptr24597, align 8 ; load; *i0ptr24591
  %fptr24592 = inttoptr i64 %f24593 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24592(i64 %a7069, i64 %rva10089)                    ; tail call
  ret void

else24564:
 %vptr24598 = alloca i64, align 8 
  %h10094 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10094, i64* %vptr24598, align 8 ; call prim_halt
  %vptr24604 = alloca i64*, align 8 
  %cloptr24599 = inttoptr i64 %h10094 to i64* 
  store volatile i64* %cloptr24599, i64** %vptr24604, align 8 ; closure/env cast; i64 -> i64*
  %vptr24605 = alloca i64*, align 8 
  %i0ptr24600 = getelementptr inbounds i64, i64* %cloptr24599, i64 1 
  store volatile i64* %i0ptr24600, i64** %vptr24605, align 8 ; &cloptr24599[1]
 %vptr24606 = alloca i64, align 8 
  %f24602 = load i64, i64* %i0ptr24600, align 8 
  store volatile i64 %f24602, i64* %vptr24606, align 8 ; load; *i0ptr24600
  %fptr24601 = inttoptr i64 %f24602 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24601(i64 %h10094, i64 %h10094)                     ; tail call
  ret void
}


define void @lam11850(i64 %env11851, i64 %rvp10085) {
 %vptr24609 = alloca i64, align 8 
  %envptr24607 = inttoptr i64 %env11851 to i64* 
  store volatile i64 %cont7247, i64* %vptr24609, align 8 ; closure/env cast; i64 -> i64*
  %vptr24610 = alloca i64*, align 8 
  %envptr24608 = getelementptr inbounds i64, i64* %envptr24607, i64 6 
  store volatile i64* %envptr24608, i64** %vptr24610, align 8 ; &envptr24607[5]
 %vptr24611 = alloca i64, align 8 
  %cont7247 = load i64, i64* %envptr24608, align 8 
  store volatile i64 %cont7247, i64* %vptr24611, align 8 ; load; *envptr24608
 %vptr24614 = alloca i64, align 8 
  %envptr24612 = inttoptr i64 %env11851 to i64* 
  store volatile i64 %emsg08636, i64* %vptr24614, align 8 ; closure/env cast; i64 -> i64*
  %vptr24615 = alloca i64*, align 8 
  %envptr24613 = getelementptr inbounds i64, i64* %envptr24612, i64 5 
  store volatile i64* %envptr24613, i64** %vptr24615, align 8 ; &envptr24612[4]
 %vptr24616 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr24613, align 8 
  store volatile i64 %emsg08636, i64* %vptr24616, align 8 ; load; *envptr24613
 %vptr24619 = alloca i64, align 8 
  %envptr24617 = inttoptr i64 %env11851 to i64* 
  store volatile i64 %ci0$c, i64* %vptr24619, align 8 ; closure/env cast; i64 -> i64*
  %vptr24620 = alloca i64*, align 8 
  %envptr24618 = getelementptr inbounds i64, i64* %envptr24617, i64 4 
  store volatile i64* %envptr24618, i64** %vptr24620, align 8 ; &envptr24617[3]
 %vptr24621 = alloca i64, align 8 
  %ci0$c = load i64, i64* %envptr24618, align 8 
  store volatile i64 %ci0$c, i64* %vptr24621, align 8 ; load; *envptr24618
 %vptr24624 = alloca i64, align 8 
  %envptr24622 = inttoptr i64 %env11851 to i64* 
  store volatile i64 %a7068, i64* %vptr24624, align 8 ; closure/env cast; i64 -> i64*
  %vptr24625 = alloca i64*, align 8 
  %envptr24623 = getelementptr inbounds i64, i64* %envptr24622, i64 3 
  store volatile i64* %envptr24623, i64** %vptr24625, align 8 ; &envptr24622[2]
 %vptr24626 = alloca i64, align 8 
  %a7068 = load i64, i64* %envptr24623, align 8 
  store volatile i64 %a7068, i64* %vptr24626, align 8 ; load; *envptr24623
 %vptr24629 = alloca i64, align 8 
  %envptr24627 = inttoptr i64 %env11851 to i64* 
  store volatile i64 %emsg18637, i64* %vptr24629, align 8 ; closure/env cast; i64 -> i64*
  %vptr24630 = alloca i64*, align 8 
  %envptr24628 = getelementptr inbounds i64, i64* %envptr24627, i64 2 
  store volatile i64* %envptr24628, i64** %vptr24630, align 8 ; &envptr24627[1]
 %vptr24631 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr24628, align 8 
  store volatile i64 %emsg18637, i64* %vptr24631, align 8 ; load; *envptr24628
 %vptr24632 = alloca i64, align 8 
  %_957248 = call i64 @prim_car(i64 %rvp10085) 
  store volatile i64 %_957248, i64* %vptr24632, align 8 ; call prim_car
 %vptr24633 = alloca i64, align 8 
  %rvp10081 = call i64 @prim_cdr(i64 %rvp10085) 
  store volatile i64 %rvp10081, i64* %vptr24633, align 8 ; call prim_cdr
 %vptr24634 = alloca i64, align 8 
  %n_6310086 = call i64 @prim_null_63(i64 %rvp10081) 
  store volatile i64 %n_6310086, i64* %vptr24634, align 8 ; call prim_null_63
  %cmpptr24638 = alloca i1, align 8  %cmp24635 = icmp eq i64 %n_6310086, 15 store volatile i1 %cmp24635, i1* %cmpptr24638, align 8; false?
  br i1 %cmp24635, label %else24637, label %then24636                                ; if

then24636:
 %vptr24639 = alloca i64, align 8 
  %h10087 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10087, i64* %vptr24639, align 8 ; call prim_halt
  %vptr24645 = alloca i64*, align 8 
  %cloptr24640 = inttoptr i64 %h10087 to i64* 
  store volatile i64* %cloptr24640, i64** %vptr24645, align 8 ; closure/env cast; i64 -> i64*
  %vptr24646 = alloca i64*, align 8 
  %i0ptr24641 = getelementptr inbounds i64, i64* %cloptr24640, i64 1 
  store volatile i64* %i0ptr24641, i64** %vptr24646, align 8 ; &cloptr24640[1]
 %vptr24647 = alloca i64, align 8 
  %f24643 = load i64, i64* %i0ptr24641, align 8 
  store volatile i64 %f24643, i64* %vptr24647, align 8 ; load; *i0ptr24641
  %fptr24642 = inttoptr i64 %f24643 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24642(i64 %h10087, i64 %h10087)                     ; tail call
  ret void

else24637:
 %vptr24648 = alloca i64, align 8 
  %a7070 = call i64 @prim_car(i64 %rvp10081) 
  store volatile i64 %a7070, i64* %vptr24648, align 8 ; call prim_car
 %vptr24649 = alloca i64, align 8 
  %na10076 = call i64 @prim_cdr(i64 %rvp10081) 
  store volatile i64 %na10076, i64* %vptr24649, align 8 ; call prim_cdr
 %vptr24650 = alloca i64, align 8 
  %n_6310082 = call i64 @prim_null_63(i64 %na10076) 
  store volatile i64 %n_6310082, i64* %vptr24650, align 8 ; call prim_null_63
  %cmpptr24654 = alloca i1, align 8  %cmp24651 = icmp eq i64 %n_6310082, 15 store volatile i1 %cmp24651, i1* %cmpptr24654, align 8; false?
  br i1 %cmp24651, label %else24653, label %then24652                                ; if

then24652:
 %vptr24655 = alloca i64, align 8 
  %rva10080 = add i64 0, 0 
  store volatile i64 %rva10080, i64* %vptr24655, align 8 ; quoted ()
 %vptr24656 = alloca i64, align 8 
  %rva10079 = call i64 @prim_cons(i64 %ci0$c, i64 %rva10080) 
  store volatile i64 %rva10079, i64* %vptr24656, align 8 ; call prim_cons
 %vptr24657 = alloca i64, align 8 
  %rva10078 = call i64 @prim_cons(i64 %a7070, i64 %rva10079) 
  store volatile i64 %rva10078, i64* %vptr24657, align 8 ; call prim_cons
 %vptr24658 = alloca i64, align 8 
  %rva10077 = call i64 @prim_cons(i64 %cont7247, i64 %rva10078) 
  store volatile i64 %rva10077, i64* %vptr24658, align 8 ; call prim_cons
  %vptr24664 = alloca i64*, align 8 
  %cloptr24659 = inttoptr i64 %a7068 to i64* 
  store volatile i64* %cloptr24659, i64** %vptr24664, align 8 ; closure/env cast; i64 -> i64*
  %vptr24665 = alloca i64*, align 8 
  %i0ptr24660 = getelementptr inbounds i64, i64* %cloptr24659, i64 1 
  store volatile i64* %i0ptr24660, i64** %vptr24665, align 8 ; &cloptr24659[1]
 %vptr24666 = alloca i64, align 8 
  %f24662 = load i64, i64* %i0ptr24660, align 8 
  store volatile i64 %f24662, i64* %vptr24666, align 8 ; load; *i0ptr24660
  %fptr24661 = inttoptr i64 %f24662 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24661(i64 %a7068, i64 %rva10077)                    ; tail call
  ret void

else24653:
 %vptr24667 = alloca i64, align 8 
  %h10083 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10083, i64* %vptr24667, align 8 ; call prim_halt
  %vptr24673 = alloca i64*, align 8 
  %cloptr24668 = inttoptr i64 %h10083 to i64* 
  store volatile i64* %cloptr24668, i64** %vptr24673, align 8 ; closure/env cast; i64 -> i64*
  %vptr24674 = alloca i64*, align 8 
  %i0ptr24669 = getelementptr inbounds i64, i64* %cloptr24668, i64 1 
  store volatile i64* %i0ptr24669, i64** %vptr24674, align 8 ; &cloptr24668[1]
 %vptr24675 = alloca i64, align 8 
  %f24671 = load i64, i64* %i0ptr24669, align 8 
  store volatile i64 %f24671, i64* %vptr24675, align 8 ; load; *i0ptr24669
  %fptr24670 = inttoptr i64 %f24671 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24670(i64 %h10083, i64 %h10083)                     ; tail call
  ret void
}


define void @lam11844(i64 %env11845, i64 %rvp10149) {
 %vptr24678 = alloca i64, align 8 
  %envptr24676 = inttoptr i64 %env11845 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr24678, align 8 ; closure/env cast; i64 -> i64*
  %vptr24679 = alloca i64*, align 8 
  %envptr24677 = getelementptr inbounds i64, i64* %envptr24676, i64 7 
  store volatile i64* %envptr24677, i64** %vptr24679, align 8 ; &envptr24676[6]
 %vptr24680 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr24677, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr24680, align 8 ; load; *envptr24677
 %vptr24683 = alloca i64, align 8 
  %envptr24681 = inttoptr i64 %env11845 to i64* 
  store volatile i64 %emsg08636, i64* %vptr24683, align 8 ; closure/env cast; i64 -> i64*
  %vptr24684 = alloca i64*, align 8 
  %envptr24682 = getelementptr inbounds i64, i64* %envptr24681, i64 6 
  store volatile i64* %envptr24682, i64** %vptr24684, align 8 ; &envptr24681[5]
 %vptr24685 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr24682, align 8 
  store volatile i64 %emsg08636, i64* %vptr24685, align 8 ; load; *envptr24682
 %vptr24688 = alloca i64, align 8 
  %envptr24686 = inttoptr i64 %env11845 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr24688, align 8 ; closure/env cast; i64 -> i64*
  %vptr24689 = alloca i64*, align 8 
  %envptr24687 = getelementptr inbounds i64, i64* %envptr24686, i64 5 
  store volatile i64* %envptr24687, i64** %vptr24689, align 8 ; &envptr24686[4]
 %vptr24690 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr24687, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr24690, align 8 ; load; *envptr24687
 %vptr24693 = alloca i64, align 8 
  %envptr24691 = inttoptr i64 %env11845 to i64* 
  store volatile i64 %emsg18637, i64* %vptr24693, align 8 ; closure/env cast; i64 -> i64*
  %vptr24694 = alloca i64*, align 8 
  %envptr24692 = getelementptr inbounds i64, i64* %envptr24691, i64 4 
  store volatile i64* %envptr24692, i64** %vptr24694, align 8 ; &envptr24691[3]
 %vptr24695 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr24692, align 8 
  store volatile i64 %emsg18637, i64* %vptr24695, align 8 ; load; *envptr24692
 %vptr24698 = alloca i64, align 8 
  %envptr24696 = inttoptr i64 %env11845 to i64* 
  store volatile i64 %cZG$_37saved_45stack, i64* %vptr24698, align 8 ; closure/env cast; i64 -> i64*
  %vptr24699 = alloca i64*, align 8 
  %envptr24697 = getelementptr inbounds i64, i64* %envptr24696, i64 3 
  store volatile i64* %envptr24697, i64** %vptr24699, align 8 ; &envptr24696[2]
 %vptr24700 = alloca i64, align 8 
  %cZG$_37saved_45stack = load i64, i64* %envptr24697, align 8 
  store volatile i64 %cZG$_37saved_45stack, i64* %vptr24700, align 8 ; load; *envptr24697
 %vptr24703 = alloca i64, align 8 
  %envptr24701 = inttoptr i64 %env11845 to i64* 
  store volatile i64 %s5Y$_37k, i64* %vptr24703, align 8 ; closure/env cast; i64 -> i64*
  %vptr24704 = alloca i64*, align 8 
  %envptr24702 = getelementptr inbounds i64, i64* %envptr24701, i64 2 
  store volatile i64* %envptr24702, i64** %vptr24704, align 8 ; &envptr24701[1]
 %vptr24705 = alloca i64, align 8 
  %s5Y$_37k = load i64, i64* %envptr24702, align 8 
  store volatile i64 %s5Y$_37k, i64* %vptr24705, align 8 ; load; *envptr24702
 %vptr24706 = alloca i64, align 8 
  %cont7249 = call i64 @prim_car(i64 %rvp10149) 
  store volatile i64 %cont7249, i64* %vptr24706, align 8 ; call prim_car
 %vptr24707 = alloca i64, align 8 
  %rvp10145 = call i64 @prim_cdr(i64 %rvp10149) 
  store volatile i64 %rvp10145, i64* %vptr24707, align 8 ; call prim_cdr
 %vptr24708 = alloca i64, align 8 
  %n_6310150 = call i64 @prim_null_63(i64 %rvp10145) 
  store volatile i64 %n_6310150, i64* %vptr24708, align 8 ; call prim_null_63
  %cmpptr24712 = alloca i1, align 8  %cmp24709 = icmp eq i64 %n_6310150, 15 store volatile i1 %cmp24709, i1* %cmpptr24712, align 8; false?
  br i1 %cmp24709, label %else24711, label %then24710                                ; if

then24710:
 %vptr24713 = alloca i64, align 8 
  %h10151 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10151, i64* %vptr24713, align 8 ; call prim_halt
  %vptr24719 = alloca i64*, align 8 
  %cloptr24714 = inttoptr i64 %h10151 to i64* 
  store volatile i64* %cloptr24714, i64** %vptr24719, align 8 ; closure/env cast; i64 -> i64*
  %vptr24720 = alloca i64*, align 8 
  %i0ptr24715 = getelementptr inbounds i64, i64* %cloptr24714, i64 1 
  store volatile i64* %i0ptr24715, i64** %vptr24720, align 8 ; &cloptr24714[1]
 %vptr24721 = alloca i64, align 8 
  %f24717 = load i64, i64* %i0ptr24715, align 8 
  store volatile i64 %f24717, i64* %vptr24721, align 8 ; load; *i0ptr24715
  %fptr24716 = inttoptr i64 %f24717 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24716(i64 %h10151, i64 %h10151)                     ; tail call
  ret void

else24711:
 %vptr24722 = alloca i64, align 8 
  %mLH$_37x = call i64 @prim_car(i64 %rvp10145) 
  store volatile i64 %mLH$_37x, i64* %vptr24722, align 8 ; call prim_car
 %vptr24723 = alloca i64, align 8 
  %na10112 = call i64 @prim_cdr(i64 %rvp10145) 
  store volatile i64 %na10112, i64* %vptr24723, align 8 ; call prim_cdr
 %vptr24724 = alloca i64, align 8 
  %n_6310146 = call i64 @prim_null_63(i64 %na10112) 
  store volatile i64 %n_6310146, i64* %vptr24724, align 8 ; call prim_null_63
  %cmpptr24728 = alloca i1, align 8  %cmp24725 = icmp eq i64 %n_6310146, 15 store volatile i1 %cmp24725, i1* %cmpptr24728, align 8; false?
  br i1 %cmp24725, label %else24727, label %then24726                                ; if

then24726:
 %vptr24729 = alloca i64, align 8 
  %arg8226 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8226, i64* %vptr24729, align 8 ; quoted int
 %vptr24730 = alloca i64, align 8 
  %a7071 = call i64 @prim_vector_45ref(i64 %SdC$_37wind_45stack, i64 %arg8226) 
  store volatile i64 %a7071, i64* %vptr24730, align 8 ; call prim_vector_45ref
 %vptr24731 = alloca i64, align 8 
  %a7072 = call i64 @prim_eq_63(i64 %cZG$_37saved_45stack, i64 %a7071) 
  store volatile i64 %a7072, i64* %vptr24731, align 8 ; call prim_eq_63
  %cmpptr24735 = alloca i1, align 8  %cmp24732 = icmp eq i64 %a7072, 15 store volatile i1 %cmp24732, i1* %cmpptr24735, align 8; false?
  br i1 %cmp24732, label %else24734, label %then24733                                ; if

then24733:
 %vptr24736 = alloca i64, align 8 
  %retprim7251 = call i64 @prim_void() 
  store volatile i64 %retprim7251, i64* %vptr24736, align 8 ; call prim_void
  %vptr24745 = alloca i64*, align 8 
  %cloptr24737 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr24737, i64** %vptr24745, align 8 ; malloc
  %vptr24746 = alloca i64*, align 8 
  %eptr24739 = getelementptr inbounds i64, i64* %cloptr24737, i64 2 
  store volatile i64* %eptr24739, i64** %vptr24746, align 8 ; &eptr24739[1]
  %vptr24747 = alloca i64*, align 8 
  %eptr24740 = getelementptr inbounds i64, i64* %cloptr24737, i64 3 
  store volatile i64* %eptr24740, i64** %vptr24747, align 8 ; &eptr24740[2]
  %vptr24748 = alloca i64*, align 8 
  %eptr24741 = getelementptr inbounds i64, i64* %cloptr24737, i64 4 
  store volatile i64* %eptr24741, i64** %vptr24748, align 8 ; &eptr24741[3]
  %vptr24749 = alloca i64*, align 8 
  %eptr24742 = getelementptr inbounds i64, i64* %cloptr24737, i64 5 
  store volatile i64* %eptr24742, i64** %vptr24749, align 8 ; &eptr24742[4]
  %vptr24750 = alloca i64*, align 8 
  %eptr24743 = getelementptr inbounds i64, i64* %cloptr24737, i64 6 
  store volatile i64* %eptr24743, i64** %vptr24750, align 8 ; &eptr24743[5]
  store i64 %s5Y$_37k, i64* %eptr24739                                               ; *eptr24739 = %s5Y$_37k
  store i64 %mLH$_37x, i64* %eptr24740                                               ; *eptr24740 = %mLH$_37x
  store i64 %emsg18637, i64* %eptr24741                                              ; *eptr24741 = %emsg18637
  store i64 %cont7249, i64* %eptr24742                                               ; *eptr24742 = %cont7249
  store i64 %emsg08636, i64* %eptr24743                                              ; *eptr24743 = %emsg08636
  %vptr24751 = alloca i64*, align 8 
  %eptr24738 = getelementptr inbounds i64, i64* %cloptr24737, i64 1 
  store volatile i64* %eptr24738, i64** %vptr24751, align 8 ; &cloptr24737[1]
 %vptr24752 = alloca i64, align 8 
  %f24744 = ptrtoint void(i64,i64)* @lam11837 to i64 
  store volatile i64 %f24744, i64* %vptr24752, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f24744, i64* %eptr24738                                                 ; store fptr
 %vptr24753 = alloca i64, align 8 
  %arg8232 = ptrtoint i64* %cloptr24737 to i64 
  store volatile i64 %arg8232, i64* %vptr24753, align 8 ; closure cast; i64* -> i64
 %vptr24754 = alloca i64, align 8 
  %arg8231 = add i64 0, 0 
  store volatile i64 %arg8231, i64* %vptr24754, align 8 ; quoted ()
 %vptr24755 = alloca i64, align 8 
  %rva10128 = add i64 0, 0 
  store volatile i64 %rva10128, i64* %vptr24755, align 8 ; quoted ()
 %vptr24756 = alloca i64, align 8 
  %rva10127 = call i64 @prim_cons(i64 %retprim7251, i64 %rva10128) 
  store volatile i64 %rva10127, i64* %vptr24756, align 8 ; call prim_cons
 %vptr24757 = alloca i64, align 8 
  %rva10126 = call i64 @prim_cons(i64 %arg8231, i64 %rva10127) 
  store volatile i64 %rva10126, i64* %vptr24757, align 8 ; call prim_cons
  %vptr24763 = alloca i64*, align 8 
  %cloptr24758 = inttoptr i64 %arg8232 to i64* 
  store volatile i64* %cloptr24758, i64** %vptr24763, align 8 ; closure/env cast; i64 -> i64*
  %vptr24764 = alloca i64*, align 8 
  %i0ptr24759 = getelementptr inbounds i64, i64* %cloptr24758, i64 1 
  store volatile i64* %i0ptr24759, i64** %vptr24764, align 8 ; &cloptr24758[1]
 %vptr24765 = alloca i64, align 8 
  %f24761 = load i64, i64* %i0ptr24759, align 8 
  store volatile i64 %f24761, i64* %vptr24765, align 8 ; load; *i0ptr24759
  %fptr24760 = inttoptr i64 %f24761 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24760(i64 %arg8232, i64 %rva10126)                  ; tail call
  ret void

else24734:
  %vptr24774 = alloca i64*, align 8 
  %cloptr24766 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr24766, i64** %vptr24774, align 8 ; malloc
  %vptr24775 = alloca i64*, align 8 
  %eptr24768 = getelementptr inbounds i64, i64* %cloptr24766, i64 2 
  store volatile i64* %eptr24768, i64** %vptr24775, align 8 ; &eptr24768[1]
  %vptr24776 = alloca i64*, align 8 
  %eptr24769 = getelementptr inbounds i64, i64* %cloptr24766, i64 3 
  store volatile i64* %eptr24769, i64** %vptr24776, align 8 ; &eptr24769[2]
  %vptr24777 = alloca i64*, align 8 
  %eptr24770 = getelementptr inbounds i64, i64* %cloptr24766, i64 4 
  store volatile i64* %eptr24770, i64** %vptr24777, align 8 ; &eptr24770[3]
  %vptr24778 = alloca i64*, align 8 
  %eptr24771 = getelementptr inbounds i64, i64* %cloptr24766, i64 5 
  store volatile i64* %eptr24771, i64** %vptr24778, align 8 ; &eptr24771[4]
  %vptr24779 = alloca i64*, align 8 
  %eptr24772 = getelementptr inbounds i64, i64* %cloptr24766, i64 6 
  store volatile i64* %eptr24772, i64** %vptr24779, align 8 ; &eptr24772[5]
  store i64 %s5Y$_37k, i64* %eptr24768                                               ; *eptr24768 = %s5Y$_37k
  store i64 %mLH$_37x, i64* %eptr24769                                               ; *eptr24769 = %mLH$_37x
  store i64 %emsg18637, i64* %eptr24770                                              ; *eptr24770 = %emsg18637
  store i64 %cont7249, i64* %eptr24771                                               ; *eptr24771 = %cont7249
  store i64 %emsg08636, i64* %eptr24772                                              ; *eptr24772 = %emsg08636
  %vptr24780 = alloca i64*, align 8 
  %eptr24767 = getelementptr inbounds i64, i64* %cloptr24766, i64 1 
  store volatile i64* %eptr24767, i64** %vptr24780, align 8 ; &cloptr24766[1]
 %vptr24781 = alloca i64, align 8 
  %f24773 = ptrtoint void(i64,i64)* @lam11841 to i64 
  store volatile i64 %f24773, i64* %vptr24781, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f24773, i64* %eptr24767                                                 ; store fptr
 %vptr24782 = alloca i64, align 8 
  %arg8237 = ptrtoint i64* %cloptr24766 to i64 
  store volatile i64 %arg8237, i64* %vptr24782, align 8 ; closure cast; i64* -> i64
 %vptr24783 = alloca i64, align 8 
  %rva10144 = add i64 0, 0 
  store volatile i64 %rva10144, i64* %vptr24783, align 8 ; quoted ()
 %vptr24784 = alloca i64, align 8 
  %rva10143 = call i64 @prim_cons(i64 %cZG$_37saved_45stack, i64 %rva10144) 
  store volatile i64 %rva10143, i64* %vptr24784, align 8 ; call prim_cons
 %vptr24785 = alloca i64, align 8 
  %rva10142 = call i64 @prim_cons(i64 %arg8237, i64 %rva10143) 
  store volatile i64 %rva10142, i64* %vptr24785, align 8 ; call prim_cons
  %vptr24791 = alloca i64*, align 8 
  %cloptr24786 = inttoptr i64 %U8g$_37do_45wind to i64* 
  store volatile i64* %cloptr24786, i64** %vptr24791, align 8 ; closure/env cast; i64 -> i64*
  %vptr24792 = alloca i64*, align 8 
  %i0ptr24787 = getelementptr inbounds i64, i64* %cloptr24786, i64 1 
  store volatile i64* %i0ptr24787, i64** %vptr24792, align 8 ; &cloptr24786[1]
 %vptr24793 = alloca i64, align 8 
  %f24789 = load i64, i64* %i0ptr24787, align 8 
  store volatile i64 %f24789, i64* %vptr24793, align 8 ; load; *i0ptr24787
  %fptr24788 = inttoptr i64 %f24789 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24788(i64 %U8g$_37do_45wind, i64 %rva10142)         ; tail call
  ret void

else24727:
 %vptr24794 = alloca i64, align 8 
  %h10147 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10147, i64* %vptr24794, align 8 ; call prim_halt
  %vptr24800 = alloca i64*, align 8 
  %cloptr24795 = inttoptr i64 %h10147 to i64* 
  store volatile i64* %cloptr24795, i64** %vptr24800, align 8 ; closure/env cast; i64 -> i64*
  %vptr24801 = alloca i64*, align 8 
  %i0ptr24796 = getelementptr inbounds i64, i64* %cloptr24795, i64 1 
  store volatile i64* %i0ptr24796, i64** %vptr24801, align 8 ; &cloptr24795[1]
 %vptr24802 = alloca i64, align 8 
  %f24798 = load i64, i64* %i0ptr24796, align 8 
  store volatile i64 %f24798, i64* %vptr24802, align 8 ; load; *i0ptr24796
  %fptr24797 = inttoptr i64 %f24798 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24797(i64 %h10147, i64 %h10147)                     ; tail call
  ret void
}


define void @lam11841(i64 %env11842, i64 %rvp10138) {
 %vptr24805 = alloca i64, align 8 
  %envptr24803 = inttoptr i64 %env11842 to i64* 
  store volatile i64 %emsg08636, i64* %vptr24805, align 8 ; closure/env cast; i64 -> i64*
  %vptr24806 = alloca i64*, align 8 
  %envptr24804 = getelementptr inbounds i64, i64* %envptr24803, i64 6 
  store volatile i64* %envptr24804, i64** %vptr24806, align 8 ; &envptr24803[5]
 %vptr24807 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr24804, align 8 
  store volatile i64 %emsg08636, i64* %vptr24807, align 8 ; load; *envptr24804
 %vptr24810 = alloca i64, align 8 
  %envptr24808 = inttoptr i64 %env11842 to i64* 
  store volatile i64 %cont7249, i64* %vptr24810, align 8 ; closure/env cast; i64 -> i64*
  %vptr24811 = alloca i64*, align 8 
  %envptr24809 = getelementptr inbounds i64, i64* %envptr24808, i64 5 
  store volatile i64* %envptr24809, i64** %vptr24811, align 8 ; &envptr24808[4]
 %vptr24812 = alloca i64, align 8 
  %cont7249 = load i64, i64* %envptr24809, align 8 
  store volatile i64 %cont7249, i64* %vptr24812, align 8 ; load; *envptr24809
 %vptr24815 = alloca i64, align 8 
  %envptr24813 = inttoptr i64 %env11842 to i64* 
  store volatile i64 %emsg18637, i64* %vptr24815, align 8 ; closure/env cast; i64 -> i64*
  %vptr24816 = alloca i64*, align 8 
  %envptr24814 = getelementptr inbounds i64, i64* %envptr24813, i64 4 
  store volatile i64* %envptr24814, i64** %vptr24816, align 8 ; &envptr24813[3]
 %vptr24817 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr24814, align 8 
  store volatile i64 %emsg18637, i64* %vptr24817, align 8 ; load; *envptr24814
 %vptr24820 = alloca i64, align 8 
  %envptr24818 = inttoptr i64 %env11842 to i64* 
  store volatile i64 %mLH$_37x, i64* %vptr24820, align 8 ; closure/env cast; i64 -> i64*
  %vptr24821 = alloca i64*, align 8 
  %envptr24819 = getelementptr inbounds i64, i64* %envptr24818, i64 3 
  store volatile i64* %envptr24819, i64** %vptr24821, align 8 ; &envptr24818[2]
 %vptr24822 = alloca i64, align 8 
  %mLH$_37x = load i64, i64* %envptr24819, align 8 
  store volatile i64 %mLH$_37x, i64* %vptr24822, align 8 ; load; *envptr24819
 %vptr24825 = alloca i64, align 8 
  %envptr24823 = inttoptr i64 %env11842 to i64* 
  store volatile i64 %s5Y$_37k, i64* %vptr24825, align 8 ; closure/env cast; i64 -> i64*
  %vptr24826 = alloca i64*, align 8 
  %envptr24824 = getelementptr inbounds i64, i64* %envptr24823, i64 2 
  store volatile i64* %envptr24824, i64** %vptr24826, align 8 ; &envptr24823[1]
 %vptr24827 = alloca i64, align 8 
  %s5Y$_37k = load i64, i64* %envptr24824, align 8 
  store volatile i64 %s5Y$_37k, i64* %vptr24827, align 8 ; load; *envptr24824
 %vptr24828 = alloca i64, align 8 
  %_957250 = call i64 @prim_car(i64 %rvp10138) 
  store volatile i64 %_957250, i64* %vptr24828, align 8 ; call prim_car
 %vptr24829 = alloca i64, align 8 
  %rvp10134 = call i64 @prim_cdr(i64 %rvp10138) 
  store volatile i64 %rvp10134, i64* %vptr24829, align 8 ; call prim_cdr
 %vptr24830 = alloca i64, align 8 
  %n_6310139 = call i64 @prim_null_63(i64 %rvp10134) 
  store volatile i64 %n_6310139, i64* %vptr24830, align 8 ; call prim_null_63
  %cmpptr24834 = alloca i1, align 8  %cmp24831 = icmp eq i64 %n_6310139, 15 store volatile i1 %cmp24831, i1* %cmpptr24834, align 8; false?
  br i1 %cmp24831, label %else24833, label %then24832                                ; if

then24832:
 %vptr24835 = alloca i64, align 8 
  %h10140 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10140, i64* %vptr24835, align 8 ; call prim_halt
  %vptr24841 = alloca i64*, align 8 
  %cloptr24836 = inttoptr i64 %h10140 to i64* 
  store volatile i64* %cloptr24836, i64** %vptr24841, align 8 ; closure/env cast; i64 -> i64*
  %vptr24842 = alloca i64*, align 8 
  %i0ptr24837 = getelementptr inbounds i64, i64* %cloptr24836, i64 1 
  store volatile i64* %i0ptr24837, i64** %vptr24842, align 8 ; &cloptr24836[1]
 %vptr24843 = alloca i64, align 8 
  %f24839 = load i64, i64* %i0ptr24837, align 8 
  store volatile i64 %f24839, i64* %vptr24843, align 8 ; load; *i0ptr24837
  %fptr24838 = inttoptr i64 %f24839 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24838(i64 %h10140, i64 %h10140)                     ; tail call
  ret void

else24833:
 %vptr24844 = alloca i64, align 8 
  %sfO$_956898 = call i64 @prim_car(i64 %rvp10134) 
  store volatile i64 %sfO$_956898, i64* %vptr24844, align 8 ; call prim_car
 %vptr24845 = alloca i64, align 8 
  %na10130 = call i64 @prim_cdr(i64 %rvp10134) 
  store volatile i64 %na10130, i64* %vptr24845, align 8 ; call prim_cdr
 %vptr24846 = alloca i64, align 8 
  %n_6310135 = call i64 @prim_null_63(i64 %na10130) 
  store volatile i64 %n_6310135, i64* %vptr24846, align 8 ; call prim_null_63
  %cmpptr24850 = alloca i1, align 8  %cmp24847 = icmp eq i64 %n_6310135, 15 store volatile i1 %cmp24847, i1* %cmpptr24850, align 8; false?
  br i1 %cmp24847, label %else24849, label %then24848                                ; if

then24848:
 %vptr24851 = alloca i64, align 8 
  %rva10133 = add i64 0, 0 
  store volatile i64 %rva10133, i64* %vptr24851, align 8 ; quoted ()
 %vptr24852 = alloca i64, align 8 
  %rva10132 = call i64 @prim_cons(i64 %mLH$_37x, i64 %rva10133) 
  store volatile i64 %rva10132, i64* %vptr24852, align 8 ; call prim_cons
 %vptr24853 = alloca i64, align 8 
  %rva10131 = call i64 @prim_cons(i64 %cont7249, i64 %rva10132) 
  store volatile i64 %rva10131, i64* %vptr24853, align 8 ; call prim_cons
  %vptr24859 = alloca i64*, align 8 
  %cloptr24854 = inttoptr i64 %s5Y$_37k to i64* 
  store volatile i64* %cloptr24854, i64** %vptr24859, align 8 ; closure/env cast; i64 -> i64*
  %vptr24860 = alloca i64*, align 8 
  %i0ptr24855 = getelementptr inbounds i64, i64* %cloptr24854, i64 1 
  store volatile i64* %i0ptr24855, i64** %vptr24860, align 8 ; &cloptr24854[1]
 %vptr24861 = alloca i64, align 8 
  %f24857 = load i64, i64* %i0ptr24855, align 8 
  store volatile i64 %f24857, i64* %vptr24861, align 8 ; load; *i0ptr24855
  %fptr24856 = inttoptr i64 %f24857 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24856(i64 %s5Y$_37k, i64 %rva10131)                 ; tail call
  ret void

else24849:
 %vptr24862 = alloca i64, align 8 
  %h10136 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10136, i64* %vptr24862, align 8 ; call prim_halt
  %vptr24868 = alloca i64*, align 8 
  %cloptr24863 = inttoptr i64 %h10136 to i64* 
  store volatile i64* %cloptr24863, i64** %vptr24868, align 8 ; closure/env cast; i64 -> i64*
  %vptr24869 = alloca i64*, align 8 
  %i0ptr24864 = getelementptr inbounds i64, i64* %cloptr24863, i64 1 
  store volatile i64* %i0ptr24864, i64** %vptr24869, align 8 ; &cloptr24863[1]
 %vptr24870 = alloca i64, align 8 
  %f24866 = load i64, i64* %i0ptr24864, align 8 
  store volatile i64 %f24866, i64* %vptr24870, align 8 ; load; *i0ptr24864
  %fptr24865 = inttoptr i64 %f24866 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24865(i64 %h10136, i64 %h10136)                     ; tail call
  ret void
}


define void @lam11837(i64 %env11838, i64 %rvp10122) {
 %vptr24873 = alloca i64, align 8 
  %envptr24871 = inttoptr i64 %env11838 to i64* 
  store volatile i64 %emsg08636, i64* %vptr24873, align 8 ; closure/env cast; i64 -> i64*
  %vptr24874 = alloca i64*, align 8 
  %envptr24872 = getelementptr inbounds i64, i64* %envptr24871, i64 6 
  store volatile i64* %envptr24872, i64** %vptr24874, align 8 ; &envptr24871[5]
 %vptr24875 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr24872, align 8 
  store volatile i64 %emsg08636, i64* %vptr24875, align 8 ; load; *envptr24872
 %vptr24878 = alloca i64, align 8 
  %envptr24876 = inttoptr i64 %env11838 to i64* 
  store volatile i64 %cont7249, i64* %vptr24878, align 8 ; closure/env cast; i64 -> i64*
  %vptr24879 = alloca i64*, align 8 
  %envptr24877 = getelementptr inbounds i64, i64* %envptr24876, i64 5 
  store volatile i64* %envptr24877, i64** %vptr24879, align 8 ; &envptr24876[4]
 %vptr24880 = alloca i64, align 8 
  %cont7249 = load i64, i64* %envptr24877, align 8 
  store volatile i64 %cont7249, i64* %vptr24880, align 8 ; load; *envptr24877
 %vptr24883 = alloca i64, align 8 
  %envptr24881 = inttoptr i64 %env11838 to i64* 
  store volatile i64 %emsg18637, i64* %vptr24883, align 8 ; closure/env cast; i64 -> i64*
  %vptr24884 = alloca i64*, align 8 
  %envptr24882 = getelementptr inbounds i64, i64* %envptr24881, i64 4 
  store volatile i64* %envptr24882, i64** %vptr24884, align 8 ; &envptr24881[3]
 %vptr24885 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr24882, align 8 
  store volatile i64 %emsg18637, i64* %vptr24885, align 8 ; load; *envptr24882
 %vptr24888 = alloca i64, align 8 
  %envptr24886 = inttoptr i64 %env11838 to i64* 
  store volatile i64 %mLH$_37x, i64* %vptr24888, align 8 ; closure/env cast; i64 -> i64*
  %vptr24889 = alloca i64*, align 8 
  %envptr24887 = getelementptr inbounds i64, i64* %envptr24886, i64 3 
  store volatile i64* %envptr24887, i64** %vptr24889, align 8 ; &envptr24886[2]
 %vptr24890 = alloca i64, align 8 
  %mLH$_37x = load i64, i64* %envptr24887, align 8 
  store volatile i64 %mLH$_37x, i64* %vptr24890, align 8 ; load; *envptr24887
 %vptr24893 = alloca i64, align 8 
  %envptr24891 = inttoptr i64 %env11838 to i64* 
  store volatile i64 %s5Y$_37k, i64* %vptr24893, align 8 ; closure/env cast; i64 -> i64*
  %vptr24894 = alloca i64*, align 8 
  %envptr24892 = getelementptr inbounds i64, i64* %envptr24891, i64 2 
  store volatile i64* %envptr24892, i64** %vptr24894, align 8 ; &envptr24891[1]
 %vptr24895 = alloca i64, align 8 
  %s5Y$_37k = load i64, i64* %envptr24892, align 8 
  store volatile i64 %s5Y$_37k, i64* %vptr24895, align 8 ; load; *envptr24892
 %vptr24896 = alloca i64, align 8 
  %_957250 = call i64 @prim_car(i64 %rvp10122) 
  store volatile i64 %_957250, i64* %vptr24896, align 8 ; call prim_car
 %vptr24897 = alloca i64, align 8 
  %rvp10118 = call i64 @prim_cdr(i64 %rvp10122) 
  store volatile i64 %rvp10118, i64* %vptr24897, align 8 ; call prim_cdr
 %vptr24898 = alloca i64, align 8 
  %n_6310123 = call i64 @prim_null_63(i64 %rvp10118) 
  store volatile i64 %n_6310123, i64* %vptr24898, align 8 ; call prim_null_63
  %cmpptr24902 = alloca i1, align 8  %cmp24899 = icmp eq i64 %n_6310123, 15 store volatile i1 %cmp24899, i1* %cmpptr24902, align 8; false?
  br i1 %cmp24899, label %else24901, label %then24900                                ; if

then24900:
 %vptr24903 = alloca i64, align 8 
  %h10124 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10124, i64* %vptr24903, align 8 ; call prim_halt
  %vptr24909 = alloca i64*, align 8 
  %cloptr24904 = inttoptr i64 %h10124 to i64* 
  store volatile i64* %cloptr24904, i64** %vptr24909, align 8 ; closure/env cast; i64 -> i64*
  %vptr24910 = alloca i64*, align 8 
  %i0ptr24905 = getelementptr inbounds i64, i64* %cloptr24904, i64 1 
  store volatile i64* %i0ptr24905, i64** %vptr24910, align 8 ; &cloptr24904[1]
 %vptr24911 = alloca i64, align 8 
  %f24907 = load i64, i64* %i0ptr24905, align 8 
  store volatile i64 %f24907, i64* %vptr24911, align 8 ; load; *i0ptr24905
  %fptr24906 = inttoptr i64 %f24907 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24906(i64 %h10124, i64 %h10124)                     ; tail call
  ret void

else24901:
 %vptr24912 = alloca i64, align 8 
  %sfO$_956898 = call i64 @prim_car(i64 %rvp10118) 
  store volatile i64 %sfO$_956898, i64* %vptr24912, align 8 ; call prim_car
 %vptr24913 = alloca i64, align 8 
  %na10114 = call i64 @prim_cdr(i64 %rvp10118) 
  store volatile i64 %na10114, i64* %vptr24913, align 8 ; call prim_cdr
 %vptr24914 = alloca i64, align 8 
  %n_6310119 = call i64 @prim_null_63(i64 %na10114) 
  store volatile i64 %n_6310119, i64* %vptr24914, align 8 ; call prim_null_63
  %cmpptr24918 = alloca i1, align 8  %cmp24915 = icmp eq i64 %n_6310119, 15 store volatile i1 %cmp24915, i1* %cmpptr24918, align 8; false?
  br i1 %cmp24915, label %else24917, label %then24916                                ; if

then24916:
 %vptr24919 = alloca i64, align 8 
  %rva10117 = add i64 0, 0 
  store volatile i64 %rva10117, i64* %vptr24919, align 8 ; quoted ()
 %vptr24920 = alloca i64, align 8 
  %rva10116 = call i64 @prim_cons(i64 %mLH$_37x, i64 %rva10117) 
  store volatile i64 %rva10116, i64* %vptr24920, align 8 ; call prim_cons
 %vptr24921 = alloca i64, align 8 
  %rva10115 = call i64 @prim_cons(i64 %cont7249, i64 %rva10116) 
  store volatile i64 %rva10115, i64* %vptr24921, align 8 ; call prim_cons
  %vptr24927 = alloca i64*, align 8 
  %cloptr24922 = inttoptr i64 %s5Y$_37k to i64* 
  store volatile i64* %cloptr24922, i64** %vptr24927, align 8 ; closure/env cast; i64 -> i64*
  %vptr24928 = alloca i64*, align 8 
  %i0ptr24923 = getelementptr inbounds i64, i64* %cloptr24922, i64 1 
  store volatile i64* %i0ptr24923, i64** %vptr24928, align 8 ; &cloptr24922[1]
 %vptr24929 = alloca i64, align 8 
  %f24925 = load i64, i64* %i0ptr24923, align 8 
  store volatile i64 %f24925, i64* %vptr24929, align 8 ; load; *i0ptr24923
  %fptr24924 = inttoptr i64 %f24925 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24924(i64 %s5Y$_37k, i64 %rva10115)                 ; tail call
  ret void

else24917:
 %vptr24930 = alloca i64, align 8 
  %h10120 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10120, i64* %vptr24930, align 8 ; call prim_halt
  %vptr24936 = alloca i64*, align 8 
  %cloptr24931 = inttoptr i64 %h10120 to i64* 
  store volatile i64* %cloptr24931, i64** %vptr24936, align 8 ; closure/env cast; i64 -> i64*
  %vptr24937 = alloca i64*, align 8 
  %i0ptr24932 = getelementptr inbounds i64, i64* %cloptr24931, i64 1 
  store volatile i64* %i0ptr24932, i64** %vptr24937, align 8 ; &cloptr24931[1]
 %vptr24938 = alloca i64, align 8 
  %f24934 = load i64, i64* %i0ptr24932, align 8 
  store volatile i64 %f24934, i64* %vptr24938, align 8 ; load; *i0ptr24932
  %fptr24933 = inttoptr i64 %f24934 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24933(i64 %h10120, i64 %h10120)                     ; tail call
  ret void
}


define void @lam11831(i64 %env11832, i64 %rvp10311) {
 %vptr24941 = alloca i64, align 8 
  %envptr24939 = inttoptr i64 %env11832 to i64* 
  store volatile i64 %cont7229, i64* %vptr24941, align 8 ; closure/env cast; i64 -> i64*
  %vptr24942 = alloca i64*, align 8 
  %envptr24940 = getelementptr inbounds i64, i64* %envptr24939, i64 11 
  store volatile i64* %envptr24940, i64** %vptr24942, align 8 ; &envptr24939[10]
 %vptr24943 = alloca i64, align 8 
  %cont7229 = load i64, i64* %envptr24940, align 8 
  store volatile i64 %cont7229, i64* %vptr24943, align 8 ; load; *envptr24940
 %vptr24946 = alloca i64, align 8 
  %envptr24944 = inttoptr i64 %env11832 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr24946, align 8 ; closure/env cast; i64 -> i64*
  %vptr24947 = alloca i64*, align 8 
  %envptr24945 = getelementptr inbounds i64, i64* %envptr24944, i64 10 
  store volatile i64* %envptr24945, i64** %vptr24947, align 8 ; &envptr24944[9]
 %vptr24948 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr24945, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr24948, align 8 ; load; *envptr24945
 %vptr24951 = alloca i64, align 8 
  %envptr24949 = inttoptr i64 %env11832 to i64* 
  store volatile i64 %a7067, i64* %vptr24951, align 8 ; closure/env cast; i64 -> i64*
  %vptr24952 = alloca i64*, align 8 
  %envptr24950 = getelementptr inbounds i64, i64* %envptr24949, i64 9 
  store volatile i64* %envptr24950, i64** %vptr24952, align 8 ; &envptr24949[8]
 %vptr24953 = alloca i64, align 8 
  %a7067 = load i64, i64* %envptr24950, align 8 
  store volatile i64 %a7067, i64* %vptr24953, align 8 ; load; *envptr24950
 %vptr24956 = alloca i64, align 8 
  %envptr24954 = inttoptr i64 %env11832 to i64* 
  store volatile i64 %emsg08636, i64* %vptr24956, align 8 ; closure/env cast; i64 -> i64*
  %vptr24957 = alloca i64*, align 8 
  %envptr24955 = getelementptr inbounds i64, i64* %envptr24954, i64 8 
  store volatile i64* %envptr24955, i64** %vptr24957, align 8 ; &envptr24954[7]
 %vptr24958 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr24955, align 8 
  store volatile i64 %emsg08636, i64* %vptr24958, align 8 ; load; *envptr24955
 %vptr24961 = alloca i64, align 8 
  %envptr24959 = inttoptr i64 %env11832 to i64* 
  store volatile i64 %MXn$x, i64* %vptr24961, align 8 ; closure/env cast; i64 -> i64*
  %vptr24962 = alloca i64*, align 8 
  %envptr24960 = getelementptr inbounds i64, i64* %envptr24959, i64 7 
  store volatile i64* %envptr24960, i64** %vptr24962, align 8 ; &envptr24959[6]
 %vptr24963 = alloca i64, align 8 
  %MXn$x = load i64, i64* %envptr24960, align 8 
  store volatile i64 %MXn$x, i64* %vptr24963, align 8 ; load; *envptr24960
 %vptr24966 = alloca i64, align 8 
  %envptr24964 = inttoptr i64 %env11832 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr24966, align 8 ; closure/env cast; i64 -> i64*
  %vptr24967 = alloca i64*, align 8 
  %envptr24965 = getelementptr inbounds i64, i64* %envptr24964, i64 6 
  store volatile i64* %envptr24965, i64** %vptr24967, align 8 ; &envptr24964[5]
 %vptr24968 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr24965, align 8 
  store volatile i64 %Pll$pred, i64* %vptr24968, align 8 ; load; *envptr24965
 %vptr24971 = alloca i64, align 8 
  %envptr24969 = inttoptr i64 %env11832 to i64* 
  store volatile i64 %ZpZ$c, i64* %vptr24971, align 8 ; closure/env cast; i64 -> i64*
  %vptr24972 = alloca i64*, align 8 
  %envptr24970 = getelementptr inbounds i64, i64* %envptr24969, i64 5 
  store volatile i64* %envptr24970, i64** %vptr24972, align 8 ; &envptr24969[4]
 %vptr24973 = alloca i64, align 8 
  %ZpZ$c = load i64, i64* %envptr24970, align 8 
  store volatile i64 %ZpZ$c, i64* %vptr24973, align 8 ; load; *envptr24970
 %vptr24976 = alloca i64, align 8 
  %envptr24974 = inttoptr i64 %env11832 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr24976, align 8 ; closure/env cast; i64 -> i64*
  %vptr24977 = alloca i64*, align 8 
  %envptr24975 = getelementptr inbounds i64, i64* %envptr24974, i64 4 
  store volatile i64* %envptr24975, i64** %vptr24977, align 8 ; &envptr24974[3]
 %vptr24978 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr24975, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr24978, align 8 ; load; *envptr24975
 %vptr24981 = alloca i64, align 8 
  %envptr24979 = inttoptr i64 %env11832 to i64* 
  store volatile i64 %YxK$fibc, i64* %vptr24981, align 8 ; closure/env cast; i64 -> i64*
  %vptr24982 = alloca i64*, align 8 
  %envptr24980 = getelementptr inbounds i64, i64* %envptr24979, i64 3 
  store volatile i64* %envptr24980, i64** %vptr24982, align 8 ; &envptr24979[2]
 %vptr24983 = alloca i64, align 8 
  %YxK$fibc = load i64, i64* %envptr24980, align 8 
  store volatile i64 %YxK$fibc, i64* %vptr24983, align 8 ; load; *envptr24980
 %vptr24986 = alloca i64, align 8 
  %envptr24984 = inttoptr i64 %env11832 to i64* 
  store volatile i64 %emsg18637, i64* %vptr24986, align 8 ; closure/env cast; i64 -> i64*
  %vptr24987 = alloca i64*, align 8 
  %envptr24985 = getelementptr inbounds i64, i64* %envptr24984, i64 2 
  store volatile i64* %envptr24985, i64** %vptr24987, align 8 ; &envptr24984[1]
 %vptr24988 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr24985, align 8 
  store volatile i64 %emsg18637, i64* %vptr24988, align 8 ; load; *envptr24985
 %vptr24989 = alloca i64, align 8 
  %_957235 = call i64 @prim_car(i64 %rvp10311) 
  store volatile i64 %_957235, i64* %vptr24989, align 8 ; call prim_car
 %vptr24990 = alloca i64, align 8 
  %rvp10307 = call i64 @prim_cdr(i64 %rvp10311) 
  store volatile i64 %rvp10307, i64* %vptr24990, align 8 ; call prim_cdr
 %vptr24991 = alloca i64, align 8 
  %n_6310312 = call i64 @prim_null_63(i64 %rvp10307) 
  store volatile i64 %n_6310312, i64* %vptr24991, align 8 ; call prim_null_63
  %cmpptr24995 = alloca i1, align 8  %cmp24992 = icmp eq i64 %n_6310312, 15 store volatile i1 %cmp24992, i1* %cmpptr24995, align 8; false?
  br i1 %cmp24992, label %else24994, label %then24993                                ; if

then24993:
 %vptr24996 = alloca i64, align 8 
  %h10313 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10313, i64* %vptr24996, align 8 ; call prim_halt
  %vptr25002 = alloca i64*, align 8 
  %cloptr24997 = inttoptr i64 %h10313 to i64* 
  store volatile i64* %cloptr24997, i64** %vptr25002, align 8 ; closure/env cast; i64 -> i64*
  %vptr25003 = alloca i64*, align 8 
  %i0ptr24998 = getelementptr inbounds i64, i64* %cloptr24997, i64 1 
  store volatile i64* %i0ptr24998, i64** %vptr25003, align 8 ; &cloptr24997[1]
 %vptr25004 = alloca i64, align 8 
  %f25000 = load i64, i64* %i0ptr24998, align 8 
  store volatile i64 %f25000, i64* %vptr25004, align 8 ; load; *i0ptr24998
  %fptr24999 = inttoptr i64 %f25000 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr24999(i64 %h10313, i64 %h10313)                     ; tail call
  ret void

else24994:
 %vptr25005 = alloca i64, align 8 
  %a7074 = call i64 @prim_car(i64 %rvp10307) 
  store volatile i64 %a7074, i64* %vptr25005, align 8 ; call prim_car
 %vptr25006 = alloca i64, align 8 
  %na10165 = call i64 @prim_cdr(i64 %rvp10307) 
  store volatile i64 %na10165, i64* %vptr25006, align 8 ; call prim_cdr
 %vptr25007 = alloca i64, align 8 
  %n_6310308 = call i64 @prim_null_63(i64 %na10165) 
  store volatile i64 %n_6310308, i64* %vptr25007, align 8 ; call prim_null_63
  %cmpptr25011 = alloca i1, align 8  %cmp25008 = icmp eq i64 %n_6310308, 15 store volatile i1 %cmp25008, i1* %cmpptr25011, align 8; false?
  br i1 %cmp25008, label %else25010, label %then25009                                ; if

then25009:
  %vptr25022 = alloca i64*, align 8 
  %cloptr25012 = call i64* @make_closure(i64 64) 
  store volatile i64* %cloptr25012, i64** %vptr25022, align 8 ; malloc
  %vptr25023 = alloca i64*, align 8 
  %eptr25014 = getelementptr inbounds i64, i64* %cloptr25012, i64 2 
  store volatile i64* %eptr25014, i64** %vptr25023, align 8 ; &eptr25014[1]
  %vptr25024 = alloca i64*, align 8 
  %eptr25015 = getelementptr inbounds i64, i64* %cloptr25012, i64 3 
  store volatile i64* %eptr25015, i64** %vptr25024, align 8 ; &eptr25015[2]
  %vptr25025 = alloca i64*, align 8 
  %eptr25016 = getelementptr inbounds i64, i64* %cloptr25012, i64 4 
  store volatile i64* %eptr25016, i64** %vptr25025, align 8 ; &eptr25016[3]
  %vptr25026 = alloca i64*, align 8 
  %eptr25017 = getelementptr inbounds i64, i64* %cloptr25012, i64 5 
  store volatile i64* %eptr25017, i64** %vptr25026, align 8 ; &eptr25017[4]
  %vptr25027 = alloca i64*, align 8 
  %eptr25018 = getelementptr inbounds i64, i64* %cloptr25012, i64 6 
  store volatile i64* %eptr25018, i64** %vptr25027, align 8 ; &eptr25018[5]
  %vptr25028 = alloca i64*, align 8 
  %eptr25019 = getelementptr inbounds i64, i64* %cloptr25012, i64 7 
  store volatile i64* %eptr25019, i64** %vptr25028, align 8 ; &eptr25019[6]
  %vptr25029 = alloca i64*, align 8 
  %eptr25020 = getelementptr inbounds i64, i64* %cloptr25012, i64 8 
  store volatile i64* %eptr25020, i64** %vptr25029, align 8 ; &eptr25020[7]
  store i64 %emsg18637, i64* %eptr25014                                              ; *eptr25014 = %emsg18637
  store i64 %YxK$fibc, i64* %eptr25015                                               ; *eptr25015 = %YxK$fibc
  store i64 %SdC$_37wind_45stack, i64* %eptr25016                                    ; *eptr25016 = %SdC$_37wind_45stack
  store i64 %Pll$pred, i64* %eptr25017                                               ; *eptr25017 = %Pll$pred
  store i64 %MXn$x, i64* %eptr25018                                                  ; *eptr25018 = %MXn$x
  store i64 %emsg08636, i64* %eptr25019                                              ; *eptr25019 = %emsg08636
  store i64 %U8g$_37do_45wind, i64* %eptr25020                                       ; *eptr25020 = %U8g$_37do_45wind
  %vptr25030 = alloca i64*, align 8 
  %eptr25013 = getelementptr inbounds i64, i64* %cloptr25012, i64 1 
  store volatile i64* %eptr25013, i64** %vptr25030, align 8 ; &cloptr25012[1]
 %vptr25031 = alloca i64, align 8 
  %f25021 = ptrtoint void(i64,i64)* @lam11829 to i64 
  store volatile i64 %f25021, i64* %vptr25031, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f25021, i64* %eptr25013                                                 ; store fptr
 %vptr25032 = alloca i64, align 8 
  %arg8244 = ptrtoint i64* %cloptr25012 to i64 
  store volatile i64 %arg8244, i64* %vptr25032, align 8 ; closure cast; i64* -> i64
  %vptr25042 = alloca i64*, align 8 
  %cloptr25033 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr25033, i64** %vptr25042, align 8 ; malloc
  %vptr25043 = alloca i64*, align 8 
  %eptr25035 = getelementptr inbounds i64, i64* %cloptr25033, i64 2 
  store volatile i64* %eptr25035, i64** %vptr25043, align 8 ; &eptr25035[1]
  %vptr25044 = alloca i64*, align 8 
  %eptr25036 = getelementptr inbounds i64, i64* %cloptr25033, i64 3 
  store volatile i64* %eptr25036, i64** %vptr25044, align 8 ; &eptr25036[2]
  %vptr25045 = alloca i64*, align 8 
  %eptr25037 = getelementptr inbounds i64, i64* %cloptr25033, i64 4 
  store volatile i64* %eptr25037, i64** %vptr25045, align 8 ; &eptr25037[3]
  %vptr25046 = alloca i64*, align 8 
  %eptr25038 = getelementptr inbounds i64, i64* %cloptr25033, i64 5 
  store volatile i64* %eptr25038, i64** %vptr25046, align 8 ; &eptr25038[4]
  %vptr25047 = alloca i64*, align 8 
  %eptr25039 = getelementptr inbounds i64, i64* %cloptr25033, i64 6 
  store volatile i64* %eptr25039, i64** %vptr25047, align 8 ; &eptr25039[5]
  %vptr25048 = alloca i64*, align 8 
  %eptr25040 = getelementptr inbounds i64, i64* %cloptr25033, i64 7 
  store volatile i64* %eptr25040, i64** %vptr25048, align 8 ; &eptr25040[6]
  store i64 %emsg18637, i64* %eptr25035                                              ; *eptr25035 = %emsg18637
  store i64 %ZpZ$c, i64* %eptr25036                                                  ; *eptr25036 = %ZpZ$c
  store i64 %a7074, i64* %eptr25037                                                  ; *eptr25037 = %a7074
  store i64 %emsg08636, i64* %eptr25038                                              ; *eptr25038 = %emsg08636
  store i64 %a7067, i64* %eptr25039                                                  ; *eptr25039 = %a7067
  store i64 %cont7229, i64* %eptr25040                                               ; *eptr25040 = %cont7229
  %vptr25049 = alloca i64*, align 8 
  %eptr25034 = getelementptr inbounds i64, i64* %cloptr25033, i64 1 
  store volatile i64* %eptr25034, i64** %vptr25049, align 8 ; &cloptr25033[1]
 %vptr25050 = alloca i64, align 8 
  %f25041 = ptrtoint void(i64,i64)* @lam11797 to i64 
  store volatile i64 %f25041, i64* %vptr25050, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f25041, i64* %eptr25034                                                 ; store fptr
 %vptr25051 = alloca i64, align 8 
  %arg8243 = ptrtoint i64* %cloptr25033 to i64 
  store volatile i64 %arg8243, i64* %vptr25051, align 8 ; closure cast; i64* -> i64
  %vptr25061 = alloca i64*, align 8 
  %cloptr25052 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr25052, i64** %vptr25061, align 8 ; malloc
  %vptr25062 = alloca i64*, align 8 
  %eptr25054 = getelementptr inbounds i64, i64* %cloptr25052, i64 2 
  store volatile i64* %eptr25054, i64** %vptr25062, align 8 ; &eptr25054[1]
  %vptr25063 = alloca i64*, align 8 
  %eptr25055 = getelementptr inbounds i64, i64* %cloptr25052, i64 3 
  store volatile i64* %eptr25055, i64** %vptr25063, align 8 ; &eptr25055[2]
  %vptr25064 = alloca i64*, align 8 
  %eptr25056 = getelementptr inbounds i64, i64* %cloptr25052, i64 4 
  store volatile i64* %eptr25056, i64** %vptr25064, align 8 ; &eptr25056[3]
  %vptr25065 = alloca i64*, align 8 
  %eptr25057 = getelementptr inbounds i64, i64* %cloptr25052, i64 5 
  store volatile i64* %eptr25057, i64** %vptr25065, align 8 ; &eptr25057[4]
  %vptr25066 = alloca i64*, align 8 
  %eptr25058 = getelementptr inbounds i64, i64* %cloptr25052, i64 6 
  store volatile i64* %eptr25058, i64** %vptr25066, align 8 ; &eptr25058[5]
  %vptr25067 = alloca i64*, align 8 
  %eptr25059 = getelementptr inbounds i64, i64* %cloptr25052, i64 7 
  store volatile i64* %eptr25059, i64** %vptr25067, align 8 ; &eptr25059[6]
  store i64 %emsg18637, i64* %eptr25054                                              ; *eptr25054 = %emsg18637
  store i64 %ZpZ$c, i64* %eptr25055                                                  ; *eptr25055 = %ZpZ$c
  store i64 %a7074, i64* %eptr25056                                                  ; *eptr25056 = %a7074
  store i64 %emsg08636, i64* %eptr25057                                              ; *eptr25057 = %emsg08636
  store i64 %a7067, i64* %eptr25058                                                  ; *eptr25058 = %a7067
  store i64 %cont7229, i64* %eptr25059                                               ; *eptr25059 = %cont7229
  %vptr25068 = alloca i64*, align 8 
  %eptr25053 = getelementptr inbounds i64, i64* %cloptr25052, i64 1 
  store volatile i64* %eptr25053, i64** %vptr25068, align 8 ; &cloptr25052[1]
 %vptr25069 = alloca i64, align 8 
  %f25060 = ptrtoint void(i64,i64)* @lam11794 to i64 
  store volatile i64 %f25060, i64* %vptr25069, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f25060, i64* %eptr25053                                                 ; store fptr
 %vptr25070 = alloca i64, align 8 
  %arg8242 = ptrtoint i64* %cloptr25052 to i64 
  store volatile i64 %arg8242, i64* %vptr25070, align 8 ; closure cast; i64* -> i64
 %vptr25071 = alloca i64, align 8 
  %rva10306 = add i64 0, 0 
  store volatile i64 %rva10306, i64* %vptr25071, align 8 ; quoted ()
 %vptr25072 = alloca i64, align 8 
  %rva10305 = call i64 @prim_cons(i64 %arg8242, i64 %rva10306) 
  store volatile i64 %rva10305, i64* %vptr25072, align 8 ; call prim_cons
 %vptr25073 = alloca i64, align 8 
  %rva10304 = call i64 @prim_cons(i64 %arg8243, i64 %rva10305) 
  store volatile i64 %rva10304, i64* %vptr25073, align 8 ; call prim_cons
  %vptr25079 = alloca i64*, align 8 
  %cloptr25074 = inttoptr i64 %arg8244 to i64* 
  store volatile i64* %cloptr25074, i64** %vptr25079, align 8 ; closure/env cast; i64 -> i64*
  %vptr25080 = alloca i64*, align 8 
  %i0ptr25075 = getelementptr inbounds i64, i64* %cloptr25074, i64 1 
  store volatile i64* %i0ptr25075, i64** %vptr25080, align 8 ; &cloptr25074[1]
 %vptr25081 = alloca i64, align 8 
  %f25077 = load i64, i64* %i0ptr25075, align 8 
  store volatile i64 %f25077, i64* %vptr25081, align 8 ; load; *i0ptr25075
  %fptr25076 = inttoptr i64 %f25077 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25076(i64 %arg8244, i64 %rva10304)                  ; tail call
  ret void

else25010:
 %vptr25082 = alloca i64, align 8 
  %h10309 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10309, i64* %vptr25082, align 8 ; call prim_halt
  %vptr25088 = alloca i64*, align 8 
  %cloptr25083 = inttoptr i64 %h10309 to i64* 
  store volatile i64* %cloptr25083, i64** %vptr25088, align 8 ; closure/env cast; i64 -> i64*
  %vptr25089 = alloca i64*, align 8 
  %i0ptr25084 = getelementptr inbounds i64, i64* %cloptr25083, i64 1 
  store volatile i64* %i0ptr25084, i64** %vptr25089, align 8 ; &cloptr25083[1]
 %vptr25090 = alloca i64, align 8 
  %f25086 = load i64, i64* %i0ptr25084, align 8 
  store volatile i64 %f25086, i64* %vptr25090, align 8 ; load; *i0ptr25084
  %fptr25085 = inttoptr i64 %f25086 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25085(i64 %h10309, i64 %h10309)                     ; tail call
  ret void
}


define void @lam11829(i64 %env11830, i64 %rvp10270) {
 %vptr25093 = alloca i64, align 8 
  %envptr25091 = inttoptr i64 %env11830 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr25093, align 8 ; closure/env cast; i64 -> i64*
  %vptr25094 = alloca i64*, align 8 
  %envptr25092 = getelementptr inbounds i64, i64* %envptr25091, i64 8 
  store volatile i64* %envptr25092, i64** %vptr25094, align 8 ; &envptr25091[7]
 %vptr25095 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr25092, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr25095, align 8 ; load; *envptr25092
 %vptr25098 = alloca i64, align 8 
  %envptr25096 = inttoptr i64 %env11830 to i64* 
  store volatile i64 %emsg08636, i64* %vptr25098, align 8 ; closure/env cast; i64 -> i64*
  %vptr25099 = alloca i64*, align 8 
  %envptr25097 = getelementptr inbounds i64, i64* %envptr25096, i64 7 
  store volatile i64* %envptr25097, i64** %vptr25099, align 8 ; &envptr25096[6]
 %vptr25100 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr25097, align 8 
  store volatile i64 %emsg08636, i64* %vptr25100, align 8 ; load; *envptr25097
 %vptr25103 = alloca i64, align 8 
  %envptr25101 = inttoptr i64 %env11830 to i64* 
  store volatile i64 %MXn$x, i64* %vptr25103, align 8 ; closure/env cast; i64 -> i64*
  %vptr25104 = alloca i64*, align 8 
  %envptr25102 = getelementptr inbounds i64, i64* %envptr25101, i64 6 
  store volatile i64* %envptr25102, i64** %vptr25104, align 8 ; &envptr25101[5]
 %vptr25105 = alloca i64, align 8 
  %MXn$x = load i64, i64* %envptr25102, align 8 
  store volatile i64 %MXn$x, i64* %vptr25105, align 8 ; load; *envptr25102
 %vptr25108 = alloca i64, align 8 
  %envptr25106 = inttoptr i64 %env11830 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr25108, align 8 ; closure/env cast; i64 -> i64*
  %vptr25109 = alloca i64*, align 8 
  %envptr25107 = getelementptr inbounds i64, i64* %envptr25106, i64 5 
  store volatile i64* %envptr25107, i64** %vptr25109, align 8 ; &envptr25106[4]
 %vptr25110 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr25107, align 8 
  store volatile i64 %Pll$pred, i64* %vptr25110, align 8 ; load; *envptr25107
 %vptr25113 = alloca i64, align 8 
  %envptr25111 = inttoptr i64 %env11830 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr25113, align 8 ; closure/env cast; i64 -> i64*
  %vptr25114 = alloca i64*, align 8 
  %envptr25112 = getelementptr inbounds i64, i64* %envptr25111, i64 4 
  store volatile i64* %envptr25112, i64** %vptr25114, align 8 ; &envptr25111[3]
 %vptr25115 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr25112, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr25115, align 8 ; load; *envptr25112
 %vptr25118 = alloca i64, align 8 
  %envptr25116 = inttoptr i64 %env11830 to i64* 
  store volatile i64 %YxK$fibc, i64* %vptr25118, align 8 ; closure/env cast; i64 -> i64*
  %vptr25119 = alloca i64*, align 8 
  %envptr25117 = getelementptr inbounds i64, i64* %envptr25116, i64 3 
  store volatile i64* %envptr25117, i64** %vptr25119, align 8 ; &envptr25116[2]
 %vptr25120 = alloca i64, align 8 
  %YxK$fibc = load i64, i64* %envptr25117, align 8 
  store volatile i64 %YxK$fibc, i64* %vptr25120, align 8 ; load; *envptr25117
 %vptr25123 = alloca i64, align 8 
  %envptr25121 = inttoptr i64 %env11830 to i64* 
  store volatile i64 %emsg18637, i64* %vptr25123, align 8 ; closure/env cast; i64 -> i64*
  %vptr25124 = alloca i64*, align 8 
  %envptr25122 = getelementptr inbounds i64, i64* %envptr25121, i64 2 
  store volatile i64* %envptr25122, i64** %vptr25124, align 8 ; &envptr25121[1]
 %vptr25125 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr25122, align 8 
  store volatile i64 %emsg18637, i64* %vptr25125, align 8 ; load; *envptr25122
 %vptr25126 = alloca i64, align 8 
  %cont7237 = call i64 @prim_car(i64 %rvp10270) 
  store volatile i64 %cont7237, i64* %vptr25126, align 8 ; call prim_car
 %vptr25127 = alloca i64, align 8 
  %rvp10266 = call i64 @prim_cdr(i64 %rvp10270) 
  store volatile i64 %rvp10266, i64* %vptr25127, align 8 ; call prim_cdr
 %vptr25128 = alloca i64, align 8 
  %n_6310271 = call i64 @prim_null_63(i64 %rvp10266) 
  store volatile i64 %n_6310271, i64* %vptr25128, align 8 ; call prim_null_63
  %cmpptr25132 = alloca i1, align 8  %cmp25129 = icmp eq i64 %n_6310271, 15 store volatile i1 %cmp25129, i1* %cmpptr25132, align 8; false?
  br i1 %cmp25129, label %else25131, label %then25130                                ; if

then25130:
 %vptr25133 = alloca i64, align 8 
  %h10272 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10272, i64* %vptr25133, align 8 ; call prim_halt
  %vptr25139 = alloca i64*, align 8 
  %cloptr25134 = inttoptr i64 %h10272 to i64* 
  store volatile i64* %cloptr25134, i64** %vptr25139, align 8 ; closure/env cast; i64 -> i64*
  %vptr25140 = alloca i64*, align 8 
  %i0ptr25135 = getelementptr inbounds i64, i64* %cloptr25134, i64 1 
  store volatile i64* %i0ptr25135, i64** %vptr25140, align 8 ; &cloptr25134[1]
 %vptr25141 = alloca i64, align 8 
  %f25137 = load i64, i64* %i0ptr25135, align 8 
  store volatile i64 %f25137, i64* %vptr25141, align 8 ; load; *i0ptr25135
  %fptr25136 = inttoptr i64 %f25137 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25136(i64 %h10272, i64 %h10272)                     ; tail call
  ret void

else25131:
 %vptr25142 = alloca i64, align 8 
  %njK$_37k = call i64 @prim_car(i64 %rvp10266) 
  store volatile i64 %njK$_37k, i64* %vptr25142, align 8 ; call prim_car
 %vptr25143 = alloca i64, align 8 
  %na10167 = call i64 @prim_cdr(i64 %rvp10266) 
  store volatile i64 %na10167, i64* %vptr25143, align 8 ; call prim_cdr
 %vptr25144 = alloca i64, align 8 
  %n_6310267 = call i64 @prim_null_63(i64 %na10167) 
  store volatile i64 %n_6310267, i64* %vptr25144, align 8 ; call prim_null_63
  %cmpptr25148 = alloca i1, align 8  %cmp25145 = icmp eq i64 %n_6310267, 15 store volatile i1 %cmp25145, i1* %cmpptr25148, align 8; false?
  br i1 %cmp25145, label %else25147, label %then25146                                ; if

then25146:
 %vptr25149 = alloca i64, align 8 
  %arg8245 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8245, i64* %vptr25149, align 8 ; quoted int
 %vptr25150 = alloca i64, align 8 
  %SiZ$_37saved_45stack = call i64 @prim_vector_45ref(i64 %SdC$_37wind_45stack, i64 %arg8245) 
  store volatile i64 %SiZ$_37saved_45stack, i64* %vptr25150, align 8 ; call prim_vector_45ref
  %vptr25160 = alloca i64*, align 8 
  %cloptr25151 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr25151, i64** %vptr25160, align 8 ; malloc
  %vptr25161 = alloca i64*, align 8 
  %eptr25153 = getelementptr inbounds i64, i64* %cloptr25151, i64 2 
  store volatile i64* %eptr25153, i64** %vptr25161, align 8 ; &eptr25153[1]
  %vptr25162 = alloca i64*, align 8 
  %eptr25154 = getelementptr inbounds i64, i64* %cloptr25151, i64 3 
  store volatile i64* %eptr25154, i64** %vptr25162, align 8 ; &eptr25154[2]
  %vptr25163 = alloca i64*, align 8 
  %eptr25155 = getelementptr inbounds i64, i64* %cloptr25151, i64 4 
  store volatile i64* %eptr25155, i64** %vptr25163, align 8 ; &eptr25155[3]
  %vptr25164 = alloca i64*, align 8 
  %eptr25156 = getelementptr inbounds i64, i64* %cloptr25151, i64 5 
  store volatile i64* %eptr25156, i64** %vptr25164, align 8 ; &eptr25156[4]
  %vptr25165 = alloca i64*, align 8 
  %eptr25157 = getelementptr inbounds i64, i64* %cloptr25151, i64 6 
  store volatile i64* %eptr25157, i64** %vptr25165, align 8 ; &eptr25157[5]
  %vptr25166 = alloca i64*, align 8 
  %eptr25158 = getelementptr inbounds i64, i64* %cloptr25151, i64 7 
  store volatile i64* %eptr25158, i64** %vptr25166, align 8 ; &eptr25158[6]
  store i64 %emsg18637, i64* %eptr25153                                              ; *eptr25153 = %emsg18637
  store i64 %cont7237, i64* %eptr25154                                               ; *eptr25154 = %cont7237
  store i64 %YxK$fibc, i64* %eptr25155                                               ; *eptr25155 = %YxK$fibc
  store i64 %Pll$pred, i64* %eptr25156                                               ; *eptr25156 = %Pll$pred
  store i64 %MXn$x, i64* %eptr25157                                                  ; *eptr25157 = %MXn$x
  store i64 %emsg08636, i64* %eptr25158                                              ; *eptr25158 = %emsg08636
  %vptr25167 = alloca i64*, align 8 
  %eptr25152 = getelementptr inbounds i64, i64* %cloptr25151, i64 1 
  store volatile i64* %eptr25152, i64** %vptr25167, align 8 ; &cloptr25151[1]
 %vptr25168 = alloca i64, align 8 
  %f25159 = ptrtoint void(i64,i64)* @lam11826 to i64 
  store volatile i64 %f25159, i64* %vptr25168, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f25159, i64* %eptr25152                                                 ; store fptr
 %vptr25169 = alloca i64, align 8 
  %arg8249 = ptrtoint i64* %cloptr25151 to i64 
  store volatile i64 %arg8249, i64* %vptr25169, align 8 ; closure cast; i64* -> i64
 %vptr25170 = alloca i64, align 8 
  %arg8248 = add i64 0, 0 
  store volatile i64 %arg8248, i64* %vptr25170, align 8 ; quoted ()
  %vptr25180 = alloca i64*, align 8 
  %cloptr25171 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr25171, i64** %vptr25180, align 8 ; malloc
  %vptr25181 = alloca i64*, align 8 
  %eptr25173 = getelementptr inbounds i64, i64* %cloptr25171, i64 2 
  store volatile i64* %eptr25173, i64** %vptr25181, align 8 ; &eptr25173[1]
  %vptr25182 = alloca i64*, align 8 
  %eptr25174 = getelementptr inbounds i64, i64* %cloptr25171, i64 3 
  store volatile i64* %eptr25174, i64** %vptr25182, align 8 ; &eptr25174[2]
  %vptr25183 = alloca i64*, align 8 
  %eptr25175 = getelementptr inbounds i64, i64* %cloptr25171, i64 4 
  store volatile i64* %eptr25175, i64** %vptr25183, align 8 ; &eptr25175[3]
  %vptr25184 = alloca i64*, align 8 
  %eptr25176 = getelementptr inbounds i64, i64* %cloptr25171, i64 5 
  store volatile i64* %eptr25176, i64** %vptr25184, align 8 ; &eptr25176[4]
  %vptr25185 = alloca i64*, align 8 
  %eptr25177 = getelementptr inbounds i64, i64* %cloptr25171, i64 6 
  store volatile i64* %eptr25177, i64** %vptr25185, align 8 ; &eptr25177[5]
  %vptr25186 = alloca i64*, align 8 
  %eptr25178 = getelementptr inbounds i64, i64* %cloptr25171, i64 7 
  store volatile i64* %eptr25178, i64** %vptr25186, align 8 ; &eptr25178[6]
  store i64 %SiZ$_37saved_45stack, i64* %eptr25173                                   ; *eptr25173 = %SiZ$_37saved_45stack
  store i64 %emsg18637, i64* %eptr25174                                              ; *eptr25174 = %emsg18637
  store i64 %SdC$_37wind_45stack, i64* %eptr25175                                    ; *eptr25175 = %SdC$_37wind_45stack
  store i64 %njK$_37k, i64* %eptr25176                                               ; *eptr25176 = %njK$_37k
  store i64 %emsg08636, i64* %eptr25177                                              ; *eptr25177 = %emsg08636
  store i64 %U8g$_37do_45wind, i64* %eptr25178                                       ; *eptr25178 = %U8g$_37do_45wind
  %vptr25187 = alloca i64*, align 8 
  %eptr25172 = getelementptr inbounds i64, i64* %cloptr25171, i64 1 
  store volatile i64* %eptr25172, i64** %vptr25187, align 8 ; &cloptr25171[1]
 %vptr25188 = alloca i64, align 8 
  %f25179 = ptrtoint void(i64,i64)* @lam11810 to i64 
  store volatile i64 %f25179, i64* %vptr25188, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f25179, i64* %eptr25172                                                 ; store fptr
 %vptr25189 = alloca i64, align 8 
  %arg8247 = ptrtoint i64* %cloptr25171 to i64 
  store volatile i64 %arg8247, i64* %vptr25189, align 8 ; closure cast; i64* -> i64
 %vptr25190 = alloca i64, align 8 
  %rva10265 = add i64 0, 0 
  store volatile i64 %rva10265, i64* %vptr25190, align 8 ; quoted ()
 %vptr25191 = alloca i64, align 8 
  %rva10264 = call i64 @prim_cons(i64 %arg8247, i64 %rva10265) 
  store volatile i64 %rva10264, i64* %vptr25191, align 8 ; call prim_cons
 %vptr25192 = alloca i64, align 8 
  %rva10263 = call i64 @prim_cons(i64 %arg8248, i64 %rva10264) 
  store volatile i64 %rva10263, i64* %vptr25192, align 8 ; call prim_cons
  %vptr25198 = alloca i64*, align 8 
  %cloptr25193 = inttoptr i64 %arg8249 to i64* 
  store volatile i64* %cloptr25193, i64** %vptr25198, align 8 ; closure/env cast; i64 -> i64*
  %vptr25199 = alloca i64*, align 8 
  %i0ptr25194 = getelementptr inbounds i64, i64* %cloptr25193, i64 1 
  store volatile i64* %i0ptr25194, i64** %vptr25199, align 8 ; &cloptr25193[1]
 %vptr25200 = alloca i64, align 8 
  %f25196 = load i64, i64* %i0ptr25194, align 8 
  store volatile i64 %f25196, i64* %vptr25200, align 8 ; load; *i0ptr25194
  %fptr25195 = inttoptr i64 %f25196 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25195(i64 %arg8249, i64 %rva10263)                  ; tail call
  ret void

else25147:
 %vptr25201 = alloca i64, align 8 
  %h10268 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10268, i64* %vptr25201, align 8 ; call prim_halt
  %vptr25207 = alloca i64*, align 8 
  %cloptr25202 = inttoptr i64 %h10268 to i64* 
  store volatile i64* %cloptr25202, i64** %vptr25207, align 8 ; closure/env cast; i64 -> i64*
  %vptr25208 = alloca i64*, align 8 
  %i0ptr25203 = getelementptr inbounds i64, i64* %cloptr25202, i64 1 
  store volatile i64* %i0ptr25203, i64** %vptr25208, align 8 ; &cloptr25202[1]
 %vptr25209 = alloca i64, align 8 
  %f25205 = load i64, i64* %i0ptr25203, align 8 
  store volatile i64 %f25205, i64* %vptr25209, align 8 ; load; *i0ptr25203
  %fptr25204 = inttoptr i64 %f25205 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25204(i64 %h10268, i64 %h10268)                     ; tail call
  ret void
}


define void @lam11826(i64 %env11827, i64 %rvp10217) {
 %vptr25212 = alloca i64, align 8 
  %envptr25210 = inttoptr i64 %env11827 to i64* 
  store volatile i64 %emsg08636, i64* %vptr25212, align 8 ; closure/env cast; i64 -> i64*
  %vptr25213 = alloca i64*, align 8 
  %envptr25211 = getelementptr inbounds i64, i64* %envptr25210, i64 7 
  store volatile i64* %envptr25211, i64** %vptr25213, align 8 ; &envptr25210[6]
 %vptr25214 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr25211, align 8 
  store volatile i64 %emsg08636, i64* %vptr25214, align 8 ; load; *envptr25211
 %vptr25217 = alloca i64, align 8 
  %envptr25215 = inttoptr i64 %env11827 to i64* 
  store volatile i64 %MXn$x, i64* %vptr25217, align 8 ; closure/env cast; i64 -> i64*
  %vptr25218 = alloca i64*, align 8 
  %envptr25216 = getelementptr inbounds i64, i64* %envptr25215, i64 6 
  store volatile i64* %envptr25216, i64** %vptr25218, align 8 ; &envptr25215[5]
 %vptr25219 = alloca i64, align 8 
  %MXn$x = load i64, i64* %envptr25216, align 8 
  store volatile i64 %MXn$x, i64* %vptr25219, align 8 ; load; *envptr25216
 %vptr25222 = alloca i64, align 8 
  %envptr25220 = inttoptr i64 %env11827 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr25222, align 8 ; closure/env cast; i64 -> i64*
  %vptr25223 = alloca i64*, align 8 
  %envptr25221 = getelementptr inbounds i64, i64* %envptr25220, i64 5 
  store volatile i64* %envptr25221, i64** %vptr25223, align 8 ; &envptr25220[4]
 %vptr25224 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr25221, align 8 
  store volatile i64 %Pll$pred, i64* %vptr25224, align 8 ; load; *envptr25221
 %vptr25227 = alloca i64, align 8 
  %envptr25225 = inttoptr i64 %env11827 to i64* 
  store volatile i64 %YxK$fibc, i64* %vptr25227, align 8 ; closure/env cast; i64 -> i64*
  %vptr25228 = alloca i64*, align 8 
  %envptr25226 = getelementptr inbounds i64, i64* %envptr25225, i64 4 
  store volatile i64* %envptr25226, i64** %vptr25228, align 8 ; &envptr25225[3]
 %vptr25229 = alloca i64, align 8 
  %YxK$fibc = load i64, i64* %envptr25226, align 8 
  store volatile i64 %YxK$fibc, i64* %vptr25229, align 8 ; load; *envptr25226
 %vptr25232 = alloca i64, align 8 
  %envptr25230 = inttoptr i64 %env11827 to i64* 
  store volatile i64 %cont7237, i64* %vptr25232, align 8 ; closure/env cast; i64 -> i64*
  %vptr25233 = alloca i64*, align 8 
  %envptr25231 = getelementptr inbounds i64, i64* %envptr25230, i64 3 
  store volatile i64* %envptr25231, i64** %vptr25233, align 8 ; &envptr25230[2]
 %vptr25234 = alloca i64, align 8 
  %cont7237 = load i64, i64* %envptr25231, align 8 
  store volatile i64 %cont7237, i64* %vptr25234, align 8 ; load; *envptr25231
 %vptr25237 = alloca i64, align 8 
  %envptr25235 = inttoptr i64 %env11827 to i64* 
  store volatile i64 %emsg18637, i64* %vptr25237, align 8 ; closure/env cast; i64 -> i64*
  %vptr25238 = alloca i64*, align 8 
  %envptr25236 = getelementptr inbounds i64, i64* %envptr25235, i64 2 
  store volatile i64* %envptr25236, i64** %vptr25238, align 8 ; &envptr25235[1]
 %vptr25239 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr25236, align 8 
  store volatile i64 %emsg18637, i64* %vptr25239, align 8 ; load; *envptr25236
 %vptr25240 = alloca i64, align 8 
  %_957238 = call i64 @prim_car(i64 %rvp10217) 
  store volatile i64 %_957238, i64* %vptr25240, align 8 ; call prim_car
 %vptr25241 = alloca i64, align 8 
  %rvp10213 = call i64 @prim_cdr(i64 %rvp10217) 
  store volatile i64 %rvp10213, i64* %vptr25241, align 8 ; call prim_cdr
 %vptr25242 = alloca i64, align 8 
  %n_6310218 = call i64 @prim_null_63(i64 %rvp10213) 
  store volatile i64 %n_6310218, i64* %vptr25242, align 8 ; call prim_null_63
  %cmpptr25246 = alloca i1, align 8  %cmp25243 = icmp eq i64 %n_6310218, 15 store volatile i1 %cmp25243, i1* %cmpptr25246, align 8; false?
  br i1 %cmp25243, label %else25245, label %then25244                                ; if

then25244:
 %vptr25247 = alloca i64, align 8 
  %h10219 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10219, i64* %vptr25247, align 8 ; call prim_halt
  %vptr25253 = alloca i64*, align 8 
  %cloptr25248 = inttoptr i64 %h10219 to i64* 
  store volatile i64* %cloptr25248, i64** %vptr25253, align 8 ; closure/env cast; i64 -> i64*
  %vptr25254 = alloca i64*, align 8 
  %i0ptr25249 = getelementptr inbounds i64, i64* %cloptr25248, i64 1 
  store volatile i64* %i0ptr25249, i64** %vptr25254, align 8 ; &cloptr25248[1]
 %vptr25255 = alloca i64, align 8 
  %f25251 = load i64, i64* %i0ptr25249, align 8 
  store volatile i64 %f25251, i64* %vptr25255, align 8 ; load; *i0ptr25249
  %fptr25250 = inttoptr i64 %f25251 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25250(i64 %h10219, i64 %h10219)                     ; tail call
  ret void

else25245:
 %vptr25256 = alloca i64, align 8 
  %a7082 = call i64 @prim_car(i64 %rvp10213) 
  store volatile i64 %a7082, i64* %vptr25256, align 8 ; call prim_car
 %vptr25257 = alloca i64, align 8 
  %na10169 = call i64 @prim_cdr(i64 %rvp10213) 
  store volatile i64 %na10169, i64* %vptr25257, align 8 ; call prim_cdr
 %vptr25258 = alloca i64, align 8 
  %n_6310214 = call i64 @prim_null_63(i64 %na10169) 
  store volatile i64 %n_6310214, i64* %vptr25258, align 8 ; call prim_null_63
  %cmpptr25262 = alloca i1, align 8  %cmp25259 = icmp eq i64 %n_6310214, 15 store volatile i1 %cmp25259, i1* %cmpptr25262, align 8; false?
  br i1 %cmp25259, label %else25261, label %then25260                                ; if

then25260:
  %vptr25271 = alloca i64*, align 8 
  %cloptr25263 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr25263, i64** %vptr25271, align 8 ; malloc
  %vptr25272 = alloca i64*, align 8 
  %eptr25265 = getelementptr inbounds i64, i64* %cloptr25263, i64 2 
  store volatile i64* %eptr25265, i64** %vptr25272, align 8 ; &eptr25265[1]
  %vptr25273 = alloca i64*, align 8 
  %eptr25266 = getelementptr inbounds i64, i64* %cloptr25263, i64 3 
  store volatile i64* %eptr25266, i64** %vptr25273, align 8 ; &eptr25266[2]
  %vptr25274 = alloca i64*, align 8 
  %eptr25267 = getelementptr inbounds i64, i64* %cloptr25263, i64 4 
  store volatile i64* %eptr25267, i64** %vptr25274, align 8 ; &eptr25267[3]
  %vptr25275 = alloca i64*, align 8 
  %eptr25268 = getelementptr inbounds i64, i64* %cloptr25263, i64 5 
  store volatile i64* %eptr25268, i64** %vptr25275, align 8 ; &eptr25268[4]
  %vptr25276 = alloca i64*, align 8 
  %eptr25269 = getelementptr inbounds i64, i64* %cloptr25263, i64 6 
  store volatile i64* %eptr25269, i64** %vptr25276, align 8 ; &eptr25269[5]
  store i64 %emsg18637, i64* %eptr25265                                              ; *eptr25265 = %emsg18637
  store i64 %YxK$fibc, i64* %eptr25266                                               ; *eptr25266 = %YxK$fibc
  store i64 %Pll$pred, i64* %eptr25267                                               ; *eptr25267 = %Pll$pred
  store i64 %MXn$x, i64* %eptr25268                                                  ; *eptr25268 = %MXn$x
  store i64 %emsg08636, i64* %eptr25269                                              ; *eptr25269 = %emsg08636
  %vptr25277 = alloca i64*, align 8 
  %eptr25264 = getelementptr inbounds i64, i64* %cloptr25263, i64 1 
  store volatile i64* %eptr25264, i64** %vptr25277, align 8 ; &cloptr25263[1]
 %vptr25278 = alloca i64, align 8 
  %f25270 = ptrtoint void(i64,i64)* @lam11824 to i64 
  store volatile i64 %f25270, i64* %vptr25278, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f25270, i64* %eptr25264                                                 ; store fptr
 %vptr25279 = alloca i64, align 8 
  %arg8252 = ptrtoint i64* %cloptr25263 to i64 
  store volatile i64 %arg8252, i64* %vptr25279, align 8 ; closure cast; i64* -> i64
 %vptr25280 = alloca i64, align 8 
  %rva10212 = add i64 0, 0 
  store volatile i64 %rva10212, i64* %vptr25280, align 8 ; quoted ()
 %vptr25281 = alloca i64, align 8 
  %rva10211 = call i64 @prim_cons(i64 %a7082, i64 %rva10212) 
  store volatile i64 %rva10211, i64* %vptr25281, align 8 ; call prim_cons
 %vptr25282 = alloca i64, align 8 
  %rva10210 = call i64 @prim_cons(i64 %cont7237, i64 %rva10211) 
  store volatile i64 %rva10210, i64* %vptr25282, align 8 ; call prim_cons
  %vptr25288 = alloca i64*, align 8 
  %cloptr25283 = inttoptr i64 %arg8252 to i64* 
  store volatile i64* %cloptr25283, i64** %vptr25288, align 8 ; closure/env cast; i64 -> i64*
  %vptr25289 = alloca i64*, align 8 
  %i0ptr25284 = getelementptr inbounds i64, i64* %cloptr25283, i64 1 
  store volatile i64* %i0ptr25284, i64** %vptr25289, align 8 ; &cloptr25283[1]
 %vptr25290 = alloca i64, align 8 
  %f25286 = load i64, i64* %i0ptr25284, align 8 
  store volatile i64 %f25286, i64* %vptr25290, align 8 ; load; *i0ptr25284
  %fptr25285 = inttoptr i64 %f25286 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25285(i64 %arg8252, i64 %rva10210)                  ; tail call
  ret void

else25261:
 %vptr25291 = alloca i64, align 8 
  %h10215 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10215, i64* %vptr25291, align 8 ; call prim_halt
  %vptr25297 = alloca i64*, align 8 
  %cloptr25292 = inttoptr i64 %h10215 to i64* 
  store volatile i64* %cloptr25292, i64** %vptr25297, align 8 ; closure/env cast; i64 -> i64*
  %vptr25298 = alloca i64*, align 8 
  %i0ptr25293 = getelementptr inbounds i64, i64* %cloptr25292, i64 1 
  store volatile i64* %i0ptr25293, i64** %vptr25298, align 8 ; &cloptr25292[1]
 %vptr25299 = alloca i64, align 8 
  %f25295 = load i64, i64* %i0ptr25293, align 8 
  store volatile i64 %f25295, i64* %vptr25299, align 8 ; load; *i0ptr25293
  %fptr25294 = inttoptr i64 %f25295 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25294(i64 %h10215, i64 %h10215)                     ; tail call
  ret void
}


define void @lam11824(i64 %env11825, i64 %rvp10206) {
 %vptr25302 = alloca i64, align 8 
  %envptr25300 = inttoptr i64 %env11825 to i64* 
  store volatile i64 %emsg08636, i64* %vptr25302, align 8 ; closure/env cast; i64 -> i64*
  %vptr25303 = alloca i64*, align 8 
  %envptr25301 = getelementptr inbounds i64, i64* %envptr25300, i64 6 
  store volatile i64* %envptr25301, i64** %vptr25303, align 8 ; &envptr25300[5]
 %vptr25304 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr25301, align 8 
  store volatile i64 %emsg08636, i64* %vptr25304, align 8 ; load; *envptr25301
 %vptr25307 = alloca i64, align 8 
  %envptr25305 = inttoptr i64 %env11825 to i64* 
  store volatile i64 %MXn$x, i64* %vptr25307, align 8 ; closure/env cast; i64 -> i64*
  %vptr25308 = alloca i64*, align 8 
  %envptr25306 = getelementptr inbounds i64, i64* %envptr25305, i64 5 
  store volatile i64* %envptr25306, i64** %vptr25308, align 8 ; &envptr25305[4]
 %vptr25309 = alloca i64, align 8 
  %MXn$x = load i64, i64* %envptr25306, align 8 
  store volatile i64 %MXn$x, i64* %vptr25309, align 8 ; load; *envptr25306
 %vptr25312 = alloca i64, align 8 
  %envptr25310 = inttoptr i64 %env11825 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr25312, align 8 ; closure/env cast; i64 -> i64*
  %vptr25313 = alloca i64*, align 8 
  %envptr25311 = getelementptr inbounds i64, i64* %envptr25310, i64 4 
  store volatile i64* %envptr25311, i64** %vptr25313, align 8 ; &envptr25310[3]
 %vptr25314 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr25311, align 8 
  store volatile i64 %Pll$pred, i64* %vptr25314, align 8 ; load; *envptr25311
 %vptr25317 = alloca i64, align 8 
  %envptr25315 = inttoptr i64 %env11825 to i64* 
  store volatile i64 %YxK$fibc, i64* %vptr25317, align 8 ; closure/env cast; i64 -> i64*
  %vptr25318 = alloca i64*, align 8 
  %envptr25316 = getelementptr inbounds i64, i64* %envptr25315, i64 3 
  store volatile i64* %envptr25316, i64** %vptr25318, align 8 ; &envptr25315[2]
 %vptr25319 = alloca i64, align 8 
  %YxK$fibc = load i64, i64* %envptr25316, align 8 
  store volatile i64 %YxK$fibc, i64* %vptr25319, align 8 ; load; *envptr25316
 %vptr25322 = alloca i64, align 8 
  %envptr25320 = inttoptr i64 %env11825 to i64* 
  store volatile i64 %emsg18637, i64* %vptr25322, align 8 ; closure/env cast; i64 -> i64*
  %vptr25323 = alloca i64*, align 8 
  %envptr25321 = getelementptr inbounds i64, i64* %envptr25320, i64 2 
  store volatile i64* %envptr25321, i64** %vptr25323, align 8 ; &envptr25320[1]
 %vptr25324 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr25321, align 8 
  store volatile i64 %emsg18637, i64* %vptr25324, align 8 ; load; *envptr25321
 %vptr25325 = alloca i64, align 8 
  %cont7239 = call i64 @prim_car(i64 %rvp10206) 
  store volatile i64 %cont7239, i64* %vptr25325, align 8 ; call prim_car
 %vptr25326 = alloca i64, align 8 
  %rvp10202 = call i64 @prim_cdr(i64 %rvp10206) 
  store volatile i64 %rvp10202, i64* %vptr25326, align 8 ; call prim_cdr
 %vptr25327 = alloca i64, align 8 
  %n_6310207 = call i64 @prim_null_63(i64 %rvp10202) 
  store volatile i64 %n_6310207, i64* %vptr25327, align 8 ; call prim_null_63
  %cmpptr25331 = alloca i1, align 8  %cmp25328 = icmp eq i64 %n_6310207, 15 store volatile i1 %cmp25328, i1* %cmpptr25331, align 8; false?
  br i1 %cmp25328, label %else25330, label %then25329                                ; if

then25329:
 %vptr25332 = alloca i64, align 8 
  %h10208 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10208, i64* %vptr25332, align 8 ; call prim_halt
  %vptr25338 = alloca i64*, align 8 
  %cloptr25333 = inttoptr i64 %h10208 to i64* 
  store volatile i64* %cloptr25333, i64** %vptr25338, align 8 ; closure/env cast; i64 -> i64*
  %vptr25339 = alloca i64*, align 8 
  %i0ptr25334 = getelementptr inbounds i64, i64* %cloptr25333, i64 1 
  store volatile i64* %i0ptr25334, i64** %vptr25339, align 8 ; &cloptr25333[1]
 %vptr25340 = alloca i64, align 8 
  %f25336 = load i64, i64* %i0ptr25334, align 8 
  store volatile i64 %f25336, i64* %vptr25340, align 8 ; load; *i0ptr25334
  %fptr25335 = inttoptr i64 %f25336 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25335(i64 %h10208, i64 %h10208)                     ; tail call
  ret void

else25330:
 %vptr25341 = alloca i64, align 8 
  %kf0$c = call i64 @prim_car(i64 %rvp10202) 
  store volatile i64 %kf0$c, i64* %vptr25341, align 8 ; call prim_car
 %vptr25342 = alloca i64, align 8 
  %na10171 = call i64 @prim_cdr(i64 %rvp10202) 
  store volatile i64 %na10171, i64* %vptr25342, align 8 ; call prim_cdr
 %vptr25343 = alloca i64, align 8 
  %n_6310203 = call i64 @prim_null_63(i64 %na10171) 
  store volatile i64 %n_6310203, i64* %vptr25343, align 8 ; call prim_null_63
  %cmpptr25347 = alloca i1, align 8  %cmp25344 = icmp eq i64 %n_6310203, 15 store volatile i1 %cmp25344, i1* %cmpptr25347, align 8; false?
  br i1 %cmp25344, label %else25346, label %then25345                                ; if

then25345:
 %vptr25348 = alloca i64, align 8 
  %arg8253 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8253, i64* %vptr25348, align 8 ; quoted int
 %vptr25349 = alloca i64, align 8 
  %a7075 = call i64 @prim_vector_45ref(i64 %YxK$fibc, i64 %arg8253) 
  store volatile i64 %a7075, i64* %vptr25349, align 8 ; call prim_vector_45ref
 %vptr25350 = alloca i64, align 8 
  %arg8255 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8255, i64* %vptr25350, align 8 ; quoted int
 %vptr25351 = alloca i64, align 8 
  %a7076 = call i64 @prim_vector_45ref(i64 %Pll$pred, i64 %arg8255) 
  store volatile i64 %a7076, i64* %vptr25351, align 8 ; call prim_vector_45ref
 %vptr25352 = alloca i64, align 8 
  %arg8257 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8257, i64* %vptr25352, align 8 ; quoted int
 %vptr25353 = alloca i64, align 8 
  %a7077 = call i64 @prim_vector_45ref(i64 %Pll$pred, i64 %arg8257) 
  store volatile i64 %a7077, i64* %vptr25353, align 8 ; call prim_vector_45ref
  %vptr25363 = alloca i64*, align 8 
  %cloptr25354 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr25354, i64** %vptr25363, align 8 ; malloc
  %vptr25364 = alloca i64*, align 8 
  %eptr25356 = getelementptr inbounds i64, i64* %cloptr25354, i64 2 
  store volatile i64* %eptr25356, i64** %vptr25364, align 8 ; &eptr25356[1]
  %vptr25365 = alloca i64*, align 8 
  %eptr25357 = getelementptr inbounds i64, i64* %cloptr25354, i64 3 
  store volatile i64* %eptr25357, i64** %vptr25365, align 8 ; &eptr25357[2]
  %vptr25366 = alloca i64*, align 8 
  %eptr25358 = getelementptr inbounds i64, i64* %cloptr25354, i64 4 
  store volatile i64* %eptr25358, i64** %vptr25366, align 8 ; &eptr25358[3]
  %vptr25367 = alloca i64*, align 8 
  %eptr25359 = getelementptr inbounds i64, i64* %cloptr25354, i64 5 
  store volatile i64* %eptr25359, i64** %vptr25367, align 8 ; &eptr25359[4]
  %vptr25368 = alloca i64*, align 8 
  %eptr25360 = getelementptr inbounds i64, i64* %cloptr25354, i64 6 
  store volatile i64* %eptr25360, i64** %vptr25368, align 8 ; &eptr25360[5]
  %vptr25369 = alloca i64*, align 8 
  %eptr25361 = getelementptr inbounds i64, i64* %cloptr25354, i64 7 
  store volatile i64* %eptr25361, i64** %vptr25369, align 8 ; &eptr25361[6]
  store i64 %emsg18637, i64* %eptr25356                                              ; *eptr25356 = %emsg18637
  store i64 %a7076, i64* %eptr25357                                                  ; *eptr25357 = %a7076
  store i64 %kf0$c, i64* %eptr25358                                                  ; *eptr25358 = %kf0$c
  store i64 %cont7239, i64* %eptr25359                                               ; *eptr25359 = %cont7239
  store i64 %emsg08636, i64* %eptr25360                                              ; *eptr25360 = %emsg08636
  store i64 %a7075, i64* %eptr25361                                                  ; *eptr25361 = %a7075
  %vptr25370 = alloca i64*, align 8 
  %eptr25355 = getelementptr inbounds i64, i64* %cloptr25354, i64 1 
  store volatile i64* %eptr25355, i64** %vptr25370, align 8 ; &cloptr25354[1]
 %vptr25371 = alloca i64, align 8 
  %f25362 = ptrtoint void(i64,i64)* @lam11819 to i64 
  store volatile i64 %f25362, i64* %vptr25371, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f25362, i64* %eptr25355                                                 ; store fptr
 %vptr25372 = alloca i64, align 8 
  %arg8260 = ptrtoint i64* %cloptr25354 to i64 
  store volatile i64 %arg8260, i64* %vptr25372, align 8 ; closure cast; i64* -> i64
 %vptr25373 = alloca i64, align 8 
  %rva10201 = add i64 0, 0 
  store volatile i64 %rva10201, i64* %vptr25373, align 8 ; quoted ()
 %vptr25374 = alloca i64, align 8 
  %rva10200 = call i64 @prim_cons(i64 %MXn$x, i64 %rva10201) 
  store volatile i64 %rva10200, i64* %vptr25374, align 8 ; call prim_cons
 %vptr25375 = alloca i64, align 8 
  %rva10199 = call i64 @prim_cons(i64 %arg8260, i64 %rva10200) 
  store volatile i64 %rva10199, i64* %vptr25375, align 8 ; call prim_cons
  %vptr25381 = alloca i64*, align 8 
  %cloptr25376 = inttoptr i64 %a7077 to i64* 
  store volatile i64* %cloptr25376, i64** %vptr25381, align 8 ; closure/env cast; i64 -> i64*
  %vptr25382 = alloca i64*, align 8 
  %i0ptr25377 = getelementptr inbounds i64, i64* %cloptr25376, i64 1 
  store volatile i64* %i0ptr25377, i64** %vptr25382, align 8 ; &cloptr25376[1]
 %vptr25383 = alloca i64, align 8 
  %f25379 = load i64, i64* %i0ptr25377, align 8 
  store volatile i64 %f25379, i64* %vptr25383, align 8 ; load; *i0ptr25377
  %fptr25378 = inttoptr i64 %f25379 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25378(i64 %a7077, i64 %rva10199)                    ; tail call
  ret void

else25346:
 %vptr25384 = alloca i64, align 8 
  %h10204 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10204, i64* %vptr25384, align 8 ; call prim_halt
  %vptr25390 = alloca i64*, align 8 
  %cloptr25385 = inttoptr i64 %h10204 to i64* 
  store volatile i64* %cloptr25385, i64** %vptr25390, align 8 ; closure/env cast; i64 -> i64*
  %vptr25391 = alloca i64*, align 8 
  %i0ptr25386 = getelementptr inbounds i64, i64* %cloptr25385, i64 1 
  store volatile i64* %i0ptr25386, i64** %vptr25391, align 8 ; &cloptr25385[1]
 %vptr25392 = alloca i64, align 8 
  %f25388 = load i64, i64* %i0ptr25386, align 8 
  store volatile i64 %f25388, i64* %vptr25392, align 8 ; load; *i0ptr25386
  %fptr25387 = inttoptr i64 %f25388 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25387(i64 %h10204, i64 %h10204)                     ; tail call
  ret void
}


define void @lam11819(i64 %env11820, i64 %rvp10195) {
 %vptr25395 = alloca i64, align 8 
  %envptr25393 = inttoptr i64 %env11820 to i64* 
  store volatile i64 %a7075, i64* %vptr25395, align 8 ; closure/env cast; i64 -> i64*
  %vptr25396 = alloca i64*, align 8 
  %envptr25394 = getelementptr inbounds i64, i64* %envptr25393, i64 7 
  store volatile i64* %envptr25394, i64** %vptr25396, align 8 ; &envptr25393[6]
 %vptr25397 = alloca i64, align 8 
  %a7075 = load i64, i64* %envptr25394, align 8 
  store volatile i64 %a7075, i64* %vptr25397, align 8 ; load; *envptr25394
 %vptr25400 = alloca i64, align 8 
  %envptr25398 = inttoptr i64 %env11820 to i64* 
  store volatile i64 %emsg08636, i64* %vptr25400, align 8 ; closure/env cast; i64 -> i64*
  %vptr25401 = alloca i64*, align 8 
  %envptr25399 = getelementptr inbounds i64, i64* %envptr25398, i64 6 
  store volatile i64* %envptr25399, i64** %vptr25401, align 8 ; &envptr25398[5]
 %vptr25402 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr25399, align 8 
  store volatile i64 %emsg08636, i64* %vptr25402, align 8 ; load; *envptr25399
 %vptr25405 = alloca i64, align 8 
  %envptr25403 = inttoptr i64 %env11820 to i64* 
  store volatile i64 %cont7239, i64* %vptr25405, align 8 ; closure/env cast; i64 -> i64*
  %vptr25406 = alloca i64*, align 8 
  %envptr25404 = getelementptr inbounds i64, i64* %envptr25403, i64 5 
  store volatile i64* %envptr25404, i64** %vptr25406, align 8 ; &envptr25403[4]
 %vptr25407 = alloca i64, align 8 
  %cont7239 = load i64, i64* %envptr25404, align 8 
  store volatile i64 %cont7239, i64* %vptr25407, align 8 ; load; *envptr25404
 %vptr25410 = alloca i64, align 8 
  %envptr25408 = inttoptr i64 %env11820 to i64* 
  store volatile i64 %kf0$c, i64* %vptr25410, align 8 ; closure/env cast; i64 -> i64*
  %vptr25411 = alloca i64*, align 8 
  %envptr25409 = getelementptr inbounds i64, i64* %envptr25408, i64 4 
  store volatile i64* %envptr25409, i64** %vptr25411, align 8 ; &envptr25408[3]
 %vptr25412 = alloca i64, align 8 
  %kf0$c = load i64, i64* %envptr25409, align 8 
  store volatile i64 %kf0$c, i64* %vptr25412, align 8 ; load; *envptr25409
 %vptr25415 = alloca i64, align 8 
  %envptr25413 = inttoptr i64 %env11820 to i64* 
  store volatile i64 %a7076, i64* %vptr25415, align 8 ; closure/env cast; i64 -> i64*
  %vptr25416 = alloca i64*, align 8 
  %envptr25414 = getelementptr inbounds i64, i64* %envptr25413, i64 3 
  store volatile i64* %envptr25414, i64** %vptr25416, align 8 ; &envptr25413[2]
 %vptr25417 = alloca i64, align 8 
  %a7076 = load i64, i64* %envptr25414, align 8 
  store volatile i64 %a7076, i64* %vptr25417, align 8 ; load; *envptr25414
 %vptr25420 = alloca i64, align 8 
  %envptr25418 = inttoptr i64 %env11820 to i64* 
  store volatile i64 %emsg18637, i64* %vptr25420, align 8 ; closure/env cast; i64 -> i64*
  %vptr25421 = alloca i64*, align 8 
  %envptr25419 = getelementptr inbounds i64, i64* %envptr25418, i64 2 
  store volatile i64* %envptr25419, i64** %vptr25421, align 8 ; &envptr25418[1]
 %vptr25422 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr25419, align 8 
  store volatile i64 %emsg18637, i64* %vptr25422, align 8 ; load; *envptr25419
 %vptr25423 = alloca i64, align 8 
  %_957240 = call i64 @prim_car(i64 %rvp10195) 
  store volatile i64 %_957240, i64* %vptr25423, align 8 ; call prim_car
 %vptr25424 = alloca i64, align 8 
  %rvp10191 = call i64 @prim_cdr(i64 %rvp10195) 
  store volatile i64 %rvp10191, i64* %vptr25424, align 8 ; call prim_cdr
 %vptr25425 = alloca i64, align 8 
  %n_6310196 = call i64 @prim_null_63(i64 %rvp10191) 
  store volatile i64 %n_6310196, i64* %vptr25425, align 8 ; call prim_null_63
  %cmpptr25429 = alloca i1, align 8  %cmp25426 = icmp eq i64 %n_6310196, 15 store volatile i1 %cmp25426, i1* %cmpptr25429, align 8; false?
  br i1 %cmp25426, label %else25428, label %then25427                                ; if

then25427:
 %vptr25430 = alloca i64, align 8 
  %h10197 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10197, i64* %vptr25430, align 8 ; call prim_halt
  %vptr25436 = alloca i64*, align 8 
  %cloptr25431 = inttoptr i64 %h10197 to i64* 
  store volatile i64* %cloptr25431, i64** %vptr25436, align 8 ; closure/env cast; i64 -> i64*
  %vptr25437 = alloca i64*, align 8 
  %i0ptr25432 = getelementptr inbounds i64, i64* %cloptr25431, i64 1 
  store volatile i64* %i0ptr25432, i64** %vptr25437, align 8 ; &cloptr25431[1]
 %vptr25438 = alloca i64, align 8 
  %f25434 = load i64, i64* %i0ptr25432, align 8 
  store volatile i64 %f25434, i64* %vptr25438, align 8 ; load; *i0ptr25432
  %fptr25433 = inttoptr i64 %f25434 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25433(i64 %h10197, i64 %h10197)                     ; tail call
  ret void

else25428:
 %vptr25439 = alloca i64, align 8 
  %a7078 = call i64 @prim_car(i64 %rvp10191) 
  store volatile i64 %a7078, i64* %vptr25439, align 8 ; call prim_car
 %vptr25440 = alloca i64, align 8 
  %na10173 = call i64 @prim_cdr(i64 %rvp10191) 
  store volatile i64 %na10173, i64* %vptr25440, align 8 ; call prim_cdr
 %vptr25441 = alloca i64, align 8 
  %n_6310192 = call i64 @prim_null_63(i64 %na10173) 
  store volatile i64 %n_6310192, i64* %vptr25441, align 8 ; call prim_null_63
  %cmpptr25445 = alloca i1, align 8  %cmp25442 = icmp eq i64 %n_6310192, 15 store volatile i1 %cmp25442, i1* %cmpptr25445, align 8; false?
  br i1 %cmp25442, label %else25444, label %then25443                                ; if

then25443:
  %vptr25454 = alloca i64*, align 8 
  %cloptr25446 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr25446, i64** %vptr25454, align 8 ; malloc
  %vptr25455 = alloca i64*, align 8 
  %eptr25448 = getelementptr inbounds i64, i64* %cloptr25446, i64 2 
  store volatile i64* %eptr25448, i64** %vptr25455, align 8 ; &eptr25448[1]
  %vptr25456 = alloca i64*, align 8 
  %eptr25449 = getelementptr inbounds i64, i64* %cloptr25446, i64 3 
  store volatile i64* %eptr25449, i64** %vptr25456, align 8 ; &eptr25449[2]
  %vptr25457 = alloca i64*, align 8 
  %eptr25450 = getelementptr inbounds i64, i64* %cloptr25446, i64 4 
  store volatile i64* %eptr25450, i64** %vptr25457, align 8 ; &eptr25450[3]
  %vptr25458 = alloca i64*, align 8 
  %eptr25451 = getelementptr inbounds i64, i64* %cloptr25446, i64 5 
  store volatile i64* %eptr25451, i64** %vptr25458, align 8 ; &eptr25451[4]
  %vptr25459 = alloca i64*, align 8 
  %eptr25452 = getelementptr inbounds i64, i64* %cloptr25446, i64 6 
  store volatile i64* %eptr25452, i64** %vptr25459, align 8 ; &eptr25452[5]
  store i64 %emsg18637, i64* %eptr25448                                              ; *eptr25448 = %emsg18637
  store i64 %kf0$c, i64* %eptr25449                                                  ; *eptr25449 = %kf0$c
  store i64 %cont7239, i64* %eptr25450                                               ; *eptr25450 = %cont7239
  store i64 %emsg08636, i64* %eptr25451                                              ; *eptr25451 = %emsg08636
  store i64 %a7075, i64* %eptr25452                                                  ; *eptr25452 = %a7075
  %vptr25460 = alloca i64*, align 8 
  %eptr25447 = getelementptr inbounds i64, i64* %cloptr25446, i64 1 
  store volatile i64* %eptr25447, i64** %vptr25460, align 8 ; &cloptr25446[1]
 %vptr25461 = alloca i64, align 8 
  %f25453 = ptrtoint void(i64,i64)* @lam11817 to i64 
  store volatile i64 %f25453, i64* %vptr25461, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f25453, i64* %eptr25447                                                 ; store fptr
 %vptr25462 = alloca i64, align 8 
  %arg8263 = ptrtoint i64* %cloptr25446 to i64 
  store volatile i64 %arg8263, i64* %vptr25462, align 8 ; closure cast; i64* -> i64
 %vptr25463 = alloca i64, align 8 
  %rva10190 = add i64 0, 0 
  store volatile i64 %rva10190, i64* %vptr25463, align 8 ; quoted ()
 %vptr25464 = alloca i64, align 8 
  %rva10189 = call i64 @prim_cons(i64 %a7078, i64 %rva10190) 
  store volatile i64 %rva10189, i64* %vptr25464, align 8 ; call prim_cons
 %vptr25465 = alloca i64, align 8 
  %rva10188 = call i64 @prim_cons(i64 %arg8263, i64 %rva10189) 
  store volatile i64 %rva10188, i64* %vptr25465, align 8 ; call prim_cons
  %vptr25471 = alloca i64*, align 8 
  %cloptr25466 = inttoptr i64 %a7076 to i64* 
  store volatile i64* %cloptr25466, i64** %vptr25471, align 8 ; closure/env cast; i64 -> i64*
  %vptr25472 = alloca i64*, align 8 
  %i0ptr25467 = getelementptr inbounds i64, i64* %cloptr25466, i64 1 
  store volatile i64* %i0ptr25467, i64** %vptr25472, align 8 ; &cloptr25466[1]
 %vptr25473 = alloca i64, align 8 
  %f25469 = load i64, i64* %i0ptr25467, align 8 
  store volatile i64 %f25469, i64* %vptr25473, align 8 ; load; *i0ptr25467
  %fptr25468 = inttoptr i64 %f25469 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25468(i64 %a7076, i64 %rva10188)                    ; tail call
  ret void

else25444:
 %vptr25474 = alloca i64, align 8 
  %h10193 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10193, i64* %vptr25474, align 8 ; call prim_halt
  %vptr25480 = alloca i64*, align 8 
  %cloptr25475 = inttoptr i64 %h10193 to i64* 
  store volatile i64* %cloptr25475, i64** %vptr25480, align 8 ; closure/env cast; i64 -> i64*
  %vptr25481 = alloca i64*, align 8 
  %i0ptr25476 = getelementptr inbounds i64, i64* %cloptr25475, i64 1 
  store volatile i64* %i0ptr25476, i64** %vptr25481, align 8 ; &cloptr25475[1]
 %vptr25482 = alloca i64, align 8 
  %f25478 = load i64, i64* %i0ptr25476, align 8 
  store volatile i64 %f25478, i64* %vptr25482, align 8 ; load; *i0ptr25476
  %fptr25477 = inttoptr i64 %f25478 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25477(i64 %h10193, i64 %h10193)                     ; tail call
  ret void
}


define void @lam11817(i64 %env11818, i64 %rvp10184) {
 %vptr25485 = alloca i64, align 8 
  %envptr25483 = inttoptr i64 %env11818 to i64* 
  store volatile i64 %a7075, i64* %vptr25485, align 8 ; closure/env cast; i64 -> i64*
  %vptr25486 = alloca i64*, align 8 
  %envptr25484 = getelementptr inbounds i64, i64* %envptr25483, i64 6 
  store volatile i64* %envptr25484, i64** %vptr25486, align 8 ; &envptr25483[5]
 %vptr25487 = alloca i64, align 8 
  %a7075 = load i64, i64* %envptr25484, align 8 
  store volatile i64 %a7075, i64* %vptr25487, align 8 ; load; *envptr25484
 %vptr25490 = alloca i64, align 8 
  %envptr25488 = inttoptr i64 %env11818 to i64* 
  store volatile i64 %emsg08636, i64* %vptr25490, align 8 ; closure/env cast; i64 -> i64*
  %vptr25491 = alloca i64*, align 8 
  %envptr25489 = getelementptr inbounds i64, i64* %envptr25488, i64 5 
  store volatile i64* %envptr25489, i64** %vptr25491, align 8 ; &envptr25488[4]
 %vptr25492 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr25489, align 8 
  store volatile i64 %emsg08636, i64* %vptr25492, align 8 ; load; *envptr25489
 %vptr25495 = alloca i64, align 8 
  %envptr25493 = inttoptr i64 %env11818 to i64* 
  store volatile i64 %cont7239, i64* %vptr25495, align 8 ; closure/env cast; i64 -> i64*
  %vptr25496 = alloca i64*, align 8 
  %envptr25494 = getelementptr inbounds i64, i64* %envptr25493, i64 4 
  store volatile i64* %envptr25494, i64** %vptr25496, align 8 ; &envptr25493[3]
 %vptr25497 = alloca i64, align 8 
  %cont7239 = load i64, i64* %envptr25494, align 8 
  store volatile i64 %cont7239, i64* %vptr25497, align 8 ; load; *envptr25494
 %vptr25500 = alloca i64, align 8 
  %envptr25498 = inttoptr i64 %env11818 to i64* 
  store volatile i64 %kf0$c, i64* %vptr25500, align 8 ; closure/env cast; i64 -> i64*
  %vptr25501 = alloca i64*, align 8 
  %envptr25499 = getelementptr inbounds i64, i64* %envptr25498, i64 3 
  store volatile i64* %envptr25499, i64** %vptr25501, align 8 ; &envptr25498[2]
 %vptr25502 = alloca i64, align 8 
  %kf0$c = load i64, i64* %envptr25499, align 8 
  store volatile i64 %kf0$c, i64* %vptr25502, align 8 ; load; *envptr25499
 %vptr25505 = alloca i64, align 8 
  %envptr25503 = inttoptr i64 %env11818 to i64* 
  store volatile i64 %emsg18637, i64* %vptr25505, align 8 ; closure/env cast; i64 -> i64*
  %vptr25506 = alloca i64*, align 8 
  %envptr25504 = getelementptr inbounds i64, i64* %envptr25503, i64 2 
  store volatile i64* %envptr25504, i64** %vptr25506, align 8 ; &envptr25503[1]
 %vptr25507 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr25504, align 8 
  store volatile i64 %emsg18637, i64* %vptr25507, align 8 ; load; *envptr25504
 %vptr25508 = alloca i64, align 8 
  %_957241 = call i64 @prim_car(i64 %rvp10184) 
  store volatile i64 %_957241, i64* %vptr25508, align 8 ; call prim_car
 %vptr25509 = alloca i64, align 8 
  %rvp10180 = call i64 @prim_cdr(i64 %rvp10184) 
  store volatile i64 %rvp10180, i64* %vptr25509, align 8 ; call prim_cdr
 %vptr25510 = alloca i64, align 8 
  %n_6310185 = call i64 @prim_null_63(i64 %rvp10180) 
  store volatile i64 %n_6310185, i64* %vptr25510, align 8 ; call prim_null_63
  %cmpptr25514 = alloca i1, align 8  %cmp25511 = icmp eq i64 %n_6310185, 15 store volatile i1 %cmp25511, i1* %cmpptr25514, align 8; false?
  br i1 %cmp25511, label %else25513, label %then25512                                ; if

then25512:
 %vptr25515 = alloca i64, align 8 
  %h10186 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10186, i64* %vptr25515, align 8 ; call prim_halt
  %vptr25521 = alloca i64*, align 8 
  %cloptr25516 = inttoptr i64 %h10186 to i64* 
  store volatile i64* %cloptr25516, i64** %vptr25521, align 8 ; closure/env cast; i64 -> i64*
  %vptr25522 = alloca i64*, align 8 
  %i0ptr25517 = getelementptr inbounds i64, i64* %cloptr25516, i64 1 
  store volatile i64* %i0ptr25517, i64** %vptr25522, align 8 ; &cloptr25516[1]
 %vptr25523 = alloca i64, align 8 
  %f25519 = load i64, i64* %i0ptr25517, align 8 
  store volatile i64 %f25519, i64* %vptr25523, align 8 ; load; *i0ptr25517
  %fptr25518 = inttoptr i64 %f25519 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25518(i64 %h10186, i64 %h10186)                     ; tail call
  ret void

else25513:
 %vptr25524 = alloca i64, align 8 
  %a7079 = call i64 @prim_car(i64 %rvp10180) 
  store volatile i64 %a7079, i64* %vptr25524, align 8 ; call prim_car
 %vptr25525 = alloca i64, align 8 
  %na10175 = call i64 @prim_cdr(i64 %rvp10180) 
  store volatile i64 %na10175, i64* %vptr25525, align 8 ; call prim_cdr
 %vptr25526 = alloca i64, align 8 
  %n_6310181 = call i64 @prim_null_63(i64 %na10175) 
  store volatile i64 %n_6310181, i64* %vptr25526, align 8 ; call prim_null_63
  %cmpptr25530 = alloca i1, align 8  %cmp25527 = icmp eq i64 %n_6310181, 15 store volatile i1 %cmp25527, i1* %cmpptr25530, align 8; false?
  br i1 %cmp25527, label %else25529, label %then25528                                ; if

then25528:
 %vptr25531 = alloca i64, align 8 
  %rva10179 = add i64 0, 0 
  store volatile i64 %rva10179, i64* %vptr25531, align 8 ; quoted ()
 %vptr25532 = alloca i64, align 8 
  %rva10178 = call i64 @prim_cons(i64 %kf0$c, i64 %rva10179) 
  store volatile i64 %rva10178, i64* %vptr25532, align 8 ; call prim_cons
 %vptr25533 = alloca i64, align 8 
  %rva10177 = call i64 @prim_cons(i64 %a7079, i64 %rva10178) 
  store volatile i64 %rva10177, i64* %vptr25533, align 8 ; call prim_cons
 %vptr25534 = alloca i64, align 8 
  %rva10176 = call i64 @prim_cons(i64 %cont7239, i64 %rva10177) 
  store volatile i64 %rva10176, i64* %vptr25534, align 8 ; call prim_cons
  %vptr25540 = alloca i64*, align 8 
  %cloptr25535 = inttoptr i64 %a7075 to i64* 
  store volatile i64* %cloptr25535, i64** %vptr25540, align 8 ; closure/env cast; i64 -> i64*
  %vptr25541 = alloca i64*, align 8 
  %i0ptr25536 = getelementptr inbounds i64, i64* %cloptr25535, i64 1 
  store volatile i64* %i0ptr25536, i64** %vptr25541, align 8 ; &cloptr25535[1]
 %vptr25542 = alloca i64, align 8 
  %f25538 = load i64, i64* %i0ptr25536, align 8 
  store volatile i64 %f25538, i64* %vptr25542, align 8 ; load; *i0ptr25536
  %fptr25537 = inttoptr i64 %f25538 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25537(i64 %a7075, i64 %rva10176)                    ; tail call
  ret void

else25529:
 %vptr25543 = alloca i64, align 8 
  %h10182 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10182, i64* %vptr25543, align 8 ; call prim_halt
  %vptr25549 = alloca i64*, align 8 
  %cloptr25544 = inttoptr i64 %h10182 to i64* 
  store volatile i64* %cloptr25544, i64** %vptr25549, align 8 ; closure/env cast; i64 -> i64*
  %vptr25550 = alloca i64*, align 8 
  %i0ptr25545 = getelementptr inbounds i64, i64* %cloptr25544, i64 1 
  store volatile i64* %i0ptr25545, i64** %vptr25550, align 8 ; &cloptr25544[1]
 %vptr25551 = alloca i64, align 8 
  %f25547 = load i64, i64* %i0ptr25545, align 8 
  store volatile i64 %f25547, i64* %vptr25551, align 8 ; load; *i0ptr25545
  %fptr25546 = inttoptr i64 %f25547 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25546(i64 %h10182, i64 %h10182)                     ; tail call
  ret void
}


define void @lam11810(i64 %env11811, i64 %rvp10259) {
 %vptr25554 = alloca i64, align 8 
  %envptr25552 = inttoptr i64 %env11811 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr25554, align 8 ; closure/env cast; i64 -> i64*
  %vptr25555 = alloca i64*, align 8 
  %envptr25553 = getelementptr inbounds i64, i64* %envptr25552, i64 7 
  store volatile i64* %envptr25553, i64** %vptr25555, align 8 ; &envptr25552[6]
 %vptr25556 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr25553, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr25556, align 8 ; load; *envptr25553
 %vptr25559 = alloca i64, align 8 
  %envptr25557 = inttoptr i64 %env11811 to i64* 
  store volatile i64 %emsg08636, i64* %vptr25559, align 8 ; closure/env cast; i64 -> i64*
  %vptr25560 = alloca i64*, align 8 
  %envptr25558 = getelementptr inbounds i64, i64* %envptr25557, i64 6 
  store volatile i64* %envptr25558, i64** %vptr25560, align 8 ; &envptr25557[5]
 %vptr25561 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr25558, align 8 
  store volatile i64 %emsg08636, i64* %vptr25561, align 8 ; load; *envptr25558
 %vptr25564 = alloca i64, align 8 
  %envptr25562 = inttoptr i64 %env11811 to i64* 
  store volatile i64 %njK$_37k, i64* %vptr25564, align 8 ; closure/env cast; i64 -> i64*
  %vptr25565 = alloca i64*, align 8 
  %envptr25563 = getelementptr inbounds i64, i64* %envptr25562, i64 5 
  store volatile i64* %envptr25563, i64** %vptr25565, align 8 ; &envptr25562[4]
 %vptr25566 = alloca i64, align 8 
  %njK$_37k = load i64, i64* %envptr25563, align 8 
  store volatile i64 %njK$_37k, i64* %vptr25566, align 8 ; load; *envptr25563
 %vptr25569 = alloca i64, align 8 
  %envptr25567 = inttoptr i64 %env11811 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr25569, align 8 ; closure/env cast; i64 -> i64*
  %vptr25570 = alloca i64*, align 8 
  %envptr25568 = getelementptr inbounds i64, i64* %envptr25567, i64 4 
  store volatile i64* %envptr25568, i64** %vptr25570, align 8 ; &envptr25567[3]
 %vptr25571 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr25568, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr25571, align 8 ; load; *envptr25568
 %vptr25574 = alloca i64, align 8 
  %envptr25572 = inttoptr i64 %env11811 to i64* 
  store volatile i64 %emsg18637, i64* %vptr25574, align 8 ; closure/env cast; i64 -> i64*
  %vptr25575 = alloca i64*, align 8 
  %envptr25573 = getelementptr inbounds i64, i64* %envptr25572, i64 3 
  store volatile i64* %envptr25573, i64** %vptr25575, align 8 ; &envptr25572[2]
 %vptr25576 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr25573, align 8 
  store volatile i64 %emsg18637, i64* %vptr25576, align 8 ; load; *envptr25573
 %vptr25579 = alloca i64, align 8 
  %envptr25577 = inttoptr i64 %env11811 to i64* 
  store volatile i64 %SiZ$_37saved_45stack, i64* %vptr25579, align 8 ; closure/env cast; i64 -> i64*
  %vptr25580 = alloca i64*, align 8 
  %envptr25578 = getelementptr inbounds i64, i64* %envptr25577, i64 2 
  store volatile i64* %envptr25578, i64** %vptr25580, align 8 ; &envptr25577[1]
 %vptr25581 = alloca i64, align 8 
  %SiZ$_37saved_45stack = load i64, i64* %envptr25578, align 8 
  store volatile i64 %SiZ$_37saved_45stack, i64* %vptr25581, align 8 ; load; *envptr25578
 %vptr25582 = alloca i64, align 8 
  %cont7242 = call i64 @prim_car(i64 %rvp10259) 
  store volatile i64 %cont7242, i64* %vptr25582, align 8 ; call prim_car
 %vptr25583 = alloca i64, align 8 
  %rvp10255 = call i64 @prim_cdr(i64 %rvp10259) 
  store volatile i64 %rvp10255, i64* %vptr25583, align 8 ; call prim_cdr
 %vptr25584 = alloca i64, align 8 
  %n_6310260 = call i64 @prim_null_63(i64 %rvp10255) 
  store volatile i64 %n_6310260, i64* %vptr25584, align 8 ; call prim_null_63
  %cmpptr25588 = alloca i1, align 8  %cmp25585 = icmp eq i64 %n_6310260, 15 store volatile i1 %cmp25585, i1* %cmpptr25588, align 8; false?
  br i1 %cmp25585, label %else25587, label %then25586                                ; if

then25586:
 %vptr25589 = alloca i64, align 8 
  %h10261 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10261, i64* %vptr25589, align 8 ; call prim_halt
  %vptr25595 = alloca i64*, align 8 
  %cloptr25590 = inttoptr i64 %h10261 to i64* 
  store volatile i64* %cloptr25590, i64** %vptr25595, align 8 ; closure/env cast; i64 -> i64*
  %vptr25596 = alloca i64*, align 8 
  %i0ptr25591 = getelementptr inbounds i64, i64* %cloptr25590, i64 1 
  store volatile i64* %i0ptr25591, i64** %vptr25596, align 8 ; &cloptr25590[1]
 %vptr25597 = alloca i64, align 8 
  %f25593 = load i64, i64* %i0ptr25591, align 8 
  store volatile i64 %f25593, i64* %vptr25597, align 8 ; load; *i0ptr25591
  %fptr25592 = inttoptr i64 %f25593 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25592(i64 %h10261, i64 %h10261)                     ; tail call
  ret void

else25587:
 %vptr25598 = alloca i64, align 8 
  %ClB$_37x = call i64 @prim_car(i64 %rvp10255) 
  store volatile i64 %ClB$_37x, i64* %vptr25598, align 8 ; call prim_car
 %vptr25599 = alloca i64, align 8 
  %na10222 = call i64 @prim_cdr(i64 %rvp10255) 
  store volatile i64 %na10222, i64* %vptr25599, align 8 ; call prim_cdr
 %vptr25600 = alloca i64, align 8 
  %n_6310256 = call i64 @prim_null_63(i64 %na10222) 
  store volatile i64 %n_6310256, i64* %vptr25600, align 8 ; call prim_null_63
  %cmpptr25604 = alloca i1, align 8  %cmp25601 = icmp eq i64 %n_6310256, 15 store volatile i1 %cmp25601, i1* %cmpptr25604, align 8; false?
  br i1 %cmp25601, label %else25603, label %then25602                                ; if

then25602:
 %vptr25605 = alloca i64, align 8 
  %arg8269 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8269, i64* %vptr25605, align 8 ; quoted int
 %vptr25606 = alloca i64, align 8 
  %a7080 = call i64 @prim_vector_45ref(i64 %SdC$_37wind_45stack, i64 %arg8269) 
  store volatile i64 %a7080, i64* %vptr25606, align 8 ; call prim_vector_45ref
 %vptr25607 = alloca i64, align 8 
  %a7081 = call i64 @prim_eq_63(i64 %SiZ$_37saved_45stack, i64 %a7080) 
  store volatile i64 %a7081, i64* %vptr25607, align 8 ; call prim_eq_63
  %cmpptr25611 = alloca i1, align 8  %cmp25608 = icmp eq i64 %a7081, 15 store volatile i1 %cmp25608, i1* %cmpptr25611, align 8; false?
  br i1 %cmp25608, label %else25610, label %then25609                                ; if

then25609:
 %vptr25612 = alloca i64, align 8 
  %retprim7244 = call i64 @prim_void() 
  store volatile i64 %retprim7244, i64* %vptr25612, align 8 ; call prim_void
  %vptr25621 = alloca i64*, align 8 
  %cloptr25613 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr25613, i64** %vptr25621, align 8 ; malloc
  %vptr25622 = alloca i64*, align 8 
  %eptr25615 = getelementptr inbounds i64, i64* %cloptr25613, i64 2 
  store volatile i64* %eptr25615, i64** %vptr25622, align 8 ; &eptr25615[1]
  %vptr25623 = alloca i64*, align 8 
  %eptr25616 = getelementptr inbounds i64, i64* %cloptr25613, i64 3 
  store volatile i64* %eptr25616, i64** %vptr25623, align 8 ; &eptr25616[2]
  %vptr25624 = alloca i64*, align 8 
  %eptr25617 = getelementptr inbounds i64, i64* %cloptr25613, i64 4 
  store volatile i64* %eptr25617, i64** %vptr25624, align 8 ; &eptr25617[3]
  %vptr25625 = alloca i64*, align 8 
  %eptr25618 = getelementptr inbounds i64, i64* %cloptr25613, i64 5 
  store volatile i64* %eptr25618, i64** %vptr25625, align 8 ; &eptr25618[4]
  %vptr25626 = alloca i64*, align 8 
  %eptr25619 = getelementptr inbounds i64, i64* %cloptr25613, i64 6 
  store volatile i64* %eptr25619, i64** %vptr25626, align 8 ; &eptr25619[5]
  store i64 %emsg18637, i64* %eptr25615                                              ; *eptr25615 = %emsg18637
  store i64 %ClB$_37x, i64* %eptr25616                                               ; *eptr25616 = %ClB$_37x
  store i64 %njK$_37k, i64* %eptr25617                                               ; *eptr25617 = %njK$_37k
  store i64 %cont7242, i64* %eptr25618                                               ; *eptr25618 = %cont7242
  store i64 %emsg08636, i64* %eptr25619                                              ; *eptr25619 = %emsg08636
  %vptr25627 = alloca i64*, align 8 
  %eptr25614 = getelementptr inbounds i64, i64* %cloptr25613, i64 1 
  store volatile i64* %eptr25614, i64** %vptr25627, align 8 ; &cloptr25613[1]
 %vptr25628 = alloca i64, align 8 
  %f25620 = ptrtoint void(i64,i64)* @lam11803 to i64 
  store volatile i64 %f25620, i64* %vptr25628, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f25620, i64* %eptr25614                                                 ; store fptr
 %vptr25629 = alloca i64, align 8 
  %arg8275 = ptrtoint i64* %cloptr25613 to i64 
  store volatile i64 %arg8275, i64* %vptr25629, align 8 ; closure cast; i64* -> i64
 %vptr25630 = alloca i64, align 8 
  %arg8274 = add i64 0, 0 
  store volatile i64 %arg8274, i64* %vptr25630, align 8 ; quoted ()
 %vptr25631 = alloca i64, align 8 
  %rva10238 = add i64 0, 0 
  store volatile i64 %rva10238, i64* %vptr25631, align 8 ; quoted ()
 %vptr25632 = alloca i64, align 8 
  %rva10237 = call i64 @prim_cons(i64 %retprim7244, i64 %rva10238) 
  store volatile i64 %rva10237, i64* %vptr25632, align 8 ; call prim_cons
 %vptr25633 = alloca i64, align 8 
  %rva10236 = call i64 @prim_cons(i64 %arg8274, i64 %rva10237) 
  store volatile i64 %rva10236, i64* %vptr25633, align 8 ; call prim_cons
  %vptr25639 = alloca i64*, align 8 
  %cloptr25634 = inttoptr i64 %arg8275 to i64* 
  store volatile i64* %cloptr25634, i64** %vptr25639, align 8 ; closure/env cast; i64 -> i64*
  %vptr25640 = alloca i64*, align 8 
  %i0ptr25635 = getelementptr inbounds i64, i64* %cloptr25634, i64 1 
  store volatile i64* %i0ptr25635, i64** %vptr25640, align 8 ; &cloptr25634[1]
 %vptr25641 = alloca i64, align 8 
  %f25637 = load i64, i64* %i0ptr25635, align 8 
  store volatile i64 %f25637, i64* %vptr25641, align 8 ; load; *i0ptr25635
  %fptr25636 = inttoptr i64 %f25637 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25636(i64 %arg8275, i64 %rva10236)                  ; tail call
  ret void

else25610:
  %vptr25650 = alloca i64*, align 8 
  %cloptr25642 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr25642, i64** %vptr25650, align 8 ; malloc
  %vptr25651 = alloca i64*, align 8 
  %eptr25644 = getelementptr inbounds i64, i64* %cloptr25642, i64 2 
  store volatile i64* %eptr25644, i64** %vptr25651, align 8 ; &eptr25644[1]
  %vptr25652 = alloca i64*, align 8 
  %eptr25645 = getelementptr inbounds i64, i64* %cloptr25642, i64 3 
  store volatile i64* %eptr25645, i64** %vptr25652, align 8 ; &eptr25645[2]
  %vptr25653 = alloca i64*, align 8 
  %eptr25646 = getelementptr inbounds i64, i64* %cloptr25642, i64 4 
  store volatile i64* %eptr25646, i64** %vptr25653, align 8 ; &eptr25646[3]
  %vptr25654 = alloca i64*, align 8 
  %eptr25647 = getelementptr inbounds i64, i64* %cloptr25642, i64 5 
  store volatile i64* %eptr25647, i64** %vptr25654, align 8 ; &eptr25647[4]
  %vptr25655 = alloca i64*, align 8 
  %eptr25648 = getelementptr inbounds i64, i64* %cloptr25642, i64 6 
  store volatile i64* %eptr25648, i64** %vptr25655, align 8 ; &eptr25648[5]
  store i64 %emsg18637, i64* %eptr25644                                              ; *eptr25644 = %emsg18637
  store i64 %ClB$_37x, i64* %eptr25645                                               ; *eptr25645 = %ClB$_37x
  store i64 %njK$_37k, i64* %eptr25646                                               ; *eptr25646 = %njK$_37k
  store i64 %cont7242, i64* %eptr25647                                               ; *eptr25647 = %cont7242
  store i64 %emsg08636, i64* %eptr25648                                              ; *eptr25648 = %emsg08636
  %vptr25656 = alloca i64*, align 8 
  %eptr25643 = getelementptr inbounds i64, i64* %cloptr25642, i64 1 
  store volatile i64* %eptr25643, i64** %vptr25656, align 8 ; &cloptr25642[1]
 %vptr25657 = alloca i64, align 8 
  %f25649 = ptrtoint void(i64,i64)* @lam11807 to i64 
  store volatile i64 %f25649, i64* %vptr25657, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f25649, i64* %eptr25643                                                 ; store fptr
 %vptr25658 = alloca i64, align 8 
  %arg8280 = ptrtoint i64* %cloptr25642 to i64 
  store volatile i64 %arg8280, i64* %vptr25658, align 8 ; closure cast; i64* -> i64
 %vptr25659 = alloca i64, align 8 
  %rva10254 = add i64 0, 0 
  store volatile i64 %rva10254, i64* %vptr25659, align 8 ; quoted ()
 %vptr25660 = alloca i64, align 8 
  %rva10253 = call i64 @prim_cons(i64 %SiZ$_37saved_45stack, i64 %rva10254) 
  store volatile i64 %rva10253, i64* %vptr25660, align 8 ; call prim_cons
 %vptr25661 = alloca i64, align 8 
  %rva10252 = call i64 @prim_cons(i64 %arg8280, i64 %rva10253) 
  store volatile i64 %rva10252, i64* %vptr25661, align 8 ; call prim_cons
  %vptr25667 = alloca i64*, align 8 
  %cloptr25662 = inttoptr i64 %U8g$_37do_45wind to i64* 
  store volatile i64* %cloptr25662, i64** %vptr25667, align 8 ; closure/env cast; i64 -> i64*
  %vptr25668 = alloca i64*, align 8 
  %i0ptr25663 = getelementptr inbounds i64, i64* %cloptr25662, i64 1 
  store volatile i64* %i0ptr25663, i64** %vptr25668, align 8 ; &cloptr25662[1]
 %vptr25669 = alloca i64, align 8 
  %f25665 = load i64, i64* %i0ptr25663, align 8 
  store volatile i64 %f25665, i64* %vptr25669, align 8 ; load; *i0ptr25663
  %fptr25664 = inttoptr i64 %f25665 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25664(i64 %U8g$_37do_45wind, i64 %rva10252)         ; tail call
  ret void

else25603:
 %vptr25670 = alloca i64, align 8 
  %h10257 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10257, i64* %vptr25670, align 8 ; call prim_halt
  %vptr25676 = alloca i64*, align 8 
  %cloptr25671 = inttoptr i64 %h10257 to i64* 
  store volatile i64* %cloptr25671, i64** %vptr25676, align 8 ; closure/env cast; i64 -> i64*
  %vptr25677 = alloca i64*, align 8 
  %i0ptr25672 = getelementptr inbounds i64, i64* %cloptr25671, i64 1 
  store volatile i64* %i0ptr25672, i64** %vptr25677, align 8 ; &cloptr25671[1]
 %vptr25678 = alloca i64, align 8 
  %f25674 = load i64, i64* %i0ptr25672, align 8 
  store volatile i64 %f25674, i64* %vptr25678, align 8 ; load; *i0ptr25672
  %fptr25673 = inttoptr i64 %f25674 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25673(i64 %h10257, i64 %h10257)                     ; tail call
  ret void
}


define void @lam11807(i64 %env11808, i64 %rvp10248) {
 %vptr25681 = alloca i64, align 8 
  %envptr25679 = inttoptr i64 %env11808 to i64* 
  store volatile i64 %emsg08636, i64* %vptr25681, align 8 ; closure/env cast; i64 -> i64*
  %vptr25682 = alloca i64*, align 8 
  %envptr25680 = getelementptr inbounds i64, i64* %envptr25679, i64 6 
  store volatile i64* %envptr25680, i64** %vptr25682, align 8 ; &envptr25679[5]
 %vptr25683 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr25680, align 8 
  store volatile i64 %emsg08636, i64* %vptr25683, align 8 ; load; *envptr25680
 %vptr25686 = alloca i64, align 8 
  %envptr25684 = inttoptr i64 %env11808 to i64* 
  store volatile i64 %cont7242, i64* %vptr25686, align 8 ; closure/env cast; i64 -> i64*
  %vptr25687 = alloca i64*, align 8 
  %envptr25685 = getelementptr inbounds i64, i64* %envptr25684, i64 5 
  store volatile i64* %envptr25685, i64** %vptr25687, align 8 ; &envptr25684[4]
 %vptr25688 = alloca i64, align 8 
  %cont7242 = load i64, i64* %envptr25685, align 8 
  store volatile i64 %cont7242, i64* %vptr25688, align 8 ; load; *envptr25685
 %vptr25691 = alloca i64, align 8 
  %envptr25689 = inttoptr i64 %env11808 to i64* 
  store volatile i64 %njK$_37k, i64* %vptr25691, align 8 ; closure/env cast; i64 -> i64*
  %vptr25692 = alloca i64*, align 8 
  %envptr25690 = getelementptr inbounds i64, i64* %envptr25689, i64 4 
  store volatile i64* %envptr25690, i64** %vptr25692, align 8 ; &envptr25689[3]
 %vptr25693 = alloca i64, align 8 
  %njK$_37k = load i64, i64* %envptr25690, align 8 
  store volatile i64 %njK$_37k, i64* %vptr25693, align 8 ; load; *envptr25690
 %vptr25696 = alloca i64, align 8 
  %envptr25694 = inttoptr i64 %env11808 to i64* 
  store volatile i64 %ClB$_37x, i64* %vptr25696, align 8 ; closure/env cast; i64 -> i64*
  %vptr25697 = alloca i64*, align 8 
  %envptr25695 = getelementptr inbounds i64, i64* %envptr25694, i64 3 
  store volatile i64* %envptr25695, i64** %vptr25697, align 8 ; &envptr25694[2]
 %vptr25698 = alloca i64, align 8 
  %ClB$_37x = load i64, i64* %envptr25695, align 8 
  store volatile i64 %ClB$_37x, i64* %vptr25698, align 8 ; load; *envptr25695
 %vptr25701 = alloca i64, align 8 
  %envptr25699 = inttoptr i64 %env11808 to i64* 
  store volatile i64 %emsg18637, i64* %vptr25701, align 8 ; closure/env cast; i64 -> i64*
  %vptr25702 = alloca i64*, align 8 
  %envptr25700 = getelementptr inbounds i64, i64* %envptr25699, i64 2 
  store volatile i64* %envptr25700, i64** %vptr25702, align 8 ; &envptr25699[1]
 %vptr25703 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr25700, align 8 
  store volatile i64 %emsg18637, i64* %vptr25703, align 8 ; load; *envptr25700
 %vptr25704 = alloca i64, align 8 
  %_957243 = call i64 @prim_car(i64 %rvp10248) 
  store volatile i64 %_957243, i64* %vptr25704, align 8 ; call prim_car
 %vptr25705 = alloca i64, align 8 
  %rvp10244 = call i64 @prim_cdr(i64 %rvp10248) 
  store volatile i64 %rvp10244, i64* %vptr25705, align 8 ; call prim_cdr
 %vptr25706 = alloca i64, align 8 
  %n_6310249 = call i64 @prim_null_63(i64 %rvp10244) 
  store volatile i64 %n_6310249, i64* %vptr25706, align 8 ; call prim_null_63
  %cmpptr25710 = alloca i1, align 8  %cmp25707 = icmp eq i64 %n_6310249, 15 store volatile i1 %cmp25707, i1* %cmpptr25710, align 8; false?
  br i1 %cmp25707, label %else25709, label %then25708                                ; if

then25708:
 %vptr25711 = alloca i64, align 8 
  %h10250 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10250, i64* %vptr25711, align 8 ; call prim_halt
  %vptr25717 = alloca i64*, align 8 
  %cloptr25712 = inttoptr i64 %h10250 to i64* 
  store volatile i64* %cloptr25712, i64** %vptr25717, align 8 ; closure/env cast; i64 -> i64*
  %vptr25718 = alloca i64*, align 8 
  %i0ptr25713 = getelementptr inbounds i64, i64* %cloptr25712, i64 1 
  store volatile i64* %i0ptr25713, i64** %vptr25718, align 8 ; &cloptr25712[1]
 %vptr25719 = alloca i64, align 8 
  %f25715 = load i64, i64* %i0ptr25713, align 8 
  store volatile i64 %f25715, i64* %vptr25719, align 8 ; load; *i0ptr25713
  %fptr25714 = inttoptr i64 %f25715 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25714(i64 %h10250, i64 %h10250)                     ; tail call
  ret void

else25709:
 %vptr25720 = alloca i64, align 8 
  %dvI$_956899 = call i64 @prim_car(i64 %rvp10244) 
  store volatile i64 %dvI$_956899, i64* %vptr25720, align 8 ; call prim_car
 %vptr25721 = alloca i64, align 8 
  %na10240 = call i64 @prim_cdr(i64 %rvp10244) 
  store volatile i64 %na10240, i64* %vptr25721, align 8 ; call prim_cdr
 %vptr25722 = alloca i64, align 8 
  %n_6310245 = call i64 @prim_null_63(i64 %na10240) 
  store volatile i64 %n_6310245, i64* %vptr25722, align 8 ; call prim_null_63
  %cmpptr25726 = alloca i1, align 8  %cmp25723 = icmp eq i64 %n_6310245, 15 store volatile i1 %cmp25723, i1* %cmpptr25726, align 8; false?
  br i1 %cmp25723, label %else25725, label %then25724                                ; if

then25724:
 %vptr25727 = alloca i64, align 8 
  %rva10243 = add i64 0, 0 
  store volatile i64 %rva10243, i64* %vptr25727, align 8 ; quoted ()
 %vptr25728 = alloca i64, align 8 
  %rva10242 = call i64 @prim_cons(i64 %ClB$_37x, i64 %rva10243) 
  store volatile i64 %rva10242, i64* %vptr25728, align 8 ; call prim_cons
 %vptr25729 = alloca i64, align 8 
  %rva10241 = call i64 @prim_cons(i64 %cont7242, i64 %rva10242) 
  store volatile i64 %rva10241, i64* %vptr25729, align 8 ; call prim_cons
  %vptr25735 = alloca i64*, align 8 
  %cloptr25730 = inttoptr i64 %njK$_37k to i64* 
  store volatile i64* %cloptr25730, i64** %vptr25735, align 8 ; closure/env cast; i64 -> i64*
  %vptr25736 = alloca i64*, align 8 
  %i0ptr25731 = getelementptr inbounds i64, i64* %cloptr25730, i64 1 
  store volatile i64* %i0ptr25731, i64** %vptr25736, align 8 ; &cloptr25730[1]
 %vptr25737 = alloca i64, align 8 
  %f25733 = load i64, i64* %i0ptr25731, align 8 
  store volatile i64 %f25733, i64* %vptr25737, align 8 ; load; *i0ptr25731
  %fptr25732 = inttoptr i64 %f25733 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25732(i64 %njK$_37k, i64 %rva10241)                 ; tail call
  ret void

else25725:
 %vptr25738 = alloca i64, align 8 
  %h10246 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10246, i64* %vptr25738, align 8 ; call prim_halt
  %vptr25744 = alloca i64*, align 8 
  %cloptr25739 = inttoptr i64 %h10246 to i64* 
  store volatile i64* %cloptr25739, i64** %vptr25744, align 8 ; closure/env cast; i64 -> i64*
  %vptr25745 = alloca i64*, align 8 
  %i0ptr25740 = getelementptr inbounds i64, i64* %cloptr25739, i64 1 
  store volatile i64* %i0ptr25740, i64** %vptr25745, align 8 ; &cloptr25739[1]
 %vptr25746 = alloca i64, align 8 
  %f25742 = load i64, i64* %i0ptr25740, align 8 
  store volatile i64 %f25742, i64* %vptr25746, align 8 ; load; *i0ptr25740
  %fptr25741 = inttoptr i64 %f25742 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25741(i64 %h10246, i64 %h10246)                     ; tail call
  ret void
}


define void @lam11803(i64 %env11804, i64 %rvp10232) {
 %vptr25749 = alloca i64, align 8 
  %envptr25747 = inttoptr i64 %env11804 to i64* 
  store volatile i64 %emsg08636, i64* %vptr25749, align 8 ; closure/env cast; i64 -> i64*
  %vptr25750 = alloca i64*, align 8 
  %envptr25748 = getelementptr inbounds i64, i64* %envptr25747, i64 6 
  store volatile i64* %envptr25748, i64** %vptr25750, align 8 ; &envptr25747[5]
 %vptr25751 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr25748, align 8 
  store volatile i64 %emsg08636, i64* %vptr25751, align 8 ; load; *envptr25748
 %vptr25754 = alloca i64, align 8 
  %envptr25752 = inttoptr i64 %env11804 to i64* 
  store volatile i64 %cont7242, i64* %vptr25754, align 8 ; closure/env cast; i64 -> i64*
  %vptr25755 = alloca i64*, align 8 
  %envptr25753 = getelementptr inbounds i64, i64* %envptr25752, i64 5 
  store volatile i64* %envptr25753, i64** %vptr25755, align 8 ; &envptr25752[4]
 %vptr25756 = alloca i64, align 8 
  %cont7242 = load i64, i64* %envptr25753, align 8 
  store volatile i64 %cont7242, i64* %vptr25756, align 8 ; load; *envptr25753
 %vptr25759 = alloca i64, align 8 
  %envptr25757 = inttoptr i64 %env11804 to i64* 
  store volatile i64 %njK$_37k, i64* %vptr25759, align 8 ; closure/env cast; i64 -> i64*
  %vptr25760 = alloca i64*, align 8 
  %envptr25758 = getelementptr inbounds i64, i64* %envptr25757, i64 4 
  store volatile i64* %envptr25758, i64** %vptr25760, align 8 ; &envptr25757[3]
 %vptr25761 = alloca i64, align 8 
  %njK$_37k = load i64, i64* %envptr25758, align 8 
  store volatile i64 %njK$_37k, i64* %vptr25761, align 8 ; load; *envptr25758
 %vptr25764 = alloca i64, align 8 
  %envptr25762 = inttoptr i64 %env11804 to i64* 
  store volatile i64 %ClB$_37x, i64* %vptr25764, align 8 ; closure/env cast; i64 -> i64*
  %vptr25765 = alloca i64*, align 8 
  %envptr25763 = getelementptr inbounds i64, i64* %envptr25762, i64 3 
  store volatile i64* %envptr25763, i64** %vptr25765, align 8 ; &envptr25762[2]
 %vptr25766 = alloca i64, align 8 
  %ClB$_37x = load i64, i64* %envptr25763, align 8 
  store volatile i64 %ClB$_37x, i64* %vptr25766, align 8 ; load; *envptr25763
 %vptr25769 = alloca i64, align 8 
  %envptr25767 = inttoptr i64 %env11804 to i64* 
  store volatile i64 %emsg18637, i64* %vptr25769, align 8 ; closure/env cast; i64 -> i64*
  %vptr25770 = alloca i64*, align 8 
  %envptr25768 = getelementptr inbounds i64, i64* %envptr25767, i64 2 
  store volatile i64* %envptr25768, i64** %vptr25770, align 8 ; &envptr25767[1]
 %vptr25771 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr25768, align 8 
  store volatile i64 %emsg18637, i64* %vptr25771, align 8 ; load; *envptr25768
 %vptr25772 = alloca i64, align 8 
  %_957243 = call i64 @prim_car(i64 %rvp10232) 
  store volatile i64 %_957243, i64* %vptr25772, align 8 ; call prim_car
 %vptr25773 = alloca i64, align 8 
  %rvp10228 = call i64 @prim_cdr(i64 %rvp10232) 
  store volatile i64 %rvp10228, i64* %vptr25773, align 8 ; call prim_cdr
 %vptr25774 = alloca i64, align 8 
  %n_6310233 = call i64 @prim_null_63(i64 %rvp10228) 
  store volatile i64 %n_6310233, i64* %vptr25774, align 8 ; call prim_null_63
  %cmpptr25778 = alloca i1, align 8  %cmp25775 = icmp eq i64 %n_6310233, 15 store volatile i1 %cmp25775, i1* %cmpptr25778, align 8; false?
  br i1 %cmp25775, label %else25777, label %then25776                                ; if

then25776:
 %vptr25779 = alloca i64, align 8 
  %h10234 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10234, i64* %vptr25779, align 8 ; call prim_halt
  %vptr25785 = alloca i64*, align 8 
  %cloptr25780 = inttoptr i64 %h10234 to i64* 
  store volatile i64* %cloptr25780, i64** %vptr25785, align 8 ; closure/env cast; i64 -> i64*
  %vptr25786 = alloca i64*, align 8 
  %i0ptr25781 = getelementptr inbounds i64, i64* %cloptr25780, i64 1 
  store volatile i64* %i0ptr25781, i64** %vptr25786, align 8 ; &cloptr25780[1]
 %vptr25787 = alloca i64, align 8 
  %f25783 = load i64, i64* %i0ptr25781, align 8 
  store volatile i64 %f25783, i64* %vptr25787, align 8 ; load; *i0ptr25781
  %fptr25782 = inttoptr i64 %f25783 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25782(i64 %h10234, i64 %h10234)                     ; tail call
  ret void

else25777:
 %vptr25788 = alloca i64, align 8 
  %dvI$_956899 = call i64 @prim_car(i64 %rvp10228) 
  store volatile i64 %dvI$_956899, i64* %vptr25788, align 8 ; call prim_car
 %vptr25789 = alloca i64, align 8 
  %na10224 = call i64 @prim_cdr(i64 %rvp10228) 
  store volatile i64 %na10224, i64* %vptr25789, align 8 ; call prim_cdr
 %vptr25790 = alloca i64, align 8 
  %n_6310229 = call i64 @prim_null_63(i64 %na10224) 
  store volatile i64 %n_6310229, i64* %vptr25790, align 8 ; call prim_null_63
  %cmpptr25794 = alloca i1, align 8  %cmp25791 = icmp eq i64 %n_6310229, 15 store volatile i1 %cmp25791, i1* %cmpptr25794, align 8; false?
  br i1 %cmp25791, label %else25793, label %then25792                                ; if

then25792:
 %vptr25795 = alloca i64, align 8 
  %rva10227 = add i64 0, 0 
  store volatile i64 %rva10227, i64* %vptr25795, align 8 ; quoted ()
 %vptr25796 = alloca i64, align 8 
  %rva10226 = call i64 @prim_cons(i64 %ClB$_37x, i64 %rva10227) 
  store volatile i64 %rva10226, i64* %vptr25796, align 8 ; call prim_cons
 %vptr25797 = alloca i64, align 8 
  %rva10225 = call i64 @prim_cons(i64 %cont7242, i64 %rva10226) 
  store volatile i64 %rva10225, i64* %vptr25797, align 8 ; call prim_cons
  %vptr25803 = alloca i64*, align 8 
  %cloptr25798 = inttoptr i64 %njK$_37k to i64* 
  store volatile i64* %cloptr25798, i64** %vptr25803, align 8 ; closure/env cast; i64 -> i64*
  %vptr25804 = alloca i64*, align 8 
  %i0ptr25799 = getelementptr inbounds i64, i64* %cloptr25798, i64 1 
  store volatile i64* %i0ptr25799, i64** %vptr25804, align 8 ; &cloptr25798[1]
 %vptr25805 = alloca i64, align 8 
  %f25801 = load i64, i64* %i0ptr25799, align 8 
  store volatile i64 %f25801, i64* %vptr25805, align 8 ; load; *i0ptr25799
  %fptr25800 = inttoptr i64 %f25801 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25800(i64 %njK$_37k, i64 %rva10225)                 ; tail call
  ret void

else25793:
 %vptr25806 = alloca i64, align 8 
  %h10230 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10230, i64* %vptr25806, align 8 ; call prim_halt
  %vptr25812 = alloca i64*, align 8 
  %cloptr25807 = inttoptr i64 %h10230 to i64* 
  store volatile i64* %cloptr25807, i64** %vptr25812, align 8 ; closure/env cast; i64 -> i64*
  %vptr25813 = alloca i64*, align 8 
  %i0ptr25808 = getelementptr inbounds i64, i64* %cloptr25807, i64 1 
  store volatile i64* %i0ptr25808, i64** %vptr25813, align 8 ; &cloptr25807[1]
 %vptr25814 = alloca i64, align 8 
  %f25810 = load i64, i64* %i0ptr25808, align 8 
  store volatile i64 %f25810, i64* %vptr25814, align 8 ; load; *i0ptr25808
  %fptr25809 = inttoptr i64 %f25810 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25809(i64 %h10230, i64 %h10230)                     ; tail call
  ret void
}


define void @lam11797(i64 %env11798, i64 %rvp10285) {
 %vptr25817 = alloca i64, align 8 
  %envptr25815 = inttoptr i64 %env11798 to i64* 
  store volatile i64 %cont7229, i64* %vptr25817, align 8 ; closure/env cast; i64 -> i64*
  %vptr25818 = alloca i64*, align 8 
  %envptr25816 = getelementptr inbounds i64, i64* %envptr25815, i64 7 
  store volatile i64* %envptr25816, i64** %vptr25818, align 8 ; &envptr25815[6]
 %vptr25819 = alloca i64, align 8 
  %cont7229 = load i64, i64* %envptr25816, align 8 
  store volatile i64 %cont7229, i64* %vptr25819, align 8 ; load; *envptr25816
 %vptr25822 = alloca i64, align 8 
  %envptr25820 = inttoptr i64 %env11798 to i64* 
  store volatile i64 %a7067, i64* %vptr25822, align 8 ; closure/env cast; i64 -> i64*
  %vptr25823 = alloca i64*, align 8 
  %envptr25821 = getelementptr inbounds i64, i64* %envptr25820, i64 6 
  store volatile i64* %envptr25821, i64** %vptr25823, align 8 ; &envptr25820[5]
 %vptr25824 = alloca i64, align 8 
  %a7067 = load i64, i64* %envptr25821, align 8 
  store volatile i64 %a7067, i64* %vptr25824, align 8 ; load; *envptr25821
 %vptr25827 = alloca i64, align 8 
  %envptr25825 = inttoptr i64 %env11798 to i64* 
  store volatile i64 %emsg08636, i64* %vptr25827, align 8 ; closure/env cast; i64 -> i64*
  %vptr25828 = alloca i64*, align 8 
  %envptr25826 = getelementptr inbounds i64, i64* %envptr25825, i64 5 
  store volatile i64* %envptr25826, i64** %vptr25828, align 8 ; &envptr25825[4]
 %vptr25829 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr25826, align 8 
  store volatile i64 %emsg08636, i64* %vptr25829, align 8 ; load; *envptr25826
 %vptr25832 = alloca i64, align 8 
  %envptr25830 = inttoptr i64 %env11798 to i64* 
  store volatile i64 %a7074, i64* %vptr25832, align 8 ; closure/env cast; i64 -> i64*
  %vptr25833 = alloca i64*, align 8 
  %envptr25831 = getelementptr inbounds i64, i64* %envptr25830, i64 4 
  store volatile i64* %envptr25831, i64** %vptr25833, align 8 ; &envptr25830[3]
 %vptr25834 = alloca i64, align 8 
  %a7074 = load i64, i64* %envptr25831, align 8 
  store volatile i64 %a7074, i64* %vptr25834, align 8 ; load; *envptr25831
 %vptr25837 = alloca i64, align 8 
  %envptr25835 = inttoptr i64 %env11798 to i64* 
  store volatile i64 %ZpZ$c, i64* %vptr25837, align 8 ; closure/env cast; i64 -> i64*
  %vptr25838 = alloca i64*, align 8 
  %envptr25836 = getelementptr inbounds i64, i64* %envptr25835, i64 3 
  store volatile i64* %envptr25836, i64** %vptr25838, align 8 ; &envptr25835[2]
 %vptr25839 = alloca i64, align 8 
  %ZpZ$c = load i64, i64* %envptr25836, align 8 
  store volatile i64 %ZpZ$c, i64* %vptr25839, align 8 ; load; *envptr25836
 %vptr25842 = alloca i64, align 8 
  %envptr25840 = inttoptr i64 %env11798 to i64* 
  store volatile i64 %emsg18637, i64* %vptr25842, align 8 ; closure/env cast; i64 -> i64*
  %vptr25843 = alloca i64*, align 8 
  %envptr25841 = getelementptr inbounds i64, i64* %envptr25840, i64 2 
  store volatile i64* %envptr25841, i64** %vptr25843, align 8 ; &envptr25840[1]
 %vptr25844 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr25841, align 8 
  store volatile i64 %emsg18637, i64* %vptr25844, align 8 ; load; *envptr25841
 %vptr25845 = alloca i64, align 8 
  %_957236 = call i64 @prim_car(i64 %rvp10285) 
  store volatile i64 %_957236, i64* %vptr25845, align 8 ; call prim_car
 %vptr25846 = alloca i64, align 8 
  %rvp10281 = call i64 @prim_cdr(i64 %rvp10285) 
  store volatile i64 %rvp10281, i64* %vptr25846, align 8 ; call prim_cdr
 %vptr25847 = alloca i64, align 8 
  %n_6310286 = call i64 @prim_null_63(i64 %rvp10281) 
  store volatile i64 %n_6310286, i64* %vptr25847, align 8 ; call prim_null_63
  %cmpptr25851 = alloca i1, align 8  %cmp25848 = icmp eq i64 %n_6310286, 15 store volatile i1 %cmp25848, i1* %cmpptr25851, align 8; false?
  br i1 %cmp25848, label %else25850, label %then25849                                ; if

then25849:
 %vptr25852 = alloca i64, align 8 
  %h10287 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10287, i64* %vptr25852, align 8 ; call prim_halt
  %vptr25858 = alloca i64*, align 8 
  %cloptr25853 = inttoptr i64 %h10287 to i64* 
  store volatile i64* %cloptr25853, i64** %vptr25858, align 8 ; closure/env cast; i64 -> i64*
  %vptr25859 = alloca i64*, align 8 
  %i0ptr25854 = getelementptr inbounds i64, i64* %cloptr25853, i64 1 
  store volatile i64* %i0ptr25854, i64** %vptr25859, align 8 ; &cloptr25853[1]
 %vptr25860 = alloca i64, align 8 
  %f25856 = load i64, i64* %i0ptr25854, align 8 
  store volatile i64 %f25856, i64* %vptr25860, align 8 ; load; *i0ptr25854
  %fptr25855 = inttoptr i64 %f25856 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25855(i64 %h10287, i64 %h10287)                     ; tail call
  ret void

else25850:
 %vptr25861 = alloca i64, align 8 
  %a7083 = call i64 @prim_car(i64 %rvp10281) 
  store volatile i64 %a7083, i64* %vptr25861, align 8 ; call prim_car
 %vptr25862 = alloca i64, align 8 
  %na10275 = call i64 @prim_cdr(i64 %rvp10281) 
  store volatile i64 %na10275, i64* %vptr25862, align 8 ; call prim_cdr
 %vptr25863 = alloca i64, align 8 
  %n_6310282 = call i64 @prim_null_63(i64 %na10275) 
  store volatile i64 %n_6310282, i64* %vptr25863, align 8 ; call prim_null_63
  %cmpptr25867 = alloca i1, align 8  %cmp25864 = icmp eq i64 %n_6310282, 15 store volatile i1 %cmp25864, i1* %cmpptr25867, align 8; false?
  br i1 %cmp25864, label %else25866, label %then25865                                ; if

then25865:
 %vptr25868 = alloca i64, align 8 
  %rva10280 = add i64 0, 0 
  store volatile i64 %rva10280, i64* %vptr25868, align 8 ; quoted ()
 %vptr25869 = alloca i64, align 8 
  %rva10279 = call i64 @prim_cons(i64 %ZpZ$c, i64 %rva10280) 
  store volatile i64 %rva10279, i64* %vptr25869, align 8 ; call prim_cons
 %vptr25870 = alloca i64, align 8 
  %rva10278 = call i64 @prim_cons(i64 %a7083, i64 %rva10279) 
  store volatile i64 %rva10278, i64* %vptr25870, align 8 ; call prim_cons
 %vptr25871 = alloca i64, align 8 
  %rva10277 = call i64 @prim_cons(i64 %a7074, i64 %rva10278) 
  store volatile i64 %rva10277, i64* %vptr25871, align 8 ; call prim_cons
 %vptr25872 = alloca i64, align 8 
  %rva10276 = call i64 @prim_cons(i64 %cont7229, i64 %rva10277) 
  store volatile i64 %rva10276, i64* %vptr25872, align 8 ; call prim_cons
  %vptr25878 = alloca i64*, align 8 
  %cloptr25873 = inttoptr i64 %a7067 to i64* 
  store volatile i64* %cloptr25873, i64** %vptr25878, align 8 ; closure/env cast; i64 -> i64*
  %vptr25879 = alloca i64*, align 8 
  %i0ptr25874 = getelementptr inbounds i64, i64* %cloptr25873, i64 1 
  store volatile i64* %i0ptr25874, i64** %vptr25879, align 8 ; &cloptr25873[1]
 %vptr25880 = alloca i64, align 8 
  %f25876 = load i64, i64* %i0ptr25874, align 8 
  store volatile i64 %f25876, i64* %vptr25880, align 8 ; load; *i0ptr25874
  %fptr25875 = inttoptr i64 %f25876 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25875(i64 %a7067, i64 %rva10276)                    ; tail call
  ret void

else25866:
 %vptr25881 = alloca i64, align 8 
  %h10283 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10283, i64* %vptr25881, align 8 ; call prim_halt
  %vptr25887 = alloca i64*, align 8 
  %cloptr25882 = inttoptr i64 %h10283 to i64* 
  store volatile i64* %cloptr25882, i64** %vptr25887, align 8 ; closure/env cast; i64 -> i64*
  %vptr25888 = alloca i64*, align 8 
  %i0ptr25883 = getelementptr inbounds i64, i64* %cloptr25882, i64 1 
  store volatile i64* %i0ptr25883, i64** %vptr25888, align 8 ; &cloptr25882[1]
 %vptr25889 = alloca i64, align 8 
  %f25885 = load i64, i64* %i0ptr25883, align 8 
  store volatile i64 %f25885, i64* %vptr25889, align 8 ; load; *i0ptr25883
  %fptr25884 = inttoptr i64 %f25885 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25884(i64 %h10283, i64 %h10283)                     ; tail call
  ret void
}


define void @lam11794(i64 %env11795, i64 %rvp10300) {
 %vptr25892 = alloca i64, align 8 
  %envptr25890 = inttoptr i64 %env11795 to i64* 
  store volatile i64 %cont7229, i64* %vptr25892, align 8 ; closure/env cast; i64 -> i64*
  %vptr25893 = alloca i64*, align 8 
  %envptr25891 = getelementptr inbounds i64, i64* %envptr25890, i64 7 
  store volatile i64* %envptr25891, i64** %vptr25893, align 8 ; &envptr25890[6]
 %vptr25894 = alloca i64, align 8 
  %cont7229 = load i64, i64* %envptr25891, align 8 
  store volatile i64 %cont7229, i64* %vptr25894, align 8 ; load; *envptr25891
 %vptr25897 = alloca i64, align 8 
  %envptr25895 = inttoptr i64 %env11795 to i64* 
  store volatile i64 %a7067, i64* %vptr25897, align 8 ; closure/env cast; i64 -> i64*
  %vptr25898 = alloca i64*, align 8 
  %envptr25896 = getelementptr inbounds i64, i64* %envptr25895, i64 6 
  store volatile i64* %envptr25896, i64** %vptr25898, align 8 ; &envptr25895[5]
 %vptr25899 = alloca i64, align 8 
  %a7067 = load i64, i64* %envptr25896, align 8 
  store volatile i64 %a7067, i64* %vptr25899, align 8 ; load; *envptr25896
 %vptr25902 = alloca i64, align 8 
  %envptr25900 = inttoptr i64 %env11795 to i64* 
  store volatile i64 %emsg08636, i64* %vptr25902, align 8 ; closure/env cast; i64 -> i64*
  %vptr25903 = alloca i64*, align 8 
  %envptr25901 = getelementptr inbounds i64, i64* %envptr25900, i64 5 
  store volatile i64* %envptr25901, i64** %vptr25903, align 8 ; &envptr25900[4]
 %vptr25904 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr25901, align 8 
  store volatile i64 %emsg08636, i64* %vptr25904, align 8 ; load; *envptr25901
 %vptr25907 = alloca i64, align 8 
  %envptr25905 = inttoptr i64 %env11795 to i64* 
  store volatile i64 %a7074, i64* %vptr25907, align 8 ; closure/env cast; i64 -> i64*
  %vptr25908 = alloca i64*, align 8 
  %envptr25906 = getelementptr inbounds i64, i64* %envptr25905, i64 4 
  store volatile i64* %envptr25906, i64** %vptr25908, align 8 ; &envptr25905[3]
 %vptr25909 = alloca i64, align 8 
  %a7074 = load i64, i64* %envptr25906, align 8 
  store volatile i64 %a7074, i64* %vptr25909, align 8 ; load; *envptr25906
 %vptr25912 = alloca i64, align 8 
  %envptr25910 = inttoptr i64 %env11795 to i64* 
  store volatile i64 %ZpZ$c, i64* %vptr25912, align 8 ; closure/env cast; i64 -> i64*
  %vptr25913 = alloca i64*, align 8 
  %envptr25911 = getelementptr inbounds i64, i64* %envptr25910, i64 3 
  store volatile i64* %envptr25911, i64** %vptr25913, align 8 ; &envptr25910[2]
 %vptr25914 = alloca i64, align 8 
  %ZpZ$c = load i64, i64* %envptr25911, align 8 
  store volatile i64 %ZpZ$c, i64* %vptr25914, align 8 ; load; *envptr25911
 %vptr25917 = alloca i64, align 8 
  %envptr25915 = inttoptr i64 %env11795 to i64* 
  store volatile i64 %emsg18637, i64* %vptr25917, align 8 ; closure/env cast; i64 -> i64*
  %vptr25918 = alloca i64*, align 8 
  %envptr25916 = getelementptr inbounds i64, i64* %envptr25915, i64 2 
  store volatile i64* %envptr25916, i64** %vptr25918, align 8 ; &envptr25915[1]
 %vptr25919 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr25916, align 8 
  store volatile i64 %emsg18637, i64* %vptr25919, align 8 ; load; *envptr25916
 %vptr25920 = alloca i64, align 8 
  %_957236 = call i64 @prim_car(i64 %rvp10300) 
  store volatile i64 %_957236, i64* %vptr25920, align 8 ; call prim_car
 %vptr25921 = alloca i64, align 8 
  %rvp10296 = call i64 @prim_cdr(i64 %rvp10300) 
  store volatile i64 %rvp10296, i64* %vptr25921, align 8 ; call prim_cdr
 %vptr25922 = alloca i64, align 8 
  %n_6310301 = call i64 @prim_null_63(i64 %rvp10296) 
  store volatile i64 %n_6310301, i64* %vptr25922, align 8 ; call prim_null_63
  %cmpptr25926 = alloca i1, align 8  %cmp25923 = icmp eq i64 %n_6310301, 15 store volatile i1 %cmp25923, i1* %cmpptr25926, align 8; false?
  br i1 %cmp25923, label %else25925, label %then25924                                ; if

then25924:
 %vptr25927 = alloca i64, align 8 
  %h10302 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10302, i64* %vptr25927, align 8 ; call prim_halt
  %vptr25933 = alloca i64*, align 8 
  %cloptr25928 = inttoptr i64 %h10302 to i64* 
  store volatile i64* %cloptr25928, i64** %vptr25933, align 8 ; closure/env cast; i64 -> i64*
  %vptr25934 = alloca i64*, align 8 
  %i0ptr25929 = getelementptr inbounds i64, i64* %cloptr25928, i64 1 
  store volatile i64* %i0ptr25929, i64** %vptr25934, align 8 ; &cloptr25928[1]
 %vptr25935 = alloca i64, align 8 
  %f25931 = load i64, i64* %i0ptr25929, align 8 
  store volatile i64 %f25931, i64* %vptr25935, align 8 ; load; *i0ptr25929
  %fptr25930 = inttoptr i64 %f25931 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25930(i64 %h10302, i64 %h10302)                     ; tail call
  ret void

else25925:
 %vptr25936 = alloca i64, align 8 
  %a7083 = call i64 @prim_car(i64 %rvp10296) 
  store volatile i64 %a7083, i64* %vptr25936, align 8 ; call prim_car
 %vptr25937 = alloca i64, align 8 
  %na10290 = call i64 @prim_cdr(i64 %rvp10296) 
  store volatile i64 %na10290, i64* %vptr25937, align 8 ; call prim_cdr
 %vptr25938 = alloca i64, align 8 
  %n_6310297 = call i64 @prim_null_63(i64 %na10290) 
  store volatile i64 %n_6310297, i64* %vptr25938, align 8 ; call prim_null_63
  %cmpptr25942 = alloca i1, align 8  %cmp25939 = icmp eq i64 %n_6310297, 15 store volatile i1 %cmp25939, i1* %cmpptr25942, align 8; false?
  br i1 %cmp25939, label %else25941, label %then25940                                ; if

then25940:
 %vptr25943 = alloca i64, align 8 
  %rva10295 = add i64 0, 0 
  store volatile i64 %rva10295, i64* %vptr25943, align 8 ; quoted ()
 %vptr25944 = alloca i64, align 8 
  %rva10294 = call i64 @prim_cons(i64 %ZpZ$c, i64 %rva10295) 
  store volatile i64 %rva10294, i64* %vptr25944, align 8 ; call prim_cons
 %vptr25945 = alloca i64, align 8 
  %rva10293 = call i64 @prim_cons(i64 %a7083, i64 %rva10294) 
  store volatile i64 %rva10293, i64* %vptr25945, align 8 ; call prim_cons
 %vptr25946 = alloca i64, align 8 
  %rva10292 = call i64 @prim_cons(i64 %a7074, i64 %rva10293) 
  store volatile i64 %rva10292, i64* %vptr25946, align 8 ; call prim_cons
 %vptr25947 = alloca i64, align 8 
  %rva10291 = call i64 @prim_cons(i64 %cont7229, i64 %rva10292) 
  store volatile i64 %rva10291, i64* %vptr25947, align 8 ; call prim_cons
  %vptr25953 = alloca i64*, align 8 
  %cloptr25948 = inttoptr i64 %a7067 to i64* 
  store volatile i64* %cloptr25948, i64** %vptr25953, align 8 ; closure/env cast; i64 -> i64*
  %vptr25954 = alloca i64*, align 8 
  %i0ptr25949 = getelementptr inbounds i64, i64* %cloptr25948, i64 1 
  store volatile i64* %i0ptr25949, i64** %vptr25954, align 8 ; &cloptr25948[1]
 %vptr25955 = alloca i64, align 8 
  %f25951 = load i64, i64* %i0ptr25949, align 8 
  store volatile i64 %f25951, i64* %vptr25955, align 8 ; load; *i0ptr25949
  %fptr25950 = inttoptr i64 %f25951 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25950(i64 %a7067, i64 %rva10291)                    ; tail call
  ret void

else25941:
 %vptr25956 = alloca i64, align 8 
  %h10298 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10298, i64* %vptr25956, align 8 ; call prim_halt
  %vptr25962 = alloca i64*, align 8 
  %cloptr25957 = inttoptr i64 %h10298 to i64* 
  store volatile i64* %cloptr25957, i64** %vptr25962, align 8 ; closure/env cast; i64 -> i64*
  %vptr25963 = alloca i64*, align 8 
  %i0ptr25958 = getelementptr inbounds i64, i64* %cloptr25957, i64 1 
  store volatile i64* %i0ptr25958, i64** %vptr25963, align 8 ; &cloptr25957[1]
 %vptr25964 = alloca i64, align 8 
  %f25960 = load i64, i64* %i0ptr25958, align 8 
  store volatile i64 %f25960, i64* %vptr25964, align 8 ; load; *i0ptr25958
  %fptr25959 = inttoptr i64 %f25960 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr25959(i64 %h10298, i64 %h10298)                     ; tail call
  ret void
}


define void @lam11790(i64 %env11791, i64 %rvp10462) {
 %vptr25967 = alloca i64, align 8 
  %envptr25965 = inttoptr i64 %env11791 to i64* 
  store volatile i64 %cont7229, i64* %vptr25967, align 8 ; closure/env cast; i64 -> i64*
  %vptr25968 = alloca i64*, align 8 
  %envptr25966 = getelementptr inbounds i64, i64* %envptr25965, i64 11 
  store volatile i64* %envptr25966, i64** %vptr25968, align 8 ; &envptr25965[10]
 %vptr25969 = alloca i64, align 8 
  %cont7229 = load i64, i64* %envptr25966, align 8 
  store volatile i64 %cont7229, i64* %vptr25969, align 8 ; load; *envptr25966
 %vptr25972 = alloca i64, align 8 
  %envptr25970 = inttoptr i64 %env11791 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr25972, align 8 ; closure/env cast; i64 -> i64*
  %vptr25973 = alloca i64*, align 8 
  %envptr25971 = getelementptr inbounds i64, i64* %envptr25970, i64 10 
  store volatile i64* %envptr25971, i64** %vptr25973, align 8 ; &envptr25970[9]
 %vptr25974 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr25971, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr25974, align 8 ; load; *envptr25971
 %vptr25977 = alloca i64, align 8 
  %envptr25975 = inttoptr i64 %env11791 to i64* 
  store volatile i64 %a7067, i64* %vptr25977, align 8 ; closure/env cast; i64 -> i64*
  %vptr25978 = alloca i64*, align 8 
  %envptr25976 = getelementptr inbounds i64, i64* %envptr25975, i64 9 
  store volatile i64* %envptr25976, i64** %vptr25978, align 8 ; &envptr25975[8]
 %vptr25979 = alloca i64, align 8 
  %a7067 = load i64, i64* %envptr25976, align 8 
  store volatile i64 %a7067, i64* %vptr25979, align 8 ; load; *envptr25976
 %vptr25982 = alloca i64, align 8 
  %envptr25980 = inttoptr i64 %env11791 to i64* 
  store volatile i64 %emsg08636, i64* %vptr25982, align 8 ; closure/env cast; i64 -> i64*
  %vptr25983 = alloca i64*, align 8 
  %envptr25981 = getelementptr inbounds i64, i64* %envptr25980, i64 8 
  store volatile i64* %envptr25981, i64** %vptr25983, align 8 ; &envptr25980[7]
 %vptr25984 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr25981, align 8 
  store volatile i64 %emsg08636, i64* %vptr25984, align 8 ; load; *envptr25981
 %vptr25987 = alloca i64, align 8 
  %envptr25985 = inttoptr i64 %env11791 to i64* 
  store volatile i64 %MXn$x, i64* %vptr25987, align 8 ; closure/env cast; i64 -> i64*
  %vptr25988 = alloca i64*, align 8 
  %envptr25986 = getelementptr inbounds i64, i64* %envptr25985, i64 7 
  store volatile i64* %envptr25986, i64** %vptr25988, align 8 ; &envptr25985[6]
 %vptr25989 = alloca i64, align 8 
  %MXn$x = load i64, i64* %envptr25986, align 8 
  store volatile i64 %MXn$x, i64* %vptr25989, align 8 ; load; *envptr25986
 %vptr25992 = alloca i64, align 8 
  %envptr25990 = inttoptr i64 %env11791 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr25992, align 8 ; closure/env cast; i64 -> i64*
  %vptr25993 = alloca i64*, align 8 
  %envptr25991 = getelementptr inbounds i64, i64* %envptr25990, i64 6 
  store volatile i64* %envptr25991, i64** %vptr25993, align 8 ; &envptr25990[5]
 %vptr25994 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr25991, align 8 
  store volatile i64 %Pll$pred, i64* %vptr25994, align 8 ; load; *envptr25991
 %vptr25997 = alloca i64, align 8 
  %envptr25995 = inttoptr i64 %env11791 to i64* 
  store volatile i64 %ZpZ$c, i64* %vptr25997, align 8 ; closure/env cast; i64 -> i64*
  %vptr25998 = alloca i64*, align 8 
  %envptr25996 = getelementptr inbounds i64, i64* %envptr25995, i64 5 
  store volatile i64* %envptr25996, i64** %vptr25998, align 8 ; &envptr25995[4]
 %vptr25999 = alloca i64, align 8 
  %ZpZ$c = load i64, i64* %envptr25996, align 8 
  store volatile i64 %ZpZ$c, i64* %vptr25999, align 8 ; load; *envptr25996
 %vptr26002 = alloca i64, align 8 
  %envptr26000 = inttoptr i64 %env11791 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr26002, align 8 ; closure/env cast; i64 -> i64*
  %vptr26003 = alloca i64*, align 8 
  %envptr26001 = getelementptr inbounds i64, i64* %envptr26000, i64 4 
  store volatile i64* %envptr26001, i64** %vptr26003, align 8 ; &envptr26000[3]
 %vptr26004 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr26001, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr26004, align 8 ; load; *envptr26001
 %vptr26007 = alloca i64, align 8 
  %envptr26005 = inttoptr i64 %env11791 to i64* 
  store volatile i64 %YxK$fibc, i64* %vptr26007, align 8 ; closure/env cast; i64 -> i64*
  %vptr26008 = alloca i64*, align 8 
  %envptr26006 = getelementptr inbounds i64, i64* %envptr26005, i64 3 
  store volatile i64* %envptr26006, i64** %vptr26008, align 8 ; &envptr26005[2]
 %vptr26009 = alloca i64, align 8 
  %YxK$fibc = load i64, i64* %envptr26006, align 8 
  store volatile i64 %YxK$fibc, i64* %vptr26009, align 8 ; load; *envptr26006
 %vptr26012 = alloca i64, align 8 
  %envptr26010 = inttoptr i64 %env11791 to i64* 
  store volatile i64 %emsg18637, i64* %vptr26012, align 8 ; closure/env cast; i64 -> i64*
  %vptr26013 = alloca i64*, align 8 
  %envptr26011 = getelementptr inbounds i64, i64* %envptr26010, i64 2 
  store volatile i64* %envptr26011, i64** %vptr26013, align 8 ; &envptr26010[1]
 %vptr26014 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr26011, align 8 
  store volatile i64 %emsg18637, i64* %vptr26014, align 8 ; load; *envptr26011
 %vptr26015 = alloca i64, align 8 
  %_957235 = call i64 @prim_car(i64 %rvp10462) 
  store volatile i64 %_957235, i64* %vptr26015, align 8 ; call prim_car
 %vptr26016 = alloca i64, align 8 
  %rvp10458 = call i64 @prim_cdr(i64 %rvp10462) 
  store volatile i64 %rvp10458, i64* %vptr26016, align 8 ; call prim_cdr
 %vptr26017 = alloca i64, align 8 
  %n_6310463 = call i64 @prim_null_63(i64 %rvp10458) 
  store volatile i64 %n_6310463, i64* %vptr26017, align 8 ; call prim_null_63
  %cmpptr26021 = alloca i1, align 8  %cmp26018 = icmp eq i64 %n_6310463, 15 store volatile i1 %cmp26018, i1* %cmpptr26021, align 8; false?
  br i1 %cmp26018, label %else26020, label %then26019                                ; if

then26019:
 %vptr26022 = alloca i64, align 8 
  %h10464 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10464, i64* %vptr26022, align 8 ; call prim_halt
  %vptr26028 = alloca i64*, align 8 
  %cloptr26023 = inttoptr i64 %h10464 to i64* 
  store volatile i64* %cloptr26023, i64** %vptr26028, align 8 ; closure/env cast; i64 -> i64*
  %vptr26029 = alloca i64*, align 8 
  %i0ptr26024 = getelementptr inbounds i64, i64* %cloptr26023, i64 1 
  store volatile i64* %i0ptr26024, i64** %vptr26029, align 8 ; &cloptr26023[1]
 %vptr26030 = alloca i64, align 8 
  %f26026 = load i64, i64* %i0ptr26024, align 8 
  store volatile i64 %f26026, i64* %vptr26030, align 8 ; load; *i0ptr26024
  %fptr26025 = inttoptr i64 %f26026 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26025(i64 %h10464, i64 %h10464)                     ; tail call
  ret void

else26020:
 %vptr26031 = alloca i64, align 8 
  %a7074 = call i64 @prim_car(i64 %rvp10458) 
  store volatile i64 %a7074, i64* %vptr26031, align 8 ; call prim_car
 %vptr26032 = alloca i64, align 8 
  %na10316 = call i64 @prim_cdr(i64 %rvp10458) 
  store volatile i64 %na10316, i64* %vptr26032, align 8 ; call prim_cdr
 %vptr26033 = alloca i64, align 8 
  %n_6310459 = call i64 @prim_null_63(i64 %na10316) 
  store volatile i64 %n_6310459, i64* %vptr26033, align 8 ; call prim_null_63
  %cmpptr26037 = alloca i1, align 8  %cmp26034 = icmp eq i64 %n_6310459, 15 store volatile i1 %cmp26034, i1* %cmpptr26037, align 8; false?
  br i1 %cmp26034, label %else26036, label %then26035                                ; if

then26035:
  %vptr26048 = alloca i64*, align 8 
  %cloptr26038 = call i64* @make_closure(i64 64) 
  store volatile i64* %cloptr26038, i64** %vptr26048, align 8 ; malloc
  %vptr26049 = alloca i64*, align 8 
  %eptr26040 = getelementptr inbounds i64, i64* %cloptr26038, i64 2 
  store volatile i64* %eptr26040, i64** %vptr26049, align 8 ; &eptr26040[1]
  %vptr26050 = alloca i64*, align 8 
  %eptr26041 = getelementptr inbounds i64, i64* %cloptr26038, i64 3 
  store volatile i64* %eptr26041, i64** %vptr26050, align 8 ; &eptr26041[2]
  %vptr26051 = alloca i64*, align 8 
  %eptr26042 = getelementptr inbounds i64, i64* %cloptr26038, i64 4 
  store volatile i64* %eptr26042, i64** %vptr26051, align 8 ; &eptr26042[3]
  %vptr26052 = alloca i64*, align 8 
  %eptr26043 = getelementptr inbounds i64, i64* %cloptr26038, i64 5 
  store volatile i64* %eptr26043, i64** %vptr26052, align 8 ; &eptr26043[4]
  %vptr26053 = alloca i64*, align 8 
  %eptr26044 = getelementptr inbounds i64, i64* %cloptr26038, i64 6 
  store volatile i64* %eptr26044, i64** %vptr26053, align 8 ; &eptr26044[5]
  %vptr26054 = alloca i64*, align 8 
  %eptr26045 = getelementptr inbounds i64, i64* %cloptr26038, i64 7 
  store volatile i64* %eptr26045, i64** %vptr26054, align 8 ; &eptr26045[6]
  %vptr26055 = alloca i64*, align 8 
  %eptr26046 = getelementptr inbounds i64, i64* %cloptr26038, i64 8 
  store volatile i64* %eptr26046, i64** %vptr26055, align 8 ; &eptr26046[7]
  store i64 %emsg18637, i64* %eptr26040                                              ; *eptr26040 = %emsg18637
  store i64 %YxK$fibc, i64* %eptr26041                                               ; *eptr26041 = %YxK$fibc
  store i64 %SdC$_37wind_45stack, i64* %eptr26042                                    ; *eptr26042 = %SdC$_37wind_45stack
  store i64 %Pll$pred, i64* %eptr26043                                               ; *eptr26043 = %Pll$pred
  store i64 %MXn$x, i64* %eptr26044                                                  ; *eptr26044 = %MXn$x
  store i64 %emsg08636, i64* %eptr26045                                              ; *eptr26045 = %emsg08636
  store i64 %U8g$_37do_45wind, i64* %eptr26046                                       ; *eptr26046 = %U8g$_37do_45wind
  %vptr26056 = alloca i64*, align 8 
  %eptr26039 = getelementptr inbounds i64, i64* %cloptr26038, i64 1 
  store volatile i64* %eptr26039, i64** %vptr26056, align 8 ; &cloptr26038[1]
 %vptr26057 = alloca i64, align 8 
  %f26047 = ptrtoint void(i64,i64)* @lam11788 to i64 
  store volatile i64 %f26047, i64* %vptr26057, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f26047, i64* %eptr26039                                                 ; store fptr
 %vptr26058 = alloca i64, align 8 
  %arg8297 = ptrtoint i64* %cloptr26038 to i64 
  store volatile i64 %arg8297, i64* %vptr26058, align 8 ; closure cast; i64* -> i64
  %vptr26068 = alloca i64*, align 8 
  %cloptr26059 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr26059, i64** %vptr26068, align 8 ; malloc
  %vptr26069 = alloca i64*, align 8 
  %eptr26061 = getelementptr inbounds i64, i64* %cloptr26059, i64 2 
  store volatile i64* %eptr26061, i64** %vptr26069, align 8 ; &eptr26061[1]
  %vptr26070 = alloca i64*, align 8 
  %eptr26062 = getelementptr inbounds i64, i64* %cloptr26059, i64 3 
  store volatile i64* %eptr26062, i64** %vptr26070, align 8 ; &eptr26062[2]
  %vptr26071 = alloca i64*, align 8 
  %eptr26063 = getelementptr inbounds i64, i64* %cloptr26059, i64 4 
  store volatile i64* %eptr26063, i64** %vptr26071, align 8 ; &eptr26063[3]
  %vptr26072 = alloca i64*, align 8 
  %eptr26064 = getelementptr inbounds i64, i64* %cloptr26059, i64 5 
  store volatile i64* %eptr26064, i64** %vptr26072, align 8 ; &eptr26064[4]
  %vptr26073 = alloca i64*, align 8 
  %eptr26065 = getelementptr inbounds i64, i64* %cloptr26059, i64 6 
  store volatile i64* %eptr26065, i64** %vptr26073, align 8 ; &eptr26065[5]
  %vptr26074 = alloca i64*, align 8 
  %eptr26066 = getelementptr inbounds i64, i64* %cloptr26059, i64 7 
  store volatile i64* %eptr26066, i64** %vptr26074, align 8 ; &eptr26066[6]
  store i64 %emsg18637, i64* %eptr26061                                              ; *eptr26061 = %emsg18637
  store i64 %ZpZ$c, i64* %eptr26062                                                  ; *eptr26062 = %ZpZ$c
  store i64 %a7074, i64* %eptr26063                                                  ; *eptr26063 = %a7074
  store i64 %emsg08636, i64* %eptr26064                                              ; *eptr26064 = %emsg08636
  store i64 %a7067, i64* %eptr26065                                                  ; *eptr26065 = %a7067
  store i64 %cont7229, i64* %eptr26066                                               ; *eptr26066 = %cont7229
  %vptr26075 = alloca i64*, align 8 
  %eptr26060 = getelementptr inbounds i64, i64* %cloptr26059, i64 1 
  store volatile i64* %eptr26060, i64** %vptr26075, align 8 ; &cloptr26059[1]
 %vptr26076 = alloca i64, align 8 
  %f26067 = ptrtoint void(i64,i64)* @lam11756 to i64 
  store volatile i64 %f26067, i64* %vptr26076, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f26067, i64* %eptr26060                                                 ; store fptr
 %vptr26077 = alloca i64, align 8 
  %arg8296 = ptrtoint i64* %cloptr26059 to i64 
  store volatile i64 %arg8296, i64* %vptr26077, align 8 ; closure cast; i64* -> i64
  %vptr26087 = alloca i64*, align 8 
  %cloptr26078 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr26078, i64** %vptr26087, align 8 ; malloc
  %vptr26088 = alloca i64*, align 8 
  %eptr26080 = getelementptr inbounds i64, i64* %cloptr26078, i64 2 
  store volatile i64* %eptr26080, i64** %vptr26088, align 8 ; &eptr26080[1]
  %vptr26089 = alloca i64*, align 8 
  %eptr26081 = getelementptr inbounds i64, i64* %cloptr26078, i64 3 
  store volatile i64* %eptr26081, i64** %vptr26089, align 8 ; &eptr26081[2]
  %vptr26090 = alloca i64*, align 8 
  %eptr26082 = getelementptr inbounds i64, i64* %cloptr26078, i64 4 
  store volatile i64* %eptr26082, i64** %vptr26090, align 8 ; &eptr26082[3]
  %vptr26091 = alloca i64*, align 8 
  %eptr26083 = getelementptr inbounds i64, i64* %cloptr26078, i64 5 
  store volatile i64* %eptr26083, i64** %vptr26091, align 8 ; &eptr26083[4]
  %vptr26092 = alloca i64*, align 8 
  %eptr26084 = getelementptr inbounds i64, i64* %cloptr26078, i64 6 
  store volatile i64* %eptr26084, i64** %vptr26092, align 8 ; &eptr26084[5]
  %vptr26093 = alloca i64*, align 8 
  %eptr26085 = getelementptr inbounds i64, i64* %cloptr26078, i64 7 
  store volatile i64* %eptr26085, i64** %vptr26093, align 8 ; &eptr26085[6]
  store i64 %emsg18637, i64* %eptr26080                                              ; *eptr26080 = %emsg18637
  store i64 %ZpZ$c, i64* %eptr26081                                                  ; *eptr26081 = %ZpZ$c
  store i64 %a7074, i64* %eptr26082                                                  ; *eptr26082 = %a7074
  store i64 %emsg08636, i64* %eptr26083                                              ; *eptr26083 = %emsg08636
  store i64 %a7067, i64* %eptr26084                                                  ; *eptr26084 = %a7067
  store i64 %cont7229, i64* %eptr26085                                               ; *eptr26085 = %cont7229
  %vptr26094 = alloca i64*, align 8 
  %eptr26079 = getelementptr inbounds i64, i64* %cloptr26078, i64 1 
  store volatile i64* %eptr26079, i64** %vptr26094, align 8 ; &cloptr26078[1]
 %vptr26095 = alloca i64, align 8 
  %f26086 = ptrtoint void(i64,i64)* @lam11753 to i64 
  store volatile i64 %f26086, i64* %vptr26095, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f26086, i64* %eptr26079                                                 ; store fptr
 %vptr26096 = alloca i64, align 8 
  %arg8295 = ptrtoint i64* %cloptr26078 to i64 
  store volatile i64 %arg8295, i64* %vptr26096, align 8 ; closure cast; i64* -> i64
 %vptr26097 = alloca i64, align 8 
  %rva10457 = add i64 0, 0 
  store volatile i64 %rva10457, i64* %vptr26097, align 8 ; quoted ()
 %vptr26098 = alloca i64, align 8 
  %rva10456 = call i64 @prim_cons(i64 %arg8295, i64 %rva10457) 
  store volatile i64 %rva10456, i64* %vptr26098, align 8 ; call prim_cons
 %vptr26099 = alloca i64, align 8 
  %rva10455 = call i64 @prim_cons(i64 %arg8296, i64 %rva10456) 
  store volatile i64 %rva10455, i64* %vptr26099, align 8 ; call prim_cons
  %vptr26105 = alloca i64*, align 8 
  %cloptr26100 = inttoptr i64 %arg8297 to i64* 
  store volatile i64* %cloptr26100, i64** %vptr26105, align 8 ; closure/env cast; i64 -> i64*
  %vptr26106 = alloca i64*, align 8 
  %i0ptr26101 = getelementptr inbounds i64, i64* %cloptr26100, i64 1 
  store volatile i64* %i0ptr26101, i64** %vptr26106, align 8 ; &cloptr26100[1]
 %vptr26107 = alloca i64, align 8 
  %f26103 = load i64, i64* %i0ptr26101, align 8 
  store volatile i64 %f26103, i64* %vptr26107, align 8 ; load; *i0ptr26101
  %fptr26102 = inttoptr i64 %f26103 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26102(i64 %arg8297, i64 %rva10455)                  ; tail call
  ret void

else26036:
 %vptr26108 = alloca i64, align 8 
  %h10460 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10460, i64* %vptr26108, align 8 ; call prim_halt
  %vptr26114 = alloca i64*, align 8 
  %cloptr26109 = inttoptr i64 %h10460 to i64* 
  store volatile i64* %cloptr26109, i64** %vptr26114, align 8 ; closure/env cast; i64 -> i64*
  %vptr26115 = alloca i64*, align 8 
  %i0ptr26110 = getelementptr inbounds i64, i64* %cloptr26109, i64 1 
  store volatile i64* %i0ptr26110, i64** %vptr26115, align 8 ; &cloptr26109[1]
 %vptr26116 = alloca i64, align 8 
  %f26112 = load i64, i64* %i0ptr26110, align 8 
  store volatile i64 %f26112, i64* %vptr26116, align 8 ; load; *i0ptr26110
  %fptr26111 = inttoptr i64 %f26112 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26111(i64 %h10460, i64 %h10460)                     ; tail call
  ret void
}


define void @lam11788(i64 %env11789, i64 %rvp10421) {
 %vptr26119 = alloca i64, align 8 
  %envptr26117 = inttoptr i64 %env11789 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr26119, align 8 ; closure/env cast; i64 -> i64*
  %vptr26120 = alloca i64*, align 8 
  %envptr26118 = getelementptr inbounds i64, i64* %envptr26117, i64 8 
  store volatile i64* %envptr26118, i64** %vptr26120, align 8 ; &envptr26117[7]
 %vptr26121 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr26118, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr26121, align 8 ; load; *envptr26118
 %vptr26124 = alloca i64, align 8 
  %envptr26122 = inttoptr i64 %env11789 to i64* 
  store volatile i64 %emsg08636, i64* %vptr26124, align 8 ; closure/env cast; i64 -> i64*
  %vptr26125 = alloca i64*, align 8 
  %envptr26123 = getelementptr inbounds i64, i64* %envptr26122, i64 7 
  store volatile i64* %envptr26123, i64** %vptr26125, align 8 ; &envptr26122[6]
 %vptr26126 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr26123, align 8 
  store volatile i64 %emsg08636, i64* %vptr26126, align 8 ; load; *envptr26123
 %vptr26129 = alloca i64, align 8 
  %envptr26127 = inttoptr i64 %env11789 to i64* 
  store volatile i64 %MXn$x, i64* %vptr26129, align 8 ; closure/env cast; i64 -> i64*
  %vptr26130 = alloca i64*, align 8 
  %envptr26128 = getelementptr inbounds i64, i64* %envptr26127, i64 6 
  store volatile i64* %envptr26128, i64** %vptr26130, align 8 ; &envptr26127[5]
 %vptr26131 = alloca i64, align 8 
  %MXn$x = load i64, i64* %envptr26128, align 8 
  store volatile i64 %MXn$x, i64* %vptr26131, align 8 ; load; *envptr26128
 %vptr26134 = alloca i64, align 8 
  %envptr26132 = inttoptr i64 %env11789 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr26134, align 8 ; closure/env cast; i64 -> i64*
  %vptr26135 = alloca i64*, align 8 
  %envptr26133 = getelementptr inbounds i64, i64* %envptr26132, i64 5 
  store volatile i64* %envptr26133, i64** %vptr26135, align 8 ; &envptr26132[4]
 %vptr26136 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr26133, align 8 
  store volatile i64 %Pll$pred, i64* %vptr26136, align 8 ; load; *envptr26133
 %vptr26139 = alloca i64, align 8 
  %envptr26137 = inttoptr i64 %env11789 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr26139, align 8 ; closure/env cast; i64 -> i64*
  %vptr26140 = alloca i64*, align 8 
  %envptr26138 = getelementptr inbounds i64, i64* %envptr26137, i64 4 
  store volatile i64* %envptr26138, i64** %vptr26140, align 8 ; &envptr26137[3]
 %vptr26141 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr26138, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr26141, align 8 ; load; *envptr26138
 %vptr26144 = alloca i64, align 8 
  %envptr26142 = inttoptr i64 %env11789 to i64* 
  store volatile i64 %YxK$fibc, i64* %vptr26144, align 8 ; closure/env cast; i64 -> i64*
  %vptr26145 = alloca i64*, align 8 
  %envptr26143 = getelementptr inbounds i64, i64* %envptr26142, i64 3 
  store volatile i64* %envptr26143, i64** %vptr26145, align 8 ; &envptr26142[2]
 %vptr26146 = alloca i64, align 8 
  %YxK$fibc = load i64, i64* %envptr26143, align 8 
  store volatile i64 %YxK$fibc, i64* %vptr26146, align 8 ; load; *envptr26143
 %vptr26149 = alloca i64, align 8 
  %envptr26147 = inttoptr i64 %env11789 to i64* 
  store volatile i64 %emsg18637, i64* %vptr26149, align 8 ; closure/env cast; i64 -> i64*
  %vptr26150 = alloca i64*, align 8 
  %envptr26148 = getelementptr inbounds i64, i64* %envptr26147, i64 2 
  store volatile i64* %envptr26148, i64** %vptr26150, align 8 ; &envptr26147[1]
 %vptr26151 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr26148, align 8 
  store volatile i64 %emsg18637, i64* %vptr26151, align 8 ; load; *envptr26148
 %vptr26152 = alloca i64, align 8 
  %cont7237 = call i64 @prim_car(i64 %rvp10421) 
  store volatile i64 %cont7237, i64* %vptr26152, align 8 ; call prim_car
 %vptr26153 = alloca i64, align 8 
  %rvp10417 = call i64 @prim_cdr(i64 %rvp10421) 
  store volatile i64 %rvp10417, i64* %vptr26153, align 8 ; call prim_cdr
 %vptr26154 = alloca i64, align 8 
  %n_6310422 = call i64 @prim_null_63(i64 %rvp10417) 
  store volatile i64 %n_6310422, i64* %vptr26154, align 8 ; call prim_null_63
  %cmpptr26158 = alloca i1, align 8  %cmp26155 = icmp eq i64 %n_6310422, 15 store volatile i1 %cmp26155, i1* %cmpptr26158, align 8; false?
  br i1 %cmp26155, label %else26157, label %then26156                                ; if

then26156:
 %vptr26159 = alloca i64, align 8 
  %h10423 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10423, i64* %vptr26159, align 8 ; call prim_halt
  %vptr26165 = alloca i64*, align 8 
  %cloptr26160 = inttoptr i64 %h10423 to i64* 
  store volatile i64* %cloptr26160, i64** %vptr26165, align 8 ; closure/env cast; i64 -> i64*
  %vptr26166 = alloca i64*, align 8 
  %i0ptr26161 = getelementptr inbounds i64, i64* %cloptr26160, i64 1 
  store volatile i64* %i0ptr26161, i64** %vptr26166, align 8 ; &cloptr26160[1]
 %vptr26167 = alloca i64, align 8 
  %f26163 = load i64, i64* %i0ptr26161, align 8 
  store volatile i64 %f26163, i64* %vptr26167, align 8 ; load; *i0ptr26161
  %fptr26162 = inttoptr i64 %f26163 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26162(i64 %h10423, i64 %h10423)                     ; tail call
  ret void

else26157:
 %vptr26168 = alloca i64, align 8 
  %njK$_37k = call i64 @prim_car(i64 %rvp10417) 
  store volatile i64 %njK$_37k, i64* %vptr26168, align 8 ; call prim_car
 %vptr26169 = alloca i64, align 8 
  %na10318 = call i64 @prim_cdr(i64 %rvp10417) 
  store volatile i64 %na10318, i64* %vptr26169, align 8 ; call prim_cdr
 %vptr26170 = alloca i64, align 8 
  %n_6310418 = call i64 @prim_null_63(i64 %na10318) 
  store volatile i64 %n_6310418, i64* %vptr26170, align 8 ; call prim_null_63
  %cmpptr26174 = alloca i1, align 8  %cmp26171 = icmp eq i64 %n_6310418, 15 store volatile i1 %cmp26171, i1* %cmpptr26174, align 8; false?
  br i1 %cmp26171, label %else26173, label %then26172                                ; if

then26172:
 %vptr26175 = alloca i64, align 8 
  %arg8298 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8298, i64* %vptr26175, align 8 ; quoted int
 %vptr26176 = alloca i64, align 8 
  %SiZ$_37saved_45stack = call i64 @prim_vector_45ref(i64 %SdC$_37wind_45stack, i64 %arg8298) 
  store volatile i64 %SiZ$_37saved_45stack, i64* %vptr26176, align 8 ; call prim_vector_45ref
  %vptr26186 = alloca i64*, align 8 
  %cloptr26177 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr26177, i64** %vptr26186, align 8 ; malloc
  %vptr26187 = alloca i64*, align 8 
  %eptr26179 = getelementptr inbounds i64, i64* %cloptr26177, i64 2 
  store volatile i64* %eptr26179, i64** %vptr26187, align 8 ; &eptr26179[1]
  %vptr26188 = alloca i64*, align 8 
  %eptr26180 = getelementptr inbounds i64, i64* %cloptr26177, i64 3 
  store volatile i64* %eptr26180, i64** %vptr26188, align 8 ; &eptr26180[2]
  %vptr26189 = alloca i64*, align 8 
  %eptr26181 = getelementptr inbounds i64, i64* %cloptr26177, i64 4 
  store volatile i64* %eptr26181, i64** %vptr26189, align 8 ; &eptr26181[3]
  %vptr26190 = alloca i64*, align 8 
  %eptr26182 = getelementptr inbounds i64, i64* %cloptr26177, i64 5 
  store volatile i64* %eptr26182, i64** %vptr26190, align 8 ; &eptr26182[4]
  %vptr26191 = alloca i64*, align 8 
  %eptr26183 = getelementptr inbounds i64, i64* %cloptr26177, i64 6 
  store volatile i64* %eptr26183, i64** %vptr26191, align 8 ; &eptr26183[5]
  %vptr26192 = alloca i64*, align 8 
  %eptr26184 = getelementptr inbounds i64, i64* %cloptr26177, i64 7 
  store volatile i64* %eptr26184, i64** %vptr26192, align 8 ; &eptr26184[6]
  store i64 %emsg18637, i64* %eptr26179                                              ; *eptr26179 = %emsg18637
  store i64 %cont7237, i64* %eptr26180                                               ; *eptr26180 = %cont7237
  store i64 %YxK$fibc, i64* %eptr26181                                               ; *eptr26181 = %YxK$fibc
  store i64 %Pll$pred, i64* %eptr26182                                               ; *eptr26182 = %Pll$pred
  store i64 %MXn$x, i64* %eptr26183                                                  ; *eptr26183 = %MXn$x
  store i64 %emsg08636, i64* %eptr26184                                              ; *eptr26184 = %emsg08636
  %vptr26193 = alloca i64*, align 8 
  %eptr26178 = getelementptr inbounds i64, i64* %cloptr26177, i64 1 
  store volatile i64* %eptr26178, i64** %vptr26193, align 8 ; &cloptr26177[1]
 %vptr26194 = alloca i64, align 8 
  %f26185 = ptrtoint void(i64,i64)* @lam11785 to i64 
  store volatile i64 %f26185, i64* %vptr26194, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f26185, i64* %eptr26178                                                 ; store fptr
 %vptr26195 = alloca i64, align 8 
  %arg8302 = ptrtoint i64* %cloptr26177 to i64 
  store volatile i64 %arg8302, i64* %vptr26195, align 8 ; closure cast; i64* -> i64
 %vptr26196 = alloca i64, align 8 
  %arg8301 = add i64 0, 0 
  store volatile i64 %arg8301, i64* %vptr26196, align 8 ; quoted ()
  %vptr26206 = alloca i64*, align 8 
  %cloptr26197 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr26197, i64** %vptr26206, align 8 ; malloc
  %vptr26207 = alloca i64*, align 8 
  %eptr26199 = getelementptr inbounds i64, i64* %cloptr26197, i64 2 
  store volatile i64* %eptr26199, i64** %vptr26207, align 8 ; &eptr26199[1]
  %vptr26208 = alloca i64*, align 8 
  %eptr26200 = getelementptr inbounds i64, i64* %cloptr26197, i64 3 
  store volatile i64* %eptr26200, i64** %vptr26208, align 8 ; &eptr26200[2]
  %vptr26209 = alloca i64*, align 8 
  %eptr26201 = getelementptr inbounds i64, i64* %cloptr26197, i64 4 
  store volatile i64* %eptr26201, i64** %vptr26209, align 8 ; &eptr26201[3]
  %vptr26210 = alloca i64*, align 8 
  %eptr26202 = getelementptr inbounds i64, i64* %cloptr26197, i64 5 
  store volatile i64* %eptr26202, i64** %vptr26210, align 8 ; &eptr26202[4]
  %vptr26211 = alloca i64*, align 8 
  %eptr26203 = getelementptr inbounds i64, i64* %cloptr26197, i64 6 
  store volatile i64* %eptr26203, i64** %vptr26211, align 8 ; &eptr26203[5]
  %vptr26212 = alloca i64*, align 8 
  %eptr26204 = getelementptr inbounds i64, i64* %cloptr26197, i64 7 
  store volatile i64* %eptr26204, i64** %vptr26212, align 8 ; &eptr26204[6]
  store i64 %SiZ$_37saved_45stack, i64* %eptr26199                                   ; *eptr26199 = %SiZ$_37saved_45stack
  store i64 %emsg18637, i64* %eptr26200                                              ; *eptr26200 = %emsg18637
  store i64 %SdC$_37wind_45stack, i64* %eptr26201                                    ; *eptr26201 = %SdC$_37wind_45stack
  store i64 %njK$_37k, i64* %eptr26202                                               ; *eptr26202 = %njK$_37k
  store i64 %emsg08636, i64* %eptr26203                                              ; *eptr26203 = %emsg08636
  store i64 %U8g$_37do_45wind, i64* %eptr26204                                       ; *eptr26204 = %U8g$_37do_45wind
  %vptr26213 = alloca i64*, align 8 
  %eptr26198 = getelementptr inbounds i64, i64* %cloptr26197, i64 1 
  store volatile i64* %eptr26198, i64** %vptr26213, align 8 ; &cloptr26197[1]
 %vptr26214 = alloca i64, align 8 
  %f26205 = ptrtoint void(i64,i64)* @lam11769 to i64 
  store volatile i64 %f26205, i64* %vptr26214, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f26205, i64* %eptr26198                                                 ; store fptr
 %vptr26215 = alloca i64, align 8 
  %arg8300 = ptrtoint i64* %cloptr26197 to i64 
  store volatile i64 %arg8300, i64* %vptr26215, align 8 ; closure cast; i64* -> i64
 %vptr26216 = alloca i64, align 8 
  %rva10416 = add i64 0, 0 
  store volatile i64 %rva10416, i64* %vptr26216, align 8 ; quoted ()
 %vptr26217 = alloca i64, align 8 
  %rva10415 = call i64 @prim_cons(i64 %arg8300, i64 %rva10416) 
  store volatile i64 %rva10415, i64* %vptr26217, align 8 ; call prim_cons
 %vptr26218 = alloca i64, align 8 
  %rva10414 = call i64 @prim_cons(i64 %arg8301, i64 %rva10415) 
  store volatile i64 %rva10414, i64* %vptr26218, align 8 ; call prim_cons
  %vptr26224 = alloca i64*, align 8 
  %cloptr26219 = inttoptr i64 %arg8302 to i64* 
  store volatile i64* %cloptr26219, i64** %vptr26224, align 8 ; closure/env cast; i64 -> i64*
  %vptr26225 = alloca i64*, align 8 
  %i0ptr26220 = getelementptr inbounds i64, i64* %cloptr26219, i64 1 
  store volatile i64* %i0ptr26220, i64** %vptr26225, align 8 ; &cloptr26219[1]
 %vptr26226 = alloca i64, align 8 
  %f26222 = load i64, i64* %i0ptr26220, align 8 
  store volatile i64 %f26222, i64* %vptr26226, align 8 ; load; *i0ptr26220
  %fptr26221 = inttoptr i64 %f26222 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26221(i64 %arg8302, i64 %rva10414)                  ; tail call
  ret void

else26173:
 %vptr26227 = alloca i64, align 8 
  %h10419 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10419, i64* %vptr26227, align 8 ; call prim_halt
  %vptr26233 = alloca i64*, align 8 
  %cloptr26228 = inttoptr i64 %h10419 to i64* 
  store volatile i64* %cloptr26228, i64** %vptr26233, align 8 ; closure/env cast; i64 -> i64*
  %vptr26234 = alloca i64*, align 8 
  %i0ptr26229 = getelementptr inbounds i64, i64* %cloptr26228, i64 1 
  store volatile i64* %i0ptr26229, i64** %vptr26234, align 8 ; &cloptr26228[1]
 %vptr26235 = alloca i64, align 8 
  %f26231 = load i64, i64* %i0ptr26229, align 8 
  store volatile i64 %f26231, i64* %vptr26235, align 8 ; load; *i0ptr26229
  %fptr26230 = inttoptr i64 %f26231 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26230(i64 %h10419, i64 %h10419)                     ; tail call
  ret void
}


define void @lam11785(i64 %env11786, i64 %rvp10368) {
 %vptr26238 = alloca i64, align 8 
  %envptr26236 = inttoptr i64 %env11786 to i64* 
  store volatile i64 %emsg08636, i64* %vptr26238, align 8 ; closure/env cast; i64 -> i64*
  %vptr26239 = alloca i64*, align 8 
  %envptr26237 = getelementptr inbounds i64, i64* %envptr26236, i64 7 
  store volatile i64* %envptr26237, i64** %vptr26239, align 8 ; &envptr26236[6]
 %vptr26240 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr26237, align 8 
  store volatile i64 %emsg08636, i64* %vptr26240, align 8 ; load; *envptr26237
 %vptr26243 = alloca i64, align 8 
  %envptr26241 = inttoptr i64 %env11786 to i64* 
  store volatile i64 %MXn$x, i64* %vptr26243, align 8 ; closure/env cast; i64 -> i64*
  %vptr26244 = alloca i64*, align 8 
  %envptr26242 = getelementptr inbounds i64, i64* %envptr26241, i64 6 
  store volatile i64* %envptr26242, i64** %vptr26244, align 8 ; &envptr26241[5]
 %vptr26245 = alloca i64, align 8 
  %MXn$x = load i64, i64* %envptr26242, align 8 
  store volatile i64 %MXn$x, i64* %vptr26245, align 8 ; load; *envptr26242
 %vptr26248 = alloca i64, align 8 
  %envptr26246 = inttoptr i64 %env11786 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr26248, align 8 ; closure/env cast; i64 -> i64*
  %vptr26249 = alloca i64*, align 8 
  %envptr26247 = getelementptr inbounds i64, i64* %envptr26246, i64 5 
  store volatile i64* %envptr26247, i64** %vptr26249, align 8 ; &envptr26246[4]
 %vptr26250 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr26247, align 8 
  store volatile i64 %Pll$pred, i64* %vptr26250, align 8 ; load; *envptr26247
 %vptr26253 = alloca i64, align 8 
  %envptr26251 = inttoptr i64 %env11786 to i64* 
  store volatile i64 %YxK$fibc, i64* %vptr26253, align 8 ; closure/env cast; i64 -> i64*
  %vptr26254 = alloca i64*, align 8 
  %envptr26252 = getelementptr inbounds i64, i64* %envptr26251, i64 4 
  store volatile i64* %envptr26252, i64** %vptr26254, align 8 ; &envptr26251[3]
 %vptr26255 = alloca i64, align 8 
  %YxK$fibc = load i64, i64* %envptr26252, align 8 
  store volatile i64 %YxK$fibc, i64* %vptr26255, align 8 ; load; *envptr26252
 %vptr26258 = alloca i64, align 8 
  %envptr26256 = inttoptr i64 %env11786 to i64* 
  store volatile i64 %cont7237, i64* %vptr26258, align 8 ; closure/env cast; i64 -> i64*
  %vptr26259 = alloca i64*, align 8 
  %envptr26257 = getelementptr inbounds i64, i64* %envptr26256, i64 3 
  store volatile i64* %envptr26257, i64** %vptr26259, align 8 ; &envptr26256[2]
 %vptr26260 = alloca i64, align 8 
  %cont7237 = load i64, i64* %envptr26257, align 8 
  store volatile i64 %cont7237, i64* %vptr26260, align 8 ; load; *envptr26257
 %vptr26263 = alloca i64, align 8 
  %envptr26261 = inttoptr i64 %env11786 to i64* 
  store volatile i64 %emsg18637, i64* %vptr26263, align 8 ; closure/env cast; i64 -> i64*
  %vptr26264 = alloca i64*, align 8 
  %envptr26262 = getelementptr inbounds i64, i64* %envptr26261, i64 2 
  store volatile i64* %envptr26262, i64** %vptr26264, align 8 ; &envptr26261[1]
 %vptr26265 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr26262, align 8 
  store volatile i64 %emsg18637, i64* %vptr26265, align 8 ; load; *envptr26262
 %vptr26266 = alloca i64, align 8 
  %_957238 = call i64 @prim_car(i64 %rvp10368) 
  store volatile i64 %_957238, i64* %vptr26266, align 8 ; call prim_car
 %vptr26267 = alloca i64, align 8 
  %rvp10364 = call i64 @prim_cdr(i64 %rvp10368) 
  store volatile i64 %rvp10364, i64* %vptr26267, align 8 ; call prim_cdr
 %vptr26268 = alloca i64, align 8 
  %n_6310369 = call i64 @prim_null_63(i64 %rvp10364) 
  store volatile i64 %n_6310369, i64* %vptr26268, align 8 ; call prim_null_63
  %cmpptr26272 = alloca i1, align 8  %cmp26269 = icmp eq i64 %n_6310369, 15 store volatile i1 %cmp26269, i1* %cmpptr26272, align 8; false?
  br i1 %cmp26269, label %else26271, label %then26270                                ; if

then26270:
 %vptr26273 = alloca i64, align 8 
  %h10370 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10370, i64* %vptr26273, align 8 ; call prim_halt
  %vptr26279 = alloca i64*, align 8 
  %cloptr26274 = inttoptr i64 %h10370 to i64* 
  store volatile i64* %cloptr26274, i64** %vptr26279, align 8 ; closure/env cast; i64 -> i64*
  %vptr26280 = alloca i64*, align 8 
  %i0ptr26275 = getelementptr inbounds i64, i64* %cloptr26274, i64 1 
  store volatile i64* %i0ptr26275, i64** %vptr26280, align 8 ; &cloptr26274[1]
 %vptr26281 = alloca i64, align 8 
  %f26277 = load i64, i64* %i0ptr26275, align 8 
  store volatile i64 %f26277, i64* %vptr26281, align 8 ; load; *i0ptr26275
  %fptr26276 = inttoptr i64 %f26277 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26276(i64 %h10370, i64 %h10370)                     ; tail call
  ret void

else26271:
 %vptr26282 = alloca i64, align 8 
  %a7082 = call i64 @prim_car(i64 %rvp10364) 
  store volatile i64 %a7082, i64* %vptr26282, align 8 ; call prim_car
 %vptr26283 = alloca i64, align 8 
  %na10320 = call i64 @prim_cdr(i64 %rvp10364) 
  store volatile i64 %na10320, i64* %vptr26283, align 8 ; call prim_cdr
 %vptr26284 = alloca i64, align 8 
  %n_6310365 = call i64 @prim_null_63(i64 %na10320) 
  store volatile i64 %n_6310365, i64* %vptr26284, align 8 ; call prim_null_63
  %cmpptr26288 = alloca i1, align 8  %cmp26285 = icmp eq i64 %n_6310365, 15 store volatile i1 %cmp26285, i1* %cmpptr26288, align 8; false?
  br i1 %cmp26285, label %else26287, label %then26286                                ; if

then26286:
  %vptr26297 = alloca i64*, align 8 
  %cloptr26289 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr26289, i64** %vptr26297, align 8 ; malloc
  %vptr26298 = alloca i64*, align 8 
  %eptr26291 = getelementptr inbounds i64, i64* %cloptr26289, i64 2 
  store volatile i64* %eptr26291, i64** %vptr26298, align 8 ; &eptr26291[1]
  %vptr26299 = alloca i64*, align 8 
  %eptr26292 = getelementptr inbounds i64, i64* %cloptr26289, i64 3 
  store volatile i64* %eptr26292, i64** %vptr26299, align 8 ; &eptr26292[2]
  %vptr26300 = alloca i64*, align 8 
  %eptr26293 = getelementptr inbounds i64, i64* %cloptr26289, i64 4 
  store volatile i64* %eptr26293, i64** %vptr26300, align 8 ; &eptr26293[3]
  %vptr26301 = alloca i64*, align 8 
  %eptr26294 = getelementptr inbounds i64, i64* %cloptr26289, i64 5 
  store volatile i64* %eptr26294, i64** %vptr26301, align 8 ; &eptr26294[4]
  %vptr26302 = alloca i64*, align 8 
  %eptr26295 = getelementptr inbounds i64, i64* %cloptr26289, i64 6 
  store volatile i64* %eptr26295, i64** %vptr26302, align 8 ; &eptr26295[5]
  store i64 %emsg18637, i64* %eptr26291                                              ; *eptr26291 = %emsg18637
  store i64 %YxK$fibc, i64* %eptr26292                                               ; *eptr26292 = %YxK$fibc
  store i64 %Pll$pred, i64* %eptr26293                                               ; *eptr26293 = %Pll$pred
  store i64 %MXn$x, i64* %eptr26294                                                  ; *eptr26294 = %MXn$x
  store i64 %emsg08636, i64* %eptr26295                                              ; *eptr26295 = %emsg08636
  %vptr26303 = alloca i64*, align 8 
  %eptr26290 = getelementptr inbounds i64, i64* %cloptr26289, i64 1 
  store volatile i64* %eptr26290, i64** %vptr26303, align 8 ; &cloptr26289[1]
 %vptr26304 = alloca i64, align 8 
  %f26296 = ptrtoint void(i64,i64)* @lam11783 to i64 
  store volatile i64 %f26296, i64* %vptr26304, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f26296, i64* %eptr26290                                                 ; store fptr
 %vptr26305 = alloca i64, align 8 
  %arg8305 = ptrtoint i64* %cloptr26289 to i64 
  store volatile i64 %arg8305, i64* %vptr26305, align 8 ; closure cast; i64* -> i64
 %vptr26306 = alloca i64, align 8 
  %rva10363 = add i64 0, 0 
  store volatile i64 %rva10363, i64* %vptr26306, align 8 ; quoted ()
 %vptr26307 = alloca i64, align 8 
  %rva10362 = call i64 @prim_cons(i64 %a7082, i64 %rva10363) 
  store volatile i64 %rva10362, i64* %vptr26307, align 8 ; call prim_cons
 %vptr26308 = alloca i64, align 8 
  %rva10361 = call i64 @prim_cons(i64 %cont7237, i64 %rva10362) 
  store volatile i64 %rva10361, i64* %vptr26308, align 8 ; call prim_cons
  %vptr26314 = alloca i64*, align 8 
  %cloptr26309 = inttoptr i64 %arg8305 to i64* 
  store volatile i64* %cloptr26309, i64** %vptr26314, align 8 ; closure/env cast; i64 -> i64*
  %vptr26315 = alloca i64*, align 8 
  %i0ptr26310 = getelementptr inbounds i64, i64* %cloptr26309, i64 1 
  store volatile i64* %i0ptr26310, i64** %vptr26315, align 8 ; &cloptr26309[1]
 %vptr26316 = alloca i64, align 8 
  %f26312 = load i64, i64* %i0ptr26310, align 8 
  store volatile i64 %f26312, i64* %vptr26316, align 8 ; load; *i0ptr26310
  %fptr26311 = inttoptr i64 %f26312 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26311(i64 %arg8305, i64 %rva10361)                  ; tail call
  ret void

else26287:
 %vptr26317 = alloca i64, align 8 
  %h10366 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10366, i64* %vptr26317, align 8 ; call prim_halt
  %vptr26323 = alloca i64*, align 8 
  %cloptr26318 = inttoptr i64 %h10366 to i64* 
  store volatile i64* %cloptr26318, i64** %vptr26323, align 8 ; closure/env cast; i64 -> i64*
  %vptr26324 = alloca i64*, align 8 
  %i0ptr26319 = getelementptr inbounds i64, i64* %cloptr26318, i64 1 
  store volatile i64* %i0ptr26319, i64** %vptr26324, align 8 ; &cloptr26318[1]
 %vptr26325 = alloca i64, align 8 
  %f26321 = load i64, i64* %i0ptr26319, align 8 
  store volatile i64 %f26321, i64* %vptr26325, align 8 ; load; *i0ptr26319
  %fptr26320 = inttoptr i64 %f26321 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26320(i64 %h10366, i64 %h10366)                     ; tail call
  ret void
}


define void @lam11783(i64 %env11784, i64 %rvp10357) {
 %vptr26328 = alloca i64, align 8 
  %envptr26326 = inttoptr i64 %env11784 to i64* 
  store volatile i64 %emsg08636, i64* %vptr26328, align 8 ; closure/env cast; i64 -> i64*
  %vptr26329 = alloca i64*, align 8 
  %envptr26327 = getelementptr inbounds i64, i64* %envptr26326, i64 6 
  store volatile i64* %envptr26327, i64** %vptr26329, align 8 ; &envptr26326[5]
 %vptr26330 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr26327, align 8 
  store volatile i64 %emsg08636, i64* %vptr26330, align 8 ; load; *envptr26327
 %vptr26333 = alloca i64, align 8 
  %envptr26331 = inttoptr i64 %env11784 to i64* 
  store volatile i64 %MXn$x, i64* %vptr26333, align 8 ; closure/env cast; i64 -> i64*
  %vptr26334 = alloca i64*, align 8 
  %envptr26332 = getelementptr inbounds i64, i64* %envptr26331, i64 5 
  store volatile i64* %envptr26332, i64** %vptr26334, align 8 ; &envptr26331[4]
 %vptr26335 = alloca i64, align 8 
  %MXn$x = load i64, i64* %envptr26332, align 8 
  store volatile i64 %MXn$x, i64* %vptr26335, align 8 ; load; *envptr26332
 %vptr26338 = alloca i64, align 8 
  %envptr26336 = inttoptr i64 %env11784 to i64* 
  store volatile i64 %Pll$pred, i64* %vptr26338, align 8 ; closure/env cast; i64 -> i64*
  %vptr26339 = alloca i64*, align 8 
  %envptr26337 = getelementptr inbounds i64, i64* %envptr26336, i64 4 
  store volatile i64* %envptr26337, i64** %vptr26339, align 8 ; &envptr26336[3]
 %vptr26340 = alloca i64, align 8 
  %Pll$pred = load i64, i64* %envptr26337, align 8 
  store volatile i64 %Pll$pred, i64* %vptr26340, align 8 ; load; *envptr26337
 %vptr26343 = alloca i64, align 8 
  %envptr26341 = inttoptr i64 %env11784 to i64* 
  store volatile i64 %YxK$fibc, i64* %vptr26343, align 8 ; closure/env cast; i64 -> i64*
  %vptr26344 = alloca i64*, align 8 
  %envptr26342 = getelementptr inbounds i64, i64* %envptr26341, i64 3 
  store volatile i64* %envptr26342, i64** %vptr26344, align 8 ; &envptr26341[2]
 %vptr26345 = alloca i64, align 8 
  %YxK$fibc = load i64, i64* %envptr26342, align 8 
  store volatile i64 %YxK$fibc, i64* %vptr26345, align 8 ; load; *envptr26342
 %vptr26348 = alloca i64, align 8 
  %envptr26346 = inttoptr i64 %env11784 to i64* 
  store volatile i64 %emsg18637, i64* %vptr26348, align 8 ; closure/env cast; i64 -> i64*
  %vptr26349 = alloca i64*, align 8 
  %envptr26347 = getelementptr inbounds i64, i64* %envptr26346, i64 2 
  store volatile i64* %envptr26347, i64** %vptr26349, align 8 ; &envptr26346[1]
 %vptr26350 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr26347, align 8 
  store volatile i64 %emsg18637, i64* %vptr26350, align 8 ; load; *envptr26347
 %vptr26351 = alloca i64, align 8 
  %cont7239 = call i64 @prim_car(i64 %rvp10357) 
  store volatile i64 %cont7239, i64* %vptr26351, align 8 ; call prim_car
 %vptr26352 = alloca i64, align 8 
  %rvp10353 = call i64 @prim_cdr(i64 %rvp10357) 
  store volatile i64 %rvp10353, i64* %vptr26352, align 8 ; call prim_cdr
 %vptr26353 = alloca i64, align 8 
  %n_6310358 = call i64 @prim_null_63(i64 %rvp10353) 
  store volatile i64 %n_6310358, i64* %vptr26353, align 8 ; call prim_null_63
  %cmpptr26357 = alloca i1, align 8  %cmp26354 = icmp eq i64 %n_6310358, 15 store volatile i1 %cmp26354, i1* %cmpptr26357, align 8; false?
  br i1 %cmp26354, label %else26356, label %then26355                                ; if

then26355:
 %vptr26358 = alloca i64, align 8 
  %h10359 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10359, i64* %vptr26358, align 8 ; call prim_halt
  %vptr26364 = alloca i64*, align 8 
  %cloptr26359 = inttoptr i64 %h10359 to i64* 
  store volatile i64* %cloptr26359, i64** %vptr26364, align 8 ; closure/env cast; i64 -> i64*
  %vptr26365 = alloca i64*, align 8 
  %i0ptr26360 = getelementptr inbounds i64, i64* %cloptr26359, i64 1 
  store volatile i64* %i0ptr26360, i64** %vptr26365, align 8 ; &cloptr26359[1]
 %vptr26366 = alloca i64, align 8 
  %f26362 = load i64, i64* %i0ptr26360, align 8 
  store volatile i64 %f26362, i64* %vptr26366, align 8 ; load; *i0ptr26360
  %fptr26361 = inttoptr i64 %f26362 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26361(i64 %h10359, i64 %h10359)                     ; tail call
  ret void

else26356:
 %vptr26367 = alloca i64, align 8 
  %kf0$c = call i64 @prim_car(i64 %rvp10353) 
  store volatile i64 %kf0$c, i64* %vptr26367, align 8 ; call prim_car
 %vptr26368 = alloca i64, align 8 
  %na10322 = call i64 @prim_cdr(i64 %rvp10353) 
  store volatile i64 %na10322, i64* %vptr26368, align 8 ; call prim_cdr
 %vptr26369 = alloca i64, align 8 
  %n_6310354 = call i64 @prim_null_63(i64 %na10322) 
  store volatile i64 %n_6310354, i64* %vptr26369, align 8 ; call prim_null_63
  %cmpptr26373 = alloca i1, align 8  %cmp26370 = icmp eq i64 %n_6310354, 15 store volatile i1 %cmp26370, i1* %cmpptr26373, align 8; false?
  br i1 %cmp26370, label %else26372, label %then26371                                ; if

then26371:
 %vptr26374 = alloca i64, align 8 
  %arg8306 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8306, i64* %vptr26374, align 8 ; quoted int
 %vptr26375 = alloca i64, align 8 
  %a7075 = call i64 @prim_vector_45ref(i64 %YxK$fibc, i64 %arg8306) 
  store volatile i64 %a7075, i64* %vptr26375, align 8 ; call prim_vector_45ref
 %vptr26376 = alloca i64, align 8 
  %arg8308 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8308, i64* %vptr26376, align 8 ; quoted int
 %vptr26377 = alloca i64, align 8 
  %a7076 = call i64 @prim_vector_45ref(i64 %Pll$pred, i64 %arg8308) 
  store volatile i64 %a7076, i64* %vptr26377, align 8 ; call prim_vector_45ref
 %vptr26378 = alloca i64, align 8 
  %arg8310 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8310, i64* %vptr26378, align 8 ; quoted int
 %vptr26379 = alloca i64, align 8 
  %a7077 = call i64 @prim_vector_45ref(i64 %Pll$pred, i64 %arg8310) 
  store volatile i64 %a7077, i64* %vptr26379, align 8 ; call prim_vector_45ref
  %vptr26389 = alloca i64*, align 8 
  %cloptr26380 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr26380, i64** %vptr26389, align 8 ; malloc
  %vptr26390 = alloca i64*, align 8 
  %eptr26382 = getelementptr inbounds i64, i64* %cloptr26380, i64 2 
  store volatile i64* %eptr26382, i64** %vptr26390, align 8 ; &eptr26382[1]
  %vptr26391 = alloca i64*, align 8 
  %eptr26383 = getelementptr inbounds i64, i64* %cloptr26380, i64 3 
  store volatile i64* %eptr26383, i64** %vptr26391, align 8 ; &eptr26383[2]
  %vptr26392 = alloca i64*, align 8 
  %eptr26384 = getelementptr inbounds i64, i64* %cloptr26380, i64 4 
  store volatile i64* %eptr26384, i64** %vptr26392, align 8 ; &eptr26384[3]
  %vptr26393 = alloca i64*, align 8 
  %eptr26385 = getelementptr inbounds i64, i64* %cloptr26380, i64 5 
  store volatile i64* %eptr26385, i64** %vptr26393, align 8 ; &eptr26385[4]
  %vptr26394 = alloca i64*, align 8 
  %eptr26386 = getelementptr inbounds i64, i64* %cloptr26380, i64 6 
  store volatile i64* %eptr26386, i64** %vptr26394, align 8 ; &eptr26386[5]
  %vptr26395 = alloca i64*, align 8 
  %eptr26387 = getelementptr inbounds i64, i64* %cloptr26380, i64 7 
  store volatile i64* %eptr26387, i64** %vptr26395, align 8 ; &eptr26387[6]
  store i64 %emsg18637, i64* %eptr26382                                              ; *eptr26382 = %emsg18637
  store i64 %a7076, i64* %eptr26383                                                  ; *eptr26383 = %a7076
  store i64 %kf0$c, i64* %eptr26384                                                  ; *eptr26384 = %kf0$c
  store i64 %cont7239, i64* %eptr26385                                               ; *eptr26385 = %cont7239
  store i64 %emsg08636, i64* %eptr26386                                              ; *eptr26386 = %emsg08636
  store i64 %a7075, i64* %eptr26387                                                  ; *eptr26387 = %a7075
  %vptr26396 = alloca i64*, align 8 
  %eptr26381 = getelementptr inbounds i64, i64* %cloptr26380, i64 1 
  store volatile i64* %eptr26381, i64** %vptr26396, align 8 ; &cloptr26380[1]
 %vptr26397 = alloca i64, align 8 
  %f26388 = ptrtoint void(i64,i64)* @lam11778 to i64 
  store volatile i64 %f26388, i64* %vptr26397, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f26388, i64* %eptr26381                                                 ; store fptr
 %vptr26398 = alloca i64, align 8 
  %arg8313 = ptrtoint i64* %cloptr26380 to i64 
  store volatile i64 %arg8313, i64* %vptr26398, align 8 ; closure cast; i64* -> i64
 %vptr26399 = alloca i64, align 8 
  %rva10352 = add i64 0, 0 
  store volatile i64 %rva10352, i64* %vptr26399, align 8 ; quoted ()
 %vptr26400 = alloca i64, align 8 
  %rva10351 = call i64 @prim_cons(i64 %MXn$x, i64 %rva10352) 
  store volatile i64 %rva10351, i64* %vptr26400, align 8 ; call prim_cons
 %vptr26401 = alloca i64, align 8 
  %rva10350 = call i64 @prim_cons(i64 %arg8313, i64 %rva10351) 
  store volatile i64 %rva10350, i64* %vptr26401, align 8 ; call prim_cons
  %vptr26407 = alloca i64*, align 8 
  %cloptr26402 = inttoptr i64 %a7077 to i64* 
  store volatile i64* %cloptr26402, i64** %vptr26407, align 8 ; closure/env cast; i64 -> i64*
  %vptr26408 = alloca i64*, align 8 
  %i0ptr26403 = getelementptr inbounds i64, i64* %cloptr26402, i64 1 
  store volatile i64* %i0ptr26403, i64** %vptr26408, align 8 ; &cloptr26402[1]
 %vptr26409 = alloca i64, align 8 
  %f26405 = load i64, i64* %i0ptr26403, align 8 
  store volatile i64 %f26405, i64* %vptr26409, align 8 ; load; *i0ptr26403
  %fptr26404 = inttoptr i64 %f26405 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26404(i64 %a7077, i64 %rva10350)                    ; tail call
  ret void

else26372:
 %vptr26410 = alloca i64, align 8 
  %h10355 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10355, i64* %vptr26410, align 8 ; call prim_halt
  %vptr26416 = alloca i64*, align 8 
  %cloptr26411 = inttoptr i64 %h10355 to i64* 
  store volatile i64* %cloptr26411, i64** %vptr26416, align 8 ; closure/env cast; i64 -> i64*
  %vptr26417 = alloca i64*, align 8 
  %i0ptr26412 = getelementptr inbounds i64, i64* %cloptr26411, i64 1 
  store volatile i64* %i0ptr26412, i64** %vptr26417, align 8 ; &cloptr26411[1]
 %vptr26418 = alloca i64, align 8 
  %f26414 = load i64, i64* %i0ptr26412, align 8 
  store volatile i64 %f26414, i64* %vptr26418, align 8 ; load; *i0ptr26412
  %fptr26413 = inttoptr i64 %f26414 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26413(i64 %h10355, i64 %h10355)                     ; tail call
  ret void
}


define void @lam11778(i64 %env11779, i64 %rvp10346) {
 %vptr26421 = alloca i64, align 8 
  %envptr26419 = inttoptr i64 %env11779 to i64* 
  store volatile i64 %a7075, i64* %vptr26421, align 8 ; closure/env cast; i64 -> i64*
  %vptr26422 = alloca i64*, align 8 
  %envptr26420 = getelementptr inbounds i64, i64* %envptr26419, i64 7 
  store volatile i64* %envptr26420, i64** %vptr26422, align 8 ; &envptr26419[6]
 %vptr26423 = alloca i64, align 8 
  %a7075 = load i64, i64* %envptr26420, align 8 
  store volatile i64 %a7075, i64* %vptr26423, align 8 ; load; *envptr26420
 %vptr26426 = alloca i64, align 8 
  %envptr26424 = inttoptr i64 %env11779 to i64* 
  store volatile i64 %emsg08636, i64* %vptr26426, align 8 ; closure/env cast; i64 -> i64*
  %vptr26427 = alloca i64*, align 8 
  %envptr26425 = getelementptr inbounds i64, i64* %envptr26424, i64 6 
  store volatile i64* %envptr26425, i64** %vptr26427, align 8 ; &envptr26424[5]
 %vptr26428 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr26425, align 8 
  store volatile i64 %emsg08636, i64* %vptr26428, align 8 ; load; *envptr26425
 %vptr26431 = alloca i64, align 8 
  %envptr26429 = inttoptr i64 %env11779 to i64* 
  store volatile i64 %cont7239, i64* %vptr26431, align 8 ; closure/env cast; i64 -> i64*
  %vptr26432 = alloca i64*, align 8 
  %envptr26430 = getelementptr inbounds i64, i64* %envptr26429, i64 5 
  store volatile i64* %envptr26430, i64** %vptr26432, align 8 ; &envptr26429[4]
 %vptr26433 = alloca i64, align 8 
  %cont7239 = load i64, i64* %envptr26430, align 8 
  store volatile i64 %cont7239, i64* %vptr26433, align 8 ; load; *envptr26430
 %vptr26436 = alloca i64, align 8 
  %envptr26434 = inttoptr i64 %env11779 to i64* 
  store volatile i64 %kf0$c, i64* %vptr26436, align 8 ; closure/env cast; i64 -> i64*
  %vptr26437 = alloca i64*, align 8 
  %envptr26435 = getelementptr inbounds i64, i64* %envptr26434, i64 4 
  store volatile i64* %envptr26435, i64** %vptr26437, align 8 ; &envptr26434[3]
 %vptr26438 = alloca i64, align 8 
  %kf0$c = load i64, i64* %envptr26435, align 8 
  store volatile i64 %kf0$c, i64* %vptr26438, align 8 ; load; *envptr26435
 %vptr26441 = alloca i64, align 8 
  %envptr26439 = inttoptr i64 %env11779 to i64* 
  store volatile i64 %a7076, i64* %vptr26441, align 8 ; closure/env cast; i64 -> i64*
  %vptr26442 = alloca i64*, align 8 
  %envptr26440 = getelementptr inbounds i64, i64* %envptr26439, i64 3 
  store volatile i64* %envptr26440, i64** %vptr26442, align 8 ; &envptr26439[2]
 %vptr26443 = alloca i64, align 8 
  %a7076 = load i64, i64* %envptr26440, align 8 
  store volatile i64 %a7076, i64* %vptr26443, align 8 ; load; *envptr26440
 %vptr26446 = alloca i64, align 8 
  %envptr26444 = inttoptr i64 %env11779 to i64* 
  store volatile i64 %emsg18637, i64* %vptr26446, align 8 ; closure/env cast; i64 -> i64*
  %vptr26447 = alloca i64*, align 8 
  %envptr26445 = getelementptr inbounds i64, i64* %envptr26444, i64 2 
  store volatile i64* %envptr26445, i64** %vptr26447, align 8 ; &envptr26444[1]
 %vptr26448 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr26445, align 8 
  store volatile i64 %emsg18637, i64* %vptr26448, align 8 ; load; *envptr26445
 %vptr26449 = alloca i64, align 8 
  %_957240 = call i64 @prim_car(i64 %rvp10346) 
  store volatile i64 %_957240, i64* %vptr26449, align 8 ; call prim_car
 %vptr26450 = alloca i64, align 8 
  %rvp10342 = call i64 @prim_cdr(i64 %rvp10346) 
  store volatile i64 %rvp10342, i64* %vptr26450, align 8 ; call prim_cdr
 %vptr26451 = alloca i64, align 8 
  %n_6310347 = call i64 @prim_null_63(i64 %rvp10342) 
  store volatile i64 %n_6310347, i64* %vptr26451, align 8 ; call prim_null_63
  %cmpptr26455 = alloca i1, align 8  %cmp26452 = icmp eq i64 %n_6310347, 15 store volatile i1 %cmp26452, i1* %cmpptr26455, align 8; false?
  br i1 %cmp26452, label %else26454, label %then26453                                ; if

then26453:
 %vptr26456 = alloca i64, align 8 
  %h10348 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10348, i64* %vptr26456, align 8 ; call prim_halt
  %vptr26462 = alloca i64*, align 8 
  %cloptr26457 = inttoptr i64 %h10348 to i64* 
  store volatile i64* %cloptr26457, i64** %vptr26462, align 8 ; closure/env cast; i64 -> i64*
  %vptr26463 = alloca i64*, align 8 
  %i0ptr26458 = getelementptr inbounds i64, i64* %cloptr26457, i64 1 
  store volatile i64* %i0ptr26458, i64** %vptr26463, align 8 ; &cloptr26457[1]
 %vptr26464 = alloca i64, align 8 
  %f26460 = load i64, i64* %i0ptr26458, align 8 
  store volatile i64 %f26460, i64* %vptr26464, align 8 ; load; *i0ptr26458
  %fptr26459 = inttoptr i64 %f26460 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26459(i64 %h10348, i64 %h10348)                     ; tail call
  ret void

else26454:
 %vptr26465 = alloca i64, align 8 
  %a7078 = call i64 @prim_car(i64 %rvp10342) 
  store volatile i64 %a7078, i64* %vptr26465, align 8 ; call prim_car
 %vptr26466 = alloca i64, align 8 
  %na10324 = call i64 @prim_cdr(i64 %rvp10342) 
  store volatile i64 %na10324, i64* %vptr26466, align 8 ; call prim_cdr
 %vptr26467 = alloca i64, align 8 
  %n_6310343 = call i64 @prim_null_63(i64 %na10324) 
  store volatile i64 %n_6310343, i64* %vptr26467, align 8 ; call prim_null_63
  %cmpptr26471 = alloca i1, align 8  %cmp26468 = icmp eq i64 %n_6310343, 15 store volatile i1 %cmp26468, i1* %cmpptr26471, align 8; false?
  br i1 %cmp26468, label %else26470, label %then26469                                ; if

then26469:
  %vptr26480 = alloca i64*, align 8 
  %cloptr26472 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr26472, i64** %vptr26480, align 8 ; malloc
  %vptr26481 = alloca i64*, align 8 
  %eptr26474 = getelementptr inbounds i64, i64* %cloptr26472, i64 2 
  store volatile i64* %eptr26474, i64** %vptr26481, align 8 ; &eptr26474[1]
  %vptr26482 = alloca i64*, align 8 
  %eptr26475 = getelementptr inbounds i64, i64* %cloptr26472, i64 3 
  store volatile i64* %eptr26475, i64** %vptr26482, align 8 ; &eptr26475[2]
  %vptr26483 = alloca i64*, align 8 
  %eptr26476 = getelementptr inbounds i64, i64* %cloptr26472, i64 4 
  store volatile i64* %eptr26476, i64** %vptr26483, align 8 ; &eptr26476[3]
  %vptr26484 = alloca i64*, align 8 
  %eptr26477 = getelementptr inbounds i64, i64* %cloptr26472, i64 5 
  store volatile i64* %eptr26477, i64** %vptr26484, align 8 ; &eptr26477[4]
  %vptr26485 = alloca i64*, align 8 
  %eptr26478 = getelementptr inbounds i64, i64* %cloptr26472, i64 6 
  store volatile i64* %eptr26478, i64** %vptr26485, align 8 ; &eptr26478[5]
  store i64 %emsg18637, i64* %eptr26474                                              ; *eptr26474 = %emsg18637
  store i64 %kf0$c, i64* %eptr26475                                                  ; *eptr26475 = %kf0$c
  store i64 %cont7239, i64* %eptr26476                                               ; *eptr26476 = %cont7239
  store i64 %emsg08636, i64* %eptr26477                                              ; *eptr26477 = %emsg08636
  store i64 %a7075, i64* %eptr26478                                                  ; *eptr26478 = %a7075
  %vptr26486 = alloca i64*, align 8 
  %eptr26473 = getelementptr inbounds i64, i64* %cloptr26472, i64 1 
  store volatile i64* %eptr26473, i64** %vptr26486, align 8 ; &cloptr26472[1]
 %vptr26487 = alloca i64, align 8 
  %f26479 = ptrtoint void(i64,i64)* @lam11776 to i64 
  store volatile i64 %f26479, i64* %vptr26487, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f26479, i64* %eptr26473                                                 ; store fptr
 %vptr26488 = alloca i64, align 8 
  %arg8316 = ptrtoint i64* %cloptr26472 to i64 
  store volatile i64 %arg8316, i64* %vptr26488, align 8 ; closure cast; i64* -> i64
 %vptr26489 = alloca i64, align 8 
  %rva10341 = add i64 0, 0 
  store volatile i64 %rva10341, i64* %vptr26489, align 8 ; quoted ()
 %vptr26490 = alloca i64, align 8 
  %rva10340 = call i64 @prim_cons(i64 %a7078, i64 %rva10341) 
  store volatile i64 %rva10340, i64* %vptr26490, align 8 ; call prim_cons
 %vptr26491 = alloca i64, align 8 
  %rva10339 = call i64 @prim_cons(i64 %arg8316, i64 %rva10340) 
  store volatile i64 %rva10339, i64* %vptr26491, align 8 ; call prim_cons
  %vptr26497 = alloca i64*, align 8 
  %cloptr26492 = inttoptr i64 %a7076 to i64* 
  store volatile i64* %cloptr26492, i64** %vptr26497, align 8 ; closure/env cast; i64 -> i64*
  %vptr26498 = alloca i64*, align 8 
  %i0ptr26493 = getelementptr inbounds i64, i64* %cloptr26492, i64 1 
  store volatile i64* %i0ptr26493, i64** %vptr26498, align 8 ; &cloptr26492[1]
 %vptr26499 = alloca i64, align 8 
  %f26495 = load i64, i64* %i0ptr26493, align 8 
  store volatile i64 %f26495, i64* %vptr26499, align 8 ; load; *i0ptr26493
  %fptr26494 = inttoptr i64 %f26495 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26494(i64 %a7076, i64 %rva10339)                    ; tail call
  ret void

else26470:
 %vptr26500 = alloca i64, align 8 
  %h10344 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10344, i64* %vptr26500, align 8 ; call prim_halt
  %vptr26506 = alloca i64*, align 8 
  %cloptr26501 = inttoptr i64 %h10344 to i64* 
  store volatile i64* %cloptr26501, i64** %vptr26506, align 8 ; closure/env cast; i64 -> i64*
  %vptr26507 = alloca i64*, align 8 
  %i0ptr26502 = getelementptr inbounds i64, i64* %cloptr26501, i64 1 
  store volatile i64* %i0ptr26502, i64** %vptr26507, align 8 ; &cloptr26501[1]
 %vptr26508 = alloca i64, align 8 
  %f26504 = load i64, i64* %i0ptr26502, align 8 
  store volatile i64 %f26504, i64* %vptr26508, align 8 ; load; *i0ptr26502
  %fptr26503 = inttoptr i64 %f26504 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26503(i64 %h10344, i64 %h10344)                     ; tail call
  ret void
}


define void @lam11776(i64 %env11777, i64 %rvp10335) {
 %vptr26511 = alloca i64, align 8 
  %envptr26509 = inttoptr i64 %env11777 to i64* 
  store volatile i64 %a7075, i64* %vptr26511, align 8 ; closure/env cast; i64 -> i64*
  %vptr26512 = alloca i64*, align 8 
  %envptr26510 = getelementptr inbounds i64, i64* %envptr26509, i64 6 
  store volatile i64* %envptr26510, i64** %vptr26512, align 8 ; &envptr26509[5]
 %vptr26513 = alloca i64, align 8 
  %a7075 = load i64, i64* %envptr26510, align 8 
  store volatile i64 %a7075, i64* %vptr26513, align 8 ; load; *envptr26510
 %vptr26516 = alloca i64, align 8 
  %envptr26514 = inttoptr i64 %env11777 to i64* 
  store volatile i64 %emsg08636, i64* %vptr26516, align 8 ; closure/env cast; i64 -> i64*
  %vptr26517 = alloca i64*, align 8 
  %envptr26515 = getelementptr inbounds i64, i64* %envptr26514, i64 5 
  store volatile i64* %envptr26515, i64** %vptr26517, align 8 ; &envptr26514[4]
 %vptr26518 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr26515, align 8 
  store volatile i64 %emsg08636, i64* %vptr26518, align 8 ; load; *envptr26515
 %vptr26521 = alloca i64, align 8 
  %envptr26519 = inttoptr i64 %env11777 to i64* 
  store volatile i64 %cont7239, i64* %vptr26521, align 8 ; closure/env cast; i64 -> i64*
  %vptr26522 = alloca i64*, align 8 
  %envptr26520 = getelementptr inbounds i64, i64* %envptr26519, i64 4 
  store volatile i64* %envptr26520, i64** %vptr26522, align 8 ; &envptr26519[3]
 %vptr26523 = alloca i64, align 8 
  %cont7239 = load i64, i64* %envptr26520, align 8 
  store volatile i64 %cont7239, i64* %vptr26523, align 8 ; load; *envptr26520
 %vptr26526 = alloca i64, align 8 
  %envptr26524 = inttoptr i64 %env11777 to i64* 
  store volatile i64 %kf0$c, i64* %vptr26526, align 8 ; closure/env cast; i64 -> i64*
  %vptr26527 = alloca i64*, align 8 
  %envptr26525 = getelementptr inbounds i64, i64* %envptr26524, i64 3 
  store volatile i64* %envptr26525, i64** %vptr26527, align 8 ; &envptr26524[2]
 %vptr26528 = alloca i64, align 8 
  %kf0$c = load i64, i64* %envptr26525, align 8 
  store volatile i64 %kf0$c, i64* %vptr26528, align 8 ; load; *envptr26525
 %vptr26531 = alloca i64, align 8 
  %envptr26529 = inttoptr i64 %env11777 to i64* 
  store volatile i64 %emsg18637, i64* %vptr26531, align 8 ; closure/env cast; i64 -> i64*
  %vptr26532 = alloca i64*, align 8 
  %envptr26530 = getelementptr inbounds i64, i64* %envptr26529, i64 2 
  store volatile i64* %envptr26530, i64** %vptr26532, align 8 ; &envptr26529[1]
 %vptr26533 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr26530, align 8 
  store volatile i64 %emsg18637, i64* %vptr26533, align 8 ; load; *envptr26530
 %vptr26534 = alloca i64, align 8 
  %_957241 = call i64 @prim_car(i64 %rvp10335) 
  store volatile i64 %_957241, i64* %vptr26534, align 8 ; call prim_car
 %vptr26535 = alloca i64, align 8 
  %rvp10331 = call i64 @prim_cdr(i64 %rvp10335) 
  store volatile i64 %rvp10331, i64* %vptr26535, align 8 ; call prim_cdr
 %vptr26536 = alloca i64, align 8 
  %n_6310336 = call i64 @prim_null_63(i64 %rvp10331) 
  store volatile i64 %n_6310336, i64* %vptr26536, align 8 ; call prim_null_63
  %cmpptr26540 = alloca i1, align 8  %cmp26537 = icmp eq i64 %n_6310336, 15 store volatile i1 %cmp26537, i1* %cmpptr26540, align 8; false?
  br i1 %cmp26537, label %else26539, label %then26538                                ; if

then26538:
 %vptr26541 = alloca i64, align 8 
  %h10337 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10337, i64* %vptr26541, align 8 ; call prim_halt
  %vptr26547 = alloca i64*, align 8 
  %cloptr26542 = inttoptr i64 %h10337 to i64* 
  store volatile i64* %cloptr26542, i64** %vptr26547, align 8 ; closure/env cast; i64 -> i64*
  %vptr26548 = alloca i64*, align 8 
  %i0ptr26543 = getelementptr inbounds i64, i64* %cloptr26542, i64 1 
  store volatile i64* %i0ptr26543, i64** %vptr26548, align 8 ; &cloptr26542[1]
 %vptr26549 = alloca i64, align 8 
  %f26545 = load i64, i64* %i0ptr26543, align 8 
  store volatile i64 %f26545, i64* %vptr26549, align 8 ; load; *i0ptr26543
  %fptr26544 = inttoptr i64 %f26545 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26544(i64 %h10337, i64 %h10337)                     ; tail call
  ret void

else26539:
 %vptr26550 = alloca i64, align 8 
  %a7079 = call i64 @prim_car(i64 %rvp10331) 
  store volatile i64 %a7079, i64* %vptr26550, align 8 ; call prim_car
 %vptr26551 = alloca i64, align 8 
  %na10326 = call i64 @prim_cdr(i64 %rvp10331) 
  store volatile i64 %na10326, i64* %vptr26551, align 8 ; call prim_cdr
 %vptr26552 = alloca i64, align 8 
  %n_6310332 = call i64 @prim_null_63(i64 %na10326) 
  store volatile i64 %n_6310332, i64* %vptr26552, align 8 ; call prim_null_63
  %cmpptr26556 = alloca i1, align 8  %cmp26553 = icmp eq i64 %n_6310332, 15 store volatile i1 %cmp26553, i1* %cmpptr26556, align 8; false?
  br i1 %cmp26553, label %else26555, label %then26554                                ; if

then26554:
 %vptr26557 = alloca i64, align 8 
  %rva10330 = add i64 0, 0 
  store volatile i64 %rva10330, i64* %vptr26557, align 8 ; quoted ()
 %vptr26558 = alloca i64, align 8 
  %rva10329 = call i64 @prim_cons(i64 %kf0$c, i64 %rva10330) 
  store volatile i64 %rva10329, i64* %vptr26558, align 8 ; call prim_cons
 %vptr26559 = alloca i64, align 8 
  %rva10328 = call i64 @prim_cons(i64 %a7079, i64 %rva10329) 
  store volatile i64 %rva10328, i64* %vptr26559, align 8 ; call prim_cons
 %vptr26560 = alloca i64, align 8 
  %rva10327 = call i64 @prim_cons(i64 %cont7239, i64 %rva10328) 
  store volatile i64 %rva10327, i64* %vptr26560, align 8 ; call prim_cons
  %vptr26566 = alloca i64*, align 8 
  %cloptr26561 = inttoptr i64 %a7075 to i64* 
  store volatile i64* %cloptr26561, i64** %vptr26566, align 8 ; closure/env cast; i64 -> i64*
  %vptr26567 = alloca i64*, align 8 
  %i0ptr26562 = getelementptr inbounds i64, i64* %cloptr26561, i64 1 
  store volatile i64* %i0ptr26562, i64** %vptr26567, align 8 ; &cloptr26561[1]
 %vptr26568 = alloca i64, align 8 
  %f26564 = load i64, i64* %i0ptr26562, align 8 
  store volatile i64 %f26564, i64* %vptr26568, align 8 ; load; *i0ptr26562
  %fptr26563 = inttoptr i64 %f26564 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26563(i64 %a7075, i64 %rva10327)                    ; tail call
  ret void

else26555:
 %vptr26569 = alloca i64, align 8 
  %h10333 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10333, i64* %vptr26569, align 8 ; call prim_halt
  %vptr26575 = alloca i64*, align 8 
  %cloptr26570 = inttoptr i64 %h10333 to i64* 
  store volatile i64* %cloptr26570, i64** %vptr26575, align 8 ; closure/env cast; i64 -> i64*
  %vptr26576 = alloca i64*, align 8 
  %i0ptr26571 = getelementptr inbounds i64, i64* %cloptr26570, i64 1 
  store volatile i64* %i0ptr26571, i64** %vptr26576, align 8 ; &cloptr26570[1]
 %vptr26577 = alloca i64, align 8 
  %f26573 = load i64, i64* %i0ptr26571, align 8 
  store volatile i64 %f26573, i64* %vptr26577, align 8 ; load; *i0ptr26571
  %fptr26572 = inttoptr i64 %f26573 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26572(i64 %h10333, i64 %h10333)                     ; tail call
  ret void
}


define void @lam11769(i64 %env11770, i64 %rvp10410) {
 %vptr26580 = alloca i64, align 8 
  %envptr26578 = inttoptr i64 %env11770 to i64* 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr26580, align 8 ; closure/env cast; i64 -> i64*
  %vptr26581 = alloca i64*, align 8 
  %envptr26579 = getelementptr inbounds i64, i64* %envptr26578, i64 7 
  store volatile i64* %envptr26579, i64** %vptr26581, align 8 ; &envptr26578[6]
 %vptr26582 = alloca i64, align 8 
  %U8g$_37do_45wind = load i64, i64* %envptr26579, align 8 
  store volatile i64 %U8g$_37do_45wind, i64* %vptr26582, align 8 ; load; *envptr26579
 %vptr26585 = alloca i64, align 8 
  %envptr26583 = inttoptr i64 %env11770 to i64* 
  store volatile i64 %emsg08636, i64* %vptr26585, align 8 ; closure/env cast; i64 -> i64*
  %vptr26586 = alloca i64*, align 8 
  %envptr26584 = getelementptr inbounds i64, i64* %envptr26583, i64 6 
  store volatile i64* %envptr26584, i64** %vptr26586, align 8 ; &envptr26583[5]
 %vptr26587 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr26584, align 8 
  store volatile i64 %emsg08636, i64* %vptr26587, align 8 ; load; *envptr26584
 %vptr26590 = alloca i64, align 8 
  %envptr26588 = inttoptr i64 %env11770 to i64* 
  store volatile i64 %njK$_37k, i64* %vptr26590, align 8 ; closure/env cast; i64 -> i64*
  %vptr26591 = alloca i64*, align 8 
  %envptr26589 = getelementptr inbounds i64, i64* %envptr26588, i64 5 
  store volatile i64* %envptr26589, i64** %vptr26591, align 8 ; &envptr26588[4]
 %vptr26592 = alloca i64, align 8 
  %njK$_37k = load i64, i64* %envptr26589, align 8 
  store volatile i64 %njK$_37k, i64* %vptr26592, align 8 ; load; *envptr26589
 %vptr26595 = alloca i64, align 8 
  %envptr26593 = inttoptr i64 %env11770 to i64* 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr26595, align 8 ; closure/env cast; i64 -> i64*
  %vptr26596 = alloca i64*, align 8 
  %envptr26594 = getelementptr inbounds i64, i64* %envptr26593, i64 4 
  store volatile i64* %envptr26594, i64** %vptr26596, align 8 ; &envptr26593[3]
 %vptr26597 = alloca i64, align 8 
  %SdC$_37wind_45stack = load i64, i64* %envptr26594, align 8 
  store volatile i64 %SdC$_37wind_45stack, i64* %vptr26597, align 8 ; load; *envptr26594
 %vptr26600 = alloca i64, align 8 
  %envptr26598 = inttoptr i64 %env11770 to i64* 
  store volatile i64 %emsg18637, i64* %vptr26600, align 8 ; closure/env cast; i64 -> i64*
  %vptr26601 = alloca i64*, align 8 
  %envptr26599 = getelementptr inbounds i64, i64* %envptr26598, i64 3 
  store volatile i64* %envptr26599, i64** %vptr26601, align 8 ; &envptr26598[2]
 %vptr26602 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr26599, align 8 
  store volatile i64 %emsg18637, i64* %vptr26602, align 8 ; load; *envptr26599
 %vptr26605 = alloca i64, align 8 
  %envptr26603 = inttoptr i64 %env11770 to i64* 
  store volatile i64 %SiZ$_37saved_45stack, i64* %vptr26605, align 8 ; closure/env cast; i64 -> i64*
  %vptr26606 = alloca i64*, align 8 
  %envptr26604 = getelementptr inbounds i64, i64* %envptr26603, i64 2 
  store volatile i64* %envptr26604, i64** %vptr26606, align 8 ; &envptr26603[1]
 %vptr26607 = alloca i64, align 8 
  %SiZ$_37saved_45stack = load i64, i64* %envptr26604, align 8 
  store volatile i64 %SiZ$_37saved_45stack, i64* %vptr26607, align 8 ; load; *envptr26604
 %vptr26608 = alloca i64, align 8 
  %cont7242 = call i64 @prim_car(i64 %rvp10410) 
  store volatile i64 %cont7242, i64* %vptr26608, align 8 ; call prim_car
 %vptr26609 = alloca i64, align 8 
  %rvp10406 = call i64 @prim_cdr(i64 %rvp10410) 
  store volatile i64 %rvp10406, i64* %vptr26609, align 8 ; call prim_cdr
 %vptr26610 = alloca i64, align 8 
  %n_6310411 = call i64 @prim_null_63(i64 %rvp10406) 
  store volatile i64 %n_6310411, i64* %vptr26610, align 8 ; call prim_null_63
  %cmpptr26614 = alloca i1, align 8  %cmp26611 = icmp eq i64 %n_6310411, 15 store volatile i1 %cmp26611, i1* %cmpptr26614, align 8; false?
  br i1 %cmp26611, label %else26613, label %then26612                                ; if

then26612:
 %vptr26615 = alloca i64, align 8 
  %h10412 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10412, i64* %vptr26615, align 8 ; call prim_halt
  %vptr26621 = alloca i64*, align 8 
  %cloptr26616 = inttoptr i64 %h10412 to i64* 
  store volatile i64* %cloptr26616, i64** %vptr26621, align 8 ; closure/env cast; i64 -> i64*
  %vptr26622 = alloca i64*, align 8 
  %i0ptr26617 = getelementptr inbounds i64, i64* %cloptr26616, i64 1 
  store volatile i64* %i0ptr26617, i64** %vptr26622, align 8 ; &cloptr26616[1]
 %vptr26623 = alloca i64, align 8 
  %f26619 = load i64, i64* %i0ptr26617, align 8 
  store volatile i64 %f26619, i64* %vptr26623, align 8 ; load; *i0ptr26617
  %fptr26618 = inttoptr i64 %f26619 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26618(i64 %h10412, i64 %h10412)                     ; tail call
  ret void

else26613:
 %vptr26624 = alloca i64, align 8 
  %ClB$_37x = call i64 @prim_car(i64 %rvp10406) 
  store volatile i64 %ClB$_37x, i64* %vptr26624, align 8 ; call prim_car
 %vptr26625 = alloca i64, align 8 
  %na10373 = call i64 @prim_cdr(i64 %rvp10406) 
  store volatile i64 %na10373, i64* %vptr26625, align 8 ; call prim_cdr
 %vptr26626 = alloca i64, align 8 
  %n_6310407 = call i64 @prim_null_63(i64 %na10373) 
  store volatile i64 %n_6310407, i64* %vptr26626, align 8 ; call prim_null_63
  %cmpptr26630 = alloca i1, align 8  %cmp26627 = icmp eq i64 %n_6310407, 15 store volatile i1 %cmp26627, i1* %cmpptr26630, align 8; false?
  br i1 %cmp26627, label %else26629, label %then26628                                ; if

then26628:
 %vptr26631 = alloca i64, align 8 
  %arg8322 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8322, i64* %vptr26631, align 8 ; quoted int
 %vptr26632 = alloca i64, align 8 
  %a7080 = call i64 @prim_vector_45ref(i64 %SdC$_37wind_45stack, i64 %arg8322) 
  store volatile i64 %a7080, i64* %vptr26632, align 8 ; call prim_vector_45ref
 %vptr26633 = alloca i64, align 8 
  %a7081 = call i64 @prim_eq_63(i64 %SiZ$_37saved_45stack, i64 %a7080) 
  store volatile i64 %a7081, i64* %vptr26633, align 8 ; call prim_eq_63
  %cmpptr26637 = alloca i1, align 8  %cmp26634 = icmp eq i64 %a7081, 15 store volatile i1 %cmp26634, i1* %cmpptr26637, align 8; false?
  br i1 %cmp26634, label %else26636, label %then26635                                ; if

then26635:
 %vptr26638 = alloca i64, align 8 
  %retprim7244 = call i64 @prim_void() 
  store volatile i64 %retprim7244, i64* %vptr26638, align 8 ; call prim_void
  %vptr26647 = alloca i64*, align 8 
  %cloptr26639 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr26639, i64** %vptr26647, align 8 ; malloc
  %vptr26648 = alloca i64*, align 8 
  %eptr26641 = getelementptr inbounds i64, i64* %cloptr26639, i64 2 
  store volatile i64* %eptr26641, i64** %vptr26648, align 8 ; &eptr26641[1]
  %vptr26649 = alloca i64*, align 8 
  %eptr26642 = getelementptr inbounds i64, i64* %cloptr26639, i64 3 
  store volatile i64* %eptr26642, i64** %vptr26649, align 8 ; &eptr26642[2]
  %vptr26650 = alloca i64*, align 8 
  %eptr26643 = getelementptr inbounds i64, i64* %cloptr26639, i64 4 
  store volatile i64* %eptr26643, i64** %vptr26650, align 8 ; &eptr26643[3]
  %vptr26651 = alloca i64*, align 8 
  %eptr26644 = getelementptr inbounds i64, i64* %cloptr26639, i64 5 
  store volatile i64* %eptr26644, i64** %vptr26651, align 8 ; &eptr26644[4]
  %vptr26652 = alloca i64*, align 8 
  %eptr26645 = getelementptr inbounds i64, i64* %cloptr26639, i64 6 
  store volatile i64* %eptr26645, i64** %vptr26652, align 8 ; &eptr26645[5]
  store i64 %emsg18637, i64* %eptr26641                                              ; *eptr26641 = %emsg18637
  store i64 %ClB$_37x, i64* %eptr26642                                               ; *eptr26642 = %ClB$_37x
  store i64 %njK$_37k, i64* %eptr26643                                               ; *eptr26643 = %njK$_37k
  store i64 %cont7242, i64* %eptr26644                                               ; *eptr26644 = %cont7242
  store i64 %emsg08636, i64* %eptr26645                                              ; *eptr26645 = %emsg08636
  %vptr26653 = alloca i64*, align 8 
  %eptr26640 = getelementptr inbounds i64, i64* %cloptr26639, i64 1 
  store volatile i64* %eptr26640, i64** %vptr26653, align 8 ; &cloptr26639[1]
 %vptr26654 = alloca i64, align 8 
  %f26646 = ptrtoint void(i64,i64)* @lam11762 to i64 
  store volatile i64 %f26646, i64* %vptr26654, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f26646, i64* %eptr26640                                                 ; store fptr
 %vptr26655 = alloca i64, align 8 
  %arg8328 = ptrtoint i64* %cloptr26639 to i64 
  store volatile i64 %arg8328, i64* %vptr26655, align 8 ; closure cast; i64* -> i64
 %vptr26656 = alloca i64, align 8 
  %arg8327 = add i64 0, 0 
  store volatile i64 %arg8327, i64* %vptr26656, align 8 ; quoted ()
 %vptr26657 = alloca i64, align 8 
  %rva10389 = add i64 0, 0 
  store volatile i64 %rva10389, i64* %vptr26657, align 8 ; quoted ()
 %vptr26658 = alloca i64, align 8 
  %rva10388 = call i64 @prim_cons(i64 %retprim7244, i64 %rva10389) 
  store volatile i64 %rva10388, i64* %vptr26658, align 8 ; call prim_cons
 %vptr26659 = alloca i64, align 8 
  %rva10387 = call i64 @prim_cons(i64 %arg8327, i64 %rva10388) 
  store volatile i64 %rva10387, i64* %vptr26659, align 8 ; call prim_cons
  %vptr26665 = alloca i64*, align 8 
  %cloptr26660 = inttoptr i64 %arg8328 to i64* 
  store volatile i64* %cloptr26660, i64** %vptr26665, align 8 ; closure/env cast; i64 -> i64*
  %vptr26666 = alloca i64*, align 8 
  %i0ptr26661 = getelementptr inbounds i64, i64* %cloptr26660, i64 1 
  store volatile i64* %i0ptr26661, i64** %vptr26666, align 8 ; &cloptr26660[1]
 %vptr26667 = alloca i64, align 8 
  %f26663 = load i64, i64* %i0ptr26661, align 8 
  store volatile i64 %f26663, i64* %vptr26667, align 8 ; load; *i0ptr26661
  %fptr26662 = inttoptr i64 %f26663 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26662(i64 %arg8328, i64 %rva10387)                  ; tail call
  ret void

else26636:
  %vptr26676 = alloca i64*, align 8 
  %cloptr26668 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr26668, i64** %vptr26676, align 8 ; malloc
  %vptr26677 = alloca i64*, align 8 
  %eptr26670 = getelementptr inbounds i64, i64* %cloptr26668, i64 2 
  store volatile i64* %eptr26670, i64** %vptr26677, align 8 ; &eptr26670[1]
  %vptr26678 = alloca i64*, align 8 
  %eptr26671 = getelementptr inbounds i64, i64* %cloptr26668, i64 3 
  store volatile i64* %eptr26671, i64** %vptr26678, align 8 ; &eptr26671[2]
  %vptr26679 = alloca i64*, align 8 
  %eptr26672 = getelementptr inbounds i64, i64* %cloptr26668, i64 4 
  store volatile i64* %eptr26672, i64** %vptr26679, align 8 ; &eptr26672[3]
  %vptr26680 = alloca i64*, align 8 
  %eptr26673 = getelementptr inbounds i64, i64* %cloptr26668, i64 5 
  store volatile i64* %eptr26673, i64** %vptr26680, align 8 ; &eptr26673[4]
  %vptr26681 = alloca i64*, align 8 
  %eptr26674 = getelementptr inbounds i64, i64* %cloptr26668, i64 6 
  store volatile i64* %eptr26674, i64** %vptr26681, align 8 ; &eptr26674[5]
  store i64 %emsg18637, i64* %eptr26670                                              ; *eptr26670 = %emsg18637
  store i64 %ClB$_37x, i64* %eptr26671                                               ; *eptr26671 = %ClB$_37x
  store i64 %njK$_37k, i64* %eptr26672                                               ; *eptr26672 = %njK$_37k
  store i64 %cont7242, i64* %eptr26673                                               ; *eptr26673 = %cont7242
  store i64 %emsg08636, i64* %eptr26674                                              ; *eptr26674 = %emsg08636
  %vptr26682 = alloca i64*, align 8 
  %eptr26669 = getelementptr inbounds i64, i64* %cloptr26668, i64 1 
  store volatile i64* %eptr26669, i64** %vptr26682, align 8 ; &cloptr26668[1]
 %vptr26683 = alloca i64, align 8 
  %f26675 = ptrtoint void(i64,i64)* @lam11766 to i64 
  store volatile i64 %f26675, i64* %vptr26683, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f26675, i64* %eptr26669                                                 ; store fptr
 %vptr26684 = alloca i64, align 8 
  %arg8333 = ptrtoint i64* %cloptr26668 to i64 
  store volatile i64 %arg8333, i64* %vptr26684, align 8 ; closure cast; i64* -> i64
 %vptr26685 = alloca i64, align 8 
  %rva10405 = add i64 0, 0 
  store volatile i64 %rva10405, i64* %vptr26685, align 8 ; quoted ()
 %vptr26686 = alloca i64, align 8 
  %rva10404 = call i64 @prim_cons(i64 %SiZ$_37saved_45stack, i64 %rva10405) 
  store volatile i64 %rva10404, i64* %vptr26686, align 8 ; call prim_cons
 %vptr26687 = alloca i64, align 8 
  %rva10403 = call i64 @prim_cons(i64 %arg8333, i64 %rva10404) 
  store volatile i64 %rva10403, i64* %vptr26687, align 8 ; call prim_cons
  %vptr26693 = alloca i64*, align 8 
  %cloptr26688 = inttoptr i64 %U8g$_37do_45wind to i64* 
  store volatile i64* %cloptr26688, i64** %vptr26693, align 8 ; closure/env cast; i64 -> i64*
  %vptr26694 = alloca i64*, align 8 
  %i0ptr26689 = getelementptr inbounds i64, i64* %cloptr26688, i64 1 
  store volatile i64* %i0ptr26689, i64** %vptr26694, align 8 ; &cloptr26688[1]
 %vptr26695 = alloca i64, align 8 
  %f26691 = load i64, i64* %i0ptr26689, align 8 
  store volatile i64 %f26691, i64* %vptr26695, align 8 ; load; *i0ptr26689
  %fptr26690 = inttoptr i64 %f26691 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26690(i64 %U8g$_37do_45wind, i64 %rva10403)         ; tail call
  ret void

else26629:
 %vptr26696 = alloca i64, align 8 
  %h10408 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10408, i64* %vptr26696, align 8 ; call prim_halt
  %vptr26702 = alloca i64*, align 8 
  %cloptr26697 = inttoptr i64 %h10408 to i64* 
  store volatile i64* %cloptr26697, i64** %vptr26702, align 8 ; closure/env cast; i64 -> i64*
  %vptr26703 = alloca i64*, align 8 
  %i0ptr26698 = getelementptr inbounds i64, i64* %cloptr26697, i64 1 
  store volatile i64* %i0ptr26698, i64** %vptr26703, align 8 ; &cloptr26697[1]
 %vptr26704 = alloca i64, align 8 
  %f26700 = load i64, i64* %i0ptr26698, align 8 
  store volatile i64 %f26700, i64* %vptr26704, align 8 ; load; *i0ptr26698
  %fptr26699 = inttoptr i64 %f26700 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26699(i64 %h10408, i64 %h10408)                     ; tail call
  ret void
}


define void @lam11766(i64 %env11767, i64 %rvp10399) {
 %vptr26707 = alloca i64, align 8 
  %envptr26705 = inttoptr i64 %env11767 to i64* 
  store volatile i64 %emsg08636, i64* %vptr26707, align 8 ; closure/env cast; i64 -> i64*
  %vptr26708 = alloca i64*, align 8 
  %envptr26706 = getelementptr inbounds i64, i64* %envptr26705, i64 6 
  store volatile i64* %envptr26706, i64** %vptr26708, align 8 ; &envptr26705[5]
 %vptr26709 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr26706, align 8 
  store volatile i64 %emsg08636, i64* %vptr26709, align 8 ; load; *envptr26706
 %vptr26712 = alloca i64, align 8 
  %envptr26710 = inttoptr i64 %env11767 to i64* 
  store volatile i64 %cont7242, i64* %vptr26712, align 8 ; closure/env cast; i64 -> i64*
  %vptr26713 = alloca i64*, align 8 
  %envptr26711 = getelementptr inbounds i64, i64* %envptr26710, i64 5 
  store volatile i64* %envptr26711, i64** %vptr26713, align 8 ; &envptr26710[4]
 %vptr26714 = alloca i64, align 8 
  %cont7242 = load i64, i64* %envptr26711, align 8 
  store volatile i64 %cont7242, i64* %vptr26714, align 8 ; load; *envptr26711
 %vptr26717 = alloca i64, align 8 
  %envptr26715 = inttoptr i64 %env11767 to i64* 
  store volatile i64 %njK$_37k, i64* %vptr26717, align 8 ; closure/env cast; i64 -> i64*
  %vptr26718 = alloca i64*, align 8 
  %envptr26716 = getelementptr inbounds i64, i64* %envptr26715, i64 4 
  store volatile i64* %envptr26716, i64** %vptr26718, align 8 ; &envptr26715[3]
 %vptr26719 = alloca i64, align 8 
  %njK$_37k = load i64, i64* %envptr26716, align 8 
  store volatile i64 %njK$_37k, i64* %vptr26719, align 8 ; load; *envptr26716
 %vptr26722 = alloca i64, align 8 
  %envptr26720 = inttoptr i64 %env11767 to i64* 
  store volatile i64 %ClB$_37x, i64* %vptr26722, align 8 ; closure/env cast; i64 -> i64*
  %vptr26723 = alloca i64*, align 8 
  %envptr26721 = getelementptr inbounds i64, i64* %envptr26720, i64 3 
  store volatile i64* %envptr26721, i64** %vptr26723, align 8 ; &envptr26720[2]
 %vptr26724 = alloca i64, align 8 
  %ClB$_37x = load i64, i64* %envptr26721, align 8 
  store volatile i64 %ClB$_37x, i64* %vptr26724, align 8 ; load; *envptr26721
 %vptr26727 = alloca i64, align 8 
  %envptr26725 = inttoptr i64 %env11767 to i64* 
  store volatile i64 %emsg18637, i64* %vptr26727, align 8 ; closure/env cast; i64 -> i64*
  %vptr26728 = alloca i64*, align 8 
  %envptr26726 = getelementptr inbounds i64, i64* %envptr26725, i64 2 
  store volatile i64* %envptr26726, i64** %vptr26728, align 8 ; &envptr26725[1]
 %vptr26729 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr26726, align 8 
  store volatile i64 %emsg18637, i64* %vptr26729, align 8 ; load; *envptr26726
 %vptr26730 = alloca i64, align 8 
  %_957243 = call i64 @prim_car(i64 %rvp10399) 
  store volatile i64 %_957243, i64* %vptr26730, align 8 ; call prim_car
 %vptr26731 = alloca i64, align 8 
  %rvp10395 = call i64 @prim_cdr(i64 %rvp10399) 
  store volatile i64 %rvp10395, i64* %vptr26731, align 8 ; call prim_cdr
 %vptr26732 = alloca i64, align 8 
  %n_6310400 = call i64 @prim_null_63(i64 %rvp10395) 
  store volatile i64 %n_6310400, i64* %vptr26732, align 8 ; call prim_null_63
  %cmpptr26736 = alloca i1, align 8  %cmp26733 = icmp eq i64 %n_6310400, 15 store volatile i1 %cmp26733, i1* %cmpptr26736, align 8; false?
  br i1 %cmp26733, label %else26735, label %then26734                                ; if

then26734:
 %vptr26737 = alloca i64, align 8 
  %h10401 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10401, i64* %vptr26737, align 8 ; call prim_halt
  %vptr26743 = alloca i64*, align 8 
  %cloptr26738 = inttoptr i64 %h10401 to i64* 
  store volatile i64* %cloptr26738, i64** %vptr26743, align 8 ; closure/env cast; i64 -> i64*
  %vptr26744 = alloca i64*, align 8 
  %i0ptr26739 = getelementptr inbounds i64, i64* %cloptr26738, i64 1 
  store volatile i64* %i0ptr26739, i64** %vptr26744, align 8 ; &cloptr26738[1]
 %vptr26745 = alloca i64, align 8 
  %f26741 = load i64, i64* %i0ptr26739, align 8 
  store volatile i64 %f26741, i64* %vptr26745, align 8 ; load; *i0ptr26739
  %fptr26740 = inttoptr i64 %f26741 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26740(i64 %h10401, i64 %h10401)                     ; tail call
  ret void

else26735:
 %vptr26746 = alloca i64, align 8 
  %dvI$_956899 = call i64 @prim_car(i64 %rvp10395) 
  store volatile i64 %dvI$_956899, i64* %vptr26746, align 8 ; call prim_car
 %vptr26747 = alloca i64, align 8 
  %na10391 = call i64 @prim_cdr(i64 %rvp10395) 
  store volatile i64 %na10391, i64* %vptr26747, align 8 ; call prim_cdr
 %vptr26748 = alloca i64, align 8 
  %n_6310396 = call i64 @prim_null_63(i64 %na10391) 
  store volatile i64 %n_6310396, i64* %vptr26748, align 8 ; call prim_null_63
  %cmpptr26752 = alloca i1, align 8  %cmp26749 = icmp eq i64 %n_6310396, 15 store volatile i1 %cmp26749, i1* %cmpptr26752, align 8; false?
  br i1 %cmp26749, label %else26751, label %then26750                                ; if

then26750:
 %vptr26753 = alloca i64, align 8 
  %rva10394 = add i64 0, 0 
  store volatile i64 %rva10394, i64* %vptr26753, align 8 ; quoted ()
 %vptr26754 = alloca i64, align 8 
  %rva10393 = call i64 @prim_cons(i64 %ClB$_37x, i64 %rva10394) 
  store volatile i64 %rva10393, i64* %vptr26754, align 8 ; call prim_cons
 %vptr26755 = alloca i64, align 8 
  %rva10392 = call i64 @prim_cons(i64 %cont7242, i64 %rva10393) 
  store volatile i64 %rva10392, i64* %vptr26755, align 8 ; call prim_cons
  %vptr26761 = alloca i64*, align 8 
  %cloptr26756 = inttoptr i64 %njK$_37k to i64* 
  store volatile i64* %cloptr26756, i64** %vptr26761, align 8 ; closure/env cast; i64 -> i64*
  %vptr26762 = alloca i64*, align 8 
  %i0ptr26757 = getelementptr inbounds i64, i64* %cloptr26756, i64 1 
  store volatile i64* %i0ptr26757, i64** %vptr26762, align 8 ; &cloptr26756[1]
 %vptr26763 = alloca i64, align 8 
  %f26759 = load i64, i64* %i0ptr26757, align 8 
  store volatile i64 %f26759, i64* %vptr26763, align 8 ; load; *i0ptr26757
  %fptr26758 = inttoptr i64 %f26759 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26758(i64 %njK$_37k, i64 %rva10392)                 ; tail call
  ret void

else26751:
 %vptr26764 = alloca i64, align 8 
  %h10397 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10397, i64* %vptr26764, align 8 ; call prim_halt
  %vptr26770 = alloca i64*, align 8 
  %cloptr26765 = inttoptr i64 %h10397 to i64* 
  store volatile i64* %cloptr26765, i64** %vptr26770, align 8 ; closure/env cast; i64 -> i64*
  %vptr26771 = alloca i64*, align 8 
  %i0ptr26766 = getelementptr inbounds i64, i64* %cloptr26765, i64 1 
  store volatile i64* %i0ptr26766, i64** %vptr26771, align 8 ; &cloptr26765[1]
 %vptr26772 = alloca i64, align 8 
  %f26768 = load i64, i64* %i0ptr26766, align 8 
  store volatile i64 %f26768, i64* %vptr26772, align 8 ; load; *i0ptr26766
  %fptr26767 = inttoptr i64 %f26768 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26767(i64 %h10397, i64 %h10397)                     ; tail call
  ret void
}


define void @lam11762(i64 %env11763, i64 %rvp10383) {
 %vptr26775 = alloca i64, align 8 
  %envptr26773 = inttoptr i64 %env11763 to i64* 
  store volatile i64 %emsg08636, i64* %vptr26775, align 8 ; closure/env cast; i64 -> i64*
  %vptr26776 = alloca i64*, align 8 
  %envptr26774 = getelementptr inbounds i64, i64* %envptr26773, i64 6 
  store volatile i64* %envptr26774, i64** %vptr26776, align 8 ; &envptr26773[5]
 %vptr26777 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr26774, align 8 
  store volatile i64 %emsg08636, i64* %vptr26777, align 8 ; load; *envptr26774
 %vptr26780 = alloca i64, align 8 
  %envptr26778 = inttoptr i64 %env11763 to i64* 
  store volatile i64 %cont7242, i64* %vptr26780, align 8 ; closure/env cast; i64 -> i64*
  %vptr26781 = alloca i64*, align 8 
  %envptr26779 = getelementptr inbounds i64, i64* %envptr26778, i64 5 
  store volatile i64* %envptr26779, i64** %vptr26781, align 8 ; &envptr26778[4]
 %vptr26782 = alloca i64, align 8 
  %cont7242 = load i64, i64* %envptr26779, align 8 
  store volatile i64 %cont7242, i64* %vptr26782, align 8 ; load; *envptr26779
 %vptr26785 = alloca i64, align 8 
  %envptr26783 = inttoptr i64 %env11763 to i64* 
  store volatile i64 %njK$_37k, i64* %vptr26785, align 8 ; closure/env cast; i64 -> i64*
  %vptr26786 = alloca i64*, align 8 
  %envptr26784 = getelementptr inbounds i64, i64* %envptr26783, i64 4 
  store volatile i64* %envptr26784, i64** %vptr26786, align 8 ; &envptr26783[3]
 %vptr26787 = alloca i64, align 8 
  %njK$_37k = load i64, i64* %envptr26784, align 8 
  store volatile i64 %njK$_37k, i64* %vptr26787, align 8 ; load; *envptr26784
 %vptr26790 = alloca i64, align 8 
  %envptr26788 = inttoptr i64 %env11763 to i64* 
  store volatile i64 %ClB$_37x, i64* %vptr26790, align 8 ; closure/env cast; i64 -> i64*
  %vptr26791 = alloca i64*, align 8 
  %envptr26789 = getelementptr inbounds i64, i64* %envptr26788, i64 3 
  store volatile i64* %envptr26789, i64** %vptr26791, align 8 ; &envptr26788[2]
 %vptr26792 = alloca i64, align 8 
  %ClB$_37x = load i64, i64* %envptr26789, align 8 
  store volatile i64 %ClB$_37x, i64* %vptr26792, align 8 ; load; *envptr26789
 %vptr26795 = alloca i64, align 8 
  %envptr26793 = inttoptr i64 %env11763 to i64* 
  store volatile i64 %emsg18637, i64* %vptr26795, align 8 ; closure/env cast; i64 -> i64*
  %vptr26796 = alloca i64*, align 8 
  %envptr26794 = getelementptr inbounds i64, i64* %envptr26793, i64 2 
  store volatile i64* %envptr26794, i64** %vptr26796, align 8 ; &envptr26793[1]
 %vptr26797 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr26794, align 8 
  store volatile i64 %emsg18637, i64* %vptr26797, align 8 ; load; *envptr26794
 %vptr26798 = alloca i64, align 8 
  %_957243 = call i64 @prim_car(i64 %rvp10383) 
  store volatile i64 %_957243, i64* %vptr26798, align 8 ; call prim_car
 %vptr26799 = alloca i64, align 8 
  %rvp10379 = call i64 @prim_cdr(i64 %rvp10383) 
  store volatile i64 %rvp10379, i64* %vptr26799, align 8 ; call prim_cdr
 %vptr26800 = alloca i64, align 8 
  %n_6310384 = call i64 @prim_null_63(i64 %rvp10379) 
  store volatile i64 %n_6310384, i64* %vptr26800, align 8 ; call prim_null_63
  %cmpptr26804 = alloca i1, align 8  %cmp26801 = icmp eq i64 %n_6310384, 15 store volatile i1 %cmp26801, i1* %cmpptr26804, align 8; false?
  br i1 %cmp26801, label %else26803, label %then26802                                ; if

then26802:
 %vptr26805 = alloca i64, align 8 
  %h10385 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10385, i64* %vptr26805, align 8 ; call prim_halt
  %vptr26811 = alloca i64*, align 8 
  %cloptr26806 = inttoptr i64 %h10385 to i64* 
  store volatile i64* %cloptr26806, i64** %vptr26811, align 8 ; closure/env cast; i64 -> i64*
  %vptr26812 = alloca i64*, align 8 
  %i0ptr26807 = getelementptr inbounds i64, i64* %cloptr26806, i64 1 
  store volatile i64* %i0ptr26807, i64** %vptr26812, align 8 ; &cloptr26806[1]
 %vptr26813 = alloca i64, align 8 
  %f26809 = load i64, i64* %i0ptr26807, align 8 
  store volatile i64 %f26809, i64* %vptr26813, align 8 ; load; *i0ptr26807
  %fptr26808 = inttoptr i64 %f26809 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26808(i64 %h10385, i64 %h10385)                     ; tail call
  ret void

else26803:
 %vptr26814 = alloca i64, align 8 
  %dvI$_956899 = call i64 @prim_car(i64 %rvp10379) 
  store volatile i64 %dvI$_956899, i64* %vptr26814, align 8 ; call prim_car
 %vptr26815 = alloca i64, align 8 
  %na10375 = call i64 @prim_cdr(i64 %rvp10379) 
  store volatile i64 %na10375, i64* %vptr26815, align 8 ; call prim_cdr
 %vptr26816 = alloca i64, align 8 
  %n_6310380 = call i64 @prim_null_63(i64 %na10375) 
  store volatile i64 %n_6310380, i64* %vptr26816, align 8 ; call prim_null_63
  %cmpptr26820 = alloca i1, align 8  %cmp26817 = icmp eq i64 %n_6310380, 15 store volatile i1 %cmp26817, i1* %cmpptr26820, align 8; false?
  br i1 %cmp26817, label %else26819, label %then26818                                ; if

then26818:
 %vptr26821 = alloca i64, align 8 
  %rva10378 = add i64 0, 0 
  store volatile i64 %rva10378, i64* %vptr26821, align 8 ; quoted ()
 %vptr26822 = alloca i64, align 8 
  %rva10377 = call i64 @prim_cons(i64 %ClB$_37x, i64 %rva10378) 
  store volatile i64 %rva10377, i64* %vptr26822, align 8 ; call prim_cons
 %vptr26823 = alloca i64, align 8 
  %rva10376 = call i64 @prim_cons(i64 %cont7242, i64 %rva10377) 
  store volatile i64 %rva10376, i64* %vptr26823, align 8 ; call prim_cons
  %vptr26829 = alloca i64*, align 8 
  %cloptr26824 = inttoptr i64 %njK$_37k to i64* 
  store volatile i64* %cloptr26824, i64** %vptr26829, align 8 ; closure/env cast; i64 -> i64*
  %vptr26830 = alloca i64*, align 8 
  %i0ptr26825 = getelementptr inbounds i64, i64* %cloptr26824, i64 1 
  store volatile i64* %i0ptr26825, i64** %vptr26830, align 8 ; &cloptr26824[1]
 %vptr26831 = alloca i64, align 8 
  %f26827 = load i64, i64* %i0ptr26825, align 8 
  store volatile i64 %f26827, i64* %vptr26831, align 8 ; load; *i0ptr26825
  %fptr26826 = inttoptr i64 %f26827 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26826(i64 %njK$_37k, i64 %rva10376)                 ; tail call
  ret void

else26819:
 %vptr26832 = alloca i64, align 8 
  %h10381 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10381, i64* %vptr26832, align 8 ; call prim_halt
  %vptr26838 = alloca i64*, align 8 
  %cloptr26833 = inttoptr i64 %h10381 to i64* 
  store volatile i64* %cloptr26833, i64** %vptr26838, align 8 ; closure/env cast; i64 -> i64*
  %vptr26839 = alloca i64*, align 8 
  %i0ptr26834 = getelementptr inbounds i64, i64* %cloptr26833, i64 1 
  store volatile i64* %i0ptr26834, i64** %vptr26839, align 8 ; &cloptr26833[1]
 %vptr26840 = alloca i64, align 8 
  %f26836 = load i64, i64* %i0ptr26834, align 8 
  store volatile i64 %f26836, i64* %vptr26840, align 8 ; load; *i0ptr26834
  %fptr26835 = inttoptr i64 %f26836 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26835(i64 %h10381, i64 %h10381)                     ; tail call
  ret void
}


define void @lam11756(i64 %env11757, i64 %rvp10436) {
 %vptr26843 = alloca i64, align 8 
  %envptr26841 = inttoptr i64 %env11757 to i64* 
  store volatile i64 %cont7229, i64* %vptr26843, align 8 ; closure/env cast; i64 -> i64*
  %vptr26844 = alloca i64*, align 8 
  %envptr26842 = getelementptr inbounds i64, i64* %envptr26841, i64 7 
  store volatile i64* %envptr26842, i64** %vptr26844, align 8 ; &envptr26841[6]
 %vptr26845 = alloca i64, align 8 
  %cont7229 = load i64, i64* %envptr26842, align 8 
  store volatile i64 %cont7229, i64* %vptr26845, align 8 ; load; *envptr26842
 %vptr26848 = alloca i64, align 8 
  %envptr26846 = inttoptr i64 %env11757 to i64* 
  store volatile i64 %a7067, i64* %vptr26848, align 8 ; closure/env cast; i64 -> i64*
  %vptr26849 = alloca i64*, align 8 
  %envptr26847 = getelementptr inbounds i64, i64* %envptr26846, i64 6 
  store volatile i64* %envptr26847, i64** %vptr26849, align 8 ; &envptr26846[5]
 %vptr26850 = alloca i64, align 8 
  %a7067 = load i64, i64* %envptr26847, align 8 
  store volatile i64 %a7067, i64* %vptr26850, align 8 ; load; *envptr26847
 %vptr26853 = alloca i64, align 8 
  %envptr26851 = inttoptr i64 %env11757 to i64* 
  store volatile i64 %emsg08636, i64* %vptr26853, align 8 ; closure/env cast; i64 -> i64*
  %vptr26854 = alloca i64*, align 8 
  %envptr26852 = getelementptr inbounds i64, i64* %envptr26851, i64 5 
  store volatile i64* %envptr26852, i64** %vptr26854, align 8 ; &envptr26851[4]
 %vptr26855 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr26852, align 8 
  store volatile i64 %emsg08636, i64* %vptr26855, align 8 ; load; *envptr26852
 %vptr26858 = alloca i64, align 8 
  %envptr26856 = inttoptr i64 %env11757 to i64* 
  store volatile i64 %a7074, i64* %vptr26858, align 8 ; closure/env cast; i64 -> i64*
  %vptr26859 = alloca i64*, align 8 
  %envptr26857 = getelementptr inbounds i64, i64* %envptr26856, i64 4 
  store volatile i64* %envptr26857, i64** %vptr26859, align 8 ; &envptr26856[3]
 %vptr26860 = alloca i64, align 8 
  %a7074 = load i64, i64* %envptr26857, align 8 
  store volatile i64 %a7074, i64* %vptr26860, align 8 ; load; *envptr26857
 %vptr26863 = alloca i64, align 8 
  %envptr26861 = inttoptr i64 %env11757 to i64* 
  store volatile i64 %ZpZ$c, i64* %vptr26863, align 8 ; closure/env cast; i64 -> i64*
  %vptr26864 = alloca i64*, align 8 
  %envptr26862 = getelementptr inbounds i64, i64* %envptr26861, i64 3 
  store volatile i64* %envptr26862, i64** %vptr26864, align 8 ; &envptr26861[2]
 %vptr26865 = alloca i64, align 8 
  %ZpZ$c = load i64, i64* %envptr26862, align 8 
  store volatile i64 %ZpZ$c, i64* %vptr26865, align 8 ; load; *envptr26862
 %vptr26868 = alloca i64, align 8 
  %envptr26866 = inttoptr i64 %env11757 to i64* 
  store volatile i64 %emsg18637, i64* %vptr26868, align 8 ; closure/env cast; i64 -> i64*
  %vptr26869 = alloca i64*, align 8 
  %envptr26867 = getelementptr inbounds i64, i64* %envptr26866, i64 2 
  store volatile i64* %envptr26867, i64** %vptr26869, align 8 ; &envptr26866[1]
 %vptr26870 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr26867, align 8 
  store volatile i64 %emsg18637, i64* %vptr26870, align 8 ; load; *envptr26867
 %vptr26871 = alloca i64, align 8 
  %_957236 = call i64 @prim_car(i64 %rvp10436) 
  store volatile i64 %_957236, i64* %vptr26871, align 8 ; call prim_car
 %vptr26872 = alloca i64, align 8 
  %rvp10432 = call i64 @prim_cdr(i64 %rvp10436) 
  store volatile i64 %rvp10432, i64* %vptr26872, align 8 ; call prim_cdr
 %vptr26873 = alloca i64, align 8 
  %n_6310437 = call i64 @prim_null_63(i64 %rvp10432) 
  store volatile i64 %n_6310437, i64* %vptr26873, align 8 ; call prim_null_63
  %cmpptr26877 = alloca i1, align 8  %cmp26874 = icmp eq i64 %n_6310437, 15 store volatile i1 %cmp26874, i1* %cmpptr26877, align 8; false?
  br i1 %cmp26874, label %else26876, label %then26875                                ; if

then26875:
 %vptr26878 = alloca i64, align 8 
  %h10438 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10438, i64* %vptr26878, align 8 ; call prim_halt
  %vptr26884 = alloca i64*, align 8 
  %cloptr26879 = inttoptr i64 %h10438 to i64* 
  store volatile i64* %cloptr26879, i64** %vptr26884, align 8 ; closure/env cast; i64 -> i64*
  %vptr26885 = alloca i64*, align 8 
  %i0ptr26880 = getelementptr inbounds i64, i64* %cloptr26879, i64 1 
  store volatile i64* %i0ptr26880, i64** %vptr26885, align 8 ; &cloptr26879[1]
 %vptr26886 = alloca i64, align 8 
  %f26882 = load i64, i64* %i0ptr26880, align 8 
  store volatile i64 %f26882, i64* %vptr26886, align 8 ; load; *i0ptr26880
  %fptr26881 = inttoptr i64 %f26882 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26881(i64 %h10438, i64 %h10438)                     ; tail call
  ret void

else26876:
 %vptr26887 = alloca i64, align 8 
  %a7083 = call i64 @prim_car(i64 %rvp10432) 
  store volatile i64 %a7083, i64* %vptr26887, align 8 ; call prim_car
 %vptr26888 = alloca i64, align 8 
  %na10426 = call i64 @prim_cdr(i64 %rvp10432) 
  store volatile i64 %na10426, i64* %vptr26888, align 8 ; call prim_cdr
 %vptr26889 = alloca i64, align 8 
  %n_6310433 = call i64 @prim_null_63(i64 %na10426) 
  store volatile i64 %n_6310433, i64* %vptr26889, align 8 ; call prim_null_63
  %cmpptr26893 = alloca i1, align 8  %cmp26890 = icmp eq i64 %n_6310433, 15 store volatile i1 %cmp26890, i1* %cmpptr26893, align 8; false?
  br i1 %cmp26890, label %else26892, label %then26891                                ; if

then26891:
 %vptr26894 = alloca i64, align 8 
  %rva10431 = add i64 0, 0 
  store volatile i64 %rva10431, i64* %vptr26894, align 8 ; quoted ()
 %vptr26895 = alloca i64, align 8 
  %rva10430 = call i64 @prim_cons(i64 %ZpZ$c, i64 %rva10431) 
  store volatile i64 %rva10430, i64* %vptr26895, align 8 ; call prim_cons
 %vptr26896 = alloca i64, align 8 
  %rva10429 = call i64 @prim_cons(i64 %a7083, i64 %rva10430) 
  store volatile i64 %rva10429, i64* %vptr26896, align 8 ; call prim_cons
 %vptr26897 = alloca i64, align 8 
  %rva10428 = call i64 @prim_cons(i64 %a7074, i64 %rva10429) 
  store volatile i64 %rva10428, i64* %vptr26897, align 8 ; call prim_cons
 %vptr26898 = alloca i64, align 8 
  %rva10427 = call i64 @prim_cons(i64 %cont7229, i64 %rva10428) 
  store volatile i64 %rva10427, i64* %vptr26898, align 8 ; call prim_cons
  %vptr26904 = alloca i64*, align 8 
  %cloptr26899 = inttoptr i64 %a7067 to i64* 
  store volatile i64* %cloptr26899, i64** %vptr26904, align 8 ; closure/env cast; i64 -> i64*
  %vptr26905 = alloca i64*, align 8 
  %i0ptr26900 = getelementptr inbounds i64, i64* %cloptr26899, i64 1 
  store volatile i64* %i0ptr26900, i64** %vptr26905, align 8 ; &cloptr26899[1]
 %vptr26906 = alloca i64, align 8 
  %f26902 = load i64, i64* %i0ptr26900, align 8 
  store volatile i64 %f26902, i64* %vptr26906, align 8 ; load; *i0ptr26900
  %fptr26901 = inttoptr i64 %f26902 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26901(i64 %a7067, i64 %rva10427)                    ; tail call
  ret void

else26892:
 %vptr26907 = alloca i64, align 8 
  %h10434 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10434, i64* %vptr26907, align 8 ; call prim_halt
  %vptr26913 = alloca i64*, align 8 
  %cloptr26908 = inttoptr i64 %h10434 to i64* 
  store volatile i64* %cloptr26908, i64** %vptr26913, align 8 ; closure/env cast; i64 -> i64*
  %vptr26914 = alloca i64*, align 8 
  %i0ptr26909 = getelementptr inbounds i64, i64* %cloptr26908, i64 1 
  store volatile i64* %i0ptr26909, i64** %vptr26914, align 8 ; &cloptr26908[1]
 %vptr26915 = alloca i64, align 8 
  %f26911 = load i64, i64* %i0ptr26909, align 8 
  store volatile i64 %f26911, i64* %vptr26915, align 8 ; load; *i0ptr26909
  %fptr26910 = inttoptr i64 %f26911 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26910(i64 %h10434, i64 %h10434)                     ; tail call
  ret void
}


define void @lam11753(i64 %env11754, i64 %rvp10451) {
 %vptr26918 = alloca i64, align 8 
  %envptr26916 = inttoptr i64 %env11754 to i64* 
  store volatile i64 %cont7229, i64* %vptr26918, align 8 ; closure/env cast; i64 -> i64*
  %vptr26919 = alloca i64*, align 8 
  %envptr26917 = getelementptr inbounds i64, i64* %envptr26916, i64 7 
  store volatile i64* %envptr26917, i64** %vptr26919, align 8 ; &envptr26916[6]
 %vptr26920 = alloca i64, align 8 
  %cont7229 = load i64, i64* %envptr26917, align 8 
  store volatile i64 %cont7229, i64* %vptr26920, align 8 ; load; *envptr26917
 %vptr26923 = alloca i64, align 8 
  %envptr26921 = inttoptr i64 %env11754 to i64* 
  store volatile i64 %a7067, i64* %vptr26923, align 8 ; closure/env cast; i64 -> i64*
  %vptr26924 = alloca i64*, align 8 
  %envptr26922 = getelementptr inbounds i64, i64* %envptr26921, i64 6 
  store volatile i64* %envptr26922, i64** %vptr26924, align 8 ; &envptr26921[5]
 %vptr26925 = alloca i64, align 8 
  %a7067 = load i64, i64* %envptr26922, align 8 
  store volatile i64 %a7067, i64* %vptr26925, align 8 ; load; *envptr26922
 %vptr26928 = alloca i64, align 8 
  %envptr26926 = inttoptr i64 %env11754 to i64* 
  store volatile i64 %emsg08636, i64* %vptr26928, align 8 ; closure/env cast; i64 -> i64*
  %vptr26929 = alloca i64*, align 8 
  %envptr26927 = getelementptr inbounds i64, i64* %envptr26926, i64 5 
  store volatile i64* %envptr26927, i64** %vptr26929, align 8 ; &envptr26926[4]
 %vptr26930 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr26927, align 8 
  store volatile i64 %emsg08636, i64* %vptr26930, align 8 ; load; *envptr26927
 %vptr26933 = alloca i64, align 8 
  %envptr26931 = inttoptr i64 %env11754 to i64* 
  store volatile i64 %a7074, i64* %vptr26933, align 8 ; closure/env cast; i64 -> i64*
  %vptr26934 = alloca i64*, align 8 
  %envptr26932 = getelementptr inbounds i64, i64* %envptr26931, i64 4 
  store volatile i64* %envptr26932, i64** %vptr26934, align 8 ; &envptr26931[3]
 %vptr26935 = alloca i64, align 8 
  %a7074 = load i64, i64* %envptr26932, align 8 
  store volatile i64 %a7074, i64* %vptr26935, align 8 ; load; *envptr26932
 %vptr26938 = alloca i64, align 8 
  %envptr26936 = inttoptr i64 %env11754 to i64* 
  store volatile i64 %ZpZ$c, i64* %vptr26938, align 8 ; closure/env cast; i64 -> i64*
  %vptr26939 = alloca i64*, align 8 
  %envptr26937 = getelementptr inbounds i64, i64* %envptr26936, i64 3 
  store volatile i64* %envptr26937, i64** %vptr26939, align 8 ; &envptr26936[2]
 %vptr26940 = alloca i64, align 8 
  %ZpZ$c = load i64, i64* %envptr26937, align 8 
  store volatile i64 %ZpZ$c, i64* %vptr26940, align 8 ; load; *envptr26937
 %vptr26943 = alloca i64, align 8 
  %envptr26941 = inttoptr i64 %env11754 to i64* 
  store volatile i64 %emsg18637, i64* %vptr26943, align 8 ; closure/env cast; i64 -> i64*
  %vptr26944 = alloca i64*, align 8 
  %envptr26942 = getelementptr inbounds i64, i64* %envptr26941, i64 2 
  store volatile i64* %envptr26942, i64** %vptr26944, align 8 ; &envptr26941[1]
 %vptr26945 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr26942, align 8 
  store volatile i64 %emsg18637, i64* %vptr26945, align 8 ; load; *envptr26942
 %vptr26946 = alloca i64, align 8 
  %_957236 = call i64 @prim_car(i64 %rvp10451) 
  store volatile i64 %_957236, i64* %vptr26946, align 8 ; call prim_car
 %vptr26947 = alloca i64, align 8 
  %rvp10447 = call i64 @prim_cdr(i64 %rvp10451) 
  store volatile i64 %rvp10447, i64* %vptr26947, align 8 ; call prim_cdr
 %vptr26948 = alloca i64, align 8 
  %n_6310452 = call i64 @prim_null_63(i64 %rvp10447) 
  store volatile i64 %n_6310452, i64* %vptr26948, align 8 ; call prim_null_63
  %cmpptr26952 = alloca i1, align 8  %cmp26949 = icmp eq i64 %n_6310452, 15 store volatile i1 %cmp26949, i1* %cmpptr26952, align 8; false?
  br i1 %cmp26949, label %else26951, label %then26950                                ; if

then26950:
 %vptr26953 = alloca i64, align 8 
  %h10453 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10453, i64* %vptr26953, align 8 ; call prim_halt
  %vptr26959 = alloca i64*, align 8 
  %cloptr26954 = inttoptr i64 %h10453 to i64* 
  store volatile i64* %cloptr26954, i64** %vptr26959, align 8 ; closure/env cast; i64 -> i64*
  %vptr26960 = alloca i64*, align 8 
  %i0ptr26955 = getelementptr inbounds i64, i64* %cloptr26954, i64 1 
  store volatile i64* %i0ptr26955, i64** %vptr26960, align 8 ; &cloptr26954[1]
 %vptr26961 = alloca i64, align 8 
  %f26957 = load i64, i64* %i0ptr26955, align 8 
  store volatile i64 %f26957, i64* %vptr26961, align 8 ; load; *i0ptr26955
  %fptr26956 = inttoptr i64 %f26957 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26956(i64 %h10453, i64 %h10453)                     ; tail call
  ret void

else26951:
 %vptr26962 = alloca i64, align 8 
  %a7083 = call i64 @prim_car(i64 %rvp10447) 
  store volatile i64 %a7083, i64* %vptr26962, align 8 ; call prim_car
 %vptr26963 = alloca i64, align 8 
  %na10441 = call i64 @prim_cdr(i64 %rvp10447) 
  store volatile i64 %na10441, i64* %vptr26963, align 8 ; call prim_cdr
 %vptr26964 = alloca i64, align 8 
  %n_6310448 = call i64 @prim_null_63(i64 %na10441) 
  store volatile i64 %n_6310448, i64* %vptr26964, align 8 ; call prim_null_63
  %cmpptr26968 = alloca i1, align 8  %cmp26965 = icmp eq i64 %n_6310448, 15 store volatile i1 %cmp26965, i1* %cmpptr26968, align 8; false?
  br i1 %cmp26965, label %else26967, label %then26966                                ; if

then26966:
 %vptr26969 = alloca i64, align 8 
  %rva10446 = add i64 0, 0 
  store volatile i64 %rva10446, i64* %vptr26969, align 8 ; quoted ()
 %vptr26970 = alloca i64, align 8 
  %rva10445 = call i64 @prim_cons(i64 %ZpZ$c, i64 %rva10446) 
  store volatile i64 %rva10445, i64* %vptr26970, align 8 ; call prim_cons
 %vptr26971 = alloca i64, align 8 
  %rva10444 = call i64 @prim_cons(i64 %a7083, i64 %rva10445) 
  store volatile i64 %rva10444, i64* %vptr26971, align 8 ; call prim_cons
 %vptr26972 = alloca i64, align 8 
  %rva10443 = call i64 @prim_cons(i64 %a7074, i64 %rva10444) 
  store volatile i64 %rva10443, i64* %vptr26972, align 8 ; call prim_cons
 %vptr26973 = alloca i64, align 8 
  %rva10442 = call i64 @prim_cons(i64 %cont7229, i64 %rva10443) 
  store volatile i64 %rva10442, i64* %vptr26973, align 8 ; call prim_cons
  %vptr26979 = alloca i64*, align 8 
  %cloptr26974 = inttoptr i64 %a7067 to i64* 
  store volatile i64* %cloptr26974, i64** %vptr26979, align 8 ; closure/env cast; i64 -> i64*
  %vptr26980 = alloca i64*, align 8 
  %i0ptr26975 = getelementptr inbounds i64, i64* %cloptr26974, i64 1 
  store volatile i64* %i0ptr26975, i64** %vptr26980, align 8 ; &cloptr26974[1]
 %vptr26981 = alloca i64, align 8 
  %f26977 = load i64, i64* %i0ptr26975, align 8 
  store volatile i64 %f26977, i64* %vptr26981, align 8 ; load; *i0ptr26975
  %fptr26976 = inttoptr i64 %f26977 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26976(i64 %a7067, i64 %rva10442)                    ; tail call
  ret void

else26967:
 %vptr26982 = alloca i64, align 8 
  %h10449 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10449, i64* %vptr26982, align 8 ; call prim_halt
  %vptr26988 = alloca i64*, align 8 
  %cloptr26983 = inttoptr i64 %h10449 to i64* 
  store volatile i64* %cloptr26983, i64** %vptr26988, align 8 ; closure/env cast; i64 -> i64*
  %vptr26989 = alloca i64*, align 8 
  %i0ptr26984 = getelementptr inbounds i64, i64* %cloptr26983, i64 1 
  store volatile i64* %i0ptr26984, i64** %vptr26989, align 8 ; &cloptr26983[1]
 %vptr26990 = alloca i64, align 8 
  %f26986 = load i64, i64* %i0ptr26984, align 8 
  store volatile i64 %f26986, i64* %vptr26990, align 8 ; load; *i0ptr26984
  %fptr26985 = inttoptr i64 %f26986 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr26985(i64 %h10449, i64 %h10449)                     ; tail call
  ret void
}


define void @lam11747(i64 %env11748, i64 %rvp10062) {
 %vptr26993 = alloca i64, align 8 
  %envptr26991 = inttoptr i64 %env11748 to i64* 
  store volatile i64 %cont7229, i64* %vptr26993, align 8 ; closure/env cast; i64 -> i64*
  %vptr26994 = alloca i64*, align 8 
  %envptr26992 = getelementptr inbounds i64, i64* %envptr26991, i64 5 
  store volatile i64* %envptr26992, i64** %vptr26994, align 8 ; &envptr26991[4]
 %vptr26995 = alloca i64, align 8 
  %cont7229 = load i64, i64* %envptr26992, align 8 
  store volatile i64 %cont7229, i64* %vptr26995, align 8 ; load; *envptr26992
 %vptr26998 = alloca i64, align 8 
  %envptr26996 = inttoptr i64 %env11748 to i64* 
  store volatile i64 %emsg08636, i64* %vptr26998, align 8 ; closure/env cast; i64 -> i64*
  %vptr26999 = alloca i64*, align 8 
  %envptr26997 = getelementptr inbounds i64, i64* %envptr26996, i64 4 
  store volatile i64* %envptr26997, i64** %vptr26999, align 8 ; &envptr26996[3]
 %vptr27000 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr26997, align 8 
  store volatile i64 %emsg08636, i64* %vptr27000, align 8 ; load; *envptr26997
 %vptr27003 = alloca i64, align 8 
  %envptr27001 = inttoptr i64 %env11748 to i64* 
  store volatile i64 %ZpZ$c, i64* %vptr27003, align 8 ; closure/env cast; i64 -> i64*
  %vptr27004 = alloca i64*, align 8 
  %envptr27002 = getelementptr inbounds i64, i64* %envptr27001, i64 3 
  store volatile i64* %envptr27002, i64** %vptr27004, align 8 ; &envptr27001[2]
 %vptr27005 = alloca i64, align 8 
  %ZpZ$c = load i64, i64* %envptr27002, align 8 
  store volatile i64 %ZpZ$c, i64* %vptr27005, align 8 ; load; *envptr27002
 %vptr27008 = alloca i64, align 8 
  %envptr27006 = inttoptr i64 %env11748 to i64* 
  store volatile i64 %emsg18637, i64* %vptr27008, align 8 ; closure/env cast; i64 -> i64*
  %vptr27009 = alloca i64*, align 8 
  %envptr27007 = getelementptr inbounds i64, i64* %envptr27006, i64 2 
  store volatile i64* %envptr27007, i64** %vptr27009, align 8 ; &envptr27006[1]
 %vptr27010 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr27007, align 8 
  store volatile i64 %emsg18637, i64* %vptr27010, align 8 ; load; *envptr27007
 %vptr27011 = alloca i64, align 8 
  %_957234 = call i64 @prim_car(i64 %rvp10062) 
  store volatile i64 %_957234, i64* %vptr27011, align 8 ; call prim_car
 %vptr27012 = alloca i64, align 8 
  %rvp10058 = call i64 @prim_cdr(i64 %rvp10062) 
  store volatile i64 %rvp10058, i64* %vptr27012, align 8 ; call prim_cdr
 %vptr27013 = alloca i64, align 8 
  %n_6310063 = call i64 @prim_null_63(i64 %rvp10058) 
  store volatile i64 %n_6310063, i64* %vptr27013, align 8 ; call prim_null_63
  %cmpptr27017 = alloca i1, align 8  %cmp27014 = icmp eq i64 %n_6310063, 15 store volatile i1 %cmp27014, i1* %cmpptr27017, align 8; false?
  br i1 %cmp27014, label %else27016, label %then27015                                ; if

then27015:
 %vptr27018 = alloca i64, align 8 
  %h10064 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10064, i64* %vptr27018, align 8 ; call prim_halt
  %vptr27024 = alloca i64*, align 8 
  %cloptr27019 = inttoptr i64 %h10064 to i64* 
  store volatile i64* %cloptr27019, i64** %vptr27024, align 8 ; closure/env cast; i64 -> i64*
  %vptr27025 = alloca i64*, align 8 
  %i0ptr27020 = getelementptr inbounds i64, i64* %cloptr27019, i64 1 
  store volatile i64* %i0ptr27020, i64** %vptr27025, align 8 ; &cloptr27019[1]
 %vptr27026 = alloca i64, align 8 
  %f27022 = load i64, i64* %i0ptr27020, align 8 
  store volatile i64 %f27022, i64* %vptr27026, align 8 ; load; *i0ptr27020
  %fptr27021 = inttoptr i64 %f27022 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27021(i64 %h10064, i64 %h10064)                     ; tail call
  ret void

else27016:
 %vptr27027 = alloca i64, align 8 
  %a7066 = call i64 @prim_car(i64 %rvp10058) 
  store volatile i64 %a7066, i64* %vptr27027, align 8 ; call prim_car
 %vptr27028 = alloca i64, align 8 
  %na10054 = call i64 @prim_cdr(i64 %rvp10058) 
  store volatile i64 %na10054, i64* %vptr27028, align 8 ; call prim_cdr
 %vptr27029 = alloca i64, align 8 
  %n_6310059 = call i64 @prim_null_63(i64 %na10054) 
  store volatile i64 %n_6310059, i64* %vptr27029, align 8 ; call prim_null_63
  %cmpptr27033 = alloca i1, align 8  %cmp27030 = icmp eq i64 %n_6310059, 15 store volatile i1 %cmp27030, i1* %cmpptr27033, align 8; false?
  br i1 %cmp27030, label %else27032, label %then27031                                ; if

then27031:
 %vptr27034 = alloca i64, align 8 
  %rva10057 = add i64 0, 0 
  store volatile i64 %rva10057, i64* %vptr27034, align 8 ; quoted ()
 %vptr27035 = alloca i64, align 8 
  %rva10056 = call i64 @prim_cons(i64 %a7066, i64 %rva10057) 
  store volatile i64 %rva10056, i64* %vptr27035, align 8 ; call prim_cons
 %vptr27036 = alloca i64, align 8 
  %rva10055 = call i64 @prim_cons(i64 %cont7229, i64 %rva10056) 
  store volatile i64 %rva10055, i64* %vptr27036, align 8 ; call prim_cons
  %vptr27042 = alloca i64*, align 8 
  %cloptr27037 = inttoptr i64 %ZpZ$c to i64* 
  store volatile i64* %cloptr27037, i64** %vptr27042, align 8 ; closure/env cast; i64 -> i64*
  %vptr27043 = alloca i64*, align 8 
  %i0ptr27038 = getelementptr inbounds i64, i64* %cloptr27037, i64 1 
  store volatile i64* %i0ptr27038, i64** %vptr27043, align 8 ; &cloptr27037[1]
 %vptr27044 = alloca i64, align 8 
  %f27040 = load i64, i64* %i0ptr27038, align 8 
  store volatile i64 %f27040, i64* %vptr27044, align 8 ; load; *i0ptr27038
  %fptr27039 = inttoptr i64 %f27040 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27039(i64 %ZpZ$c, i64 %rva10055)                    ; tail call
  ret void

else27032:
 %vptr27045 = alloca i64, align 8 
  %h10060 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10060, i64* %vptr27045, align 8 ; call prim_halt
  %vptr27051 = alloca i64*, align 8 
  %cloptr27046 = inttoptr i64 %h10060 to i64* 
  store volatile i64* %cloptr27046, i64** %vptr27051, align 8 ; closure/env cast; i64 -> i64*
  %vptr27052 = alloca i64*, align 8 
  %i0ptr27047 = getelementptr inbounds i64, i64* %cloptr27046, i64 1 
  store volatile i64* %i0ptr27047, i64** %vptr27052, align 8 ; &cloptr27046[1]
 %vptr27053 = alloca i64, align 8 
  %f27049 = load i64, i64* %i0ptr27047, align 8 
  store volatile i64 %f27049, i64* %vptr27053, align 8 ; load; *i0ptr27047
  %fptr27048 = inttoptr i64 %f27049 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27048(i64 %h10060, i64 %h10060)                     ; tail call
  ret void
}


define void @lam11739(i64 %env11740, i64 %rvp10042) {
 %vptr27056 = alloca i64, align 8 
  %envptr27054 = inttoptr i64 %env11740 to i64* 
  store volatile i64 %cont7229, i64* %vptr27056, align 8 ; closure/env cast; i64 -> i64*
  %vptr27057 = alloca i64*, align 8 
  %envptr27055 = getelementptr inbounds i64, i64* %envptr27054, i64 5 
  store volatile i64* %envptr27055, i64** %vptr27057, align 8 ; &envptr27054[4]
 %vptr27058 = alloca i64, align 8 
  %cont7229 = load i64, i64* %envptr27055, align 8 
  store volatile i64 %cont7229, i64* %vptr27058, align 8 ; load; *envptr27055
 %vptr27061 = alloca i64, align 8 
  %envptr27059 = inttoptr i64 %env11740 to i64* 
  store volatile i64 %emsg08636, i64* %vptr27061, align 8 ; closure/env cast; i64 -> i64*
  %vptr27062 = alloca i64*, align 8 
  %envptr27060 = getelementptr inbounds i64, i64* %envptr27059, i64 4 
  store volatile i64* %envptr27060, i64** %vptr27062, align 8 ; &envptr27059[3]
 %vptr27063 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr27060, align 8 
  store volatile i64 %emsg08636, i64* %vptr27063, align 8 ; load; *envptr27060
 %vptr27066 = alloca i64, align 8 
  %envptr27064 = inttoptr i64 %env11740 to i64* 
  store volatile i64 %ZpZ$c, i64* %vptr27066, align 8 ; closure/env cast; i64 -> i64*
  %vptr27067 = alloca i64*, align 8 
  %envptr27065 = getelementptr inbounds i64, i64* %envptr27064, i64 3 
  store volatile i64* %envptr27065, i64** %vptr27067, align 8 ; &envptr27064[2]
 %vptr27068 = alloca i64, align 8 
  %ZpZ$c = load i64, i64* %envptr27065, align 8 
  store volatile i64 %ZpZ$c, i64* %vptr27068, align 8 ; load; *envptr27065
 %vptr27071 = alloca i64, align 8 
  %envptr27069 = inttoptr i64 %env11740 to i64* 
  store volatile i64 %emsg18637, i64* %vptr27071, align 8 ; closure/env cast; i64 -> i64*
  %vptr27072 = alloca i64*, align 8 
  %envptr27070 = getelementptr inbounds i64, i64* %envptr27069, i64 2 
  store volatile i64* %envptr27070, i64** %vptr27072, align 8 ; &envptr27069[1]
 %vptr27073 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr27070, align 8 
  store volatile i64 %emsg18637, i64* %vptr27073, align 8 ; load; *envptr27070
 %vptr27074 = alloca i64, align 8 
  %_957231 = call i64 @prim_car(i64 %rvp10042) 
  store volatile i64 %_957231, i64* %vptr27074, align 8 ; call prim_car
 %vptr27075 = alloca i64, align 8 
  %rvp10038 = call i64 @prim_cdr(i64 %rvp10042) 
  store volatile i64 %rvp10038, i64* %vptr27075, align 8 ; call prim_cdr
 %vptr27076 = alloca i64, align 8 
  %n_6310043 = call i64 @prim_null_63(i64 %rvp10038) 
  store volatile i64 %n_6310043, i64* %vptr27076, align 8 ; call prim_null_63
  %cmpptr27080 = alloca i1, align 8  %cmp27077 = icmp eq i64 %n_6310043, 15 store volatile i1 %cmp27077, i1* %cmpptr27080, align 8; false?
  br i1 %cmp27077, label %else27079, label %then27078                                ; if

then27078:
 %vptr27081 = alloca i64, align 8 
  %h10044 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10044, i64* %vptr27081, align 8 ; call prim_halt
  %vptr27087 = alloca i64*, align 8 
  %cloptr27082 = inttoptr i64 %h10044 to i64* 
  store volatile i64* %cloptr27082, i64** %vptr27087, align 8 ; closure/env cast; i64 -> i64*
  %vptr27088 = alloca i64*, align 8 
  %i0ptr27083 = getelementptr inbounds i64, i64* %cloptr27082, i64 1 
  store volatile i64* %i0ptr27083, i64** %vptr27088, align 8 ; &cloptr27082[1]
 %vptr27089 = alloca i64, align 8 
  %f27085 = load i64, i64* %i0ptr27083, align 8 
  store volatile i64 %f27085, i64* %vptr27089, align 8 ; load; *i0ptr27083
  %fptr27084 = inttoptr i64 %f27085 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27084(i64 %h10044, i64 %h10044)                     ; tail call
  ret void

else27079:
 %vptr27090 = alloca i64, align 8 
  %a7060 = call i64 @prim_car(i64 %rvp10038) 
  store volatile i64 %a7060, i64* %vptr27090, align 8 ; call prim_car
 %vptr27091 = alloca i64, align 8 
  %na10034 = call i64 @prim_cdr(i64 %rvp10038) 
  store volatile i64 %na10034, i64* %vptr27091, align 8 ; call prim_cdr
 %vptr27092 = alloca i64, align 8 
  %n_6310039 = call i64 @prim_null_63(i64 %na10034) 
  store volatile i64 %n_6310039, i64* %vptr27092, align 8 ; call prim_null_63
  %cmpptr27096 = alloca i1, align 8  %cmp27093 = icmp eq i64 %n_6310039, 15 store volatile i1 %cmp27093, i1* %cmpptr27096, align 8; false?
  br i1 %cmp27093, label %else27095, label %then27094                                ; if

then27094:
 %vptr27097 = alloca i64, align 8 
  %rva10037 = add i64 0, 0 
  store volatile i64 %rva10037, i64* %vptr27097, align 8 ; quoted ()
 %vptr27098 = alloca i64, align 8 
  %rva10036 = call i64 @prim_cons(i64 %a7060, i64 %rva10037) 
  store volatile i64 %rva10036, i64* %vptr27098, align 8 ; call prim_cons
 %vptr27099 = alloca i64, align 8 
  %rva10035 = call i64 @prim_cons(i64 %cont7229, i64 %rva10036) 
  store volatile i64 %rva10035, i64* %vptr27099, align 8 ; call prim_cons
  %vptr27105 = alloca i64*, align 8 
  %cloptr27100 = inttoptr i64 %ZpZ$c to i64* 
  store volatile i64* %cloptr27100, i64** %vptr27105, align 8 ; closure/env cast; i64 -> i64*
  %vptr27106 = alloca i64*, align 8 
  %i0ptr27101 = getelementptr inbounds i64, i64* %cloptr27100, i64 1 
  store volatile i64* %i0ptr27101, i64** %vptr27106, align 8 ; &cloptr27100[1]
 %vptr27107 = alloca i64, align 8 
  %f27103 = load i64, i64* %i0ptr27101, align 8 
  store volatile i64 %f27103, i64* %vptr27107, align 8 ; load; *i0ptr27101
  %fptr27102 = inttoptr i64 %f27103 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27102(i64 %ZpZ$c, i64 %rva10035)                    ; tail call
  ret void

else27095:
 %vptr27108 = alloca i64, align 8 
  %h10040 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10040, i64* %vptr27108, align 8 ; call prim_halt
  %vptr27114 = alloca i64*, align 8 
  %cloptr27109 = inttoptr i64 %h10040 to i64* 
  store volatile i64* %cloptr27109, i64** %vptr27114, align 8 ; closure/env cast; i64 -> i64*
  %vptr27115 = alloca i64*, align 8 
  %i0ptr27110 = getelementptr inbounds i64, i64* %cloptr27109, i64 1 
  store volatile i64* %i0ptr27110, i64** %vptr27115, align 8 ; &cloptr27109[1]
 %vptr27116 = alloca i64, align 8 
  %f27112 = load i64, i64* %i0ptr27110, align 8 
  store volatile i64 %f27112, i64* %vptr27116, align 8 ; load; *i0ptr27110
  %fptr27111 = inttoptr i64 %f27112 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27111(i64 %h10040, i64 %h10040)                     ; tail call
  ret void
}


define void @lam11724(i64 %env11725, i64 %rvp10549) {
 %vptr27119 = alloca i64, align 8 
  %envptr27117 = inttoptr i64 %env11725 to i64* 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr27119, align 8 ; closure/env cast; i64 -> i64*
  %vptr27120 = alloca i64*, align 8 
  %envptr27118 = getelementptr inbounds i64, i64* %envptr27117, i64 5 
  store volatile i64* %envptr27118, i64** %vptr27120, align 8 ; &envptr27117[4]
 %vptr27121 = alloca i64, align 8 
  %Iic$peano_45_62nat = load i64, i64* %envptr27118, align 8 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr27121, align 8 ; load; *envptr27118
 %vptr27124 = alloca i64, align 8 
  %envptr27122 = inttoptr i64 %env11725 to i64* 
  store volatile i64 %a7084, i64* %vptr27124, align 8 ; closure/env cast; i64 -> i64*
  %vptr27125 = alloca i64*, align 8 
  %envptr27123 = getelementptr inbounds i64, i64* %envptr27122, i64 4 
  store volatile i64* %envptr27123, i64** %vptr27125, align 8 ; &envptr27122[3]
 %vptr27126 = alloca i64, align 8 
  %a7084 = load i64, i64* %envptr27123, align 8 
  store volatile i64 %a7084, i64* %vptr27126, align 8 ; load; *envptr27123
 %vptr27129 = alloca i64, align 8 
  %envptr27127 = inttoptr i64 %env11725 to i64* 
  store volatile i64 %emsg08636, i64* %vptr27129, align 8 ; closure/env cast; i64 -> i64*
  %vptr27130 = alloca i64*, align 8 
  %envptr27128 = getelementptr inbounds i64, i64* %envptr27127, i64 3 
  store volatile i64* %envptr27128, i64** %vptr27130, align 8 ; &envptr27127[2]
 %vptr27131 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr27128, align 8 
  store volatile i64 %emsg08636, i64* %vptr27131, align 8 ; load; *envptr27128
 %vptr27134 = alloca i64, align 8 
  %envptr27132 = inttoptr i64 %env11725 to i64* 
  store volatile i64 %emsg18637, i64* %vptr27134, align 8 ; closure/env cast; i64 -> i64*
  %vptr27135 = alloca i64*, align 8 
  %envptr27133 = getelementptr inbounds i64, i64* %envptr27132, i64 2 
  store volatile i64* %envptr27133, i64** %vptr27135, align 8 ; &envptr27132[1]
 %vptr27136 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr27133, align 8 
  store volatile i64 %emsg18637, i64* %vptr27136, align 8 ; load; *envptr27133
 %vptr27137 = alloca i64, align 8 
  %_957252 = call i64 @prim_car(i64 %rvp10549) 
  store volatile i64 %_957252, i64* %vptr27137, align 8 ; call prim_car
 %vptr27138 = alloca i64, align 8 
  %rvp10545 = call i64 @prim_cdr(i64 %rvp10549) 
  store volatile i64 %rvp10545, i64* %vptr27138, align 8 ; call prim_cdr
 %vptr27139 = alloca i64, align 8 
  %n_6310550 = call i64 @prim_null_63(i64 %rvp10545) 
  store volatile i64 %n_6310550, i64* %vptr27139, align 8 ; call prim_null_63
  %cmpptr27143 = alloca i1, align 8  %cmp27140 = icmp eq i64 %n_6310550, 15 store volatile i1 %cmp27140, i1* %cmpptr27143, align 8; false?
  br i1 %cmp27140, label %else27142, label %then27141                                ; if

then27141:
 %vptr27144 = alloca i64, align 8 
  %h10551 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10551, i64* %vptr27144, align 8 ; call prim_halt
  %vptr27150 = alloca i64*, align 8 
  %cloptr27145 = inttoptr i64 %h10551 to i64* 
  store volatile i64* %cloptr27145, i64** %vptr27150, align 8 ; closure/env cast; i64 -> i64*
  %vptr27151 = alloca i64*, align 8 
  %i0ptr27146 = getelementptr inbounds i64, i64* %cloptr27145, i64 1 
  store volatile i64* %i0ptr27146, i64** %vptr27151, align 8 ; &cloptr27145[1]
 %vptr27152 = alloca i64, align 8 
  %f27148 = load i64, i64* %i0ptr27146, align 8 
  store volatile i64 %f27148, i64* %vptr27152, align 8 ; load; *i0ptr27146
  %fptr27147 = inttoptr i64 %f27148 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27147(i64 %h10551, i64 %h10551)                     ; tail call
  ret void

else27142:
 %vptr27153 = alloca i64, align 8 
  %a7086 = call i64 @prim_car(i64 %rvp10545) 
  store volatile i64 %a7086, i64* %vptr27153, align 8 ; call prim_car
 %vptr27154 = alloca i64, align 8 
  %na10515 = call i64 @prim_cdr(i64 %rvp10545) 
  store volatile i64 %na10515, i64* %vptr27154, align 8 ; call prim_cdr
 %vptr27155 = alloca i64, align 8 
  %n_6310546 = call i64 @prim_null_63(i64 %na10515) 
  store volatile i64 %n_6310546, i64* %vptr27155, align 8 ; call prim_null_63
  %cmpptr27159 = alloca i1, align 8  %cmp27156 = icmp eq i64 %n_6310546, 15 store volatile i1 %cmp27156, i1* %cmpptr27159, align 8; false?
  br i1 %cmp27156, label %else27158, label %then27157                                ; if

then27157:
  %vptr27165 = alloca i64*, align 8 
  %cloptr27160 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr27160, i64** %vptr27165, align 8 ; malloc
  %vptr27166 = alloca i64*, align 8 
  %eptr27162 = getelementptr inbounds i64, i64* %cloptr27160, i64 2 
  store volatile i64* %eptr27162, i64** %vptr27166, align 8 ; &eptr27162[1]
  %vptr27167 = alloca i64*, align 8 
  %eptr27163 = getelementptr inbounds i64, i64* %cloptr27160, i64 3 
  store volatile i64* %eptr27163, i64** %vptr27167, align 8 ; &eptr27163[2]
  store i64 %emsg18637, i64* %eptr27162                                              ; *eptr27162 = %emsg18637
  store i64 %emsg08636, i64* %eptr27163                                              ; *eptr27163 = %emsg08636
  %vptr27168 = alloca i64*, align 8 
  %eptr27161 = getelementptr inbounds i64, i64* %cloptr27160, i64 1 
  store volatile i64* %eptr27161, i64** %vptr27168, align 8 ; &cloptr27160[1]
 %vptr27169 = alloca i64, align 8 
  %f27164 = ptrtoint void(i64,i64)* @lam11722 to i64 
  store volatile i64 %f27164, i64* %vptr27169, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f27164, i64* %eptr27161                                                 ; store fptr
 %vptr27170 = alloca i64, align 8 
  %arg8378 = ptrtoint i64* %cloptr27160 to i64 
  store volatile i64 %arg8378, i64* %vptr27170, align 8 ; closure cast; i64* -> i64
  %vptr27177 = alloca i64*, align 8 
  %cloptr27171 = call i64* @make_closure(i64 32) 
  store volatile i64* %cloptr27171, i64** %vptr27177, align 8 ; malloc
  %vptr27178 = alloca i64*, align 8 
  %eptr27173 = getelementptr inbounds i64, i64* %cloptr27171, i64 2 
  store volatile i64* %eptr27173, i64** %vptr27178, align 8 ; &eptr27173[1]
  %vptr27179 = alloca i64*, align 8 
  %eptr27174 = getelementptr inbounds i64, i64* %cloptr27171, i64 3 
  store volatile i64* %eptr27174, i64** %vptr27179, align 8 ; &eptr27174[2]
  %vptr27180 = alloca i64*, align 8 
  %eptr27175 = getelementptr inbounds i64, i64* %cloptr27171, i64 4 
  store volatile i64* %eptr27175, i64** %vptr27180, align 8 ; &eptr27175[3]
  store i64 %emsg18637, i64* %eptr27173                                              ; *eptr27173 = %emsg18637
  store i64 %emsg08636, i64* %eptr27174                                              ; *eptr27174 = %emsg08636
  store i64 %Iic$peano_45_62nat, i64* %eptr27175                                     ; *eptr27175 = %Iic$peano_45_62nat
  %vptr27181 = alloca i64*, align 8 
  %eptr27172 = getelementptr inbounds i64, i64* %cloptr27171, i64 1 
  store volatile i64* %eptr27172, i64** %vptr27181, align 8 ; &cloptr27171[1]
 %vptr27182 = alloca i64, align 8 
  %f27176 = ptrtoint void(i64,i64)* @lam11719 to i64 
  store volatile i64 %f27176, i64* %vptr27182, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f27176, i64* %eptr27172                                                 ; store fptr
 %vptr27183 = alloca i64, align 8 
  %arg8376 = ptrtoint i64* %cloptr27171 to i64 
  store volatile i64 %arg8376, i64* %vptr27183, align 8 ; closure cast; i64* -> i64
 %vptr27184 = alloca i64, align 8 
  %rva10544 = add i64 0, 0 
  store volatile i64 %rva10544, i64* %vptr27184, align 8 ; quoted ()
 %vptr27185 = alloca i64, align 8 
  %rva10543 = call i64 @prim_cons(i64 %arg8376, i64 %rva10544) 
  store volatile i64 %rva10543, i64* %vptr27185, align 8 ; call prim_cons
 %vptr27186 = alloca i64, align 8 
  %rva10542 = call i64 @prim_cons(i64 %a7086, i64 %rva10543) 
  store volatile i64 %rva10542, i64* %vptr27186, align 8 ; call prim_cons
 %vptr27187 = alloca i64, align 8 
  %rva10541 = call i64 @prim_cons(i64 %arg8378, i64 %rva10542) 
  store volatile i64 %rva10541, i64* %vptr27187, align 8 ; call prim_cons
  %vptr27193 = alloca i64*, align 8 
  %cloptr27188 = inttoptr i64 %a7084 to i64* 
  store volatile i64* %cloptr27188, i64** %vptr27193, align 8 ; closure/env cast; i64 -> i64*
  %vptr27194 = alloca i64*, align 8 
  %i0ptr27189 = getelementptr inbounds i64, i64* %cloptr27188, i64 1 
  store volatile i64* %i0ptr27189, i64** %vptr27194, align 8 ; &cloptr27188[1]
 %vptr27195 = alloca i64, align 8 
  %f27191 = load i64, i64* %i0ptr27189, align 8 
  store volatile i64 %f27191, i64* %vptr27195, align 8 ; load; *i0ptr27189
  %fptr27190 = inttoptr i64 %f27191 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27190(i64 %a7084, i64 %rva10541)                    ; tail call
  ret void

else27158:
 %vptr27196 = alloca i64, align 8 
  %h10547 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10547, i64* %vptr27196, align 8 ; call prim_halt
  %vptr27202 = alloca i64*, align 8 
  %cloptr27197 = inttoptr i64 %h10547 to i64* 
  store volatile i64* %cloptr27197, i64** %vptr27202, align 8 ; closure/env cast; i64 -> i64*
  %vptr27203 = alloca i64*, align 8 
  %i0ptr27198 = getelementptr inbounds i64, i64* %cloptr27197, i64 1 
  store volatile i64* %i0ptr27198, i64** %vptr27203, align 8 ; &cloptr27197[1]
 %vptr27204 = alloca i64, align 8 
  %f27200 = load i64, i64* %i0ptr27198, align 8 
  store volatile i64 %f27200, i64* %vptr27204, align 8 ; load; *i0ptr27198
  %fptr27199 = inttoptr i64 %f27200 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27199(i64 %h10547, i64 %h10547)                     ; tail call
  ret void
}


define void @lam11722(i64 %env11723, i64 %rvp10524) {
 %vptr27207 = alloca i64, align 8 
  %envptr27205 = inttoptr i64 %env11723 to i64* 
  store volatile i64 %emsg08636, i64* %vptr27207, align 8 ; closure/env cast; i64 -> i64*
  %vptr27208 = alloca i64*, align 8 
  %envptr27206 = getelementptr inbounds i64, i64* %envptr27205, i64 3 
  store volatile i64* %envptr27206, i64** %vptr27208, align 8 ; &envptr27205[2]
 %vptr27209 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr27206, align 8 
  store volatile i64 %emsg08636, i64* %vptr27209, align 8 ; load; *envptr27206
 %vptr27212 = alloca i64, align 8 
  %envptr27210 = inttoptr i64 %env11723 to i64* 
  store volatile i64 %emsg18637, i64* %vptr27212, align 8 ; closure/env cast; i64 -> i64*
  %vptr27213 = alloca i64*, align 8 
  %envptr27211 = getelementptr inbounds i64, i64* %envptr27210, i64 2 
  store volatile i64* %envptr27211, i64** %vptr27213, align 8 ; &envptr27210[1]
 %vptr27214 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr27211, align 8 
  store volatile i64 %emsg18637, i64* %vptr27214, align 8 ; load; *envptr27211
 %vptr27215 = alloca i64, align 8 
  %_950 = call i64 @prim_car(i64 %rvp10524) 
  store volatile i64 %_950, i64* %vptr27215, align 8 ; call prim_car
 %vptr27216 = alloca i64, align 8 
  %rvp10520 = call i64 @prim_cdr(i64 %rvp10524) 
  store volatile i64 %rvp10520, i64* %vptr27216, align 8 ; call prim_cdr
 %vptr27217 = alloca i64, align 8 
  %n_6310525 = call i64 @prim_null_63(i64 %rvp10520) 
  store volatile i64 %n_6310525, i64* %vptr27217, align 8 ; call prim_null_63
  %cmpptr27221 = alloca i1, align 8  %cmp27218 = icmp eq i64 %n_6310525, 15 store volatile i1 %cmp27218, i1* %cmpptr27221, align 8; false?
  br i1 %cmp27218, label %else27220, label %then27219                                ; if

then27219:
 %vptr27222 = alloca i64, align 8 
  %h10526 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10526, i64* %vptr27222, align 8 ; call prim_halt
  %vptr27228 = alloca i64*, align 8 
  %cloptr27223 = inttoptr i64 %h10526 to i64* 
  store volatile i64* %cloptr27223, i64** %vptr27228, align 8 ; closure/env cast; i64 -> i64*
  %vptr27229 = alloca i64*, align 8 
  %i0ptr27224 = getelementptr inbounds i64, i64* %cloptr27223, i64 1 
  store volatile i64* %i0ptr27224, i64** %vptr27229, align 8 ; &cloptr27223[1]
 %vptr27230 = alloca i64, align 8 
  %f27226 = load i64, i64* %i0ptr27224, align 8 
  store volatile i64 %f27226, i64* %vptr27230, align 8 ; load; *i0ptr27224
  %fptr27225 = inttoptr i64 %f27226 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27225(i64 %h10526, i64 %h10526)                     ; tail call
  ret void

else27220:
 %vptr27231 = alloca i64, align 8 
  %x = call i64 @prim_car(i64 %rvp10520) 
  store volatile i64 %x, i64* %vptr27231, align 8 ; call prim_car
 %vptr27232 = alloca i64, align 8 
  %na10517 = call i64 @prim_cdr(i64 %rvp10520) 
  store volatile i64 %na10517, i64* %vptr27232, align 8 ; call prim_cdr
 %vptr27233 = alloca i64, align 8 
  %n_6310521 = call i64 @prim_null_63(i64 %na10517) 
  store volatile i64 %n_6310521, i64* %vptr27233, align 8 ; call prim_null_63
  %cmpptr27237 = alloca i1, align 8  %cmp27234 = icmp eq i64 %n_6310521, 15 store volatile i1 %cmp27234, i1* %cmpptr27237, align 8; false?
  br i1 %cmp27234, label %else27236, label %then27235                                ; if

then27235:
 %vptr27238 = alloca i64, align 8 
  %_951 = call i64 @prim_halt(i64 %x) 
  store volatile i64 %_951, i64* %vptr27238, align 8 ; call prim_halt
 %vptr27239 = alloca i64, align 8 
  %rva10519 = add i64 0, 0 
  store volatile i64 %rva10519, i64* %vptr27239, align 8 ; quoted ()
 %vptr27240 = alloca i64, align 8 
  %rva10518 = call i64 @prim_cons(i64 %_951, i64 %rva10519) 
  store volatile i64 %rva10518, i64* %vptr27240, align 8 ; call prim_cons
  %vptr27246 = alloca i64*, align 8 
  %cloptr27241 = inttoptr i64 %_951 to i64* 
  store volatile i64* %cloptr27241, i64** %vptr27246, align 8 ; closure/env cast; i64 -> i64*
  %vptr27247 = alloca i64*, align 8 
  %i0ptr27242 = getelementptr inbounds i64, i64* %cloptr27241, i64 1 
  store volatile i64* %i0ptr27242, i64** %vptr27247, align 8 ; &cloptr27241[1]
 %vptr27248 = alloca i64, align 8 
  %f27244 = load i64, i64* %i0ptr27242, align 8 
  store volatile i64 %f27244, i64* %vptr27248, align 8 ; load; *i0ptr27242
  %fptr27243 = inttoptr i64 %f27244 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27243(i64 %_951, i64 %rva10518)                     ; tail call
  ret void

else27236:
 %vptr27249 = alloca i64, align 8 
  %h10522 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10522, i64* %vptr27249, align 8 ; call prim_halt
  %vptr27255 = alloca i64*, align 8 
  %cloptr27250 = inttoptr i64 %h10522 to i64* 
  store volatile i64* %cloptr27250, i64** %vptr27255, align 8 ; closure/env cast; i64 -> i64*
  %vptr27256 = alloca i64*, align 8 
  %i0ptr27251 = getelementptr inbounds i64, i64* %cloptr27250, i64 1 
  store volatile i64* %i0ptr27251, i64** %vptr27256, align 8 ; &cloptr27250[1]
 %vptr27257 = alloca i64, align 8 
  %f27253 = load i64, i64* %i0ptr27251, align 8 
  store volatile i64 %f27253, i64* %vptr27257, align 8 ; load; *i0ptr27251
  %fptr27252 = inttoptr i64 %f27253 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27252(i64 %h10522, i64 %h10522)                     ; tail call
  ret void
}


define void @lam11719(i64 %env11720, i64 %rvp10537) {
 %vptr27260 = alloca i64, align 8 
  %envptr27258 = inttoptr i64 %env11720 to i64* 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr27260, align 8 ; closure/env cast; i64 -> i64*
  %vptr27261 = alloca i64*, align 8 
  %envptr27259 = getelementptr inbounds i64, i64* %envptr27258, i64 4 
  store volatile i64* %envptr27259, i64** %vptr27261, align 8 ; &envptr27258[3]
 %vptr27262 = alloca i64, align 8 
  %Iic$peano_45_62nat = load i64, i64* %envptr27259, align 8 
  store volatile i64 %Iic$peano_45_62nat, i64* %vptr27262, align 8 ; load; *envptr27259
 %vptr27265 = alloca i64, align 8 
  %envptr27263 = inttoptr i64 %env11720 to i64* 
  store volatile i64 %emsg08636, i64* %vptr27265, align 8 ; closure/env cast; i64 -> i64*
  %vptr27266 = alloca i64*, align 8 
  %envptr27264 = getelementptr inbounds i64, i64* %envptr27263, i64 3 
  store volatile i64* %envptr27264, i64** %vptr27266, align 8 ; &envptr27263[2]
 %vptr27267 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr27264, align 8 
  store volatile i64 %emsg08636, i64* %vptr27267, align 8 ; load; *envptr27264
 %vptr27270 = alloca i64, align 8 
  %envptr27268 = inttoptr i64 %env11720 to i64* 
  store volatile i64 %emsg18637, i64* %vptr27270, align 8 ; closure/env cast; i64 -> i64*
  %vptr27271 = alloca i64*, align 8 
  %envptr27269 = getelementptr inbounds i64, i64* %envptr27268, i64 2 
  store volatile i64* %envptr27269, i64** %vptr27271, align 8 ; &envptr27268[1]
 %vptr27272 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr27269, align 8 
  store volatile i64 %emsg18637, i64* %vptr27272, align 8 ; load; *envptr27269
 %vptr27273 = alloca i64, align 8 
  %cont7253 = call i64 @prim_car(i64 %rvp10537) 
  store volatile i64 %cont7253, i64* %vptr27273, align 8 ; call prim_car
 %vptr27274 = alloca i64, align 8 
  %rvp10533 = call i64 @prim_cdr(i64 %rvp10537) 
  store volatile i64 %rvp10533, i64* %vptr27274, align 8 ; call prim_cdr
 %vptr27275 = alloca i64, align 8 
  %n_6310538 = call i64 @prim_null_63(i64 %rvp10533) 
  store volatile i64 %n_6310538, i64* %vptr27275, align 8 ; call prim_null_63
  %cmpptr27279 = alloca i1, align 8  %cmp27276 = icmp eq i64 %n_6310538, 15 store volatile i1 %cmp27276, i1* %cmpptr27279, align 8; false?
  br i1 %cmp27276, label %else27278, label %then27277                                ; if

then27277:
 %vptr27280 = alloca i64, align 8 
  %h10539 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10539, i64* %vptr27280, align 8 ; call prim_halt
  %vptr27286 = alloca i64*, align 8 
  %cloptr27281 = inttoptr i64 %h10539 to i64* 
  store volatile i64* %cloptr27281, i64** %vptr27286, align 8 ; closure/env cast; i64 -> i64*
  %vptr27287 = alloca i64*, align 8 
  %i0ptr27282 = getelementptr inbounds i64, i64* %cloptr27281, i64 1 
  store volatile i64* %i0ptr27282, i64** %vptr27287, align 8 ; &cloptr27281[1]
 %vptr27288 = alloca i64, align 8 
  %f27284 = load i64, i64* %i0ptr27282, align 8 
  store volatile i64 %f27284, i64* %vptr27288, align 8 ; load; *i0ptr27282
  %fptr27283 = inttoptr i64 %f27284 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27283(i64 %h10539, i64 %h10539)                     ; tail call
  ret void

else27278:
 %vptr27289 = alloca i64, align 8 
  %iuZ$x = call i64 @prim_car(i64 %rvp10533) 
  store volatile i64 %iuZ$x, i64* %vptr27289, align 8 ; call prim_car
 %vptr27290 = alloca i64, align 8 
  %na10529 = call i64 @prim_cdr(i64 %rvp10533) 
  store volatile i64 %na10529, i64* %vptr27290, align 8 ; call prim_cdr
 %vptr27291 = alloca i64, align 8 
  %n_6310534 = call i64 @prim_null_63(i64 %na10529) 
  store volatile i64 %n_6310534, i64* %vptr27291, align 8 ; call prim_null_63
  %cmpptr27295 = alloca i1, align 8  %cmp27292 = icmp eq i64 %n_6310534, 15 store volatile i1 %cmp27292, i1* %cmpptr27295, align 8; false?
  br i1 %cmp27292, label %else27294, label %then27293                                ; if

then27293:
 %vptr27296 = alloca i64, align 8 
  %arg8383 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8383, i64* %vptr27296, align 8 ; quoted int
 %vptr27297 = alloca i64, align 8 
  %a7087 = call i64 @prim_vector_45ref(i64 %Iic$peano_45_62nat, i64 %arg8383) 
  store volatile i64 %a7087, i64* %vptr27297, align 8 ; call prim_vector_45ref
 %vptr27298 = alloca i64, align 8 
  %rva10532 = add i64 0, 0 
  store volatile i64 %rva10532, i64* %vptr27298, align 8 ; quoted ()
 %vptr27299 = alloca i64, align 8 
  %rva10531 = call i64 @prim_cons(i64 %iuZ$x, i64 %rva10532) 
  store volatile i64 %rva10531, i64* %vptr27299, align 8 ; call prim_cons
 %vptr27300 = alloca i64, align 8 
  %rva10530 = call i64 @prim_cons(i64 %cont7253, i64 %rva10531) 
  store volatile i64 %rva10530, i64* %vptr27300, align 8 ; call prim_cons
  %vptr27306 = alloca i64*, align 8 
  %cloptr27301 = inttoptr i64 %a7087 to i64* 
  store volatile i64* %cloptr27301, i64** %vptr27306, align 8 ; closure/env cast; i64 -> i64*
  %vptr27307 = alloca i64*, align 8 
  %i0ptr27302 = getelementptr inbounds i64, i64* %cloptr27301, i64 1 
  store volatile i64* %i0ptr27302, i64** %vptr27307, align 8 ; &cloptr27301[1]
 %vptr27308 = alloca i64, align 8 
  %f27304 = load i64, i64* %i0ptr27302, align 8 
  store volatile i64 %f27304, i64* %vptr27308, align 8 ; load; *i0ptr27302
  %fptr27303 = inttoptr i64 %f27304 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27303(i64 %a7087, i64 %rva10530)                    ; tail call
  ret void

else27294:
 %vptr27309 = alloca i64, align 8 
  %h10535 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10535, i64* %vptr27309, align 8 ; call prim_halt
  %vptr27315 = alloca i64*, align 8 
  %cloptr27310 = inttoptr i64 %h10535 to i64* 
  store volatile i64* %cloptr27310, i64** %vptr27315, align 8 ; closure/env cast; i64 -> i64*
  %vptr27316 = alloca i64*, align 8 
  %i0ptr27311 = getelementptr inbounds i64, i64* %cloptr27310, i64 1 
  store volatile i64* %i0ptr27311, i64** %vptr27316, align 8 ; &cloptr27310[1]
 %vptr27317 = alloca i64, align 8 
  %f27313 = load i64, i64* %i0ptr27311, align 8 
  store volatile i64 %f27313, i64* %vptr27317, align 8 ; load; *i0ptr27311
  %fptr27312 = inttoptr i64 %f27313 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27312(i64 %h10535, i64 %h10535)                     ; tail call
  ret void
}


define void @lam11685(i64 %env11686, i64 %rvp10922) {
 %vptr27320 = alloca i64, align 8 
  %envptr27318 = inttoptr i64 %env11686 to i64* 
  store volatile i64 %awI$_37map1, i64* %vptr27320, align 8 ; closure/env cast; i64 -> i64*
  %vptr27321 = alloca i64*, align 8 
  %envptr27319 = getelementptr inbounds i64, i64* %envptr27318, i64 6 
  store volatile i64* %envptr27319, i64** %vptr27321, align 8 ; &envptr27318[5]
 %vptr27322 = alloca i64, align 8 
  %awI$_37map1 = load i64, i64* %envptr27319, align 8 
  store volatile i64 %awI$_37map1, i64* %vptr27322, align 8 ; load; *envptr27319
 %vptr27325 = alloca i64, align 8 
  %envptr27323 = inttoptr i64 %env11686 to i64* 
  store volatile i64 %emsg08636, i64* %vptr27325, align 8 ; closure/env cast; i64 -> i64*
  %vptr27326 = alloca i64*, align 8 
  %envptr27324 = getelementptr inbounds i64, i64* %envptr27323, i64 5 
  store volatile i64* %envptr27324, i64** %vptr27326, align 8 ; &envptr27323[4]
 %vptr27327 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr27324, align 8 
  store volatile i64 %emsg08636, i64* %vptr27327, align 8 ; load; *envptr27324
 %vptr27330 = alloca i64, align 8 
  %envptr27328 = inttoptr i64 %env11686 to i64* 
  store volatile i64 %emsg18637, i64* %vptr27330, align 8 ; closure/env cast; i64 -> i64*
  %vptr27331 = alloca i64*, align 8 
  %envptr27329 = getelementptr inbounds i64, i64* %envptr27328, i64 4 
  store volatile i64* %envptr27329, i64** %vptr27331, align 8 ; &envptr27328[3]
 %vptr27332 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr27329, align 8 
  store volatile i64 %emsg18637, i64* %vptr27332, align 8 ; load; *envptr27329
 %vptr27335 = alloca i64, align 8 
  %envptr27333 = inttoptr i64 %env11686 to i64* 
  store volatile i64 %rC6$_37foldr, i64* %vptr27335, align 8 ; closure/env cast; i64 -> i64*
  %vptr27336 = alloca i64*, align 8 
  %envptr27334 = getelementptr inbounds i64, i64* %envptr27333, i64 3 
  store volatile i64* %envptr27334, i64** %vptr27336, align 8 ; &envptr27333[2]
 %vptr27337 = alloca i64, align 8 
  %rC6$_37foldr = load i64, i64* %envptr27334, align 8 
  store volatile i64 %rC6$_37foldr, i64* %vptr27337, align 8 ; load; *envptr27334
 %vptr27340 = alloca i64, align 8 
  %envptr27338 = inttoptr i64 %env11686 to i64* 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr27340, align 8 ; closure/env cast; i64 -> i64*
  %vptr27341 = alloca i64*, align 8 
  %envptr27339 = getelementptr inbounds i64, i64* %envptr27338, i64 2 
  store volatile i64* %envptr27339, i64** %vptr27341, align 8 ; &envptr27338[1]
 %vptr27342 = alloca i64, align 8 
  %Mcq$_37foldr1 = load i64, i64* %envptr27339, align 8 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr27342, align 8 ; load; *envptr27339
 %vptr27343 = alloca i64, align 8 
  %cont7296 = call i64 @prim_car(i64 %rvp10922) 
  store volatile i64 %cont7296, i64* %vptr27343, align 8 ; call prim_car
 %vptr27344 = alloca i64, align 8 
  %rvp10918 = call i64 @prim_cdr(i64 %rvp10922) 
  store volatile i64 %rvp10918, i64* %vptr27344, align 8 ; call prim_cdr
 %vptr27345 = alloca i64, align 8 
  %n_6310923 = call i64 @prim_null_63(i64 %rvp10918) 
  store volatile i64 %n_6310923, i64* %vptr27345, align 8 ; call prim_null_63
  %cmpptr27349 = alloca i1, align 8  %cmp27346 = icmp eq i64 %n_6310923, 15 store volatile i1 %cmp27346, i1* %cmpptr27349, align 8; false?
  br i1 %cmp27346, label %else27348, label %then27347                                ; if

then27347:
 %vptr27350 = alloca i64, align 8 
  %h10924 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10924, i64* %vptr27350, align 8 ; call prim_halt
  %vptr27356 = alloca i64*, align 8 
  %cloptr27351 = inttoptr i64 %h10924 to i64* 
  store volatile i64* %cloptr27351, i64** %vptr27356, align 8 ; closure/env cast; i64 -> i64*
  %vptr27357 = alloca i64*, align 8 
  %i0ptr27352 = getelementptr inbounds i64, i64* %cloptr27351, i64 1 
  store volatile i64* %i0ptr27352, i64** %vptr27357, align 8 ; &cloptr27351[1]
 %vptr27358 = alloca i64, align 8 
  %f27354 = load i64, i64* %i0ptr27352, align 8 
  store volatile i64 %f27354, i64* %vptr27358, align 8 ; load; *i0ptr27352
  %fptr27353 = inttoptr i64 %f27354 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27353(i64 %h10924, i64 %h10924)                     ; tail call
  ret void

else27348:
 %vptr27359 = alloca i64, align 8 
  %Xz7$_37foldl = call i64 @prim_car(i64 %rvp10918) 
  store volatile i64 %Xz7$_37foldl, i64* %vptr27359, align 8 ; call prim_car
 %vptr27360 = alloca i64, align 8 
  %na10754 = call i64 @prim_cdr(i64 %rvp10918) 
  store volatile i64 %na10754, i64* %vptr27360, align 8 ; call prim_cdr
 %vptr27361 = alloca i64, align 8 
  %n_6310919 = call i64 @prim_null_63(i64 %na10754) 
  store volatile i64 %n_6310919, i64* %vptr27361, align 8 ; call prim_null_63
  %cmpptr27365 = alloca i1, align 8  %cmp27362 = icmp eq i64 %n_6310919, 15 store volatile i1 %cmp27362, i1* %cmpptr27365, align 8; false?
  br i1 %cmp27362, label %else27364, label %then27363                                ; if

then27363:
 %vptr27366 = alloca i64, align 8 
  %arg8389 = add i64 0, 0 
  store volatile i64 %arg8389, i64* %vptr27366, align 8 ; quoted ()
  %vptr27376 = alloca i64*, align 8 
  %cloptr27367 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr27367, i64** %vptr27376, align 8 ; malloc
  %vptr27377 = alloca i64*, align 8 
  %eptr27369 = getelementptr inbounds i64, i64* %cloptr27367, i64 2 
  store volatile i64* %eptr27369, i64** %vptr27377, align 8 ; &eptr27369[1]
  %vptr27378 = alloca i64*, align 8 
  %eptr27370 = getelementptr inbounds i64, i64* %cloptr27367, i64 3 
  store volatile i64* %eptr27370, i64** %vptr27378, align 8 ; &eptr27370[2]
  %vptr27379 = alloca i64*, align 8 
  %eptr27371 = getelementptr inbounds i64, i64* %cloptr27367, i64 4 
  store volatile i64* %eptr27371, i64** %vptr27379, align 8 ; &eptr27371[3]
  %vptr27380 = alloca i64*, align 8 
  %eptr27372 = getelementptr inbounds i64, i64* %cloptr27367, i64 5 
  store volatile i64* %eptr27372, i64** %vptr27380, align 8 ; &eptr27372[4]
  %vptr27381 = alloca i64*, align 8 
  %eptr27373 = getelementptr inbounds i64, i64* %cloptr27367, i64 6 
  store volatile i64* %eptr27373, i64** %vptr27381, align 8 ; &eptr27373[5]
  %vptr27382 = alloca i64*, align 8 
  %eptr27374 = getelementptr inbounds i64, i64* %cloptr27367, i64 7 
  store volatile i64* %eptr27374, i64** %vptr27382, align 8 ; &eptr27374[6]
  store i64 %Mcq$_37foldr1, i64* %eptr27369                                          ; *eptr27369 = %Mcq$_37foldr1
  store i64 %rC6$_37foldr, i64* %eptr27370                                           ; *eptr27370 = %rC6$_37foldr
  store i64 %emsg18637, i64* %eptr27371                                              ; *eptr27371 = %emsg18637
  store i64 %Xz7$_37foldl, i64* %eptr27372                                           ; *eptr27372 = %Xz7$_37foldl
  store i64 %emsg08636, i64* %eptr27373                                              ; *eptr27373 = %emsg08636
  store i64 %awI$_37map1, i64* %eptr27374                                            ; *eptr27374 = %awI$_37map1
  %vptr27383 = alloca i64*, align 8 
  %eptr27368 = getelementptr inbounds i64, i64* %cloptr27367, i64 1 
  store volatile i64* %eptr27368, i64** %vptr27383, align 8 ; &cloptr27367[1]
 %vptr27384 = alloca i64, align 8 
  %f27375 = ptrtoint void(i64,i64)* @lam11682 to i64 
  store volatile i64 %f27375, i64* %vptr27384, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f27375, i64* %eptr27368                                                 ; store fptr
 %vptr27385 = alloca i64, align 8 
  %arg8388 = ptrtoint i64* %cloptr27367 to i64 
  store volatile i64 %arg8388, i64* %vptr27385, align 8 ; closure cast; i64* -> i64
 %vptr27386 = alloca i64, align 8 
  %rva10917 = add i64 0, 0 
  store volatile i64 %rva10917, i64* %vptr27386, align 8 ; quoted ()
 %vptr27387 = alloca i64, align 8 
  %rva10916 = call i64 @prim_cons(i64 %arg8388, i64 %rva10917) 
  store volatile i64 %rva10916, i64* %vptr27387, align 8 ; call prim_cons
 %vptr27388 = alloca i64, align 8 
  %rva10915 = call i64 @prim_cons(i64 %arg8389, i64 %rva10916) 
  store volatile i64 %rva10915, i64* %vptr27388, align 8 ; call prim_cons
  %vptr27394 = alloca i64*, align 8 
  %cloptr27389 = inttoptr i64 %cont7296 to i64* 
  store volatile i64* %cloptr27389, i64** %vptr27394, align 8 ; closure/env cast; i64 -> i64*
  %vptr27395 = alloca i64*, align 8 
  %i0ptr27390 = getelementptr inbounds i64, i64* %cloptr27389, i64 1 
  store volatile i64* %i0ptr27390, i64** %vptr27395, align 8 ; &cloptr27389[1]
 %vptr27396 = alloca i64, align 8 
  %f27392 = load i64, i64* %i0ptr27390, align 8 
  store volatile i64 %f27392, i64* %vptr27396, align 8 ; load; *i0ptr27390
  %fptr27391 = inttoptr i64 %f27392 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27391(i64 %cont7296, i64 %rva10915)                 ; tail call
  ret void

else27364:
 %vptr27397 = alloca i64, align 8 
  %h10920 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10920, i64* %vptr27397, align 8 ; call prim_halt
  %vptr27403 = alloca i64*, align 8 
  %cloptr27398 = inttoptr i64 %h10920 to i64* 
  store volatile i64* %cloptr27398, i64** %vptr27403, align 8 ; closure/env cast; i64 -> i64*
  %vptr27404 = alloca i64*, align 8 
  %i0ptr27399 = getelementptr inbounds i64, i64* %cloptr27398, i64 1 
  store volatile i64* %i0ptr27399, i64** %vptr27404, align 8 ; &cloptr27398[1]
 %vptr27405 = alloca i64, align 8 
  %f27401 = load i64, i64* %i0ptr27399, align 8 
  store volatile i64 %f27401, i64* %vptr27405, align 8 ; load; *i0ptr27399
  %fptr27400 = inttoptr i64 %f27401 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27400(i64 %h10920, i64 %h10920)                     ; tail call
  ret void
}


define void @lam11682(i64 %env11683, i64 %N2T$args7298) {
 %vptr27408 = alloca i64, align 8 
  %envptr27406 = inttoptr i64 %env11683 to i64* 
  store volatile i64 %awI$_37map1, i64* %vptr27408, align 8 ; closure/env cast; i64 -> i64*
  %vptr27409 = alloca i64*, align 8 
  %envptr27407 = getelementptr inbounds i64, i64* %envptr27406, i64 7 
  store volatile i64* %envptr27407, i64** %vptr27409, align 8 ; &envptr27406[6]
 %vptr27410 = alloca i64, align 8 
  %awI$_37map1 = load i64, i64* %envptr27407, align 8 
  store volatile i64 %awI$_37map1, i64* %vptr27410, align 8 ; load; *envptr27407
 %vptr27413 = alloca i64, align 8 
  %envptr27411 = inttoptr i64 %env11683 to i64* 
  store volatile i64 %emsg08636, i64* %vptr27413, align 8 ; closure/env cast; i64 -> i64*
  %vptr27414 = alloca i64*, align 8 
  %envptr27412 = getelementptr inbounds i64, i64* %envptr27411, i64 6 
  store volatile i64* %envptr27412, i64** %vptr27414, align 8 ; &envptr27411[5]
 %vptr27415 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr27412, align 8 
  store volatile i64 %emsg08636, i64* %vptr27415, align 8 ; load; *envptr27412
 %vptr27418 = alloca i64, align 8 
  %envptr27416 = inttoptr i64 %env11683 to i64* 
  store volatile i64 %Xz7$_37foldl, i64* %vptr27418, align 8 ; closure/env cast; i64 -> i64*
  %vptr27419 = alloca i64*, align 8 
  %envptr27417 = getelementptr inbounds i64, i64* %envptr27416, i64 5 
  store volatile i64* %envptr27417, i64** %vptr27419, align 8 ; &envptr27416[4]
 %vptr27420 = alloca i64, align 8 
  %Xz7$_37foldl = load i64, i64* %envptr27417, align 8 
  store volatile i64 %Xz7$_37foldl, i64* %vptr27420, align 8 ; load; *envptr27417
 %vptr27423 = alloca i64, align 8 
  %envptr27421 = inttoptr i64 %env11683 to i64* 
  store volatile i64 %emsg18637, i64* %vptr27423, align 8 ; closure/env cast; i64 -> i64*
  %vptr27424 = alloca i64*, align 8 
  %envptr27422 = getelementptr inbounds i64, i64* %envptr27421, i64 4 
  store volatile i64* %envptr27422, i64** %vptr27424, align 8 ; &envptr27421[3]
 %vptr27425 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr27422, align 8 
  store volatile i64 %emsg18637, i64* %vptr27425, align 8 ; load; *envptr27422
 %vptr27428 = alloca i64, align 8 
  %envptr27426 = inttoptr i64 %env11683 to i64* 
  store volatile i64 %rC6$_37foldr, i64* %vptr27428, align 8 ; closure/env cast; i64 -> i64*
  %vptr27429 = alloca i64*, align 8 
  %envptr27427 = getelementptr inbounds i64, i64* %envptr27426, i64 3 
  store volatile i64* %envptr27427, i64** %vptr27429, align 8 ; &envptr27426[2]
 %vptr27430 = alloca i64, align 8 
  %rC6$_37foldr = load i64, i64* %envptr27427, align 8 
  store volatile i64 %rC6$_37foldr, i64* %vptr27430, align 8 ; load; *envptr27427
 %vptr27433 = alloca i64, align 8 
  %envptr27431 = inttoptr i64 %env11683 to i64* 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr27433, align 8 ; closure/env cast; i64 -> i64*
  %vptr27434 = alloca i64*, align 8 
  %envptr27432 = getelementptr inbounds i64, i64* %envptr27431, i64 2 
  store volatile i64* %envptr27432, i64** %vptr27434, align 8 ; &envptr27431[1]
 %vptr27435 = alloca i64, align 8 
  %Mcq$_37foldr1 = load i64, i64* %envptr27432, align 8 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr27435, align 8 ; load; *envptr27432
 %vptr27436 = alloca i64, align 8 
  %cont7297 = call i64 @prim_car(i64 %N2T$args7298) 
  store volatile i64 %cont7297, i64* %vptr27436, align 8 ; call prim_car
 %vptr27437 = alloca i64, align 8 
  %N2T$args = call i64 @prim_cdr(i64 %N2T$args7298) 
  store volatile i64 %N2T$args, i64* %vptr27437, align 8 ; call prim_cdr
 %vptr27438 = alloca i64, align 8 
  %Ycz$f = call i64 @prim_car(i64 %N2T$args) 
  store volatile i64 %Ycz$f, i64* %vptr27438, align 8 ; call prim_car
 %vptr27439 = alloca i64, align 8 
  %a6947 = call i64 @prim_cdr(i64 %N2T$args) 
  store volatile i64 %a6947, i64* %vptr27439, align 8 ; call prim_cdr
 %vptr27440 = alloca i64, align 8 
  %retprim7317 = call i64 @prim_car(i64 %a6947) 
  store volatile i64 %retprim7317, i64* %vptr27440, align 8 ; call prim_car
  %vptr27453 = alloca i64*, align 8 
  %cloptr27441 = call i64* @make_closure(i64 80) 
  store volatile i64* %cloptr27441, i64** %vptr27453, align 8 ; malloc
  %vptr27454 = alloca i64*, align 8 
  %eptr27443 = getelementptr inbounds i64, i64* %cloptr27441, i64 2 
  store volatile i64* %eptr27443, i64** %vptr27454, align 8 ; &eptr27443[1]
  %vptr27455 = alloca i64*, align 8 
  %eptr27444 = getelementptr inbounds i64, i64* %cloptr27441, i64 3 
  store volatile i64* %eptr27444, i64** %vptr27455, align 8 ; &eptr27444[2]
  %vptr27456 = alloca i64*, align 8 
  %eptr27445 = getelementptr inbounds i64, i64* %cloptr27441, i64 4 
  store volatile i64* %eptr27445, i64** %vptr27456, align 8 ; &eptr27445[3]
  %vptr27457 = alloca i64*, align 8 
  %eptr27446 = getelementptr inbounds i64, i64* %cloptr27441, i64 5 
  store volatile i64* %eptr27446, i64** %vptr27457, align 8 ; &eptr27446[4]
  %vptr27458 = alloca i64*, align 8 
  %eptr27447 = getelementptr inbounds i64, i64* %cloptr27441, i64 6 
  store volatile i64* %eptr27447, i64** %vptr27458, align 8 ; &eptr27447[5]
  %vptr27459 = alloca i64*, align 8 
  %eptr27448 = getelementptr inbounds i64, i64* %cloptr27441, i64 7 
  store volatile i64* %eptr27448, i64** %vptr27459, align 8 ; &eptr27448[6]
  %vptr27460 = alloca i64*, align 8 
  %eptr27449 = getelementptr inbounds i64, i64* %cloptr27441, i64 8 
  store volatile i64* %eptr27449, i64** %vptr27460, align 8 ; &eptr27449[7]
  %vptr27461 = alloca i64*, align 8 
  %eptr27450 = getelementptr inbounds i64, i64* %cloptr27441, i64 9 
  store volatile i64* %eptr27450, i64** %vptr27461, align 8 ; &eptr27450[8]
  %vptr27462 = alloca i64*, align 8 
  %eptr27451 = getelementptr inbounds i64, i64* %cloptr27441, i64 10 
  store volatile i64* %eptr27451, i64** %vptr27462, align 8 ; &eptr27451[9]
  store i64 %Mcq$_37foldr1, i64* %eptr27443                                          ; *eptr27443 = %Mcq$_37foldr1
  store i64 %rC6$_37foldr, i64* %eptr27444                                           ; *eptr27444 = %rC6$_37foldr
  store i64 %emsg18637, i64* %eptr27445                                              ; *eptr27445 = %emsg18637
  store i64 %Xz7$_37foldl, i64* %eptr27446                                           ; *eptr27446 = %Xz7$_37foldl
  store i64 %Ycz$f, i64* %eptr27447                                                  ; *eptr27447 = %Ycz$f
  store i64 %emsg08636, i64* %eptr27448                                              ; *eptr27448 = %emsg08636
  store i64 %awI$_37map1, i64* %eptr27449                                            ; *eptr27449 = %awI$_37map1
  store i64 %cont7297, i64* %eptr27450                                               ; *eptr27450 = %cont7297
  store i64 %N2T$args, i64* %eptr27451                                               ; *eptr27451 = %N2T$args
  %vptr27463 = alloca i64*, align 8 
  %eptr27442 = getelementptr inbounds i64, i64* %cloptr27441, i64 1 
  store volatile i64* %eptr27442, i64** %vptr27463, align 8 ; &cloptr27441[1]
 %vptr27464 = alloca i64, align 8 
  %f27452 = ptrtoint void(i64,i64)* @lam11680 to i64 
  store volatile i64 %f27452, i64* %vptr27464, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f27452, i64* %eptr27442                                                 ; store fptr
 %vptr27465 = alloca i64, align 8 
  %arg8398 = ptrtoint i64* %cloptr27441 to i64 
  store volatile i64 %arg8398, i64* %vptr27465, align 8 ; closure cast; i64* -> i64
 %vptr27466 = alloca i64, align 8 
  %arg8397 = add i64 0, 0 
  store volatile i64 %arg8397, i64* %vptr27466, align 8 ; quoted ()
 %vptr27467 = alloca i64, align 8 
  %rva10914 = add i64 0, 0 
  store volatile i64 %rva10914, i64* %vptr27467, align 8 ; quoted ()
 %vptr27468 = alloca i64, align 8 
  %rva10913 = call i64 @prim_cons(i64 %retprim7317, i64 %rva10914) 
  store volatile i64 %rva10913, i64* %vptr27468, align 8 ; call prim_cons
 %vptr27469 = alloca i64, align 8 
  %rva10912 = call i64 @prim_cons(i64 %arg8397, i64 %rva10913) 
  store volatile i64 %rva10912, i64* %vptr27469, align 8 ; call prim_cons
  %vptr27475 = alloca i64*, align 8 
  %cloptr27470 = inttoptr i64 %arg8398 to i64* 
  store volatile i64* %cloptr27470, i64** %vptr27475, align 8 ; closure/env cast; i64 -> i64*
  %vptr27476 = alloca i64*, align 8 
  %i0ptr27471 = getelementptr inbounds i64, i64* %cloptr27470, i64 1 
  store volatile i64* %i0ptr27471, i64** %vptr27476, align 8 ; &cloptr27470[1]
 %vptr27477 = alloca i64, align 8 
  %f27473 = load i64, i64* %i0ptr27471, align 8 
  store volatile i64 %f27473, i64* %vptr27477, align 8 ; load; *i0ptr27471
  %fptr27472 = inttoptr i64 %f27473 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27472(i64 %arg8398, i64 %rva10912)                  ; tail call
  ret void
}


define void @lam11680(i64 %env11681, i64 %rvp10908) {
 %vptr27480 = alloca i64, align 8 
  %envptr27478 = inttoptr i64 %env11681 to i64* 
  store volatile i64 %N2T$args, i64* %vptr27480, align 8 ; closure/env cast; i64 -> i64*
  %vptr27481 = alloca i64*, align 8 
  %envptr27479 = getelementptr inbounds i64, i64* %envptr27478, i64 10 
  store volatile i64* %envptr27479, i64** %vptr27481, align 8 ; &envptr27478[9]
 %vptr27482 = alloca i64, align 8 
  %N2T$args = load i64, i64* %envptr27479, align 8 
  store volatile i64 %N2T$args, i64* %vptr27482, align 8 ; load; *envptr27479
 %vptr27485 = alloca i64, align 8 
  %envptr27483 = inttoptr i64 %env11681 to i64* 
  store volatile i64 %cont7297, i64* %vptr27485, align 8 ; closure/env cast; i64 -> i64*
  %vptr27486 = alloca i64*, align 8 
  %envptr27484 = getelementptr inbounds i64, i64* %envptr27483, i64 9 
  store volatile i64* %envptr27484, i64** %vptr27486, align 8 ; &envptr27483[8]
 %vptr27487 = alloca i64, align 8 
  %cont7297 = load i64, i64* %envptr27484, align 8 
  store volatile i64 %cont7297, i64* %vptr27487, align 8 ; load; *envptr27484
 %vptr27490 = alloca i64, align 8 
  %envptr27488 = inttoptr i64 %env11681 to i64* 
  store volatile i64 %awI$_37map1, i64* %vptr27490, align 8 ; closure/env cast; i64 -> i64*
  %vptr27491 = alloca i64*, align 8 
  %envptr27489 = getelementptr inbounds i64, i64* %envptr27488, i64 8 
  store volatile i64* %envptr27489, i64** %vptr27491, align 8 ; &envptr27488[7]
 %vptr27492 = alloca i64, align 8 
  %awI$_37map1 = load i64, i64* %envptr27489, align 8 
  store volatile i64 %awI$_37map1, i64* %vptr27492, align 8 ; load; *envptr27489
 %vptr27495 = alloca i64, align 8 
  %envptr27493 = inttoptr i64 %env11681 to i64* 
  store volatile i64 %emsg08636, i64* %vptr27495, align 8 ; closure/env cast; i64 -> i64*
  %vptr27496 = alloca i64*, align 8 
  %envptr27494 = getelementptr inbounds i64, i64* %envptr27493, i64 7 
  store volatile i64* %envptr27494, i64** %vptr27496, align 8 ; &envptr27493[6]
 %vptr27497 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr27494, align 8 
  store volatile i64 %emsg08636, i64* %vptr27497, align 8 ; load; *envptr27494
 %vptr27500 = alloca i64, align 8 
  %envptr27498 = inttoptr i64 %env11681 to i64* 
  store volatile i64 %Ycz$f, i64* %vptr27500, align 8 ; closure/env cast; i64 -> i64*
  %vptr27501 = alloca i64*, align 8 
  %envptr27499 = getelementptr inbounds i64, i64* %envptr27498, i64 6 
  store volatile i64* %envptr27499, i64** %vptr27501, align 8 ; &envptr27498[5]
 %vptr27502 = alloca i64, align 8 
  %Ycz$f = load i64, i64* %envptr27499, align 8 
  store volatile i64 %Ycz$f, i64* %vptr27502, align 8 ; load; *envptr27499
 %vptr27505 = alloca i64, align 8 
  %envptr27503 = inttoptr i64 %env11681 to i64* 
  store volatile i64 %Xz7$_37foldl, i64* %vptr27505, align 8 ; closure/env cast; i64 -> i64*
  %vptr27506 = alloca i64*, align 8 
  %envptr27504 = getelementptr inbounds i64, i64* %envptr27503, i64 5 
  store volatile i64* %envptr27504, i64** %vptr27506, align 8 ; &envptr27503[4]
 %vptr27507 = alloca i64, align 8 
  %Xz7$_37foldl = load i64, i64* %envptr27504, align 8 
  store volatile i64 %Xz7$_37foldl, i64* %vptr27507, align 8 ; load; *envptr27504
 %vptr27510 = alloca i64, align 8 
  %envptr27508 = inttoptr i64 %env11681 to i64* 
  store volatile i64 %emsg18637, i64* %vptr27510, align 8 ; closure/env cast; i64 -> i64*
  %vptr27511 = alloca i64*, align 8 
  %envptr27509 = getelementptr inbounds i64, i64* %envptr27508, i64 4 
  store volatile i64* %envptr27509, i64** %vptr27511, align 8 ; &envptr27508[3]
 %vptr27512 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr27509, align 8 
  store volatile i64 %emsg18637, i64* %vptr27512, align 8 ; load; *envptr27509
 %vptr27515 = alloca i64, align 8 
  %envptr27513 = inttoptr i64 %env11681 to i64* 
  store volatile i64 %rC6$_37foldr, i64* %vptr27515, align 8 ; closure/env cast; i64 -> i64*
  %vptr27516 = alloca i64*, align 8 
  %envptr27514 = getelementptr inbounds i64, i64* %envptr27513, i64 3 
  store volatile i64* %envptr27514, i64** %vptr27516, align 8 ; &envptr27513[2]
 %vptr27517 = alloca i64, align 8 
  %rC6$_37foldr = load i64, i64* %envptr27514, align 8 
  store volatile i64 %rC6$_37foldr, i64* %vptr27517, align 8 ; load; *envptr27514
 %vptr27520 = alloca i64, align 8 
  %envptr27518 = inttoptr i64 %env11681 to i64* 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr27520, align 8 ; closure/env cast; i64 -> i64*
  %vptr27521 = alloca i64*, align 8 
  %envptr27519 = getelementptr inbounds i64, i64* %envptr27518, i64 2 
  store volatile i64* %envptr27519, i64** %vptr27521, align 8 ; &envptr27518[1]
 %vptr27522 = alloca i64, align 8 
  %Mcq$_37foldr1 = load i64, i64* %envptr27519, align 8 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr27522, align 8 ; load; *envptr27519
 %vptr27523 = alloca i64, align 8 
  %_957299 = call i64 @prim_car(i64 %rvp10908) 
  store volatile i64 %_957299, i64* %vptr27523, align 8 ; call prim_car
 %vptr27524 = alloca i64, align 8 
  %rvp10904 = call i64 @prim_cdr(i64 %rvp10908) 
  store volatile i64 %rvp10904, i64* %vptr27524, align 8 ; call prim_cdr
 %vptr27525 = alloca i64, align 8 
  %n_6310909 = call i64 @prim_null_63(i64 %rvp10904) 
  store volatile i64 %n_6310909, i64* %vptr27525, align 8 ; call prim_null_63
  %cmpptr27529 = alloca i1, align 8  %cmp27526 = icmp eq i64 %n_6310909, 15 store volatile i1 %cmp27526, i1* %cmpptr27529, align 8; false?
  br i1 %cmp27526, label %else27528, label %then27527                                ; if

then27527:
 %vptr27530 = alloca i64, align 8 
  %h10910 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10910, i64* %vptr27530, align 8 ; call prim_halt
  %vptr27536 = alloca i64*, align 8 
  %cloptr27531 = inttoptr i64 %h10910 to i64* 
  store volatile i64* %cloptr27531, i64** %vptr27536, align 8 ; closure/env cast; i64 -> i64*
  %vptr27537 = alloca i64*, align 8 
  %i0ptr27532 = getelementptr inbounds i64, i64* %cloptr27531, i64 1 
  store volatile i64* %i0ptr27532, i64** %vptr27537, align 8 ; &cloptr27531[1]
 %vptr27538 = alloca i64, align 8 
  %f27534 = load i64, i64* %i0ptr27532, align 8 
  store volatile i64 %f27534, i64* %vptr27538, align 8 ; load; *i0ptr27532
  %fptr27533 = inttoptr i64 %f27534 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27533(i64 %h10910, i64 %h10910)                     ; tail call
  ret void

else27528:
 %vptr27539 = alloca i64, align 8 
  %NXp$acc = call i64 @prim_car(i64 %rvp10904) 
  store volatile i64 %NXp$acc, i64* %vptr27539, align 8 ; call prim_car
 %vptr27540 = alloca i64, align 8 
  %na10756 = call i64 @prim_cdr(i64 %rvp10904) 
  store volatile i64 %na10756, i64* %vptr27540, align 8 ; call prim_cdr
 %vptr27541 = alloca i64, align 8 
  %n_6310905 = call i64 @prim_null_63(i64 %na10756) 
  store volatile i64 %n_6310905, i64* %vptr27541, align 8 ; call prim_null_63
  %cmpptr27545 = alloca i1, align 8  %cmp27542 = icmp eq i64 %n_6310905, 15 store volatile i1 %cmp27542, i1* %cmpptr27545, align 8; false?
  br i1 %cmp27542, label %else27544, label %then27543                                ; if

then27543:
 %vptr27546 = alloca i64, align 8 
  %a6948 = call i64 @prim_cdr(i64 %N2T$args) 
  store volatile i64 %a6948, i64* %vptr27546, align 8 ; call prim_cdr
 %vptr27547 = alloca i64, align 8 
  %retprim7316 = call i64 @prim_cdr(i64 %a6948) 
  store volatile i64 %retprim7316, i64* %vptr27547, align 8 ; call prim_cdr
  %vptr27560 = alloca i64*, align 8 
  %cloptr27548 = call i64* @make_closure(i64 80) 
  store volatile i64* %cloptr27548, i64** %vptr27560, align 8 ; malloc
  %vptr27561 = alloca i64*, align 8 
  %eptr27550 = getelementptr inbounds i64, i64* %cloptr27548, i64 2 
  store volatile i64* %eptr27550, i64** %vptr27561, align 8 ; &eptr27550[1]
  %vptr27562 = alloca i64*, align 8 
  %eptr27551 = getelementptr inbounds i64, i64* %cloptr27548, i64 3 
  store volatile i64* %eptr27551, i64** %vptr27562, align 8 ; &eptr27551[2]
  %vptr27563 = alloca i64*, align 8 
  %eptr27552 = getelementptr inbounds i64, i64* %cloptr27548, i64 4 
  store volatile i64* %eptr27552, i64** %vptr27563, align 8 ; &eptr27552[3]
  %vptr27564 = alloca i64*, align 8 
  %eptr27553 = getelementptr inbounds i64, i64* %cloptr27548, i64 5 
  store volatile i64* %eptr27553, i64** %vptr27564, align 8 ; &eptr27553[4]
  %vptr27565 = alloca i64*, align 8 
  %eptr27554 = getelementptr inbounds i64, i64* %cloptr27548, i64 6 
  store volatile i64* %eptr27554, i64** %vptr27565, align 8 ; &eptr27554[5]
  %vptr27566 = alloca i64*, align 8 
  %eptr27555 = getelementptr inbounds i64, i64* %cloptr27548, i64 7 
  store volatile i64* %eptr27555, i64** %vptr27566, align 8 ; &eptr27555[6]
  %vptr27567 = alloca i64*, align 8 
  %eptr27556 = getelementptr inbounds i64, i64* %cloptr27548, i64 8 
  store volatile i64* %eptr27556, i64** %vptr27567, align 8 ; &eptr27556[7]
  %vptr27568 = alloca i64*, align 8 
  %eptr27557 = getelementptr inbounds i64, i64* %cloptr27548, i64 9 
  store volatile i64* %eptr27557, i64** %vptr27568, align 8 ; &eptr27557[8]
  %vptr27569 = alloca i64*, align 8 
  %eptr27558 = getelementptr inbounds i64, i64* %cloptr27548, i64 10 
  store volatile i64* %eptr27558, i64** %vptr27569, align 8 ; &eptr27558[9]
  store i64 %Mcq$_37foldr1, i64* %eptr27550                                          ; *eptr27550 = %Mcq$_37foldr1
  store i64 %rC6$_37foldr, i64* %eptr27551                                           ; *eptr27551 = %rC6$_37foldr
  store i64 %emsg18637, i64* %eptr27552                                              ; *eptr27552 = %emsg18637
  store i64 %Xz7$_37foldl, i64* %eptr27553                                           ; *eptr27553 = %Xz7$_37foldl
  store i64 %NXp$acc, i64* %eptr27554                                                ; *eptr27554 = %NXp$acc
  store i64 %Ycz$f, i64* %eptr27555                                                  ; *eptr27555 = %Ycz$f
  store i64 %emsg08636, i64* %eptr27556                                              ; *eptr27556 = %emsg08636
  store i64 %awI$_37map1, i64* %eptr27557                                            ; *eptr27557 = %awI$_37map1
  store i64 %cont7297, i64* %eptr27558                                               ; *eptr27558 = %cont7297
  %vptr27570 = alloca i64*, align 8 
  %eptr27549 = getelementptr inbounds i64, i64* %cloptr27548, i64 1 
  store volatile i64* %eptr27549, i64** %vptr27570, align 8 ; &cloptr27548[1]
 %vptr27571 = alloca i64, align 8 
  %f27559 = ptrtoint void(i64,i64)* @lam11678 to i64 
  store volatile i64 %f27559, i64* %vptr27571, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f27559, i64* %eptr27549                                                 ; store fptr
 %vptr27572 = alloca i64, align 8 
  %arg8403 = ptrtoint i64* %cloptr27548 to i64 
  store volatile i64 %arg8403, i64* %vptr27572, align 8 ; closure cast; i64* -> i64
 %vptr27573 = alloca i64, align 8 
  %arg8402 = add i64 0, 0 
  store volatile i64 %arg8402, i64* %vptr27573, align 8 ; quoted ()
 %vptr27574 = alloca i64, align 8 
  %rva10903 = add i64 0, 0 
  store volatile i64 %rva10903, i64* %vptr27574, align 8 ; quoted ()
 %vptr27575 = alloca i64, align 8 
  %rva10902 = call i64 @prim_cons(i64 %retprim7316, i64 %rva10903) 
  store volatile i64 %rva10902, i64* %vptr27575, align 8 ; call prim_cons
 %vptr27576 = alloca i64, align 8 
  %rva10901 = call i64 @prim_cons(i64 %arg8402, i64 %rva10902) 
  store volatile i64 %rva10901, i64* %vptr27576, align 8 ; call prim_cons
  %vptr27582 = alloca i64*, align 8 
  %cloptr27577 = inttoptr i64 %arg8403 to i64* 
  store volatile i64* %cloptr27577, i64** %vptr27582, align 8 ; closure/env cast; i64 -> i64*
  %vptr27583 = alloca i64*, align 8 
  %i0ptr27578 = getelementptr inbounds i64, i64* %cloptr27577, i64 1 
  store volatile i64* %i0ptr27578, i64** %vptr27583, align 8 ; &cloptr27577[1]
 %vptr27584 = alloca i64, align 8 
  %f27580 = load i64, i64* %i0ptr27578, align 8 
  store volatile i64 %f27580, i64* %vptr27584, align 8 ; load; *i0ptr27578
  %fptr27579 = inttoptr i64 %f27580 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27579(i64 %arg8403, i64 %rva10901)                  ; tail call
  ret void

else27544:
 %vptr27585 = alloca i64, align 8 
  %h10906 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10906, i64* %vptr27585, align 8 ; call prim_halt
  %vptr27591 = alloca i64*, align 8 
  %cloptr27586 = inttoptr i64 %h10906 to i64* 
  store volatile i64* %cloptr27586, i64** %vptr27591, align 8 ; closure/env cast; i64 -> i64*
  %vptr27592 = alloca i64*, align 8 
  %i0ptr27587 = getelementptr inbounds i64, i64* %cloptr27586, i64 1 
  store volatile i64* %i0ptr27587, i64** %vptr27592, align 8 ; &cloptr27586[1]
 %vptr27593 = alloca i64, align 8 
  %f27589 = load i64, i64* %i0ptr27587, align 8 
  store volatile i64 %f27589, i64* %vptr27593, align 8 ; load; *i0ptr27587
  %fptr27588 = inttoptr i64 %f27589 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27588(i64 %h10906, i64 %h10906)                     ; tail call
  ret void
}


define void @lam11678(i64 %env11679, i64 %rvp10897) {
 %vptr27596 = alloca i64, align 8 
  %envptr27594 = inttoptr i64 %env11679 to i64* 
  store volatile i64 %cont7297, i64* %vptr27596, align 8 ; closure/env cast; i64 -> i64*
  %vptr27597 = alloca i64*, align 8 
  %envptr27595 = getelementptr inbounds i64, i64* %envptr27594, i64 10 
  store volatile i64* %envptr27595, i64** %vptr27597, align 8 ; &envptr27594[9]
 %vptr27598 = alloca i64, align 8 
  %cont7297 = load i64, i64* %envptr27595, align 8 
  store volatile i64 %cont7297, i64* %vptr27598, align 8 ; load; *envptr27595
 %vptr27601 = alloca i64, align 8 
  %envptr27599 = inttoptr i64 %env11679 to i64* 
  store volatile i64 %awI$_37map1, i64* %vptr27601, align 8 ; closure/env cast; i64 -> i64*
  %vptr27602 = alloca i64*, align 8 
  %envptr27600 = getelementptr inbounds i64, i64* %envptr27599, i64 9 
  store volatile i64* %envptr27600, i64** %vptr27602, align 8 ; &envptr27599[8]
 %vptr27603 = alloca i64, align 8 
  %awI$_37map1 = load i64, i64* %envptr27600, align 8 
  store volatile i64 %awI$_37map1, i64* %vptr27603, align 8 ; load; *envptr27600
 %vptr27606 = alloca i64, align 8 
  %envptr27604 = inttoptr i64 %env11679 to i64* 
  store volatile i64 %emsg08636, i64* %vptr27606, align 8 ; closure/env cast; i64 -> i64*
  %vptr27607 = alloca i64*, align 8 
  %envptr27605 = getelementptr inbounds i64, i64* %envptr27604, i64 8 
  store volatile i64* %envptr27605, i64** %vptr27607, align 8 ; &envptr27604[7]
 %vptr27608 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr27605, align 8 
  store volatile i64 %emsg08636, i64* %vptr27608, align 8 ; load; *envptr27605
 %vptr27611 = alloca i64, align 8 
  %envptr27609 = inttoptr i64 %env11679 to i64* 
  store volatile i64 %Ycz$f, i64* %vptr27611, align 8 ; closure/env cast; i64 -> i64*
  %vptr27612 = alloca i64*, align 8 
  %envptr27610 = getelementptr inbounds i64, i64* %envptr27609, i64 7 
  store volatile i64* %envptr27610, i64** %vptr27612, align 8 ; &envptr27609[6]
 %vptr27613 = alloca i64, align 8 
  %Ycz$f = load i64, i64* %envptr27610, align 8 
  store volatile i64 %Ycz$f, i64* %vptr27613, align 8 ; load; *envptr27610
 %vptr27616 = alloca i64, align 8 
  %envptr27614 = inttoptr i64 %env11679 to i64* 
  store volatile i64 %NXp$acc, i64* %vptr27616, align 8 ; closure/env cast; i64 -> i64*
  %vptr27617 = alloca i64*, align 8 
  %envptr27615 = getelementptr inbounds i64, i64* %envptr27614, i64 6 
  store volatile i64* %envptr27615, i64** %vptr27617, align 8 ; &envptr27614[5]
 %vptr27618 = alloca i64, align 8 
  %NXp$acc = load i64, i64* %envptr27615, align 8 
  store volatile i64 %NXp$acc, i64* %vptr27618, align 8 ; load; *envptr27615
 %vptr27621 = alloca i64, align 8 
  %envptr27619 = inttoptr i64 %env11679 to i64* 
  store volatile i64 %Xz7$_37foldl, i64* %vptr27621, align 8 ; closure/env cast; i64 -> i64*
  %vptr27622 = alloca i64*, align 8 
  %envptr27620 = getelementptr inbounds i64, i64* %envptr27619, i64 5 
  store volatile i64* %envptr27620, i64** %vptr27622, align 8 ; &envptr27619[4]
 %vptr27623 = alloca i64, align 8 
  %Xz7$_37foldl = load i64, i64* %envptr27620, align 8 
  store volatile i64 %Xz7$_37foldl, i64* %vptr27623, align 8 ; load; *envptr27620
 %vptr27626 = alloca i64, align 8 
  %envptr27624 = inttoptr i64 %env11679 to i64* 
  store volatile i64 %emsg18637, i64* %vptr27626, align 8 ; closure/env cast; i64 -> i64*
  %vptr27627 = alloca i64*, align 8 
  %envptr27625 = getelementptr inbounds i64, i64* %envptr27624, i64 4 
  store volatile i64* %envptr27625, i64** %vptr27627, align 8 ; &envptr27624[3]
 %vptr27628 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr27625, align 8 
  store volatile i64 %emsg18637, i64* %vptr27628, align 8 ; load; *envptr27625
 %vptr27631 = alloca i64, align 8 
  %envptr27629 = inttoptr i64 %env11679 to i64* 
  store volatile i64 %rC6$_37foldr, i64* %vptr27631, align 8 ; closure/env cast; i64 -> i64*
  %vptr27632 = alloca i64*, align 8 
  %envptr27630 = getelementptr inbounds i64, i64* %envptr27629, i64 3 
  store volatile i64* %envptr27630, i64** %vptr27632, align 8 ; &envptr27629[2]
 %vptr27633 = alloca i64, align 8 
  %rC6$_37foldr = load i64, i64* %envptr27630, align 8 
  store volatile i64 %rC6$_37foldr, i64* %vptr27633, align 8 ; load; *envptr27630
 %vptr27636 = alloca i64, align 8 
  %envptr27634 = inttoptr i64 %env11679 to i64* 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr27636, align 8 ; closure/env cast; i64 -> i64*
  %vptr27637 = alloca i64*, align 8 
  %envptr27635 = getelementptr inbounds i64, i64* %envptr27634, i64 2 
  store volatile i64* %envptr27635, i64** %vptr27637, align 8 ; &envptr27634[1]
 %vptr27638 = alloca i64, align 8 
  %Mcq$_37foldr1 = load i64, i64* %envptr27635, align 8 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr27638, align 8 ; load; *envptr27635
 %vptr27639 = alloca i64, align 8 
  %_957300 = call i64 @prim_car(i64 %rvp10897) 
  store volatile i64 %_957300, i64* %vptr27639, align 8 ; call prim_car
 %vptr27640 = alloca i64, align 8 
  %rvp10893 = call i64 @prim_cdr(i64 %rvp10897) 
  store volatile i64 %rvp10893, i64* %vptr27640, align 8 ; call prim_cdr
 %vptr27641 = alloca i64, align 8 
  %n_6310898 = call i64 @prim_null_63(i64 %rvp10893) 
  store volatile i64 %n_6310898, i64* %vptr27641, align 8 ; call prim_null_63
  %cmpptr27645 = alloca i1, align 8  %cmp27642 = icmp eq i64 %n_6310898, 15 store volatile i1 %cmp27642, i1* %cmpptr27645, align 8; false?
  br i1 %cmp27642, label %else27644, label %then27643                                ; if

then27643:
 %vptr27646 = alloca i64, align 8 
  %h10899 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10899, i64* %vptr27646, align 8 ; call prim_halt
  %vptr27652 = alloca i64*, align 8 
  %cloptr27647 = inttoptr i64 %h10899 to i64* 
  store volatile i64* %cloptr27647, i64** %vptr27652, align 8 ; closure/env cast; i64 -> i64*
  %vptr27653 = alloca i64*, align 8 
  %i0ptr27648 = getelementptr inbounds i64, i64* %cloptr27647, i64 1 
  store volatile i64* %i0ptr27648, i64** %vptr27653, align 8 ; &cloptr27647[1]
 %vptr27654 = alloca i64, align 8 
  %f27650 = load i64, i64* %i0ptr27648, align 8 
  store volatile i64 %f27650, i64* %vptr27654, align 8 ; load; *i0ptr27648
  %fptr27649 = inttoptr i64 %f27650 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27649(i64 %h10899, i64 %h10899)                     ; tail call
  ret void

else27644:
 %vptr27655 = alloca i64, align 8 
  %j0V$lsts = call i64 @prim_car(i64 %rvp10893) 
  store volatile i64 %j0V$lsts, i64* %vptr27655, align 8 ; call prim_car
 %vptr27656 = alloca i64, align 8 
  %na10758 = call i64 @prim_cdr(i64 %rvp10893) 
  store volatile i64 %na10758, i64* %vptr27656, align 8 ; call prim_cdr
 %vptr27657 = alloca i64, align 8 
  %n_6310894 = call i64 @prim_null_63(i64 %na10758) 
  store volatile i64 %n_6310894, i64* %vptr27657, align 8 ; call prim_null_63
  %cmpptr27661 = alloca i1, align 8  %cmp27658 = icmp eq i64 %n_6310894, 15 store volatile i1 %cmp27658, i1* %cmpptr27661, align 8; false?
  br i1 %cmp27658, label %else27660, label %then27659                                ; if

then27659:
  %vptr27674 = alloca i64*, align 8 
  %cloptr27662 = call i64* @make_closure(i64 80) 
  store volatile i64* %cloptr27662, i64** %vptr27674, align 8 ; malloc
  %vptr27675 = alloca i64*, align 8 
  %eptr27664 = getelementptr inbounds i64, i64* %cloptr27662, i64 2 
  store volatile i64* %eptr27664, i64** %vptr27675, align 8 ; &eptr27664[1]
  %vptr27676 = alloca i64*, align 8 
  %eptr27665 = getelementptr inbounds i64, i64* %cloptr27662, i64 3 
  store volatile i64* %eptr27665, i64** %vptr27676, align 8 ; &eptr27665[2]
  %vptr27677 = alloca i64*, align 8 
  %eptr27666 = getelementptr inbounds i64, i64* %cloptr27662, i64 4 
  store volatile i64* %eptr27666, i64** %vptr27677, align 8 ; &eptr27666[3]
  %vptr27678 = alloca i64*, align 8 
  %eptr27667 = getelementptr inbounds i64, i64* %cloptr27662, i64 5 
  store volatile i64* %eptr27667, i64** %vptr27678, align 8 ; &eptr27667[4]
  %vptr27679 = alloca i64*, align 8 
  %eptr27668 = getelementptr inbounds i64, i64* %cloptr27662, i64 6 
  store volatile i64* %eptr27668, i64** %vptr27679, align 8 ; &eptr27668[5]
  %vptr27680 = alloca i64*, align 8 
  %eptr27669 = getelementptr inbounds i64, i64* %cloptr27662, i64 7 
  store volatile i64* %eptr27669, i64** %vptr27680, align 8 ; &eptr27669[6]
  %vptr27681 = alloca i64*, align 8 
  %eptr27670 = getelementptr inbounds i64, i64* %cloptr27662, i64 8 
  store volatile i64* %eptr27670, i64** %vptr27681, align 8 ; &eptr27670[7]
  %vptr27682 = alloca i64*, align 8 
  %eptr27671 = getelementptr inbounds i64, i64* %cloptr27662, i64 9 
  store volatile i64* %eptr27671, i64** %vptr27682, align 8 ; &eptr27671[8]
  %vptr27683 = alloca i64*, align 8 
  %eptr27672 = getelementptr inbounds i64, i64* %cloptr27662, i64 10 
  store volatile i64* %eptr27672, i64** %vptr27683, align 8 ; &eptr27672[9]
  store i64 %rC6$_37foldr, i64* %eptr27664                                           ; *eptr27664 = %rC6$_37foldr
  store i64 %emsg18637, i64* %eptr27665                                              ; *eptr27665 = %emsg18637
  store i64 %Xz7$_37foldl, i64* %eptr27666                                           ; *eptr27666 = %Xz7$_37foldl
  store i64 %NXp$acc, i64* %eptr27667                                                ; *eptr27667 = %NXp$acc
  store i64 %Ycz$f, i64* %eptr27668                                                  ; *eptr27668 = %Ycz$f
  store i64 %j0V$lsts, i64* %eptr27669                                               ; *eptr27669 = %j0V$lsts
  store i64 %emsg08636, i64* %eptr27670                                              ; *eptr27670 = %emsg08636
  store i64 %awI$_37map1, i64* %eptr27671                                            ; *eptr27671 = %awI$_37map1
  store i64 %cont7297, i64* %eptr27672                                               ; *eptr27672 = %cont7297
  %vptr27684 = alloca i64*, align 8 
  %eptr27663 = getelementptr inbounds i64, i64* %cloptr27662, i64 1 
  store volatile i64* %eptr27663, i64** %vptr27684, align 8 ; &cloptr27662[1]
 %vptr27685 = alloca i64, align 8 
  %f27673 = ptrtoint void(i64,i64)* @lam11676 to i64 
  store volatile i64 %f27673, i64* %vptr27685, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f27673, i64* %eptr27663                                                 ; store fptr
 %vptr27686 = alloca i64, align 8 
  %arg8407 = ptrtoint i64* %cloptr27662 to i64 
  store volatile i64 %arg8407, i64* %vptr27686, align 8 ; closure cast; i64* -> i64
  %vptr27692 = alloca i64*, align 8 
  %cloptr27687 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr27687, i64** %vptr27692, align 8 ; malloc
  %vptr27693 = alloca i64*, align 8 
  %eptr27689 = getelementptr inbounds i64, i64* %cloptr27687, i64 2 
  store volatile i64* %eptr27689, i64** %vptr27693, align 8 ; &eptr27689[1]
  %vptr27694 = alloca i64*, align 8 
  %eptr27690 = getelementptr inbounds i64, i64* %cloptr27687, i64 3 
  store volatile i64* %eptr27690, i64** %vptr27694, align 8 ; &eptr27690[2]
  store i64 %emsg18637, i64* %eptr27689                                              ; *eptr27689 = %emsg18637
  store i64 %emsg08636, i64* %eptr27690                                              ; *eptr27690 = %emsg08636
  %vptr27695 = alloca i64*, align 8 
  %eptr27688 = getelementptr inbounds i64, i64* %cloptr27687, i64 1 
  store volatile i64* %eptr27688, i64** %vptr27695, align 8 ; &cloptr27687[1]
 %vptr27696 = alloca i64, align 8 
  %f27691 = ptrtoint void(i64,i64)* @lam11648 to i64 
  store volatile i64 %f27691, i64* %vptr27696, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f27691, i64* %eptr27688                                                 ; store fptr
 %vptr27697 = alloca i64, align 8 
  %arg8406 = ptrtoint i64* %cloptr27687 to i64 
  store volatile i64 %arg8406, i64* %vptr27697, align 8 ; closure cast; i64* -> i64
 %vptr27698 = alloca i64, align 8 
  %arg8405 = call i64 @const_init_false() 
  store volatile i64 %arg8405, i64* %vptr27698, align 8 ; quoted #f
 %vptr27699 = alloca i64, align 8 
  %rva10892 = add i64 0, 0 
  store volatile i64 %rva10892, i64* %vptr27699, align 8 ; quoted ()
 %vptr27700 = alloca i64, align 8 
  %rva10891 = call i64 @prim_cons(i64 %j0V$lsts, i64 %rva10892) 
  store volatile i64 %rva10891, i64* %vptr27700, align 8 ; call prim_cons
 %vptr27701 = alloca i64, align 8 
  %rva10890 = call i64 @prim_cons(i64 %arg8405, i64 %rva10891) 
  store volatile i64 %rva10890, i64* %vptr27701, align 8 ; call prim_cons
 %vptr27702 = alloca i64, align 8 
  %rva10889 = call i64 @prim_cons(i64 %arg8406, i64 %rva10890) 
  store volatile i64 %rva10889, i64* %vptr27702, align 8 ; call prim_cons
 %vptr27703 = alloca i64, align 8 
  %rva10888 = call i64 @prim_cons(i64 %arg8407, i64 %rva10889) 
  store volatile i64 %rva10888, i64* %vptr27703, align 8 ; call prim_cons
  %vptr27709 = alloca i64*, align 8 
  %cloptr27704 = inttoptr i64 %Mcq$_37foldr1 to i64* 
  store volatile i64* %cloptr27704, i64** %vptr27709, align 8 ; closure/env cast; i64 -> i64*
  %vptr27710 = alloca i64*, align 8 
  %i0ptr27705 = getelementptr inbounds i64, i64* %cloptr27704, i64 1 
  store volatile i64* %i0ptr27705, i64** %vptr27710, align 8 ; &cloptr27704[1]
 %vptr27711 = alloca i64, align 8 
  %f27707 = load i64, i64* %i0ptr27705, align 8 
  store volatile i64 %f27707, i64* %vptr27711, align 8 ; load; *i0ptr27705
  %fptr27706 = inttoptr i64 %f27707 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27706(i64 %Mcq$_37foldr1, i64 %rva10888)            ; tail call
  ret void

else27660:
 %vptr27712 = alloca i64, align 8 
  %h10895 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10895, i64* %vptr27712, align 8 ; call prim_halt
  %vptr27718 = alloca i64*, align 8 
  %cloptr27713 = inttoptr i64 %h10895 to i64* 
  store volatile i64* %cloptr27713, i64** %vptr27718, align 8 ; closure/env cast; i64 -> i64*
  %vptr27719 = alloca i64*, align 8 
  %i0ptr27714 = getelementptr inbounds i64, i64* %cloptr27713, i64 1 
  store volatile i64* %i0ptr27714, i64** %vptr27719, align 8 ; &cloptr27713[1]
 %vptr27720 = alloca i64, align 8 
  %f27716 = load i64, i64* %i0ptr27714, align 8 
  store volatile i64 %f27716, i64* %vptr27720, align 8 ; load; *i0ptr27714
  %fptr27715 = inttoptr i64 %f27716 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27715(i64 %h10895, i64 %h10895)                     ; tail call
  ret void
}


define void @lam11676(i64 %env11677, i64 %rvp10864) {
 %vptr27723 = alloca i64, align 8 
  %envptr27721 = inttoptr i64 %env11677 to i64* 
  store volatile i64 %cont7297, i64* %vptr27723, align 8 ; closure/env cast; i64 -> i64*
  %vptr27724 = alloca i64*, align 8 
  %envptr27722 = getelementptr inbounds i64, i64* %envptr27721, i64 10 
  store volatile i64* %envptr27722, i64** %vptr27724, align 8 ; &envptr27721[9]
 %vptr27725 = alloca i64, align 8 
  %cont7297 = load i64, i64* %envptr27722, align 8 
  store volatile i64 %cont7297, i64* %vptr27725, align 8 ; load; *envptr27722
 %vptr27728 = alloca i64, align 8 
  %envptr27726 = inttoptr i64 %env11677 to i64* 
  store volatile i64 %awI$_37map1, i64* %vptr27728, align 8 ; closure/env cast; i64 -> i64*
  %vptr27729 = alloca i64*, align 8 
  %envptr27727 = getelementptr inbounds i64, i64* %envptr27726, i64 9 
  store volatile i64* %envptr27727, i64** %vptr27729, align 8 ; &envptr27726[8]
 %vptr27730 = alloca i64, align 8 
  %awI$_37map1 = load i64, i64* %envptr27727, align 8 
  store volatile i64 %awI$_37map1, i64* %vptr27730, align 8 ; load; *envptr27727
 %vptr27733 = alloca i64, align 8 
  %envptr27731 = inttoptr i64 %env11677 to i64* 
  store volatile i64 %emsg08636, i64* %vptr27733, align 8 ; closure/env cast; i64 -> i64*
  %vptr27734 = alloca i64*, align 8 
  %envptr27732 = getelementptr inbounds i64, i64* %envptr27731, i64 8 
  store volatile i64* %envptr27732, i64** %vptr27734, align 8 ; &envptr27731[7]
 %vptr27735 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr27732, align 8 
  store volatile i64 %emsg08636, i64* %vptr27735, align 8 ; load; *envptr27732
 %vptr27738 = alloca i64, align 8 
  %envptr27736 = inttoptr i64 %env11677 to i64* 
  store volatile i64 %j0V$lsts, i64* %vptr27738, align 8 ; closure/env cast; i64 -> i64*
  %vptr27739 = alloca i64*, align 8 
  %envptr27737 = getelementptr inbounds i64, i64* %envptr27736, i64 7 
  store volatile i64* %envptr27737, i64** %vptr27739, align 8 ; &envptr27736[6]
 %vptr27740 = alloca i64, align 8 
  %j0V$lsts = load i64, i64* %envptr27737, align 8 
  store volatile i64 %j0V$lsts, i64* %vptr27740, align 8 ; load; *envptr27737
 %vptr27743 = alloca i64, align 8 
  %envptr27741 = inttoptr i64 %env11677 to i64* 
  store volatile i64 %Ycz$f, i64* %vptr27743, align 8 ; closure/env cast; i64 -> i64*
  %vptr27744 = alloca i64*, align 8 
  %envptr27742 = getelementptr inbounds i64, i64* %envptr27741, i64 6 
  store volatile i64* %envptr27742, i64** %vptr27744, align 8 ; &envptr27741[5]
 %vptr27745 = alloca i64, align 8 
  %Ycz$f = load i64, i64* %envptr27742, align 8 
  store volatile i64 %Ycz$f, i64* %vptr27745, align 8 ; load; *envptr27742
 %vptr27748 = alloca i64, align 8 
  %envptr27746 = inttoptr i64 %env11677 to i64* 
  store volatile i64 %NXp$acc, i64* %vptr27748, align 8 ; closure/env cast; i64 -> i64*
  %vptr27749 = alloca i64*, align 8 
  %envptr27747 = getelementptr inbounds i64, i64* %envptr27746, i64 5 
  store volatile i64* %envptr27747, i64** %vptr27749, align 8 ; &envptr27746[4]
 %vptr27750 = alloca i64, align 8 
  %NXp$acc = load i64, i64* %envptr27747, align 8 
  store volatile i64 %NXp$acc, i64* %vptr27750, align 8 ; load; *envptr27747
 %vptr27753 = alloca i64, align 8 
  %envptr27751 = inttoptr i64 %env11677 to i64* 
  store volatile i64 %Xz7$_37foldl, i64* %vptr27753, align 8 ; closure/env cast; i64 -> i64*
  %vptr27754 = alloca i64*, align 8 
  %envptr27752 = getelementptr inbounds i64, i64* %envptr27751, i64 4 
  store volatile i64* %envptr27752, i64** %vptr27754, align 8 ; &envptr27751[3]
 %vptr27755 = alloca i64, align 8 
  %Xz7$_37foldl = load i64, i64* %envptr27752, align 8 
  store volatile i64 %Xz7$_37foldl, i64* %vptr27755, align 8 ; load; *envptr27752
 %vptr27758 = alloca i64, align 8 
  %envptr27756 = inttoptr i64 %env11677 to i64* 
  store volatile i64 %emsg18637, i64* %vptr27758, align 8 ; closure/env cast; i64 -> i64*
  %vptr27759 = alloca i64*, align 8 
  %envptr27757 = getelementptr inbounds i64, i64* %envptr27756, i64 3 
  store volatile i64* %envptr27757, i64** %vptr27759, align 8 ; &envptr27756[2]
 %vptr27760 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr27757, align 8 
  store volatile i64 %emsg18637, i64* %vptr27760, align 8 ; load; *envptr27757
 %vptr27763 = alloca i64, align 8 
  %envptr27761 = inttoptr i64 %env11677 to i64* 
  store volatile i64 %rC6$_37foldr, i64* %vptr27763, align 8 ; closure/env cast; i64 -> i64*
  %vptr27764 = alloca i64*, align 8 
  %envptr27762 = getelementptr inbounds i64, i64* %envptr27761, i64 2 
  store volatile i64* %envptr27762, i64** %vptr27764, align 8 ; &envptr27761[1]
 %vptr27765 = alloca i64, align 8 
  %rC6$_37foldr = load i64, i64* %envptr27762, align 8 
  store volatile i64 %rC6$_37foldr, i64* %vptr27765, align 8 ; load; *envptr27762
 %vptr27766 = alloca i64, align 8 
  %_957301 = call i64 @prim_car(i64 %rvp10864) 
  store volatile i64 %_957301, i64* %vptr27766, align 8 ; call prim_car
 %vptr27767 = alloca i64, align 8 
  %rvp10860 = call i64 @prim_cdr(i64 %rvp10864) 
  store volatile i64 %rvp10860, i64* %vptr27767, align 8 ; call prim_cdr
 %vptr27768 = alloca i64, align 8 
  %n_6310865 = call i64 @prim_null_63(i64 %rvp10860) 
  store volatile i64 %n_6310865, i64* %vptr27768, align 8 ; call prim_null_63
  %cmpptr27772 = alloca i1, align 8  %cmp27769 = icmp eq i64 %n_6310865, 15 store volatile i1 %cmp27769, i1* %cmpptr27772, align 8; false?
  br i1 %cmp27769, label %else27771, label %then27770                                ; if

then27770:
 %vptr27773 = alloca i64, align 8 
  %h10866 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10866, i64* %vptr27773, align 8 ; call prim_halt
  %vptr27779 = alloca i64*, align 8 
  %cloptr27774 = inttoptr i64 %h10866 to i64* 
  store volatile i64* %cloptr27774, i64** %vptr27779, align 8 ; closure/env cast; i64 -> i64*
  %vptr27780 = alloca i64*, align 8 
  %i0ptr27775 = getelementptr inbounds i64, i64* %cloptr27774, i64 1 
  store volatile i64* %i0ptr27775, i64** %vptr27780, align 8 ; &cloptr27774[1]
 %vptr27781 = alloca i64, align 8 
  %f27777 = load i64, i64* %i0ptr27775, align 8 
  store volatile i64 %f27777, i64* %vptr27781, align 8 ; load; *i0ptr27775
  %fptr27776 = inttoptr i64 %f27777 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27776(i64 %h10866, i64 %h10866)                     ; tail call
  ret void

else27771:
 %vptr27782 = alloca i64, align 8 
  %a6949 = call i64 @prim_car(i64 %rvp10860) 
  store volatile i64 %a6949, i64* %vptr27782, align 8 ; call prim_car
 %vptr27783 = alloca i64, align 8 
  %na10760 = call i64 @prim_cdr(i64 %rvp10860) 
  store volatile i64 %na10760, i64* %vptr27783, align 8 ; call prim_cdr
 %vptr27784 = alloca i64, align 8 
  %n_6310861 = call i64 @prim_null_63(i64 %na10760) 
  store volatile i64 %n_6310861, i64* %vptr27784, align 8 ; call prim_null_63
  %cmpptr27788 = alloca i1, align 8  %cmp27785 = icmp eq i64 %n_6310861, 15 store volatile i1 %cmp27785, i1* %cmpptr27788, align 8; false?
  br i1 %cmp27785, label %else27787, label %then27786                                ; if

then27786:
  %cmpptr27792 = alloca i1, align 8  %cmp27789 = icmp eq i64 %a6949, 15 store volatile i1 %cmp27789, i1* %cmpptr27792, align 8; false?
  br i1 %cmp27789, label %else27791, label %then27790                                ; if

then27790:
 %vptr27793 = alloca i64, align 8 
  %arg8410 = add i64 0, 0 
  store volatile i64 %arg8410, i64* %vptr27793, align 8 ; quoted ()
 %vptr27794 = alloca i64, align 8 
  %rva10763 = add i64 0, 0 
  store volatile i64 %rva10763, i64* %vptr27794, align 8 ; quoted ()
 %vptr27795 = alloca i64, align 8 
  %rva10762 = call i64 @prim_cons(i64 %NXp$acc, i64 %rva10763) 
  store volatile i64 %rva10762, i64* %vptr27795, align 8 ; call prim_cons
 %vptr27796 = alloca i64, align 8 
  %rva10761 = call i64 @prim_cons(i64 %arg8410, i64 %rva10762) 
  store volatile i64 %rva10761, i64* %vptr27796, align 8 ; call prim_cons
  %vptr27802 = alloca i64*, align 8 
  %cloptr27797 = inttoptr i64 %cont7297 to i64* 
  store volatile i64* %cloptr27797, i64** %vptr27802, align 8 ; closure/env cast; i64 -> i64*
  %vptr27803 = alloca i64*, align 8 
  %i0ptr27798 = getelementptr inbounds i64, i64* %cloptr27797, i64 1 
  store volatile i64* %i0ptr27798, i64** %vptr27803, align 8 ; &cloptr27797[1]
 %vptr27804 = alloca i64, align 8 
  %f27800 = load i64, i64* %i0ptr27798, align 8 
  store volatile i64 %f27800, i64* %vptr27804, align 8 ; load; *i0ptr27798
  %fptr27799 = inttoptr i64 %f27800 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27799(i64 %cont7297, i64 %rva10761)                 ; tail call
  ret void

else27791:
  %vptr27817 = alloca i64*, align 8 
  %cloptr27805 = call i64* @make_closure(i64 80) 
  store volatile i64* %cloptr27805, i64** %vptr27817, align 8 ; malloc
  %vptr27818 = alloca i64*, align 8 
  %eptr27807 = getelementptr inbounds i64, i64* %cloptr27805, i64 2 
  store volatile i64* %eptr27807, i64** %vptr27818, align 8 ; &eptr27807[1]
  %vptr27819 = alloca i64*, align 8 
  %eptr27808 = getelementptr inbounds i64, i64* %cloptr27805, i64 3 
  store volatile i64* %eptr27808, i64** %vptr27819, align 8 ; &eptr27808[2]
  %vptr27820 = alloca i64*, align 8 
  %eptr27809 = getelementptr inbounds i64, i64* %cloptr27805, i64 4 
  store volatile i64* %eptr27809, i64** %vptr27820, align 8 ; &eptr27809[3]
  %vptr27821 = alloca i64*, align 8 
  %eptr27810 = getelementptr inbounds i64, i64* %cloptr27805, i64 5 
  store volatile i64* %eptr27810, i64** %vptr27821, align 8 ; &eptr27810[4]
  %vptr27822 = alloca i64*, align 8 
  %eptr27811 = getelementptr inbounds i64, i64* %cloptr27805, i64 6 
  store volatile i64* %eptr27811, i64** %vptr27822, align 8 ; &eptr27811[5]
  %vptr27823 = alloca i64*, align 8 
  %eptr27812 = getelementptr inbounds i64, i64* %cloptr27805, i64 7 
  store volatile i64* %eptr27812, i64** %vptr27823, align 8 ; &eptr27812[6]
  %vptr27824 = alloca i64*, align 8 
  %eptr27813 = getelementptr inbounds i64, i64* %cloptr27805, i64 8 
  store volatile i64* %eptr27813, i64** %vptr27824, align 8 ; &eptr27813[7]
  %vptr27825 = alloca i64*, align 8 
  %eptr27814 = getelementptr inbounds i64, i64* %cloptr27805, i64 9 
  store volatile i64* %eptr27814, i64** %vptr27825, align 8 ; &eptr27814[8]
  %vptr27826 = alloca i64*, align 8 
  %eptr27815 = getelementptr inbounds i64, i64* %cloptr27805, i64 10 
  store volatile i64* %eptr27815, i64** %vptr27826, align 8 ; &eptr27815[9]
  store i64 %rC6$_37foldr, i64* %eptr27807                                           ; *eptr27807 = %rC6$_37foldr
  store i64 %emsg18637, i64* %eptr27808                                              ; *eptr27808 = %emsg18637
  store i64 %Xz7$_37foldl, i64* %eptr27809                                           ; *eptr27809 = %Xz7$_37foldl
  store i64 %NXp$acc, i64* %eptr27810                                                ; *eptr27810 = %NXp$acc
  store i64 %Ycz$f, i64* %eptr27811                                                  ; *eptr27811 = %Ycz$f
  store i64 %j0V$lsts, i64* %eptr27812                                               ; *eptr27812 = %j0V$lsts
  store i64 %emsg08636, i64* %eptr27813                                              ; *eptr27813 = %emsg08636
  store i64 %awI$_37map1, i64* %eptr27814                                            ; *eptr27814 = %awI$_37map1
  store i64 %cont7297, i64* %eptr27815                                               ; *eptr27815 = %cont7297
  %vptr27827 = alloca i64*, align 8 
  %eptr27806 = getelementptr inbounds i64, i64* %cloptr27805, i64 1 
  store volatile i64* %eptr27806, i64** %vptr27827, align 8 ; &cloptr27805[1]
 %vptr27828 = alloca i64, align 8 
  %f27816 = ptrtoint void(i64,i64)* @lam11674 to i64 
  store volatile i64 %f27816, i64* %vptr27828, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f27816, i64* %eptr27806                                                 ; store fptr
 %vptr27829 = alloca i64, align 8 
  %arg8414 = ptrtoint i64* %cloptr27805 to i64 
  store volatile i64 %arg8414, i64* %vptr27829, align 8 ; closure cast; i64* -> i64
  %vptr27835 = alloca i64*, align 8 
  %cloptr27830 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr27830, i64** %vptr27835, align 8 ; malloc
  %vptr27836 = alloca i64*, align 8 
  %eptr27832 = getelementptr inbounds i64, i64* %cloptr27830, i64 2 
  store volatile i64* %eptr27832, i64** %vptr27836, align 8 ; &eptr27832[1]
  %vptr27837 = alloca i64*, align 8 
  %eptr27833 = getelementptr inbounds i64, i64* %cloptr27830, i64 3 
  store volatile i64* %eptr27833, i64** %vptr27837, align 8 ; &eptr27833[2]
  store i64 %emsg18637, i64* %eptr27832                                              ; *eptr27832 = %emsg18637
  store i64 %emsg08636, i64* %eptr27833                                              ; *eptr27833 = %emsg08636
  %vptr27838 = alloca i64*, align 8 
  %eptr27831 = getelementptr inbounds i64, i64* %cloptr27830, i64 1 
  store volatile i64* %eptr27831, i64** %vptr27838, align 8 ; &cloptr27830[1]
 %vptr27839 = alloca i64, align 8 
  %f27834 = ptrtoint void(i64,i64)* @lam11655 to i64 
  store volatile i64 %f27834, i64* %vptr27839, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f27834, i64* %eptr27831                                                 ; store fptr
 %vptr27840 = alloca i64, align 8 
  %arg8413 = ptrtoint i64* %cloptr27830 to i64 
  store volatile i64 %arg8413, i64* %vptr27840, align 8 ; closure cast; i64* -> i64
 %vptr27841 = alloca i64, align 8 
  %rva10859 = add i64 0, 0 
  store volatile i64 %rva10859, i64* %vptr27841, align 8 ; quoted ()
 %vptr27842 = alloca i64, align 8 
  %rva10858 = call i64 @prim_cons(i64 %j0V$lsts, i64 %rva10859) 
  store volatile i64 %rva10858, i64* %vptr27842, align 8 ; call prim_cons
 %vptr27843 = alloca i64, align 8 
  %rva10857 = call i64 @prim_cons(i64 %arg8413, i64 %rva10858) 
  store volatile i64 %rva10857, i64* %vptr27843, align 8 ; call prim_cons
 %vptr27844 = alloca i64, align 8 
  %rva10856 = call i64 @prim_cons(i64 %arg8414, i64 %rva10857) 
  store volatile i64 %rva10856, i64* %vptr27844, align 8 ; call prim_cons
  %vptr27850 = alloca i64*, align 8 
  %cloptr27845 = inttoptr i64 %awI$_37map1 to i64* 
  store volatile i64* %cloptr27845, i64** %vptr27850, align 8 ; closure/env cast; i64 -> i64*
  %vptr27851 = alloca i64*, align 8 
  %i0ptr27846 = getelementptr inbounds i64, i64* %cloptr27845, i64 1 
  store volatile i64* %i0ptr27846, i64** %vptr27851, align 8 ; &cloptr27845[1]
 %vptr27852 = alloca i64, align 8 
  %f27848 = load i64, i64* %i0ptr27846, align 8 
  store volatile i64 %f27848, i64* %vptr27852, align 8 ; load; *i0ptr27846
  %fptr27847 = inttoptr i64 %f27848 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27847(i64 %awI$_37map1, i64 %rva10856)              ; tail call
  ret void

else27787:
 %vptr27853 = alloca i64, align 8 
  %h10862 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10862, i64* %vptr27853, align 8 ; call prim_halt
  %vptr27859 = alloca i64*, align 8 
  %cloptr27854 = inttoptr i64 %h10862 to i64* 
  store volatile i64* %cloptr27854, i64** %vptr27859, align 8 ; closure/env cast; i64 -> i64*
  %vptr27860 = alloca i64*, align 8 
  %i0ptr27855 = getelementptr inbounds i64, i64* %cloptr27854, i64 1 
  store volatile i64* %i0ptr27855, i64** %vptr27860, align 8 ; &cloptr27854[1]
 %vptr27861 = alloca i64, align 8 
  %f27857 = load i64, i64* %i0ptr27855, align 8 
  store volatile i64 %f27857, i64* %vptr27861, align 8 ; load; *i0ptr27855
  %fptr27856 = inttoptr i64 %f27857 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27856(i64 %h10862, i64 %h10862)                     ; tail call
  ret void
}


define void @lam11674(i64 %env11675, i64 %rvp10839) {
 %vptr27864 = alloca i64, align 8 
  %envptr27862 = inttoptr i64 %env11675 to i64* 
  store volatile i64 %cont7297, i64* %vptr27864, align 8 ; closure/env cast; i64 -> i64*
  %vptr27865 = alloca i64*, align 8 
  %envptr27863 = getelementptr inbounds i64, i64* %envptr27862, i64 10 
  store volatile i64* %envptr27863, i64** %vptr27865, align 8 ; &envptr27862[9]
 %vptr27866 = alloca i64, align 8 
  %cont7297 = load i64, i64* %envptr27863, align 8 
  store volatile i64 %cont7297, i64* %vptr27866, align 8 ; load; *envptr27863
 %vptr27869 = alloca i64, align 8 
  %envptr27867 = inttoptr i64 %env11675 to i64* 
  store volatile i64 %awI$_37map1, i64* %vptr27869, align 8 ; closure/env cast; i64 -> i64*
  %vptr27870 = alloca i64*, align 8 
  %envptr27868 = getelementptr inbounds i64, i64* %envptr27867, i64 9 
  store volatile i64* %envptr27868, i64** %vptr27870, align 8 ; &envptr27867[8]
 %vptr27871 = alloca i64, align 8 
  %awI$_37map1 = load i64, i64* %envptr27868, align 8 
  store volatile i64 %awI$_37map1, i64* %vptr27871, align 8 ; load; *envptr27868
 %vptr27874 = alloca i64, align 8 
  %envptr27872 = inttoptr i64 %env11675 to i64* 
  store volatile i64 %emsg08636, i64* %vptr27874, align 8 ; closure/env cast; i64 -> i64*
  %vptr27875 = alloca i64*, align 8 
  %envptr27873 = getelementptr inbounds i64, i64* %envptr27872, i64 8 
  store volatile i64* %envptr27873, i64** %vptr27875, align 8 ; &envptr27872[7]
 %vptr27876 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr27873, align 8 
  store volatile i64 %emsg08636, i64* %vptr27876, align 8 ; load; *envptr27873
 %vptr27879 = alloca i64, align 8 
  %envptr27877 = inttoptr i64 %env11675 to i64* 
  store volatile i64 %j0V$lsts, i64* %vptr27879, align 8 ; closure/env cast; i64 -> i64*
  %vptr27880 = alloca i64*, align 8 
  %envptr27878 = getelementptr inbounds i64, i64* %envptr27877, i64 7 
  store volatile i64* %envptr27878, i64** %vptr27880, align 8 ; &envptr27877[6]
 %vptr27881 = alloca i64, align 8 
  %j0V$lsts = load i64, i64* %envptr27878, align 8 
  store volatile i64 %j0V$lsts, i64* %vptr27881, align 8 ; load; *envptr27878
 %vptr27884 = alloca i64, align 8 
  %envptr27882 = inttoptr i64 %env11675 to i64* 
  store volatile i64 %Ycz$f, i64* %vptr27884, align 8 ; closure/env cast; i64 -> i64*
  %vptr27885 = alloca i64*, align 8 
  %envptr27883 = getelementptr inbounds i64, i64* %envptr27882, i64 6 
  store volatile i64* %envptr27883, i64** %vptr27885, align 8 ; &envptr27882[5]
 %vptr27886 = alloca i64, align 8 
  %Ycz$f = load i64, i64* %envptr27883, align 8 
  store volatile i64 %Ycz$f, i64* %vptr27886, align 8 ; load; *envptr27883
 %vptr27889 = alloca i64, align 8 
  %envptr27887 = inttoptr i64 %env11675 to i64* 
  store volatile i64 %NXp$acc, i64* %vptr27889, align 8 ; closure/env cast; i64 -> i64*
  %vptr27890 = alloca i64*, align 8 
  %envptr27888 = getelementptr inbounds i64, i64* %envptr27887, i64 5 
  store volatile i64* %envptr27888, i64** %vptr27890, align 8 ; &envptr27887[4]
 %vptr27891 = alloca i64, align 8 
  %NXp$acc = load i64, i64* %envptr27888, align 8 
  store volatile i64 %NXp$acc, i64* %vptr27891, align 8 ; load; *envptr27888
 %vptr27894 = alloca i64, align 8 
  %envptr27892 = inttoptr i64 %env11675 to i64* 
  store volatile i64 %Xz7$_37foldl, i64* %vptr27894, align 8 ; closure/env cast; i64 -> i64*
  %vptr27895 = alloca i64*, align 8 
  %envptr27893 = getelementptr inbounds i64, i64* %envptr27892, i64 4 
  store volatile i64* %envptr27893, i64** %vptr27895, align 8 ; &envptr27892[3]
 %vptr27896 = alloca i64, align 8 
  %Xz7$_37foldl = load i64, i64* %envptr27893, align 8 
  store volatile i64 %Xz7$_37foldl, i64* %vptr27896, align 8 ; load; *envptr27893
 %vptr27899 = alloca i64, align 8 
  %envptr27897 = inttoptr i64 %env11675 to i64* 
  store volatile i64 %emsg18637, i64* %vptr27899, align 8 ; closure/env cast; i64 -> i64*
  %vptr27900 = alloca i64*, align 8 
  %envptr27898 = getelementptr inbounds i64, i64* %envptr27897, i64 3 
  store volatile i64* %envptr27898, i64** %vptr27900, align 8 ; &envptr27897[2]
 %vptr27901 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr27898, align 8 
  store volatile i64 %emsg18637, i64* %vptr27901, align 8 ; load; *envptr27898
 %vptr27904 = alloca i64, align 8 
  %envptr27902 = inttoptr i64 %env11675 to i64* 
  store volatile i64 %rC6$_37foldr, i64* %vptr27904, align 8 ; closure/env cast; i64 -> i64*
  %vptr27905 = alloca i64*, align 8 
  %envptr27903 = getelementptr inbounds i64, i64* %envptr27902, i64 2 
  store volatile i64* %envptr27903, i64** %vptr27905, align 8 ; &envptr27902[1]
 %vptr27906 = alloca i64, align 8 
  %rC6$_37foldr = load i64, i64* %envptr27903, align 8 
  store volatile i64 %rC6$_37foldr, i64* %vptr27906, align 8 ; load; *envptr27903
 %vptr27907 = alloca i64, align 8 
  %_957302 = call i64 @prim_car(i64 %rvp10839) 
  store volatile i64 %_957302, i64* %vptr27907, align 8 ; call prim_car
 %vptr27908 = alloca i64, align 8 
  %rvp10835 = call i64 @prim_cdr(i64 %rvp10839) 
  store volatile i64 %rvp10835, i64* %vptr27908, align 8 ; call prim_cdr
 %vptr27909 = alloca i64, align 8 
  %n_6310840 = call i64 @prim_null_63(i64 %rvp10835) 
  store volatile i64 %n_6310840, i64* %vptr27909, align 8 ; call prim_null_63
  %cmpptr27913 = alloca i1, align 8  %cmp27910 = icmp eq i64 %n_6310840, 15 store volatile i1 %cmp27910, i1* %cmpptr27913, align 8; false?
  br i1 %cmp27910, label %else27912, label %then27911                                ; if

then27911:
 %vptr27914 = alloca i64, align 8 
  %h10841 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10841, i64* %vptr27914, align 8 ; call prim_halt
  %vptr27920 = alloca i64*, align 8 
  %cloptr27915 = inttoptr i64 %h10841 to i64* 
  store volatile i64* %cloptr27915, i64** %vptr27920, align 8 ; closure/env cast; i64 -> i64*
  %vptr27921 = alloca i64*, align 8 
  %i0ptr27916 = getelementptr inbounds i64, i64* %cloptr27915, i64 1 
  store volatile i64* %i0ptr27916, i64** %vptr27921, align 8 ; &cloptr27915[1]
 %vptr27922 = alloca i64, align 8 
  %f27918 = load i64, i64* %i0ptr27916, align 8 
  store volatile i64 %f27918, i64* %vptr27922, align 8 ; load; *i0ptr27916
  %fptr27917 = inttoptr i64 %f27918 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27917(i64 %h10841, i64 %h10841)                     ; tail call
  ret void

else27912:
 %vptr27923 = alloca i64, align 8 
  %k3m$lsts_43 = call i64 @prim_car(i64 %rvp10835) 
  store volatile i64 %k3m$lsts_43, i64* %vptr27923, align 8 ; call prim_car
 %vptr27924 = alloca i64, align 8 
  %na10765 = call i64 @prim_cdr(i64 %rvp10835) 
  store volatile i64 %na10765, i64* %vptr27924, align 8 ; call prim_cdr
 %vptr27925 = alloca i64, align 8 
  %n_6310836 = call i64 @prim_null_63(i64 %na10765) 
  store volatile i64 %n_6310836, i64* %vptr27925, align 8 ; call prim_null_63
  %cmpptr27929 = alloca i1, align 8  %cmp27926 = icmp eq i64 %n_6310836, 15 store volatile i1 %cmp27926, i1* %cmpptr27929, align 8; false?
  br i1 %cmp27926, label %else27928, label %then27927                                ; if

then27927:
  %vptr27941 = alloca i64*, align 8 
  %cloptr27930 = call i64* @make_closure(i64 72) 
  store volatile i64* %cloptr27930, i64** %vptr27941, align 8 ; malloc
  %vptr27942 = alloca i64*, align 8 
  %eptr27932 = getelementptr inbounds i64, i64* %cloptr27930, i64 2 
  store volatile i64* %eptr27932, i64** %vptr27942, align 8 ; &eptr27932[1]
  %vptr27943 = alloca i64*, align 8 
  %eptr27933 = getelementptr inbounds i64, i64* %cloptr27930, i64 3 
  store volatile i64* %eptr27933, i64** %vptr27943, align 8 ; &eptr27933[2]
  %vptr27944 = alloca i64*, align 8 
  %eptr27934 = getelementptr inbounds i64, i64* %cloptr27930, i64 4 
  store volatile i64* %eptr27934, i64** %vptr27944, align 8 ; &eptr27934[3]
  %vptr27945 = alloca i64*, align 8 
  %eptr27935 = getelementptr inbounds i64, i64* %cloptr27930, i64 5 
  store volatile i64* %eptr27935, i64** %vptr27945, align 8 ; &eptr27935[4]
  %vptr27946 = alloca i64*, align 8 
  %eptr27936 = getelementptr inbounds i64, i64* %cloptr27930, i64 6 
  store volatile i64* %eptr27936, i64** %vptr27946, align 8 ; &eptr27936[5]
  %vptr27947 = alloca i64*, align 8 
  %eptr27937 = getelementptr inbounds i64, i64* %cloptr27930, i64 7 
  store volatile i64* %eptr27937, i64** %vptr27947, align 8 ; &eptr27937[6]
  %vptr27948 = alloca i64*, align 8 
  %eptr27938 = getelementptr inbounds i64, i64* %cloptr27930, i64 8 
  store volatile i64* %eptr27938, i64** %vptr27948, align 8 ; &eptr27938[7]
  %vptr27949 = alloca i64*, align 8 
  %eptr27939 = getelementptr inbounds i64, i64* %cloptr27930, i64 9 
  store volatile i64* %eptr27939, i64** %vptr27949, align 8 ; &eptr27939[8]
  store i64 %k3m$lsts_43, i64* %eptr27932                                            ; *eptr27932 = %k3m$lsts_43
  store i64 %rC6$_37foldr, i64* %eptr27933                                           ; *eptr27933 = %rC6$_37foldr
  store i64 %emsg18637, i64* %eptr27934                                              ; *eptr27934 = %emsg18637
  store i64 %Xz7$_37foldl, i64* %eptr27935                                           ; *eptr27935 = %Xz7$_37foldl
  store i64 %NXp$acc, i64* %eptr27936                                                ; *eptr27936 = %NXp$acc
  store i64 %Ycz$f, i64* %eptr27937                                                  ; *eptr27937 = %Ycz$f
  store i64 %emsg08636, i64* %eptr27938                                              ; *eptr27938 = %emsg08636
  store i64 %cont7297, i64* %eptr27939                                               ; *eptr27939 = %cont7297
  %vptr27950 = alloca i64*, align 8 
  %eptr27931 = getelementptr inbounds i64, i64* %cloptr27930, i64 1 
  store volatile i64* %eptr27931, i64** %vptr27950, align 8 ; &cloptr27930[1]
 %vptr27951 = alloca i64, align 8 
  %f27940 = ptrtoint void(i64,i64)* @lam11672 to i64 
  store volatile i64 %f27940, i64* %vptr27951, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f27940, i64* %eptr27931                                                 ; store fptr
 %vptr27952 = alloca i64, align 8 
  %arg8418 = ptrtoint i64* %cloptr27930 to i64 
  store volatile i64 %arg8418, i64* %vptr27952, align 8 ; closure cast; i64* -> i64
  %vptr27958 = alloca i64*, align 8 
  %cloptr27953 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr27953, i64** %vptr27958, align 8 ; malloc
  %vptr27959 = alloca i64*, align 8 
  %eptr27955 = getelementptr inbounds i64, i64* %cloptr27953, i64 2 
  store volatile i64* %eptr27955, i64** %vptr27959, align 8 ; &eptr27955[1]
  %vptr27960 = alloca i64*, align 8 
  %eptr27956 = getelementptr inbounds i64, i64* %cloptr27953, i64 3 
  store volatile i64* %eptr27956, i64** %vptr27960, align 8 ; &eptr27956[2]
  store i64 %emsg18637, i64* %eptr27955                                              ; *eptr27955 = %emsg18637
  store i64 %emsg08636, i64* %eptr27956                                              ; *eptr27956 = %emsg08636
  %vptr27961 = alloca i64*, align 8 
  %eptr27954 = getelementptr inbounds i64, i64* %cloptr27953, i64 1 
  store volatile i64* %eptr27954, i64** %vptr27961, align 8 ; &cloptr27953[1]
 %vptr27962 = alloca i64, align 8 
  %f27957 = ptrtoint void(i64,i64)* @lam11660 to i64 
  store volatile i64 %f27957, i64* %vptr27962, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f27957, i64* %eptr27954                                                 ; store fptr
 %vptr27963 = alloca i64, align 8 
  %arg8417 = ptrtoint i64* %cloptr27953 to i64 
  store volatile i64 %arg8417, i64* %vptr27963, align 8 ; closure cast; i64* -> i64
 %vptr27964 = alloca i64, align 8 
  %rva10834 = add i64 0, 0 
  store volatile i64 %rva10834, i64* %vptr27964, align 8 ; quoted ()
 %vptr27965 = alloca i64, align 8 
  %rva10833 = call i64 @prim_cons(i64 %j0V$lsts, i64 %rva10834) 
  store volatile i64 %rva10833, i64* %vptr27965, align 8 ; call prim_cons
 %vptr27966 = alloca i64, align 8 
  %rva10832 = call i64 @prim_cons(i64 %arg8417, i64 %rva10833) 
  store volatile i64 %rva10832, i64* %vptr27966, align 8 ; call prim_cons
 %vptr27967 = alloca i64, align 8 
  %rva10831 = call i64 @prim_cons(i64 %arg8418, i64 %rva10832) 
  store volatile i64 %rva10831, i64* %vptr27967, align 8 ; call prim_cons
  %vptr27973 = alloca i64*, align 8 
  %cloptr27968 = inttoptr i64 %awI$_37map1 to i64* 
  store volatile i64* %cloptr27968, i64** %vptr27973, align 8 ; closure/env cast; i64 -> i64*
  %vptr27974 = alloca i64*, align 8 
  %i0ptr27969 = getelementptr inbounds i64, i64* %cloptr27968, i64 1 
  store volatile i64* %i0ptr27969, i64** %vptr27974, align 8 ; &cloptr27968[1]
 %vptr27975 = alloca i64, align 8 
  %f27971 = load i64, i64* %i0ptr27969, align 8 
  store volatile i64 %f27971, i64* %vptr27975, align 8 ; load; *i0ptr27969
  %fptr27970 = inttoptr i64 %f27971 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27970(i64 %awI$_37map1, i64 %rva10831)              ; tail call
  ret void

else27928:
 %vptr27976 = alloca i64, align 8 
  %h10837 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10837, i64* %vptr27976, align 8 ; call prim_halt
  %vptr27982 = alloca i64*, align 8 
  %cloptr27977 = inttoptr i64 %h10837 to i64* 
  store volatile i64* %cloptr27977, i64** %vptr27982, align 8 ; closure/env cast; i64 -> i64*
  %vptr27983 = alloca i64*, align 8 
  %i0ptr27978 = getelementptr inbounds i64, i64* %cloptr27977, i64 1 
  store volatile i64* %i0ptr27978, i64** %vptr27983, align 8 ; &cloptr27977[1]
 %vptr27984 = alloca i64, align 8 
  %f27980 = load i64, i64* %i0ptr27978, align 8 
  store volatile i64 %f27980, i64* %vptr27984, align 8 ; load; *i0ptr27978
  %fptr27979 = inttoptr i64 %f27980 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr27979(i64 %h10837, i64 %h10837)                     ; tail call
  ret void
}


define void @lam11672(i64 %env11673, i64 %rvp10814) {
 %vptr27987 = alloca i64, align 8 
  %envptr27985 = inttoptr i64 %env11673 to i64* 
  store volatile i64 %cont7297, i64* %vptr27987, align 8 ; closure/env cast; i64 -> i64*
  %vptr27988 = alloca i64*, align 8 
  %envptr27986 = getelementptr inbounds i64, i64* %envptr27985, i64 9 
  store volatile i64* %envptr27986, i64** %vptr27988, align 8 ; &envptr27985[8]
 %vptr27989 = alloca i64, align 8 
  %cont7297 = load i64, i64* %envptr27986, align 8 
  store volatile i64 %cont7297, i64* %vptr27989, align 8 ; load; *envptr27986
 %vptr27992 = alloca i64, align 8 
  %envptr27990 = inttoptr i64 %env11673 to i64* 
  store volatile i64 %emsg08636, i64* %vptr27992, align 8 ; closure/env cast; i64 -> i64*
  %vptr27993 = alloca i64*, align 8 
  %envptr27991 = getelementptr inbounds i64, i64* %envptr27990, i64 8 
  store volatile i64* %envptr27991, i64** %vptr27993, align 8 ; &envptr27990[7]
 %vptr27994 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr27991, align 8 
  store volatile i64 %emsg08636, i64* %vptr27994, align 8 ; load; *envptr27991
 %vptr27997 = alloca i64, align 8 
  %envptr27995 = inttoptr i64 %env11673 to i64* 
  store volatile i64 %Ycz$f, i64* %vptr27997, align 8 ; closure/env cast; i64 -> i64*
  %vptr27998 = alloca i64*, align 8 
  %envptr27996 = getelementptr inbounds i64, i64* %envptr27995, i64 7 
  store volatile i64* %envptr27996, i64** %vptr27998, align 8 ; &envptr27995[6]
 %vptr27999 = alloca i64, align 8 
  %Ycz$f = load i64, i64* %envptr27996, align 8 
  store volatile i64 %Ycz$f, i64* %vptr27999, align 8 ; load; *envptr27996
 %vptr28002 = alloca i64, align 8 
  %envptr28000 = inttoptr i64 %env11673 to i64* 
  store volatile i64 %NXp$acc, i64* %vptr28002, align 8 ; closure/env cast; i64 -> i64*
  %vptr28003 = alloca i64*, align 8 
  %envptr28001 = getelementptr inbounds i64, i64* %envptr28000, i64 6 
  store volatile i64* %envptr28001, i64** %vptr28003, align 8 ; &envptr28000[5]
 %vptr28004 = alloca i64, align 8 
  %NXp$acc = load i64, i64* %envptr28001, align 8 
  store volatile i64 %NXp$acc, i64* %vptr28004, align 8 ; load; *envptr28001
 %vptr28007 = alloca i64, align 8 
  %envptr28005 = inttoptr i64 %env11673 to i64* 
  store volatile i64 %Xz7$_37foldl, i64* %vptr28007, align 8 ; closure/env cast; i64 -> i64*
  %vptr28008 = alloca i64*, align 8 
  %envptr28006 = getelementptr inbounds i64, i64* %envptr28005, i64 5 
  store volatile i64* %envptr28006, i64** %vptr28008, align 8 ; &envptr28005[4]
 %vptr28009 = alloca i64, align 8 
  %Xz7$_37foldl = load i64, i64* %envptr28006, align 8 
  store volatile i64 %Xz7$_37foldl, i64* %vptr28009, align 8 ; load; *envptr28006
 %vptr28012 = alloca i64, align 8 
  %envptr28010 = inttoptr i64 %env11673 to i64* 
  store volatile i64 %emsg18637, i64* %vptr28012, align 8 ; closure/env cast; i64 -> i64*
  %vptr28013 = alloca i64*, align 8 
  %envptr28011 = getelementptr inbounds i64, i64* %envptr28010, i64 4 
  store volatile i64* %envptr28011, i64** %vptr28013, align 8 ; &envptr28010[3]
 %vptr28014 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr28011, align 8 
  store volatile i64 %emsg18637, i64* %vptr28014, align 8 ; load; *envptr28011
 %vptr28017 = alloca i64, align 8 
  %envptr28015 = inttoptr i64 %env11673 to i64* 
  store volatile i64 %rC6$_37foldr, i64* %vptr28017, align 8 ; closure/env cast; i64 -> i64*
  %vptr28018 = alloca i64*, align 8 
  %envptr28016 = getelementptr inbounds i64, i64* %envptr28015, i64 3 
  store volatile i64* %envptr28016, i64** %vptr28018, align 8 ; &envptr28015[2]
 %vptr28019 = alloca i64, align 8 
  %rC6$_37foldr = load i64, i64* %envptr28016, align 8 
  store volatile i64 %rC6$_37foldr, i64* %vptr28019, align 8 ; load; *envptr28016
 %vptr28022 = alloca i64, align 8 
  %envptr28020 = inttoptr i64 %env11673 to i64* 
  store volatile i64 %k3m$lsts_43, i64* %vptr28022, align 8 ; closure/env cast; i64 -> i64*
  %vptr28023 = alloca i64*, align 8 
  %envptr28021 = getelementptr inbounds i64, i64* %envptr28020, i64 2 
  store volatile i64* %envptr28021, i64** %vptr28023, align 8 ; &envptr28020[1]
 %vptr28024 = alloca i64, align 8 
  %k3m$lsts_43 = load i64, i64* %envptr28021, align 8 
  store volatile i64 %k3m$lsts_43, i64* %vptr28024, align 8 ; load; *envptr28021
 %vptr28025 = alloca i64, align 8 
  %_957303 = call i64 @prim_car(i64 %rvp10814) 
  store volatile i64 %_957303, i64* %vptr28025, align 8 ; call prim_car
 %vptr28026 = alloca i64, align 8 
  %rvp10810 = call i64 @prim_cdr(i64 %rvp10814) 
  store volatile i64 %rvp10810, i64* %vptr28026, align 8 ; call prim_cdr
 %vptr28027 = alloca i64, align 8 
  %n_6310815 = call i64 @prim_null_63(i64 %rvp10810) 
  store volatile i64 %n_6310815, i64* %vptr28027, align 8 ; call prim_null_63
  %cmpptr28031 = alloca i1, align 8  %cmp28028 = icmp eq i64 %n_6310815, 15 store volatile i1 %cmp28028, i1* %cmpptr28031, align 8; false?
  br i1 %cmp28028, label %else28030, label %then28029                                ; if

then28029:
 %vptr28032 = alloca i64, align 8 
  %h10816 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10816, i64* %vptr28032, align 8 ; call prim_halt
  %vptr28038 = alloca i64*, align 8 
  %cloptr28033 = inttoptr i64 %h10816 to i64* 
  store volatile i64* %cloptr28033, i64** %vptr28038, align 8 ; closure/env cast; i64 -> i64*
  %vptr28039 = alloca i64*, align 8 
  %i0ptr28034 = getelementptr inbounds i64, i64* %cloptr28033, i64 1 
  store volatile i64* %i0ptr28034, i64** %vptr28039, align 8 ; &cloptr28033[1]
 %vptr28040 = alloca i64, align 8 
  %f28036 = load i64, i64* %i0ptr28034, align 8 
  store volatile i64 %f28036, i64* %vptr28040, align 8 ; load; *i0ptr28034
  %fptr28035 = inttoptr i64 %f28036 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28035(i64 %h10816, i64 %h10816)                     ; tail call
  ret void

else28030:
 %vptr28041 = alloca i64, align 8 
  %e2C$vs = call i64 @prim_car(i64 %rvp10810) 
  store volatile i64 %e2C$vs, i64* %vptr28041, align 8 ; call prim_car
 %vptr28042 = alloca i64, align 8 
  %na10767 = call i64 @prim_cdr(i64 %rvp10810) 
  store volatile i64 %na10767, i64* %vptr28042, align 8 ; call prim_cdr
 %vptr28043 = alloca i64, align 8 
  %n_6310811 = call i64 @prim_null_63(i64 %na10767) 
  store volatile i64 %n_6310811, i64* %vptr28043, align 8 ; call prim_null_63
  %cmpptr28047 = alloca i1, align 8  %cmp28044 = icmp eq i64 %n_6310811, 15 store volatile i1 %cmp28044, i1* %cmpptr28047, align 8; false?
  br i1 %cmp28044, label %else28046, label %then28045                                ; if

then28045:
 %vptr28048 = alloca i64, align 8 
  %arg8420 = add i64 0, 0 
  store volatile i64 %arg8420, i64* %vptr28048, align 8 ; quoted ()
 %vptr28049 = alloca i64, align 8 
  %a6950 = call i64 @prim_cons(i64 %NXp$acc, i64 %arg8420) 
  store volatile i64 %a6950, i64* %vptr28049, align 8 ; call prim_cons
  %vptr28059 = alloca i64*, align 8 
  %cloptr28050 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr28050, i64** %vptr28059, align 8 ; malloc
  %vptr28060 = alloca i64*, align 8 
  %eptr28052 = getelementptr inbounds i64, i64* %cloptr28050, i64 2 
  store volatile i64* %eptr28052, i64** %vptr28060, align 8 ; &eptr28052[1]
  %vptr28061 = alloca i64*, align 8 
  %eptr28053 = getelementptr inbounds i64, i64* %cloptr28050, i64 3 
  store volatile i64* %eptr28053, i64** %vptr28061, align 8 ; &eptr28053[2]
  %vptr28062 = alloca i64*, align 8 
  %eptr28054 = getelementptr inbounds i64, i64* %cloptr28050, i64 4 
  store volatile i64* %eptr28054, i64** %vptr28062, align 8 ; &eptr28054[3]
  %vptr28063 = alloca i64*, align 8 
  %eptr28055 = getelementptr inbounds i64, i64* %cloptr28050, i64 5 
  store volatile i64* %eptr28055, i64** %vptr28063, align 8 ; &eptr28055[4]
  %vptr28064 = alloca i64*, align 8 
  %eptr28056 = getelementptr inbounds i64, i64* %cloptr28050, i64 6 
  store volatile i64* %eptr28056, i64** %vptr28064, align 8 ; &eptr28056[5]
  %vptr28065 = alloca i64*, align 8 
  %eptr28057 = getelementptr inbounds i64, i64* %cloptr28050, i64 7 
  store volatile i64* %eptr28057, i64** %vptr28065, align 8 ; &eptr28057[6]
  store i64 %k3m$lsts_43, i64* %eptr28052                                            ; *eptr28052 = %k3m$lsts_43
  store i64 %emsg18637, i64* %eptr28053                                              ; *eptr28053 = %emsg18637
  store i64 %Xz7$_37foldl, i64* %eptr28054                                           ; *eptr28054 = %Xz7$_37foldl
  store i64 %Ycz$f, i64* %eptr28055                                                  ; *eptr28055 = %Ycz$f
  store i64 %emsg08636, i64* %eptr28056                                              ; *eptr28056 = %emsg08636
  store i64 %cont7297, i64* %eptr28057                                               ; *eptr28057 = %cont7297
  %vptr28066 = alloca i64*, align 8 
  %eptr28051 = getelementptr inbounds i64, i64* %cloptr28050, i64 1 
  store volatile i64* %eptr28051, i64** %vptr28066, align 8 ; &cloptr28050[1]
 %vptr28067 = alloca i64, align 8 
  %f28058 = ptrtoint void(i64,i64)* @lam11669 to i64 
  store volatile i64 %f28058, i64* %vptr28067, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f28058, i64* %eptr28051                                                 ; store fptr
 %vptr28068 = alloca i64, align 8 
  %arg8425 = ptrtoint i64* %cloptr28050 to i64 
  store volatile i64 %arg8425, i64* %vptr28068, align 8 ; closure cast; i64* -> i64
  %vptr28074 = alloca i64*, align 8 
  %cloptr28069 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr28069, i64** %vptr28074, align 8 ; malloc
  %vptr28075 = alloca i64*, align 8 
  %eptr28071 = getelementptr inbounds i64, i64* %cloptr28069, i64 2 
  store volatile i64* %eptr28071, i64** %vptr28075, align 8 ; &eptr28071[1]
  %vptr28076 = alloca i64*, align 8 
  %eptr28072 = getelementptr inbounds i64, i64* %cloptr28069, i64 3 
  store volatile i64* %eptr28072, i64** %vptr28076, align 8 ; &eptr28072[2]
  store i64 %emsg18637, i64* %eptr28071                                              ; *eptr28071 = %emsg18637
  store i64 %emsg08636, i64* %eptr28072                                              ; *eptr28072 = %emsg08636
  %vptr28077 = alloca i64*, align 8 
  %eptr28070 = getelementptr inbounds i64, i64* %cloptr28069, i64 1 
  store volatile i64* %eptr28070, i64** %vptr28077, align 8 ; &cloptr28069[1]
 %vptr28078 = alloca i64, align 8 
  %f28073 = ptrtoint void(i64,i64)* @lam11665 to i64 
  store volatile i64 %f28073, i64* %vptr28078, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f28073, i64* %eptr28070                                                 ; store fptr
 %vptr28079 = alloca i64, align 8 
  %arg8424 = ptrtoint i64* %cloptr28069 to i64 
  store volatile i64 %arg8424, i64* %vptr28079, align 8 ; closure cast; i64* -> i64
 %vptr28080 = alloca i64, align 8 
  %rva10809 = add i64 0, 0 
  store volatile i64 %rva10809, i64* %vptr28080, align 8 ; quoted ()
 %vptr28081 = alloca i64, align 8 
  %rva10808 = call i64 @prim_cons(i64 %e2C$vs, i64 %rva10809) 
  store volatile i64 %rva10808, i64* %vptr28081, align 8 ; call prim_cons
 %vptr28082 = alloca i64, align 8 
  %rva10807 = call i64 @prim_cons(i64 %a6950, i64 %rva10808) 
  store volatile i64 %rva10807, i64* %vptr28082, align 8 ; call prim_cons
 %vptr28083 = alloca i64, align 8 
  %rva10806 = call i64 @prim_cons(i64 %arg8424, i64 %rva10807) 
  store volatile i64 %rva10806, i64* %vptr28083, align 8 ; call prim_cons
 %vptr28084 = alloca i64, align 8 
  %rva10805 = call i64 @prim_cons(i64 %arg8425, i64 %rva10806) 
  store volatile i64 %rva10805, i64* %vptr28084, align 8 ; call prim_cons
  %vptr28090 = alloca i64*, align 8 
  %cloptr28085 = inttoptr i64 %rC6$_37foldr to i64* 
  store volatile i64* %cloptr28085, i64** %vptr28090, align 8 ; closure/env cast; i64 -> i64*
  %vptr28091 = alloca i64*, align 8 
  %i0ptr28086 = getelementptr inbounds i64, i64* %cloptr28085, i64 1 
  store volatile i64* %i0ptr28086, i64** %vptr28091, align 8 ; &cloptr28085[1]
 %vptr28092 = alloca i64, align 8 
  %f28088 = load i64, i64* %i0ptr28086, align 8 
  store volatile i64 %f28088, i64* %vptr28092, align 8 ; load; *i0ptr28086
  %fptr28087 = inttoptr i64 %f28088 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28087(i64 %rC6$_37foldr, i64 %rva10805)             ; tail call
  ret void

else28046:
 %vptr28093 = alloca i64, align 8 
  %h10812 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10812, i64* %vptr28093, align 8 ; call prim_halt
  %vptr28099 = alloca i64*, align 8 
  %cloptr28094 = inttoptr i64 %h10812 to i64* 
  store volatile i64* %cloptr28094, i64** %vptr28099, align 8 ; closure/env cast; i64 -> i64*
  %vptr28100 = alloca i64*, align 8 
  %i0ptr28095 = getelementptr inbounds i64, i64* %cloptr28094, i64 1 
  store volatile i64* %i0ptr28095, i64** %vptr28100, align 8 ; &cloptr28094[1]
 %vptr28101 = alloca i64, align 8 
  %f28097 = load i64, i64* %i0ptr28095, align 8 
  store volatile i64 %f28097, i64* %vptr28101, align 8 ; load; *i0ptr28095
  %fptr28096 = inttoptr i64 %f28097 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28096(i64 %h10812, i64 %h10812)                     ; tail call
  ret void
}


define void @lam11669(i64 %env11670, i64 %rvp10784) {
 %vptr28104 = alloca i64, align 8 
  %envptr28102 = inttoptr i64 %env11670 to i64* 
  store volatile i64 %cont7297, i64* %vptr28104, align 8 ; closure/env cast; i64 -> i64*
  %vptr28105 = alloca i64*, align 8 
  %envptr28103 = getelementptr inbounds i64, i64* %envptr28102, i64 7 
  store volatile i64* %envptr28103, i64** %vptr28105, align 8 ; &envptr28102[6]
 %vptr28106 = alloca i64, align 8 
  %cont7297 = load i64, i64* %envptr28103, align 8 
  store volatile i64 %cont7297, i64* %vptr28106, align 8 ; load; *envptr28103
 %vptr28109 = alloca i64, align 8 
  %envptr28107 = inttoptr i64 %env11670 to i64* 
  store volatile i64 %emsg08636, i64* %vptr28109, align 8 ; closure/env cast; i64 -> i64*
  %vptr28110 = alloca i64*, align 8 
  %envptr28108 = getelementptr inbounds i64, i64* %envptr28107, i64 6 
  store volatile i64* %envptr28108, i64** %vptr28110, align 8 ; &envptr28107[5]
 %vptr28111 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr28108, align 8 
  store volatile i64 %emsg08636, i64* %vptr28111, align 8 ; load; *envptr28108
 %vptr28114 = alloca i64, align 8 
  %envptr28112 = inttoptr i64 %env11670 to i64* 
  store volatile i64 %Ycz$f, i64* %vptr28114, align 8 ; closure/env cast; i64 -> i64*
  %vptr28115 = alloca i64*, align 8 
  %envptr28113 = getelementptr inbounds i64, i64* %envptr28112, i64 5 
  store volatile i64* %envptr28113, i64** %vptr28115, align 8 ; &envptr28112[4]
 %vptr28116 = alloca i64, align 8 
  %Ycz$f = load i64, i64* %envptr28113, align 8 
  store volatile i64 %Ycz$f, i64* %vptr28116, align 8 ; load; *envptr28113
 %vptr28119 = alloca i64, align 8 
  %envptr28117 = inttoptr i64 %env11670 to i64* 
  store volatile i64 %Xz7$_37foldl, i64* %vptr28119, align 8 ; closure/env cast; i64 -> i64*
  %vptr28120 = alloca i64*, align 8 
  %envptr28118 = getelementptr inbounds i64, i64* %envptr28117, i64 4 
  store volatile i64* %envptr28118, i64** %vptr28120, align 8 ; &envptr28117[3]
 %vptr28121 = alloca i64, align 8 
  %Xz7$_37foldl = load i64, i64* %envptr28118, align 8 
  store volatile i64 %Xz7$_37foldl, i64* %vptr28121, align 8 ; load; *envptr28118
 %vptr28124 = alloca i64, align 8 
  %envptr28122 = inttoptr i64 %env11670 to i64* 
  store volatile i64 %emsg18637, i64* %vptr28124, align 8 ; closure/env cast; i64 -> i64*
  %vptr28125 = alloca i64*, align 8 
  %envptr28123 = getelementptr inbounds i64, i64* %envptr28122, i64 3 
  store volatile i64* %envptr28123, i64** %vptr28125, align 8 ; &envptr28122[2]
 %vptr28126 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr28123, align 8 
  store volatile i64 %emsg18637, i64* %vptr28126, align 8 ; load; *envptr28123
 %vptr28129 = alloca i64, align 8 
  %envptr28127 = inttoptr i64 %env11670 to i64* 
  store volatile i64 %k3m$lsts_43, i64* %vptr28129, align 8 ; closure/env cast; i64 -> i64*
  %vptr28130 = alloca i64*, align 8 
  %envptr28128 = getelementptr inbounds i64, i64* %envptr28127, i64 2 
  store volatile i64* %envptr28128, i64** %vptr28130, align 8 ; &envptr28127[1]
 %vptr28131 = alloca i64, align 8 
  %k3m$lsts_43 = load i64, i64* %envptr28128, align 8 
  store volatile i64 %k3m$lsts_43, i64* %vptr28131, align 8 ; load; *envptr28128
 %vptr28132 = alloca i64, align 8 
  %_957306 = call i64 @prim_car(i64 %rvp10784) 
  store volatile i64 %_957306, i64* %vptr28132, align 8 ; call prim_car
 %vptr28133 = alloca i64, align 8 
  %rvp10780 = call i64 @prim_cdr(i64 %rvp10784) 
  store volatile i64 %rvp10780, i64* %vptr28133, align 8 ; call prim_cdr
 %vptr28134 = alloca i64, align 8 
  %n_6310785 = call i64 @prim_null_63(i64 %rvp10780) 
  store volatile i64 %n_6310785, i64* %vptr28134, align 8 ; call prim_null_63
  %cmpptr28138 = alloca i1, align 8  %cmp28135 = icmp eq i64 %n_6310785, 15 store volatile i1 %cmp28135, i1* %cmpptr28138, align 8; false?
  br i1 %cmp28135, label %else28137, label %then28136                                ; if

then28136:
 %vptr28139 = alloca i64, align 8 
  %h10786 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10786, i64* %vptr28139, align 8 ; call prim_halt
  %vptr28145 = alloca i64*, align 8 
  %cloptr28140 = inttoptr i64 %h10786 to i64* 
  store volatile i64* %cloptr28140, i64** %vptr28145, align 8 ; closure/env cast; i64 -> i64*
  %vptr28146 = alloca i64*, align 8 
  %i0ptr28141 = getelementptr inbounds i64, i64* %cloptr28140, i64 1 
  store volatile i64* %i0ptr28141, i64** %vptr28146, align 8 ; &cloptr28140[1]
 %vptr28147 = alloca i64, align 8 
  %f28143 = load i64, i64* %i0ptr28141, align 8 
  store volatile i64 %f28143, i64* %vptr28147, align 8 ; load; *i0ptr28141
  %fptr28142 = inttoptr i64 %f28143 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28142(i64 %h10786, i64 %h10786)                     ; tail call
  ret void

else28137:
 %vptr28148 = alloca i64, align 8 
  %a6951 = call i64 @prim_car(i64 %rvp10780) 
  store volatile i64 %a6951, i64* %vptr28148, align 8 ; call prim_car
 %vptr28149 = alloca i64, align 8 
  %na10769 = call i64 @prim_cdr(i64 %rvp10780) 
  store volatile i64 %na10769, i64* %vptr28149, align 8 ; call prim_cdr
 %vptr28150 = alloca i64, align 8 
  %n_6310781 = call i64 @prim_null_63(i64 %na10769) 
  store volatile i64 %n_6310781, i64* %vptr28150, align 8 ; call prim_null_63
  %cmpptr28154 = alloca i1, align 8  %cmp28151 = icmp eq i64 %n_6310781, 15 store volatile i1 %cmp28151, i1* %cmpptr28154, align 8; false?
  br i1 %cmp28151, label %else28153, label %then28152                                ; if

then28152:
  %vptr28164 = alloca i64*, align 8 
  %cloptr28155 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr28155, i64** %vptr28164, align 8 ; malloc
  %vptr28165 = alloca i64*, align 8 
  %eptr28157 = getelementptr inbounds i64, i64* %cloptr28155, i64 2 
  store volatile i64* %eptr28157, i64** %vptr28165, align 8 ; &eptr28157[1]
  %vptr28166 = alloca i64*, align 8 
  %eptr28158 = getelementptr inbounds i64, i64* %cloptr28155, i64 3 
  store volatile i64* %eptr28158, i64** %vptr28166, align 8 ; &eptr28158[2]
  %vptr28167 = alloca i64*, align 8 
  %eptr28159 = getelementptr inbounds i64, i64* %cloptr28155, i64 4 
  store volatile i64* %eptr28159, i64** %vptr28167, align 8 ; &eptr28159[3]
  %vptr28168 = alloca i64*, align 8 
  %eptr28160 = getelementptr inbounds i64, i64* %cloptr28155, i64 5 
  store volatile i64* %eptr28160, i64** %vptr28168, align 8 ; &eptr28160[4]
  %vptr28169 = alloca i64*, align 8 
  %eptr28161 = getelementptr inbounds i64, i64* %cloptr28155, i64 6 
  store volatile i64* %eptr28161, i64** %vptr28169, align 8 ; &eptr28161[5]
  %vptr28170 = alloca i64*, align 8 
  %eptr28162 = getelementptr inbounds i64, i64* %cloptr28155, i64 7 
  store volatile i64* %eptr28162, i64** %vptr28170, align 8 ; &eptr28162[6]
  store i64 %k3m$lsts_43, i64* %eptr28157                                            ; *eptr28157 = %k3m$lsts_43
  store i64 %emsg18637, i64* %eptr28158                                              ; *eptr28158 = %emsg18637
  store i64 %Xz7$_37foldl, i64* %eptr28159                                           ; *eptr28159 = %Xz7$_37foldl
  store i64 %Ycz$f, i64* %eptr28160                                                  ; *eptr28160 = %Ycz$f
  store i64 %emsg08636, i64* %eptr28161                                              ; *eptr28161 = %emsg08636
  store i64 %cont7297, i64* %eptr28162                                               ; *eptr28162 = %cont7297
  %vptr28171 = alloca i64*, align 8 
  %eptr28156 = getelementptr inbounds i64, i64* %cloptr28155, i64 1 
  store volatile i64* %eptr28156, i64** %vptr28171, align 8 ; &cloptr28155[1]
 %vptr28172 = alloca i64, align 8 
  %f28163 = ptrtoint void(i64,i64)* @lam11667 to i64 
  store volatile i64 %f28163, i64* %vptr28172, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f28163, i64* %eptr28156                                                 ; store fptr
 %vptr28173 = alloca i64, align 8 
  %arg8428 = ptrtoint i64* %cloptr28155 to i64 
  store volatile i64 %arg8428, i64* %vptr28173, align 8 ; closure cast; i64* -> i64
 %vptr28174 = alloca i64, align 8 
  %cps_45lst7307 = call i64 @prim_cons(i64 %arg8428, i64 %a6951) 
  store volatile i64 %cps_45lst7307, i64* %vptr28174, align 8 ; call prim_cons
  %vptr28180 = alloca i64*, align 8 
  %cloptr28175 = inttoptr i64 %Ycz$f to i64* 
  store volatile i64* %cloptr28175, i64** %vptr28180, align 8 ; closure/env cast; i64 -> i64*
  %vptr28181 = alloca i64*, align 8 
  %i0ptr28176 = getelementptr inbounds i64, i64* %cloptr28175, i64 1 
  store volatile i64* %i0ptr28176, i64** %vptr28181, align 8 ; &cloptr28175[1]
 %vptr28182 = alloca i64, align 8 
  %f28178 = load i64, i64* %i0ptr28176, align 8 
  store volatile i64 %f28178, i64* %vptr28182, align 8 ; load; *i0ptr28176
  %fptr28177 = inttoptr i64 %f28178 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28177(i64 %Ycz$f, i64 %cps_45lst7307)               ; tail call
  ret void

else28153:
 %vptr28183 = alloca i64, align 8 
  %h10782 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10782, i64* %vptr28183, align 8 ; call prim_halt
  %vptr28189 = alloca i64*, align 8 
  %cloptr28184 = inttoptr i64 %h10782 to i64* 
  store volatile i64* %cloptr28184, i64** %vptr28189, align 8 ; closure/env cast; i64 -> i64*
  %vptr28190 = alloca i64*, align 8 
  %i0ptr28185 = getelementptr inbounds i64, i64* %cloptr28184, i64 1 
  store volatile i64* %i0ptr28185, i64** %vptr28190, align 8 ; &cloptr28184[1]
 %vptr28191 = alloca i64, align 8 
  %f28187 = load i64, i64* %i0ptr28185, align 8 
  store volatile i64 %f28187, i64* %vptr28191, align 8 ; load; *i0ptr28185
  %fptr28186 = inttoptr i64 %f28187 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28186(i64 %h10782, i64 %h10782)                     ; tail call
  ret void
}


define void @lam11667(i64 %env11668, i64 %rvp10776) {
 %vptr28194 = alloca i64, align 8 
  %envptr28192 = inttoptr i64 %env11668 to i64* 
  store volatile i64 %cont7297, i64* %vptr28194, align 8 ; closure/env cast; i64 -> i64*
  %vptr28195 = alloca i64*, align 8 
  %envptr28193 = getelementptr inbounds i64, i64* %envptr28192, i64 7 
  store volatile i64* %envptr28193, i64** %vptr28195, align 8 ; &envptr28192[6]
 %vptr28196 = alloca i64, align 8 
  %cont7297 = load i64, i64* %envptr28193, align 8 
  store volatile i64 %cont7297, i64* %vptr28196, align 8 ; load; *envptr28193
 %vptr28199 = alloca i64, align 8 
  %envptr28197 = inttoptr i64 %env11668 to i64* 
  store volatile i64 %emsg08636, i64* %vptr28199, align 8 ; closure/env cast; i64 -> i64*
  %vptr28200 = alloca i64*, align 8 
  %envptr28198 = getelementptr inbounds i64, i64* %envptr28197, i64 6 
  store volatile i64* %envptr28198, i64** %vptr28200, align 8 ; &envptr28197[5]
 %vptr28201 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr28198, align 8 
  store volatile i64 %emsg08636, i64* %vptr28201, align 8 ; load; *envptr28198
 %vptr28204 = alloca i64, align 8 
  %envptr28202 = inttoptr i64 %env11668 to i64* 
  store volatile i64 %Ycz$f, i64* %vptr28204, align 8 ; closure/env cast; i64 -> i64*
  %vptr28205 = alloca i64*, align 8 
  %envptr28203 = getelementptr inbounds i64, i64* %envptr28202, i64 5 
  store volatile i64* %envptr28203, i64** %vptr28205, align 8 ; &envptr28202[4]
 %vptr28206 = alloca i64, align 8 
  %Ycz$f = load i64, i64* %envptr28203, align 8 
  store volatile i64 %Ycz$f, i64* %vptr28206, align 8 ; load; *envptr28203
 %vptr28209 = alloca i64, align 8 
  %envptr28207 = inttoptr i64 %env11668 to i64* 
  store volatile i64 %Xz7$_37foldl, i64* %vptr28209, align 8 ; closure/env cast; i64 -> i64*
  %vptr28210 = alloca i64*, align 8 
  %envptr28208 = getelementptr inbounds i64, i64* %envptr28207, i64 4 
  store volatile i64* %envptr28208, i64** %vptr28210, align 8 ; &envptr28207[3]
 %vptr28211 = alloca i64, align 8 
  %Xz7$_37foldl = load i64, i64* %envptr28208, align 8 
  store volatile i64 %Xz7$_37foldl, i64* %vptr28211, align 8 ; load; *envptr28208
 %vptr28214 = alloca i64, align 8 
  %envptr28212 = inttoptr i64 %env11668 to i64* 
  store volatile i64 %emsg18637, i64* %vptr28214, align 8 ; closure/env cast; i64 -> i64*
  %vptr28215 = alloca i64*, align 8 
  %envptr28213 = getelementptr inbounds i64, i64* %envptr28212, i64 3 
  store volatile i64* %envptr28213, i64** %vptr28215, align 8 ; &envptr28212[2]
 %vptr28216 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr28213, align 8 
  store volatile i64 %emsg18637, i64* %vptr28216, align 8 ; load; *envptr28213
 %vptr28219 = alloca i64, align 8 
  %envptr28217 = inttoptr i64 %env11668 to i64* 
  store volatile i64 %k3m$lsts_43, i64* %vptr28219, align 8 ; closure/env cast; i64 -> i64*
  %vptr28220 = alloca i64*, align 8 
  %envptr28218 = getelementptr inbounds i64, i64* %envptr28217, i64 2 
  store volatile i64* %envptr28218, i64** %vptr28220, align 8 ; &envptr28217[1]
 %vptr28221 = alloca i64, align 8 
  %k3m$lsts_43 = load i64, i64* %envptr28218, align 8 
  store volatile i64 %k3m$lsts_43, i64* %vptr28221, align 8 ; load; *envptr28218
 %vptr28222 = alloca i64, align 8 
  %_957304 = call i64 @prim_car(i64 %rvp10776) 
  store volatile i64 %_957304, i64* %vptr28222, align 8 ; call prim_car
 %vptr28223 = alloca i64, align 8 
  %rvp10772 = call i64 @prim_cdr(i64 %rvp10776) 
  store volatile i64 %rvp10772, i64* %vptr28223, align 8 ; call prim_cdr
 %vptr28224 = alloca i64, align 8 
  %n_6310777 = call i64 @prim_null_63(i64 %rvp10772) 
  store volatile i64 %n_6310777, i64* %vptr28224, align 8 ; call prim_null_63
  %cmpptr28228 = alloca i1, align 8  %cmp28225 = icmp eq i64 %n_6310777, 15 store volatile i1 %cmp28225, i1* %cmpptr28228, align 8; false?
  br i1 %cmp28225, label %else28227, label %then28226                                ; if

then28226:
 %vptr28229 = alloca i64, align 8 
  %h10778 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10778, i64* %vptr28229, align 8 ; call prim_halt
  %vptr28235 = alloca i64*, align 8 
  %cloptr28230 = inttoptr i64 %h10778 to i64* 
  store volatile i64* %cloptr28230, i64** %vptr28235, align 8 ; closure/env cast; i64 -> i64*
  %vptr28236 = alloca i64*, align 8 
  %i0ptr28231 = getelementptr inbounds i64, i64* %cloptr28230, i64 1 
  store volatile i64* %i0ptr28231, i64** %vptr28236, align 8 ; &cloptr28230[1]
 %vptr28237 = alloca i64, align 8 
  %f28233 = load i64, i64* %i0ptr28231, align 8 
  store volatile i64 %f28233, i64* %vptr28237, align 8 ; load; *i0ptr28231
  %fptr28232 = inttoptr i64 %f28233 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28232(i64 %h10778, i64 %h10778)                     ; tail call
  ret void

else28227:
 %vptr28238 = alloca i64, align 8 
  %KiO$acc_43 = call i64 @prim_car(i64 %rvp10772) 
  store volatile i64 %KiO$acc_43, i64* %vptr28238, align 8 ; call prim_car
 %vptr28239 = alloca i64, align 8 
  %na10771 = call i64 @prim_cdr(i64 %rvp10772) 
  store volatile i64 %na10771, i64* %vptr28239, align 8 ; call prim_cdr
 %vptr28240 = alloca i64, align 8 
  %n_6310773 = call i64 @prim_null_63(i64 %na10771) 
  store volatile i64 %n_6310773, i64* %vptr28240, align 8 ; call prim_null_63
  %cmpptr28244 = alloca i1, align 8  %cmp28241 = icmp eq i64 %n_6310773, 15 store volatile i1 %cmp28241, i1* %cmpptr28244, align 8; false?
  br i1 %cmp28241, label %else28243, label %then28242                                ; if

then28242:
 %vptr28245 = alloca i64, align 8 
  %a6952 = call i64 @prim_cons(i64 %KiO$acc_43, i64 %k3m$lsts_43) 
  store volatile i64 %a6952, i64* %vptr28245, align 8 ; call prim_cons
 %vptr28246 = alloca i64, align 8 
  %a6953 = call i64 @prim_cons(i64 %Ycz$f, i64 %a6952) 
  store volatile i64 %a6953, i64* %vptr28246, align 8 ; call prim_cons
 %vptr28247 = alloca i64, align 8 
  %cps_45lst7305 = call i64 @prim_cons(i64 %cont7297, i64 %a6953) 
  store volatile i64 %cps_45lst7305, i64* %vptr28247, align 8 ; call prim_cons
  %vptr28253 = alloca i64*, align 8 
  %cloptr28248 = inttoptr i64 %Xz7$_37foldl to i64* 
  store volatile i64* %cloptr28248, i64** %vptr28253, align 8 ; closure/env cast; i64 -> i64*
  %vptr28254 = alloca i64*, align 8 
  %i0ptr28249 = getelementptr inbounds i64, i64* %cloptr28248, i64 1 
  store volatile i64* %i0ptr28249, i64** %vptr28254, align 8 ; &cloptr28248[1]
 %vptr28255 = alloca i64, align 8 
  %f28251 = load i64, i64* %i0ptr28249, align 8 
  store volatile i64 %f28251, i64* %vptr28255, align 8 ; load; *i0ptr28249
  %fptr28250 = inttoptr i64 %f28251 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28250(i64 %Xz7$_37foldl, i64 %cps_45lst7305)        ; tail call
  ret void

else28243:
 %vptr28256 = alloca i64, align 8 
  %h10774 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10774, i64* %vptr28256, align 8 ; call prim_halt
  %vptr28262 = alloca i64*, align 8 
  %cloptr28257 = inttoptr i64 %h10774 to i64* 
  store volatile i64* %cloptr28257, i64** %vptr28262, align 8 ; closure/env cast; i64 -> i64*
  %vptr28263 = alloca i64*, align 8 
  %i0ptr28258 = getelementptr inbounds i64, i64* %cloptr28257, i64 1 
  store volatile i64* %i0ptr28258, i64** %vptr28263, align 8 ; &cloptr28257[1]
 %vptr28264 = alloca i64, align 8 
  %f28260 = load i64, i64* %i0ptr28258, align 8 
  store volatile i64 %f28260, i64* %vptr28264, align 8 ; load; *i0ptr28258
  %fptr28259 = inttoptr i64 %f28260 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28259(i64 %h10774, i64 %h10774)                     ; tail call
  ret void
}


define void @lam11665(i64 %env11666, i64 %rvp10801) {
 %vptr28267 = alloca i64, align 8 
  %envptr28265 = inttoptr i64 %env11666 to i64* 
  store volatile i64 %emsg08636, i64* %vptr28267, align 8 ; closure/env cast; i64 -> i64*
  %vptr28268 = alloca i64*, align 8 
  %envptr28266 = getelementptr inbounds i64, i64* %envptr28265, i64 3 
  store volatile i64* %envptr28266, i64** %vptr28268, align 8 ; &envptr28265[2]
 %vptr28269 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr28266, align 8 
  store volatile i64 %emsg08636, i64* %vptr28269, align 8 ; load; *envptr28266
 %vptr28272 = alloca i64, align 8 
  %envptr28270 = inttoptr i64 %env11666 to i64* 
  store volatile i64 %emsg18637, i64* %vptr28272, align 8 ; closure/env cast; i64 -> i64*
  %vptr28273 = alloca i64*, align 8 
  %envptr28271 = getelementptr inbounds i64, i64* %envptr28270, i64 2 
  store volatile i64* %envptr28271, i64** %vptr28273, align 8 ; &envptr28270[1]
 %vptr28274 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr28271, align 8 
  store volatile i64 %emsg18637, i64* %vptr28274, align 8 ; load; *envptr28271
 %vptr28275 = alloca i64, align 8 
  %cont7308 = call i64 @prim_car(i64 %rvp10801) 
  store volatile i64 %cont7308, i64* %vptr28275, align 8 ; call prim_car
 %vptr28276 = alloca i64, align 8 
  %rvp10797 = call i64 @prim_cdr(i64 %rvp10801) 
  store volatile i64 %rvp10797, i64* %vptr28276, align 8 ; call prim_cdr
 %vptr28277 = alloca i64, align 8 
  %n_6310802 = call i64 @prim_null_63(i64 %rvp10797) 
  store volatile i64 %n_6310802, i64* %vptr28277, align 8 ; call prim_null_63
  %cmpptr28281 = alloca i1, align 8  %cmp28278 = icmp eq i64 %n_6310802, 15 store volatile i1 %cmp28278, i1* %cmpptr28281, align 8; false?
  br i1 %cmp28278, label %else28280, label %then28279                                ; if

then28279:
 %vptr28282 = alloca i64, align 8 
  %h10803 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10803, i64* %vptr28282, align 8 ; call prim_halt
  %vptr28288 = alloca i64*, align 8 
  %cloptr28283 = inttoptr i64 %h10803 to i64* 
  store volatile i64* %cloptr28283, i64** %vptr28288, align 8 ; closure/env cast; i64 -> i64*
  %vptr28289 = alloca i64*, align 8 
  %i0ptr28284 = getelementptr inbounds i64, i64* %cloptr28283, i64 1 
  store volatile i64* %i0ptr28284, i64** %vptr28289, align 8 ; &cloptr28283[1]
 %vptr28290 = alloca i64, align 8 
  %f28286 = load i64, i64* %i0ptr28284, align 8 
  store volatile i64 %f28286, i64* %vptr28290, align 8 ; load; *i0ptr28284
  %fptr28285 = inttoptr i64 %f28286 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28285(i64 %h10803, i64 %h10803)                     ; tail call
  ret void

else28280:
 %vptr28291 = alloca i64, align 8 
  %G5k$a = call i64 @prim_car(i64 %rvp10797) 
  store volatile i64 %G5k$a, i64* %vptr28291, align 8 ; call prim_car
 %vptr28292 = alloca i64, align 8 
  %rvp10793 = call i64 @prim_cdr(i64 %rvp10797) 
  store volatile i64 %rvp10793, i64* %vptr28292, align 8 ; call prim_cdr
 %vptr28293 = alloca i64, align 8 
  %n_6310798 = call i64 @prim_null_63(i64 %rvp10793) 
  store volatile i64 %n_6310798, i64* %vptr28293, align 8 ; call prim_null_63
  %cmpptr28297 = alloca i1, align 8  %cmp28294 = icmp eq i64 %n_6310798, 15 store volatile i1 %cmp28294, i1* %cmpptr28297, align 8; false?
  br i1 %cmp28294, label %else28296, label %then28295                                ; if

then28295:
 %vptr28298 = alloca i64, align 8 
  %h10799 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10799, i64* %vptr28298, align 8 ; call prim_halt
  %vptr28304 = alloca i64*, align 8 
  %cloptr28299 = inttoptr i64 %h10799 to i64* 
  store volatile i64* %cloptr28299, i64** %vptr28304, align 8 ; closure/env cast; i64 -> i64*
  %vptr28305 = alloca i64*, align 8 
  %i0ptr28300 = getelementptr inbounds i64, i64* %cloptr28299, i64 1 
  store volatile i64* %i0ptr28300, i64** %vptr28305, align 8 ; &cloptr28299[1]
 %vptr28306 = alloca i64, align 8 
  %f28302 = load i64, i64* %i0ptr28300, align 8 
  store volatile i64 %f28302, i64* %vptr28306, align 8 ; load; *i0ptr28300
  %fptr28301 = inttoptr i64 %f28302 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28301(i64 %h10799, i64 %h10799)                     ; tail call
  ret void

else28296:
 %vptr28307 = alloca i64, align 8 
  %vAn$b = call i64 @prim_car(i64 %rvp10793) 
  store volatile i64 %vAn$b, i64* %vptr28307, align 8 ; call prim_car
 %vptr28308 = alloca i64, align 8 
  %na10789 = call i64 @prim_cdr(i64 %rvp10793) 
  store volatile i64 %na10789, i64* %vptr28308, align 8 ; call prim_cdr
 %vptr28309 = alloca i64, align 8 
  %n_6310794 = call i64 @prim_null_63(i64 %na10789) 
  store volatile i64 %n_6310794, i64* %vptr28309, align 8 ; call prim_null_63
  %cmpptr28313 = alloca i1, align 8  %cmp28310 = icmp eq i64 %n_6310794, 15 store volatile i1 %cmp28310, i1* %cmpptr28313, align 8; false?
  br i1 %cmp28310, label %else28312, label %then28311                                ; if

then28311:
 %vptr28314 = alloca i64, align 8 
  %retprim7309 = call i64 @prim_cons(i64 %G5k$a, i64 %vAn$b) 
  store volatile i64 %retprim7309, i64* %vptr28314, align 8 ; call prim_cons
 %vptr28315 = alloca i64, align 8 
  %arg8438 = add i64 0, 0 
  store volatile i64 %arg8438, i64* %vptr28315, align 8 ; quoted ()
 %vptr28316 = alloca i64, align 8 
  %rva10792 = add i64 0, 0 
  store volatile i64 %rva10792, i64* %vptr28316, align 8 ; quoted ()
 %vptr28317 = alloca i64, align 8 
  %rva10791 = call i64 @prim_cons(i64 %retprim7309, i64 %rva10792) 
  store volatile i64 %rva10791, i64* %vptr28317, align 8 ; call prim_cons
 %vptr28318 = alloca i64, align 8 
  %rva10790 = call i64 @prim_cons(i64 %arg8438, i64 %rva10791) 
  store volatile i64 %rva10790, i64* %vptr28318, align 8 ; call prim_cons
  %vptr28324 = alloca i64*, align 8 
  %cloptr28319 = inttoptr i64 %cont7308 to i64* 
  store volatile i64* %cloptr28319, i64** %vptr28324, align 8 ; closure/env cast; i64 -> i64*
  %vptr28325 = alloca i64*, align 8 
  %i0ptr28320 = getelementptr inbounds i64, i64* %cloptr28319, i64 1 
  store volatile i64* %i0ptr28320, i64** %vptr28325, align 8 ; &cloptr28319[1]
 %vptr28326 = alloca i64, align 8 
  %f28322 = load i64, i64* %i0ptr28320, align 8 
  store volatile i64 %f28322, i64* %vptr28326, align 8 ; load; *i0ptr28320
  %fptr28321 = inttoptr i64 %f28322 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28321(i64 %cont7308, i64 %rva10790)                 ; tail call
  ret void

else28312:
 %vptr28327 = alloca i64, align 8 
  %h10795 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10795, i64* %vptr28327, align 8 ; call prim_halt
  %vptr28333 = alloca i64*, align 8 
  %cloptr28328 = inttoptr i64 %h10795 to i64* 
  store volatile i64* %cloptr28328, i64** %vptr28333, align 8 ; closure/env cast; i64 -> i64*
  %vptr28334 = alloca i64*, align 8 
  %i0ptr28329 = getelementptr inbounds i64, i64* %cloptr28328, i64 1 
  store volatile i64* %i0ptr28329, i64** %vptr28334, align 8 ; &cloptr28328[1]
 %vptr28335 = alloca i64, align 8 
  %f28331 = load i64, i64* %i0ptr28329, align 8 
  store volatile i64 %f28331, i64* %vptr28335, align 8 ; load; *i0ptr28329
  %fptr28330 = inttoptr i64 %f28331 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28330(i64 %h10795, i64 %h10795)                     ; tail call
  ret void
}


define void @lam11660(i64 %env11661, i64 %rvp10827) {
 %vptr28338 = alloca i64, align 8 
  %envptr28336 = inttoptr i64 %env11661 to i64* 
  store volatile i64 %emsg08636, i64* %vptr28338, align 8 ; closure/env cast; i64 -> i64*
  %vptr28339 = alloca i64*, align 8 
  %envptr28337 = getelementptr inbounds i64, i64* %envptr28336, i64 3 
  store volatile i64* %envptr28337, i64** %vptr28339, align 8 ; &envptr28336[2]
 %vptr28340 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr28337, align 8 
  store volatile i64 %emsg08636, i64* %vptr28340, align 8 ; load; *envptr28337
 %vptr28343 = alloca i64, align 8 
  %envptr28341 = inttoptr i64 %env11661 to i64* 
  store volatile i64 %emsg18637, i64* %vptr28343, align 8 ; closure/env cast; i64 -> i64*
  %vptr28344 = alloca i64*, align 8 
  %envptr28342 = getelementptr inbounds i64, i64* %envptr28341, i64 2 
  store volatile i64* %envptr28342, i64** %vptr28344, align 8 ; &envptr28341[1]
 %vptr28345 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr28342, align 8 
  store volatile i64 %emsg18637, i64* %vptr28345, align 8 ; load; *envptr28342
 %vptr28346 = alloca i64, align 8 
  %cont7310 = call i64 @prim_car(i64 %rvp10827) 
  store volatile i64 %cont7310, i64* %vptr28346, align 8 ; call prim_car
 %vptr28347 = alloca i64, align 8 
  %rvp10823 = call i64 @prim_cdr(i64 %rvp10827) 
  store volatile i64 %rvp10823, i64* %vptr28347, align 8 ; call prim_cdr
 %vptr28348 = alloca i64, align 8 
  %n_6310828 = call i64 @prim_null_63(i64 %rvp10823) 
  store volatile i64 %n_6310828, i64* %vptr28348, align 8 ; call prim_null_63
  %cmpptr28352 = alloca i1, align 8  %cmp28349 = icmp eq i64 %n_6310828, 15 store volatile i1 %cmp28349, i1* %cmpptr28352, align 8; false?
  br i1 %cmp28349, label %else28351, label %then28350                                ; if

then28350:
 %vptr28353 = alloca i64, align 8 
  %h10829 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10829, i64* %vptr28353, align 8 ; call prim_halt
  %vptr28359 = alloca i64*, align 8 
  %cloptr28354 = inttoptr i64 %h10829 to i64* 
  store volatile i64* %cloptr28354, i64** %vptr28359, align 8 ; closure/env cast; i64 -> i64*
  %vptr28360 = alloca i64*, align 8 
  %i0ptr28355 = getelementptr inbounds i64, i64* %cloptr28354, i64 1 
  store volatile i64* %i0ptr28355, i64** %vptr28360, align 8 ; &cloptr28354[1]
 %vptr28361 = alloca i64, align 8 
  %f28357 = load i64, i64* %i0ptr28355, align 8 
  store volatile i64 %f28357, i64* %vptr28361, align 8 ; load; *i0ptr28355
  %fptr28356 = inttoptr i64 %f28357 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28356(i64 %h10829, i64 %h10829)                     ; tail call
  ret void

else28351:
 %vptr28362 = alloca i64, align 8 
  %wlL$x = call i64 @prim_car(i64 %rvp10823) 
  store volatile i64 %wlL$x, i64* %vptr28362, align 8 ; call prim_car
 %vptr28363 = alloca i64, align 8 
  %na10819 = call i64 @prim_cdr(i64 %rvp10823) 
  store volatile i64 %na10819, i64* %vptr28363, align 8 ; call prim_cdr
 %vptr28364 = alloca i64, align 8 
  %n_6310824 = call i64 @prim_null_63(i64 %na10819) 
  store volatile i64 %n_6310824, i64* %vptr28364, align 8 ; call prim_null_63
  %cmpptr28368 = alloca i1, align 8  %cmp28365 = icmp eq i64 %n_6310824, 15 store volatile i1 %cmp28365, i1* %cmpptr28368, align 8; false?
  br i1 %cmp28365, label %else28367, label %then28366                                ; if

then28366:
 %vptr28369 = alloca i64, align 8 
  %retprim7311 = call i64 @prim_car(i64 %wlL$x) 
  store volatile i64 %retprim7311, i64* %vptr28369, align 8 ; call prim_car
 %vptr28370 = alloca i64, align 8 
  %arg8442 = add i64 0, 0 
  store volatile i64 %arg8442, i64* %vptr28370, align 8 ; quoted ()
 %vptr28371 = alloca i64, align 8 
  %rva10822 = add i64 0, 0 
  store volatile i64 %rva10822, i64* %vptr28371, align 8 ; quoted ()
 %vptr28372 = alloca i64, align 8 
  %rva10821 = call i64 @prim_cons(i64 %retprim7311, i64 %rva10822) 
  store volatile i64 %rva10821, i64* %vptr28372, align 8 ; call prim_cons
 %vptr28373 = alloca i64, align 8 
  %rva10820 = call i64 @prim_cons(i64 %arg8442, i64 %rva10821) 
  store volatile i64 %rva10820, i64* %vptr28373, align 8 ; call prim_cons
  %vptr28379 = alloca i64*, align 8 
  %cloptr28374 = inttoptr i64 %cont7310 to i64* 
  store volatile i64* %cloptr28374, i64** %vptr28379, align 8 ; closure/env cast; i64 -> i64*
  %vptr28380 = alloca i64*, align 8 
  %i0ptr28375 = getelementptr inbounds i64, i64* %cloptr28374, i64 1 
  store volatile i64* %i0ptr28375, i64** %vptr28380, align 8 ; &cloptr28374[1]
 %vptr28381 = alloca i64, align 8 
  %f28377 = load i64, i64* %i0ptr28375, align 8 
  store volatile i64 %f28377, i64* %vptr28381, align 8 ; load; *i0ptr28375
  %fptr28376 = inttoptr i64 %f28377 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28376(i64 %cont7310, i64 %rva10820)                 ; tail call
  ret void

else28367:
 %vptr28382 = alloca i64, align 8 
  %h10825 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10825, i64* %vptr28382, align 8 ; call prim_halt
  %vptr28388 = alloca i64*, align 8 
  %cloptr28383 = inttoptr i64 %h10825 to i64* 
  store volatile i64* %cloptr28383, i64** %vptr28388, align 8 ; closure/env cast; i64 -> i64*
  %vptr28389 = alloca i64*, align 8 
  %i0ptr28384 = getelementptr inbounds i64, i64* %cloptr28383, i64 1 
  store volatile i64* %i0ptr28384, i64** %vptr28389, align 8 ; &cloptr28383[1]
 %vptr28390 = alloca i64, align 8 
  %f28386 = load i64, i64* %i0ptr28384, align 8 
  store volatile i64 %f28386, i64* %vptr28390, align 8 ; load; *i0ptr28384
  %fptr28385 = inttoptr i64 %f28386 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28385(i64 %h10825, i64 %h10825)                     ; tail call
  ret void
}


define void @lam11655(i64 %env11656, i64 %rvp10852) {
 %vptr28393 = alloca i64, align 8 
  %envptr28391 = inttoptr i64 %env11656 to i64* 
  store volatile i64 %emsg08636, i64* %vptr28393, align 8 ; closure/env cast; i64 -> i64*
  %vptr28394 = alloca i64*, align 8 
  %envptr28392 = getelementptr inbounds i64, i64* %envptr28391, i64 3 
  store volatile i64* %envptr28392, i64** %vptr28394, align 8 ; &envptr28391[2]
 %vptr28395 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr28392, align 8 
  store volatile i64 %emsg08636, i64* %vptr28395, align 8 ; load; *envptr28392
 %vptr28398 = alloca i64, align 8 
  %envptr28396 = inttoptr i64 %env11656 to i64* 
  store volatile i64 %emsg18637, i64* %vptr28398, align 8 ; closure/env cast; i64 -> i64*
  %vptr28399 = alloca i64*, align 8 
  %envptr28397 = getelementptr inbounds i64, i64* %envptr28396, i64 2 
  store volatile i64* %envptr28397, i64** %vptr28399, align 8 ; &envptr28396[1]
 %vptr28400 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr28397, align 8 
  store volatile i64 %emsg18637, i64* %vptr28400, align 8 ; load; *envptr28397
 %vptr28401 = alloca i64, align 8 
  %cont7312 = call i64 @prim_car(i64 %rvp10852) 
  store volatile i64 %cont7312, i64* %vptr28401, align 8 ; call prim_car
 %vptr28402 = alloca i64, align 8 
  %rvp10848 = call i64 @prim_cdr(i64 %rvp10852) 
  store volatile i64 %rvp10848, i64* %vptr28402, align 8 ; call prim_cdr
 %vptr28403 = alloca i64, align 8 
  %n_6310853 = call i64 @prim_null_63(i64 %rvp10848) 
  store volatile i64 %n_6310853, i64* %vptr28403, align 8 ; call prim_null_63
  %cmpptr28407 = alloca i1, align 8  %cmp28404 = icmp eq i64 %n_6310853, 15 store volatile i1 %cmp28404, i1* %cmpptr28407, align 8; false?
  br i1 %cmp28404, label %else28406, label %then28405                                ; if

then28405:
 %vptr28408 = alloca i64, align 8 
  %h10854 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10854, i64* %vptr28408, align 8 ; call prim_halt
  %vptr28414 = alloca i64*, align 8 
  %cloptr28409 = inttoptr i64 %h10854 to i64* 
  store volatile i64* %cloptr28409, i64** %vptr28414, align 8 ; closure/env cast; i64 -> i64*
  %vptr28415 = alloca i64*, align 8 
  %i0ptr28410 = getelementptr inbounds i64, i64* %cloptr28409, i64 1 
  store volatile i64* %i0ptr28410, i64** %vptr28415, align 8 ; &cloptr28409[1]
 %vptr28416 = alloca i64, align 8 
  %f28412 = load i64, i64* %i0ptr28410, align 8 
  store volatile i64 %f28412, i64* %vptr28416, align 8 ; load; *i0ptr28410
  %fptr28411 = inttoptr i64 %f28412 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28411(i64 %h10854, i64 %h10854)                     ; tail call
  ret void

else28406:
 %vptr28417 = alloca i64, align 8 
  %pDc$x = call i64 @prim_car(i64 %rvp10848) 
  store volatile i64 %pDc$x, i64* %vptr28417, align 8 ; call prim_car
 %vptr28418 = alloca i64, align 8 
  %na10844 = call i64 @prim_cdr(i64 %rvp10848) 
  store volatile i64 %na10844, i64* %vptr28418, align 8 ; call prim_cdr
 %vptr28419 = alloca i64, align 8 
  %n_6310849 = call i64 @prim_null_63(i64 %na10844) 
  store volatile i64 %n_6310849, i64* %vptr28419, align 8 ; call prim_null_63
  %cmpptr28423 = alloca i1, align 8  %cmp28420 = icmp eq i64 %n_6310849, 15 store volatile i1 %cmp28420, i1* %cmpptr28423, align 8; false?
  br i1 %cmp28420, label %else28422, label %then28421                                ; if

then28421:
 %vptr28424 = alloca i64, align 8 
  %retprim7313 = call i64 @prim_cdr(i64 %pDc$x) 
  store volatile i64 %retprim7313, i64* %vptr28424, align 8 ; call prim_cdr
 %vptr28425 = alloca i64, align 8 
  %arg8446 = add i64 0, 0 
  store volatile i64 %arg8446, i64* %vptr28425, align 8 ; quoted ()
 %vptr28426 = alloca i64, align 8 
  %rva10847 = add i64 0, 0 
  store volatile i64 %rva10847, i64* %vptr28426, align 8 ; quoted ()
 %vptr28427 = alloca i64, align 8 
  %rva10846 = call i64 @prim_cons(i64 %retprim7313, i64 %rva10847) 
  store volatile i64 %rva10846, i64* %vptr28427, align 8 ; call prim_cons
 %vptr28428 = alloca i64, align 8 
  %rva10845 = call i64 @prim_cons(i64 %arg8446, i64 %rva10846) 
  store volatile i64 %rva10845, i64* %vptr28428, align 8 ; call prim_cons
  %vptr28434 = alloca i64*, align 8 
  %cloptr28429 = inttoptr i64 %cont7312 to i64* 
  store volatile i64* %cloptr28429, i64** %vptr28434, align 8 ; closure/env cast; i64 -> i64*
  %vptr28435 = alloca i64*, align 8 
  %i0ptr28430 = getelementptr inbounds i64, i64* %cloptr28429, i64 1 
  store volatile i64* %i0ptr28430, i64** %vptr28435, align 8 ; &cloptr28429[1]
 %vptr28436 = alloca i64, align 8 
  %f28432 = load i64, i64* %i0ptr28430, align 8 
  store volatile i64 %f28432, i64* %vptr28436, align 8 ; load; *i0ptr28430
  %fptr28431 = inttoptr i64 %f28432 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28431(i64 %cont7312, i64 %rva10845)                 ; tail call
  ret void

else28422:
 %vptr28437 = alloca i64, align 8 
  %h10850 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10850, i64* %vptr28437, align 8 ; call prim_halt
  %vptr28443 = alloca i64*, align 8 
  %cloptr28438 = inttoptr i64 %h10850 to i64* 
  store volatile i64* %cloptr28438, i64** %vptr28443, align 8 ; closure/env cast; i64 -> i64*
  %vptr28444 = alloca i64*, align 8 
  %i0ptr28439 = getelementptr inbounds i64, i64* %cloptr28438, i64 1 
  store volatile i64* %i0ptr28439, i64** %vptr28444, align 8 ; &cloptr28438[1]
 %vptr28445 = alloca i64, align 8 
  %f28441 = load i64, i64* %i0ptr28439, align 8 
  store volatile i64 %f28441, i64* %vptr28445, align 8 ; load; *i0ptr28439
  %fptr28440 = inttoptr i64 %f28441 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28440(i64 %h10850, i64 %h10850)                     ; tail call
  ret void
}


define void @lam11648(i64 %env11649, i64 %rvp10884) {
 %vptr28448 = alloca i64, align 8 
  %envptr28446 = inttoptr i64 %env11649 to i64* 
  store volatile i64 %emsg08636, i64* %vptr28448, align 8 ; closure/env cast; i64 -> i64*
  %vptr28449 = alloca i64*, align 8 
  %envptr28447 = getelementptr inbounds i64, i64* %envptr28446, i64 3 
  store volatile i64* %envptr28447, i64** %vptr28449, align 8 ; &envptr28446[2]
 %vptr28450 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr28447, align 8 
  store volatile i64 %emsg08636, i64* %vptr28450, align 8 ; load; *envptr28447
 %vptr28453 = alloca i64, align 8 
  %envptr28451 = inttoptr i64 %env11649 to i64* 
  store volatile i64 %emsg18637, i64* %vptr28453, align 8 ; closure/env cast; i64 -> i64*
  %vptr28454 = alloca i64*, align 8 
  %envptr28452 = getelementptr inbounds i64, i64* %envptr28451, i64 2 
  store volatile i64* %envptr28452, i64** %vptr28454, align 8 ; &envptr28451[1]
 %vptr28455 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr28452, align 8 
  store volatile i64 %emsg18637, i64* %vptr28455, align 8 ; load; *envptr28452
 %vptr28456 = alloca i64, align 8 
  %cont7314 = call i64 @prim_car(i64 %rvp10884) 
  store volatile i64 %cont7314, i64* %vptr28456, align 8 ; call prim_car
 %vptr28457 = alloca i64, align 8 
  %rvp10880 = call i64 @prim_cdr(i64 %rvp10884) 
  store volatile i64 %rvp10880, i64* %vptr28457, align 8 ; call prim_cdr
 %vptr28458 = alloca i64, align 8 
  %n_6310885 = call i64 @prim_null_63(i64 %rvp10880) 
  store volatile i64 %n_6310885, i64* %vptr28458, align 8 ; call prim_null_63
  %cmpptr28462 = alloca i1, align 8  %cmp28459 = icmp eq i64 %n_6310885, 15 store volatile i1 %cmp28459, i1* %cmpptr28462, align 8; false?
  br i1 %cmp28459, label %else28461, label %then28460                                ; if

then28460:
 %vptr28463 = alloca i64, align 8 
  %h10886 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10886, i64* %vptr28463, align 8 ; call prim_halt
  %vptr28469 = alloca i64*, align 8 
  %cloptr28464 = inttoptr i64 %h10886 to i64* 
  store volatile i64* %cloptr28464, i64** %vptr28469, align 8 ; closure/env cast; i64 -> i64*
  %vptr28470 = alloca i64*, align 8 
  %i0ptr28465 = getelementptr inbounds i64, i64* %cloptr28464, i64 1 
  store volatile i64* %i0ptr28465, i64** %vptr28470, align 8 ; &cloptr28464[1]
 %vptr28471 = alloca i64, align 8 
  %f28467 = load i64, i64* %i0ptr28465, align 8 
  store volatile i64 %f28467, i64* %vptr28471, align 8 ; load; *i0ptr28465
  %fptr28466 = inttoptr i64 %f28467 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28466(i64 %h10886, i64 %h10886)                     ; tail call
  ret void

else28461:
 %vptr28472 = alloca i64, align 8 
  %VTE$lst = call i64 @prim_car(i64 %rvp10880) 
  store volatile i64 %VTE$lst, i64* %vptr28472, align 8 ; call prim_car
 %vptr28473 = alloca i64, align 8 
  %rvp10876 = call i64 @prim_cdr(i64 %rvp10880) 
  store volatile i64 %rvp10876, i64* %vptr28473, align 8 ; call prim_cdr
 %vptr28474 = alloca i64, align 8 
  %n_6310881 = call i64 @prim_null_63(i64 %rvp10876) 
  store volatile i64 %n_6310881, i64* %vptr28474, align 8 ; call prim_null_63
  %cmpptr28478 = alloca i1, align 8  %cmp28475 = icmp eq i64 %n_6310881, 15 store volatile i1 %cmp28475, i1* %cmpptr28478, align 8; false?
  br i1 %cmp28475, label %else28477, label %then28476                                ; if

then28476:
 %vptr28479 = alloca i64, align 8 
  %h10882 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10882, i64* %vptr28479, align 8 ; call prim_halt
  %vptr28485 = alloca i64*, align 8 
  %cloptr28480 = inttoptr i64 %h10882 to i64* 
  store volatile i64* %cloptr28480, i64** %vptr28485, align 8 ; closure/env cast; i64 -> i64*
  %vptr28486 = alloca i64*, align 8 
  %i0ptr28481 = getelementptr inbounds i64, i64* %cloptr28480, i64 1 
  store volatile i64* %i0ptr28481, i64** %vptr28486, align 8 ; &cloptr28480[1]
 %vptr28487 = alloca i64, align 8 
  %f28483 = load i64, i64* %i0ptr28481, align 8 
  store volatile i64 %f28483, i64* %vptr28487, align 8 ; load; *i0ptr28481
  %fptr28482 = inttoptr i64 %f28483 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28482(i64 %h10882, i64 %h10882)                     ; tail call
  ret void

else28477:
 %vptr28488 = alloca i64, align 8 
  %PQl$b = call i64 @prim_car(i64 %rvp10876) 
  store volatile i64 %PQl$b, i64* %vptr28488, align 8 ; call prim_car
 %vptr28489 = alloca i64, align 8 
  %na10869 = call i64 @prim_cdr(i64 %rvp10876) 
  store volatile i64 %na10869, i64* %vptr28489, align 8 ; call prim_cdr
 %vptr28490 = alloca i64, align 8 
  %n_6310877 = call i64 @prim_null_63(i64 %na10869) 
  store volatile i64 %n_6310877, i64* %vptr28490, align 8 ; call prim_null_63
  %cmpptr28494 = alloca i1, align 8  %cmp28491 = icmp eq i64 %n_6310877, 15 store volatile i1 %cmp28491, i1* %cmpptr28494, align 8; false?
  br i1 %cmp28491, label %else28493, label %then28492                                ; if

then28492:
  %cmpptr28498 = alloca i1, align 8  %cmp28495 = icmp eq i64 %PQl$b, 15 store volatile i1 %cmp28495, i1* %cmpptr28498, align 8; false?
  br i1 %cmp28495, label %else28497, label %then28496                                ; if

then28496:
 %vptr28499 = alloca i64, align 8 
  %arg8449 = add i64 0, 0 
  store volatile i64 %arg8449, i64* %vptr28499, align 8 ; quoted ()
 %vptr28500 = alloca i64, align 8 
  %rva10872 = add i64 0, 0 
  store volatile i64 %rva10872, i64* %vptr28500, align 8 ; quoted ()
 %vptr28501 = alloca i64, align 8 
  %rva10871 = call i64 @prim_cons(i64 %PQl$b, i64 %rva10872) 
  store volatile i64 %rva10871, i64* %vptr28501, align 8 ; call prim_cons
 %vptr28502 = alloca i64, align 8 
  %rva10870 = call i64 @prim_cons(i64 %arg8449, i64 %rva10871) 
  store volatile i64 %rva10870, i64* %vptr28502, align 8 ; call prim_cons
  %vptr28508 = alloca i64*, align 8 
  %cloptr28503 = inttoptr i64 %cont7314 to i64* 
  store volatile i64* %cloptr28503, i64** %vptr28508, align 8 ; closure/env cast; i64 -> i64*
  %vptr28509 = alloca i64*, align 8 
  %i0ptr28504 = getelementptr inbounds i64, i64* %cloptr28503, i64 1 
  store volatile i64* %i0ptr28504, i64** %vptr28509, align 8 ; &cloptr28503[1]
 %vptr28510 = alloca i64, align 8 
  %f28506 = load i64, i64* %i0ptr28504, align 8 
  store volatile i64 %f28506, i64* %vptr28510, align 8 ; load; *i0ptr28504
  %fptr28505 = inttoptr i64 %f28506 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28505(i64 %cont7314, i64 %rva10870)                 ; tail call
  ret void

else28497:
 %vptr28511 = alloca i64, align 8 
  %retprim7315 = call i64 @prim_null_63(i64 %VTE$lst) 
  store volatile i64 %retprim7315, i64* %vptr28511, align 8 ; call prim_null_63
 %vptr28512 = alloca i64, align 8 
  %arg8453 = add i64 0, 0 
  store volatile i64 %arg8453, i64* %vptr28512, align 8 ; quoted ()
 %vptr28513 = alloca i64, align 8 
  %rva10875 = add i64 0, 0 
  store volatile i64 %rva10875, i64* %vptr28513, align 8 ; quoted ()
 %vptr28514 = alloca i64, align 8 
  %rva10874 = call i64 @prim_cons(i64 %retprim7315, i64 %rva10875) 
  store volatile i64 %rva10874, i64* %vptr28514, align 8 ; call prim_cons
 %vptr28515 = alloca i64, align 8 
  %rva10873 = call i64 @prim_cons(i64 %arg8453, i64 %rva10874) 
  store volatile i64 %rva10873, i64* %vptr28515, align 8 ; call prim_cons
  %vptr28521 = alloca i64*, align 8 
  %cloptr28516 = inttoptr i64 %cont7314 to i64* 
  store volatile i64* %cloptr28516, i64** %vptr28521, align 8 ; closure/env cast; i64 -> i64*
  %vptr28522 = alloca i64*, align 8 
  %i0ptr28517 = getelementptr inbounds i64, i64* %cloptr28516, i64 1 
  store volatile i64* %i0ptr28517, i64** %vptr28522, align 8 ; &cloptr28516[1]
 %vptr28523 = alloca i64, align 8 
  %f28519 = load i64, i64* %i0ptr28517, align 8 
  store volatile i64 %f28519, i64* %vptr28523, align 8 ; load; *i0ptr28517
  %fptr28518 = inttoptr i64 %f28519 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28518(i64 %cont7314, i64 %rva10873)                 ; tail call
  ret void

else28493:
 %vptr28524 = alloca i64, align 8 
  %h10878 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10878, i64* %vptr28524, align 8 ; call prim_halt
  %vptr28530 = alloca i64*, align 8 
  %cloptr28525 = inttoptr i64 %h10878 to i64* 
  store volatile i64* %cloptr28525, i64** %vptr28530, align 8 ; closure/env cast; i64 -> i64*
  %vptr28531 = alloca i64*, align 8 
  %i0ptr28526 = getelementptr inbounds i64, i64* %cloptr28525, i64 1 
  store volatile i64* %i0ptr28526, i64** %vptr28531, align 8 ; &cloptr28525[1]
 %vptr28532 = alloca i64, align 8 
  %f28528 = load i64, i64* %i0ptr28526, align 8 
  store volatile i64 %f28528, i64* %vptr28532, align 8 ; load; *i0ptr28526
  %fptr28527 = inttoptr i64 %f28528 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28527(i64 %h10878, i64 %h10878)                     ; tail call
  ret void
}


define void @lam11634(i64 %env11635, i64 %rvp11106) {
 %vptr28535 = alloca i64, align 8 
  %envptr28533 = inttoptr i64 %env11635 to i64* 
  store volatile i64 %Gcn$_37map1, i64* %vptr28535, align 8 ; closure/env cast; i64 -> i64*
  %vptr28536 = alloca i64*, align 8 
  %envptr28534 = getelementptr inbounds i64, i64* %envptr28533, i64 5 
  store volatile i64* %envptr28534, i64** %vptr28536, align 8 ; &envptr28533[4]
 %vptr28537 = alloca i64, align 8 
  %Gcn$_37map1 = load i64, i64* %envptr28534, align 8 
  store volatile i64 %Gcn$_37map1, i64* %vptr28537, align 8 ; load; *envptr28534
 %vptr28540 = alloca i64, align 8 
  %envptr28538 = inttoptr i64 %env11635 to i64* 
  store volatile i64 %emsg08636, i64* %vptr28540, align 8 ; closure/env cast; i64 -> i64*
  %vptr28541 = alloca i64*, align 8 
  %envptr28539 = getelementptr inbounds i64, i64* %envptr28538, i64 4 
  store volatile i64* %envptr28539, i64** %vptr28541, align 8 ; &envptr28538[3]
 %vptr28542 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr28539, align 8 
  store volatile i64 %emsg08636, i64* %vptr28542, align 8 ; load; *envptr28539
 %vptr28545 = alloca i64, align 8 
  %envptr28543 = inttoptr i64 %env11635 to i64* 
  store volatile i64 %emsg18637, i64* %vptr28545, align 8 ; closure/env cast; i64 -> i64*
  %vptr28546 = alloca i64*, align 8 
  %envptr28544 = getelementptr inbounds i64, i64* %envptr28543, i64 3 
  store volatile i64* %envptr28544, i64** %vptr28546, align 8 ; &envptr28543[2]
 %vptr28547 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr28544, align 8 
  store volatile i64 %emsg18637, i64* %vptr28547, align 8 ; load; *envptr28544
 %vptr28550 = alloca i64, align 8 
  %envptr28548 = inttoptr i64 %env11635 to i64* 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr28550, align 8 ; closure/env cast; i64 -> i64*
  %vptr28551 = alloca i64*, align 8 
  %envptr28549 = getelementptr inbounds i64, i64* %envptr28548, i64 2 
  store volatile i64* %envptr28549, i64** %vptr28551, align 8 ; &envptr28548[1]
 %vptr28552 = alloca i64, align 8 
  %Mcq$_37foldr1 = load i64, i64* %envptr28549, align 8 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr28552, align 8 ; load; *envptr28549
 %vptr28553 = alloca i64, align 8 
  %cont7318 = call i64 @prim_car(i64 %rvp11106) 
  store volatile i64 %cont7318, i64* %vptr28553, align 8 ; call prim_car
 %vptr28554 = alloca i64, align 8 
  %rvp11102 = call i64 @prim_cdr(i64 %rvp11106) 
  store volatile i64 %rvp11102, i64* %vptr28554, align 8 ; call prim_cdr
 %vptr28555 = alloca i64, align 8 
  %n_6311107 = call i64 @prim_null_63(i64 %rvp11102) 
  store volatile i64 %n_6311107, i64* %vptr28555, align 8 ; call prim_null_63
  %cmpptr28559 = alloca i1, align 8  %cmp28556 = icmp eq i64 %n_6311107, 15 store volatile i1 %cmp28556, i1* %cmpptr28559, align 8; false?
  br i1 %cmp28556, label %else28558, label %then28557                                ; if

then28557:
 %vptr28560 = alloca i64, align 8 
  %h11108 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11108, i64* %vptr28560, align 8 ; call prim_halt
  %vptr28566 = alloca i64*, align 8 
  %cloptr28561 = inttoptr i64 %h11108 to i64* 
  store volatile i64* %cloptr28561, i64** %vptr28566, align 8 ; closure/env cast; i64 -> i64*
  %vptr28567 = alloca i64*, align 8 
  %i0ptr28562 = getelementptr inbounds i64, i64* %cloptr28561, i64 1 
  store volatile i64* %i0ptr28562, i64** %vptr28567, align 8 ; &cloptr28561[1]
 %vptr28568 = alloca i64, align 8 
  %f28564 = load i64, i64* %i0ptr28562, align 8 
  store volatile i64 %f28564, i64* %vptr28568, align 8 ; load; *i0ptr28562
  %fptr28563 = inttoptr i64 %f28564 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28563(i64 %h11108, i64 %h11108)                     ; tail call
  ret void

else28558:
 %vptr28569 = alloca i64, align 8 
  %lDS$_37foldr = call i64 @prim_car(i64 %rvp11102) 
  store volatile i64 %lDS$_37foldr, i64* %vptr28569, align 8 ; call prim_car
 %vptr28570 = alloca i64, align 8 
  %na10938 = call i64 @prim_cdr(i64 %rvp11102) 
  store volatile i64 %na10938, i64* %vptr28570, align 8 ; call prim_cdr
 %vptr28571 = alloca i64, align 8 
  %n_6311103 = call i64 @prim_null_63(i64 %na10938) 
  store volatile i64 %n_6311103, i64* %vptr28571, align 8 ; call prim_null_63
  %cmpptr28575 = alloca i1, align 8  %cmp28572 = icmp eq i64 %n_6311103, 15 store volatile i1 %cmp28572, i1* %cmpptr28575, align 8; false?
  br i1 %cmp28572, label %else28574, label %then28573                                ; if

then28573:
 %vptr28576 = alloca i64, align 8 
  %arg8456 = add i64 0, 0 
  store volatile i64 %arg8456, i64* %vptr28576, align 8 ; quoted ()
  %vptr28585 = alloca i64*, align 8 
  %cloptr28577 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr28577, i64** %vptr28585, align 8 ; malloc
  %vptr28586 = alloca i64*, align 8 
  %eptr28579 = getelementptr inbounds i64, i64* %cloptr28577, i64 2 
  store volatile i64* %eptr28579, i64** %vptr28586, align 8 ; &eptr28579[1]
  %vptr28587 = alloca i64*, align 8 
  %eptr28580 = getelementptr inbounds i64, i64* %cloptr28577, i64 3 
  store volatile i64* %eptr28580, i64** %vptr28587, align 8 ; &eptr28580[2]
  %vptr28588 = alloca i64*, align 8 
  %eptr28581 = getelementptr inbounds i64, i64* %cloptr28577, i64 4 
  store volatile i64* %eptr28581, i64** %vptr28588, align 8 ; &eptr28581[3]
  %vptr28589 = alloca i64*, align 8 
  %eptr28582 = getelementptr inbounds i64, i64* %cloptr28577, i64 5 
  store volatile i64* %eptr28582, i64** %vptr28589, align 8 ; &eptr28582[4]
  %vptr28590 = alloca i64*, align 8 
  %eptr28583 = getelementptr inbounds i64, i64* %cloptr28577, i64 6 
  store volatile i64* %eptr28583, i64** %vptr28590, align 8 ; &eptr28583[5]
  store i64 %Mcq$_37foldr1, i64* %eptr28579                                          ; *eptr28579 = %Mcq$_37foldr1
  store i64 %lDS$_37foldr, i64* %eptr28580                                           ; *eptr28580 = %lDS$_37foldr
  store i64 %emsg18637, i64* %eptr28581                                              ; *eptr28581 = %emsg18637
  store i64 %emsg08636, i64* %eptr28582                                              ; *eptr28582 = %emsg08636
  store i64 %Gcn$_37map1, i64* %eptr28583                                            ; *eptr28583 = %Gcn$_37map1
  %vptr28591 = alloca i64*, align 8 
  %eptr28578 = getelementptr inbounds i64, i64* %cloptr28577, i64 1 
  store volatile i64* %eptr28578, i64** %vptr28591, align 8 ; &cloptr28577[1]
 %vptr28592 = alloca i64, align 8 
  %f28584 = ptrtoint void(i64,i64)* @lam11631 to i64 
  store volatile i64 %f28584, i64* %vptr28592, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f28584, i64* %eptr28578                                                 ; store fptr
 %vptr28593 = alloca i64, align 8 
  %arg8455 = ptrtoint i64* %cloptr28577 to i64 
  store volatile i64 %arg8455, i64* %vptr28593, align 8 ; closure cast; i64* -> i64
 %vptr28594 = alloca i64, align 8 
  %rva11101 = add i64 0, 0 
  store volatile i64 %rva11101, i64* %vptr28594, align 8 ; quoted ()
 %vptr28595 = alloca i64, align 8 
  %rva11100 = call i64 @prim_cons(i64 %arg8455, i64 %rva11101) 
  store volatile i64 %rva11100, i64* %vptr28595, align 8 ; call prim_cons
 %vptr28596 = alloca i64, align 8 
  %rva11099 = call i64 @prim_cons(i64 %arg8456, i64 %rva11100) 
  store volatile i64 %rva11099, i64* %vptr28596, align 8 ; call prim_cons
  %vptr28602 = alloca i64*, align 8 
  %cloptr28597 = inttoptr i64 %cont7318 to i64* 
  store volatile i64* %cloptr28597, i64** %vptr28602, align 8 ; closure/env cast; i64 -> i64*
  %vptr28603 = alloca i64*, align 8 
  %i0ptr28598 = getelementptr inbounds i64, i64* %cloptr28597, i64 1 
  store volatile i64* %i0ptr28598, i64** %vptr28603, align 8 ; &cloptr28597[1]
 %vptr28604 = alloca i64, align 8 
  %f28600 = load i64, i64* %i0ptr28598, align 8 
  store volatile i64 %f28600, i64* %vptr28604, align 8 ; load; *i0ptr28598
  %fptr28599 = inttoptr i64 %f28600 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28599(i64 %cont7318, i64 %rva11099)                 ; tail call
  ret void

else28574:
 %vptr28605 = alloca i64, align 8 
  %h11104 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11104, i64* %vptr28605, align 8 ; call prim_halt
  %vptr28611 = alloca i64*, align 8 
  %cloptr28606 = inttoptr i64 %h11104 to i64* 
  store volatile i64* %cloptr28606, i64** %vptr28611, align 8 ; closure/env cast; i64 -> i64*
  %vptr28612 = alloca i64*, align 8 
  %i0ptr28607 = getelementptr inbounds i64, i64* %cloptr28606, i64 1 
  store volatile i64* %i0ptr28607, i64** %vptr28612, align 8 ; &cloptr28606[1]
 %vptr28613 = alloca i64, align 8 
  %f28609 = load i64, i64* %i0ptr28607, align 8 
  store volatile i64 %f28609, i64* %vptr28613, align 8 ; load; *i0ptr28607
  %fptr28608 = inttoptr i64 %f28609 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28608(i64 %h11104, i64 %h11104)                     ; tail call
  ret void
}


define void @lam11631(i64 %env11632, i64 %OmV$args7320) {
 %vptr28616 = alloca i64, align 8 
  %envptr28614 = inttoptr i64 %env11632 to i64* 
  store volatile i64 %Gcn$_37map1, i64* %vptr28616, align 8 ; closure/env cast; i64 -> i64*
  %vptr28617 = alloca i64*, align 8 
  %envptr28615 = getelementptr inbounds i64, i64* %envptr28614, i64 6 
  store volatile i64* %envptr28615, i64** %vptr28617, align 8 ; &envptr28614[5]
 %vptr28618 = alloca i64, align 8 
  %Gcn$_37map1 = load i64, i64* %envptr28615, align 8 
  store volatile i64 %Gcn$_37map1, i64* %vptr28618, align 8 ; load; *envptr28615
 %vptr28621 = alloca i64, align 8 
  %envptr28619 = inttoptr i64 %env11632 to i64* 
  store volatile i64 %emsg08636, i64* %vptr28621, align 8 ; closure/env cast; i64 -> i64*
  %vptr28622 = alloca i64*, align 8 
  %envptr28620 = getelementptr inbounds i64, i64* %envptr28619, i64 5 
  store volatile i64* %envptr28620, i64** %vptr28622, align 8 ; &envptr28619[4]
 %vptr28623 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr28620, align 8 
  store volatile i64 %emsg08636, i64* %vptr28623, align 8 ; load; *envptr28620
 %vptr28626 = alloca i64, align 8 
  %envptr28624 = inttoptr i64 %env11632 to i64* 
  store volatile i64 %emsg18637, i64* %vptr28626, align 8 ; closure/env cast; i64 -> i64*
  %vptr28627 = alloca i64*, align 8 
  %envptr28625 = getelementptr inbounds i64, i64* %envptr28624, i64 4 
  store volatile i64* %envptr28625, i64** %vptr28627, align 8 ; &envptr28624[3]
 %vptr28628 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr28625, align 8 
  store volatile i64 %emsg18637, i64* %vptr28628, align 8 ; load; *envptr28625
 %vptr28631 = alloca i64, align 8 
  %envptr28629 = inttoptr i64 %env11632 to i64* 
  store volatile i64 %lDS$_37foldr, i64* %vptr28631, align 8 ; closure/env cast; i64 -> i64*
  %vptr28632 = alloca i64*, align 8 
  %envptr28630 = getelementptr inbounds i64, i64* %envptr28629, i64 3 
  store volatile i64* %envptr28630, i64** %vptr28632, align 8 ; &envptr28629[2]
 %vptr28633 = alloca i64, align 8 
  %lDS$_37foldr = load i64, i64* %envptr28630, align 8 
  store volatile i64 %lDS$_37foldr, i64* %vptr28633, align 8 ; load; *envptr28630
 %vptr28636 = alloca i64, align 8 
  %envptr28634 = inttoptr i64 %env11632 to i64* 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr28636, align 8 ; closure/env cast; i64 -> i64*
  %vptr28637 = alloca i64*, align 8 
  %envptr28635 = getelementptr inbounds i64, i64* %envptr28634, i64 2 
  store volatile i64* %envptr28635, i64** %vptr28637, align 8 ; &envptr28634[1]
 %vptr28638 = alloca i64, align 8 
  %Mcq$_37foldr1 = load i64, i64* %envptr28635, align 8 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr28638, align 8 ; load; *envptr28635
 %vptr28639 = alloca i64, align 8 
  %cont7319 = call i64 @prim_car(i64 %OmV$args7320) 
  store volatile i64 %cont7319, i64* %vptr28639, align 8 ; call prim_car
 %vptr28640 = alloca i64, align 8 
  %OmV$args = call i64 @prim_cdr(i64 %OmV$args7320) 
  store volatile i64 %OmV$args, i64* %vptr28640, align 8 ; call prim_cdr
 %vptr28641 = alloca i64, align 8 
  %MYb$f = call i64 @prim_car(i64 %OmV$args) 
  store volatile i64 %MYb$f, i64* %vptr28641, align 8 ; call prim_car
 %vptr28642 = alloca i64, align 8 
  %a6933 = call i64 @prim_cdr(i64 %OmV$args) 
  store volatile i64 %a6933, i64* %vptr28642, align 8 ; call prim_cdr
 %vptr28643 = alloca i64, align 8 
  %retprim7339 = call i64 @prim_car(i64 %a6933) 
  store volatile i64 %retprim7339, i64* %vptr28643, align 8 ; call prim_car
  %vptr28655 = alloca i64*, align 8 
  %cloptr28644 = call i64* @make_closure(i64 72) 
  store volatile i64* %cloptr28644, i64** %vptr28655, align 8 ; malloc
  %vptr28656 = alloca i64*, align 8 
  %eptr28646 = getelementptr inbounds i64, i64* %cloptr28644, i64 2 
  store volatile i64* %eptr28646, i64** %vptr28656, align 8 ; &eptr28646[1]
  %vptr28657 = alloca i64*, align 8 
  %eptr28647 = getelementptr inbounds i64, i64* %cloptr28644, i64 3 
  store volatile i64* %eptr28647, i64** %vptr28657, align 8 ; &eptr28647[2]
  %vptr28658 = alloca i64*, align 8 
  %eptr28648 = getelementptr inbounds i64, i64* %cloptr28644, i64 4 
  store volatile i64* %eptr28648, i64** %vptr28658, align 8 ; &eptr28648[3]
  %vptr28659 = alloca i64*, align 8 
  %eptr28649 = getelementptr inbounds i64, i64* %cloptr28644, i64 5 
  store volatile i64* %eptr28649, i64** %vptr28659, align 8 ; &eptr28649[4]
  %vptr28660 = alloca i64*, align 8 
  %eptr28650 = getelementptr inbounds i64, i64* %cloptr28644, i64 6 
  store volatile i64* %eptr28650, i64** %vptr28660, align 8 ; &eptr28650[5]
  %vptr28661 = alloca i64*, align 8 
  %eptr28651 = getelementptr inbounds i64, i64* %cloptr28644, i64 7 
  store volatile i64* %eptr28651, i64** %vptr28661, align 8 ; &eptr28651[6]
  %vptr28662 = alloca i64*, align 8 
  %eptr28652 = getelementptr inbounds i64, i64* %cloptr28644, i64 8 
  store volatile i64* %eptr28652, i64** %vptr28662, align 8 ; &eptr28652[7]
  %vptr28663 = alloca i64*, align 8 
  %eptr28653 = getelementptr inbounds i64, i64* %cloptr28644, i64 9 
  store volatile i64* %eptr28653, i64** %vptr28663, align 8 ; &eptr28653[8]
  store i64 %Mcq$_37foldr1, i64* %eptr28646                                          ; *eptr28646 = %Mcq$_37foldr1
  store i64 %lDS$_37foldr, i64* %eptr28647                                           ; *eptr28647 = %lDS$_37foldr
  store i64 %emsg18637, i64* %eptr28648                                              ; *eptr28648 = %emsg18637
  store i64 %cont7319, i64* %eptr28649                                               ; *eptr28649 = %cont7319
  store i64 %OmV$args, i64* %eptr28650                                               ; *eptr28650 = %OmV$args
  store i64 %emsg08636, i64* %eptr28651                                              ; *eptr28651 = %emsg08636
  store i64 %MYb$f, i64* %eptr28652                                                  ; *eptr28652 = %MYb$f
  store i64 %Gcn$_37map1, i64* %eptr28653                                            ; *eptr28653 = %Gcn$_37map1
  %vptr28664 = alloca i64*, align 8 
  %eptr28645 = getelementptr inbounds i64, i64* %cloptr28644, i64 1 
  store volatile i64* %eptr28645, i64** %vptr28664, align 8 ; &cloptr28644[1]
 %vptr28665 = alloca i64, align 8 
  %f28654 = ptrtoint void(i64,i64)* @lam11629 to i64 
  store volatile i64 %f28654, i64* %vptr28665, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f28654, i64* %eptr28645                                                 ; store fptr
 %vptr28666 = alloca i64, align 8 
  %arg8465 = ptrtoint i64* %cloptr28644 to i64 
  store volatile i64 %arg8465, i64* %vptr28666, align 8 ; closure cast; i64* -> i64
 %vptr28667 = alloca i64, align 8 
  %arg8464 = add i64 0, 0 
  store volatile i64 %arg8464, i64* %vptr28667, align 8 ; quoted ()
 %vptr28668 = alloca i64, align 8 
  %rva11098 = add i64 0, 0 
  store volatile i64 %rva11098, i64* %vptr28668, align 8 ; quoted ()
 %vptr28669 = alloca i64, align 8 
  %rva11097 = call i64 @prim_cons(i64 %retprim7339, i64 %rva11098) 
  store volatile i64 %rva11097, i64* %vptr28669, align 8 ; call prim_cons
 %vptr28670 = alloca i64, align 8 
  %rva11096 = call i64 @prim_cons(i64 %arg8464, i64 %rva11097) 
  store volatile i64 %rva11096, i64* %vptr28670, align 8 ; call prim_cons
  %vptr28676 = alloca i64*, align 8 
  %cloptr28671 = inttoptr i64 %arg8465 to i64* 
  store volatile i64* %cloptr28671, i64** %vptr28676, align 8 ; closure/env cast; i64 -> i64*
  %vptr28677 = alloca i64*, align 8 
  %i0ptr28672 = getelementptr inbounds i64, i64* %cloptr28671, i64 1 
  store volatile i64* %i0ptr28672, i64** %vptr28677, align 8 ; &cloptr28671[1]
 %vptr28678 = alloca i64, align 8 
  %f28674 = load i64, i64* %i0ptr28672, align 8 
  store volatile i64 %f28674, i64* %vptr28678, align 8 ; load; *i0ptr28672
  %fptr28673 = inttoptr i64 %f28674 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28673(i64 %arg8465, i64 %rva11096)                  ; tail call
  ret void
}


define void @lam11629(i64 %env11630, i64 %rvp11092) {
 %vptr28681 = alloca i64, align 8 
  %envptr28679 = inttoptr i64 %env11630 to i64* 
  store volatile i64 %Gcn$_37map1, i64* %vptr28681, align 8 ; closure/env cast; i64 -> i64*
  %vptr28682 = alloca i64*, align 8 
  %envptr28680 = getelementptr inbounds i64, i64* %envptr28679, i64 9 
  store volatile i64* %envptr28680, i64** %vptr28682, align 8 ; &envptr28679[8]
 %vptr28683 = alloca i64, align 8 
  %Gcn$_37map1 = load i64, i64* %envptr28680, align 8 
  store volatile i64 %Gcn$_37map1, i64* %vptr28683, align 8 ; load; *envptr28680
 %vptr28686 = alloca i64, align 8 
  %envptr28684 = inttoptr i64 %env11630 to i64* 
  store volatile i64 %MYb$f, i64* %vptr28686, align 8 ; closure/env cast; i64 -> i64*
  %vptr28687 = alloca i64*, align 8 
  %envptr28685 = getelementptr inbounds i64, i64* %envptr28684, i64 8 
  store volatile i64* %envptr28685, i64** %vptr28687, align 8 ; &envptr28684[7]
 %vptr28688 = alloca i64, align 8 
  %MYb$f = load i64, i64* %envptr28685, align 8 
  store volatile i64 %MYb$f, i64* %vptr28688, align 8 ; load; *envptr28685
 %vptr28691 = alloca i64, align 8 
  %envptr28689 = inttoptr i64 %env11630 to i64* 
  store volatile i64 %emsg08636, i64* %vptr28691, align 8 ; closure/env cast; i64 -> i64*
  %vptr28692 = alloca i64*, align 8 
  %envptr28690 = getelementptr inbounds i64, i64* %envptr28689, i64 7 
  store volatile i64* %envptr28690, i64** %vptr28692, align 8 ; &envptr28689[6]
 %vptr28693 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr28690, align 8 
  store volatile i64 %emsg08636, i64* %vptr28693, align 8 ; load; *envptr28690
 %vptr28696 = alloca i64, align 8 
  %envptr28694 = inttoptr i64 %env11630 to i64* 
  store volatile i64 %OmV$args, i64* %vptr28696, align 8 ; closure/env cast; i64 -> i64*
  %vptr28697 = alloca i64*, align 8 
  %envptr28695 = getelementptr inbounds i64, i64* %envptr28694, i64 6 
  store volatile i64* %envptr28695, i64** %vptr28697, align 8 ; &envptr28694[5]
 %vptr28698 = alloca i64, align 8 
  %OmV$args = load i64, i64* %envptr28695, align 8 
  store volatile i64 %OmV$args, i64* %vptr28698, align 8 ; load; *envptr28695
 %vptr28701 = alloca i64, align 8 
  %envptr28699 = inttoptr i64 %env11630 to i64* 
  store volatile i64 %cont7319, i64* %vptr28701, align 8 ; closure/env cast; i64 -> i64*
  %vptr28702 = alloca i64*, align 8 
  %envptr28700 = getelementptr inbounds i64, i64* %envptr28699, i64 5 
  store volatile i64* %envptr28700, i64** %vptr28702, align 8 ; &envptr28699[4]
 %vptr28703 = alloca i64, align 8 
  %cont7319 = load i64, i64* %envptr28700, align 8 
  store volatile i64 %cont7319, i64* %vptr28703, align 8 ; load; *envptr28700
 %vptr28706 = alloca i64, align 8 
  %envptr28704 = inttoptr i64 %env11630 to i64* 
  store volatile i64 %emsg18637, i64* %vptr28706, align 8 ; closure/env cast; i64 -> i64*
  %vptr28707 = alloca i64*, align 8 
  %envptr28705 = getelementptr inbounds i64, i64* %envptr28704, i64 4 
  store volatile i64* %envptr28705, i64** %vptr28707, align 8 ; &envptr28704[3]
 %vptr28708 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr28705, align 8 
  store volatile i64 %emsg18637, i64* %vptr28708, align 8 ; load; *envptr28705
 %vptr28711 = alloca i64, align 8 
  %envptr28709 = inttoptr i64 %env11630 to i64* 
  store volatile i64 %lDS$_37foldr, i64* %vptr28711, align 8 ; closure/env cast; i64 -> i64*
  %vptr28712 = alloca i64*, align 8 
  %envptr28710 = getelementptr inbounds i64, i64* %envptr28709, i64 3 
  store volatile i64* %envptr28710, i64** %vptr28712, align 8 ; &envptr28709[2]
 %vptr28713 = alloca i64, align 8 
  %lDS$_37foldr = load i64, i64* %envptr28710, align 8 
  store volatile i64 %lDS$_37foldr, i64* %vptr28713, align 8 ; load; *envptr28710
 %vptr28716 = alloca i64, align 8 
  %envptr28714 = inttoptr i64 %env11630 to i64* 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr28716, align 8 ; closure/env cast; i64 -> i64*
  %vptr28717 = alloca i64*, align 8 
  %envptr28715 = getelementptr inbounds i64, i64* %envptr28714, i64 2 
  store volatile i64* %envptr28715, i64** %vptr28717, align 8 ; &envptr28714[1]
 %vptr28718 = alloca i64, align 8 
  %Mcq$_37foldr1 = load i64, i64* %envptr28715, align 8 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr28718, align 8 ; load; *envptr28715
 %vptr28719 = alloca i64, align 8 
  %_957321 = call i64 @prim_car(i64 %rvp11092) 
  store volatile i64 %_957321, i64* %vptr28719, align 8 ; call prim_car
 %vptr28720 = alloca i64, align 8 
  %rvp11088 = call i64 @prim_cdr(i64 %rvp11092) 
  store volatile i64 %rvp11088, i64* %vptr28720, align 8 ; call prim_cdr
 %vptr28721 = alloca i64, align 8 
  %n_6311093 = call i64 @prim_null_63(i64 %rvp11088) 
  store volatile i64 %n_6311093, i64* %vptr28721, align 8 ; call prim_null_63
  %cmpptr28725 = alloca i1, align 8  %cmp28722 = icmp eq i64 %n_6311093, 15 store volatile i1 %cmp28722, i1* %cmpptr28725, align 8; false?
  br i1 %cmp28722, label %else28724, label %then28723                                ; if

then28723:
 %vptr28726 = alloca i64, align 8 
  %h11094 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11094, i64* %vptr28726, align 8 ; call prim_halt
  %vptr28732 = alloca i64*, align 8 
  %cloptr28727 = inttoptr i64 %h11094 to i64* 
  store volatile i64* %cloptr28727, i64** %vptr28732, align 8 ; closure/env cast; i64 -> i64*
  %vptr28733 = alloca i64*, align 8 
  %i0ptr28728 = getelementptr inbounds i64, i64* %cloptr28727, i64 1 
  store volatile i64* %i0ptr28728, i64** %vptr28733, align 8 ; &cloptr28727[1]
 %vptr28734 = alloca i64, align 8 
  %f28730 = load i64, i64* %i0ptr28728, align 8 
  store volatile i64 %f28730, i64* %vptr28734, align 8 ; load; *i0ptr28728
  %fptr28729 = inttoptr i64 %f28730 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28729(i64 %h11094, i64 %h11094)                     ; tail call
  ret void

else28724:
 %vptr28735 = alloca i64, align 8 
  %FWN$acc = call i64 @prim_car(i64 %rvp11088) 
  store volatile i64 %FWN$acc, i64* %vptr28735, align 8 ; call prim_car
 %vptr28736 = alloca i64, align 8 
  %na10940 = call i64 @prim_cdr(i64 %rvp11088) 
  store volatile i64 %na10940, i64* %vptr28736, align 8 ; call prim_cdr
 %vptr28737 = alloca i64, align 8 
  %n_6311089 = call i64 @prim_null_63(i64 %na10940) 
  store volatile i64 %n_6311089, i64* %vptr28737, align 8 ; call prim_null_63
  %cmpptr28741 = alloca i1, align 8  %cmp28738 = icmp eq i64 %n_6311089, 15 store volatile i1 %cmp28738, i1* %cmpptr28741, align 8; false?
  br i1 %cmp28738, label %else28740, label %then28739                                ; if

then28739:
 %vptr28742 = alloca i64, align 8 
  %a6934 = call i64 @prim_cdr(i64 %OmV$args) 
  store volatile i64 %a6934, i64* %vptr28742, align 8 ; call prim_cdr
 %vptr28743 = alloca i64, align 8 
  %retprim7338 = call i64 @prim_cdr(i64 %a6934) 
  store volatile i64 %retprim7338, i64* %vptr28743, align 8 ; call prim_cdr
  %vptr28755 = alloca i64*, align 8 
  %cloptr28744 = call i64* @make_closure(i64 72) 
  store volatile i64* %cloptr28744, i64** %vptr28755, align 8 ; malloc
  %vptr28756 = alloca i64*, align 8 
  %eptr28746 = getelementptr inbounds i64, i64* %cloptr28744, i64 2 
  store volatile i64* %eptr28746, i64** %vptr28756, align 8 ; &eptr28746[1]
  %vptr28757 = alloca i64*, align 8 
  %eptr28747 = getelementptr inbounds i64, i64* %cloptr28744, i64 3 
  store volatile i64* %eptr28747, i64** %vptr28757, align 8 ; &eptr28747[2]
  %vptr28758 = alloca i64*, align 8 
  %eptr28748 = getelementptr inbounds i64, i64* %cloptr28744, i64 4 
  store volatile i64* %eptr28748, i64** %vptr28758, align 8 ; &eptr28748[3]
  %vptr28759 = alloca i64*, align 8 
  %eptr28749 = getelementptr inbounds i64, i64* %cloptr28744, i64 5 
  store volatile i64* %eptr28749, i64** %vptr28759, align 8 ; &eptr28749[4]
  %vptr28760 = alloca i64*, align 8 
  %eptr28750 = getelementptr inbounds i64, i64* %cloptr28744, i64 6 
  store volatile i64* %eptr28750, i64** %vptr28760, align 8 ; &eptr28750[5]
  %vptr28761 = alloca i64*, align 8 
  %eptr28751 = getelementptr inbounds i64, i64* %cloptr28744, i64 7 
  store volatile i64* %eptr28751, i64** %vptr28761, align 8 ; &eptr28751[6]
  %vptr28762 = alloca i64*, align 8 
  %eptr28752 = getelementptr inbounds i64, i64* %cloptr28744, i64 8 
  store volatile i64* %eptr28752, i64** %vptr28762, align 8 ; &eptr28752[7]
  %vptr28763 = alloca i64*, align 8 
  %eptr28753 = getelementptr inbounds i64, i64* %cloptr28744, i64 9 
  store volatile i64* %eptr28753, i64** %vptr28763, align 8 ; &eptr28753[8]
  store i64 %Mcq$_37foldr1, i64* %eptr28746                                          ; *eptr28746 = %Mcq$_37foldr1
  store i64 %FWN$acc, i64* %eptr28747                                                ; *eptr28747 = %FWN$acc
  store i64 %lDS$_37foldr, i64* %eptr28748                                           ; *eptr28748 = %lDS$_37foldr
  store i64 %emsg18637, i64* %eptr28749                                              ; *eptr28749 = %emsg18637
  store i64 %cont7319, i64* %eptr28750                                               ; *eptr28750 = %cont7319
  store i64 %emsg08636, i64* %eptr28751                                              ; *eptr28751 = %emsg08636
  store i64 %MYb$f, i64* %eptr28752                                                  ; *eptr28752 = %MYb$f
  store i64 %Gcn$_37map1, i64* %eptr28753                                            ; *eptr28753 = %Gcn$_37map1
  %vptr28764 = alloca i64*, align 8 
  %eptr28745 = getelementptr inbounds i64, i64* %cloptr28744, i64 1 
  store volatile i64* %eptr28745, i64** %vptr28764, align 8 ; &cloptr28744[1]
 %vptr28765 = alloca i64, align 8 
  %f28754 = ptrtoint void(i64,i64)* @lam11627 to i64 
  store volatile i64 %f28754, i64* %vptr28765, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f28754, i64* %eptr28745                                                 ; store fptr
 %vptr28766 = alloca i64, align 8 
  %arg8470 = ptrtoint i64* %cloptr28744 to i64 
  store volatile i64 %arg8470, i64* %vptr28766, align 8 ; closure cast; i64* -> i64
 %vptr28767 = alloca i64, align 8 
  %arg8469 = add i64 0, 0 
  store volatile i64 %arg8469, i64* %vptr28767, align 8 ; quoted ()
 %vptr28768 = alloca i64, align 8 
  %rva11087 = add i64 0, 0 
  store volatile i64 %rva11087, i64* %vptr28768, align 8 ; quoted ()
 %vptr28769 = alloca i64, align 8 
  %rva11086 = call i64 @prim_cons(i64 %retprim7338, i64 %rva11087) 
  store volatile i64 %rva11086, i64* %vptr28769, align 8 ; call prim_cons
 %vptr28770 = alloca i64, align 8 
  %rva11085 = call i64 @prim_cons(i64 %arg8469, i64 %rva11086) 
  store volatile i64 %rva11085, i64* %vptr28770, align 8 ; call prim_cons
  %vptr28776 = alloca i64*, align 8 
  %cloptr28771 = inttoptr i64 %arg8470 to i64* 
  store volatile i64* %cloptr28771, i64** %vptr28776, align 8 ; closure/env cast; i64 -> i64*
  %vptr28777 = alloca i64*, align 8 
  %i0ptr28772 = getelementptr inbounds i64, i64* %cloptr28771, i64 1 
  store volatile i64* %i0ptr28772, i64** %vptr28777, align 8 ; &cloptr28771[1]
 %vptr28778 = alloca i64, align 8 
  %f28774 = load i64, i64* %i0ptr28772, align 8 
  store volatile i64 %f28774, i64* %vptr28778, align 8 ; load; *i0ptr28772
  %fptr28773 = inttoptr i64 %f28774 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28773(i64 %arg8470, i64 %rva11085)                  ; tail call
  ret void

else28740:
 %vptr28779 = alloca i64, align 8 
  %h11090 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11090, i64* %vptr28779, align 8 ; call prim_halt
  %vptr28785 = alloca i64*, align 8 
  %cloptr28780 = inttoptr i64 %h11090 to i64* 
  store volatile i64* %cloptr28780, i64** %vptr28785, align 8 ; closure/env cast; i64 -> i64*
  %vptr28786 = alloca i64*, align 8 
  %i0ptr28781 = getelementptr inbounds i64, i64* %cloptr28780, i64 1 
  store volatile i64* %i0ptr28781, i64** %vptr28786, align 8 ; &cloptr28780[1]
 %vptr28787 = alloca i64, align 8 
  %f28783 = load i64, i64* %i0ptr28781, align 8 
  store volatile i64 %f28783, i64* %vptr28787, align 8 ; load; *i0ptr28781
  %fptr28782 = inttoptr i64 %f28783 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28782(i64 %h11090, i64 %h11090)                     ; tail call
  ret void
}


define void @lam11627(i64 %env11628, i64 %rvp11081) {
 %vptr28790 = alloca i64, align 8 
  %envptr28788 = inttoptr i64 %env11628 to i64* 
  store volatile i64 %Gcn$_37map1, i64* %vptr28790, align 8 ; closure/env cast; i64 -> i64*
  %vptr28791 = alloca i64*, align 8 
  %envptr28789 = getelementptr inbounds i64, i64* %envptr28788, i64 9 
  store volatile i64* %envptr28789, i64** %vptr28791, align 8 ; &envptr28788[8]
 %vptr28792 = alloca i64, align 8 
  %Gcn$_37map1 = load i64, i64* %envptr28789, align 8 
  store volatile i64 %Gcn$_37map1, i64* %vptr28792, align 8 ; load; *envptr28789
 %vptr28795 = alloca i64, align 8 
  %envptr28793 = inttoptr i64 %env11628 to i64* 
  store volatile i64 %MYb$f, i64* %vptr28795, align 8 ; closure/env cast; i64 -> i64*
  %vptr28796 = alloca i64*, align 8 
  %envptr28794 = getelementptr inbounds i64, i64* %envptr28793, i64 8 
  store volatile i64* %envptr28794, i64** %vptr28796, align 8 ; &envptr28793[7]
 %vptr28797 = alloca i64, align 8 
  %MYb$f = load i64, i64* %envptr28794, align 8 
  store volatile i64 %MYb$f, i64* %vptr28797, align 8 ; load; *envptr28794
 %vptr28800 = alloca i64, align 8 
  %envptr28798 = inttoptr i64 %env11628 to i64* 
  store volatile i64 %emsg08636, i64* %vptr28800, align 8 ; closure/env cast; i64 -> i64*
  %vptr28801 = alloca i64*, align 8 
  %envptr28799 = getelementptr inbounds i64, i64* %envptr28798, i64 7 
  store volatile i64* %envptr28799, i64** %vptr28801, align 8 ; &envptr28798[6]
 %vptr28802 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr28799, align 8 
  store volatile i64 %emsg08636, i64* %vptr28802, align 8 ; load; *envptr28799
 %vptr28805 = alloca i64, align 8 
  %envptr28803 = inttoptr i64 %env11628 to i64* 
  store volatile i64 %cont7319, i64* %vptr28805, align 8 ; closure/env cast; i64 -> i64*
  %vptr28806 = alloca i64*, align 8 
  %envptr28804 = getelementptr inbounds i64, i64* %envptr28803, i64 6 
  store volatile i64* %envptr28804, i64** %vptr28806, align 8 ; &envptr28803[5]
 %vptr28807 = alloca i64, align 8 
  %cont7319 = load i64, i64* %envptr28804, align 8 
  store volatile i64 %cont7319, i64* %vptr28807, align 8 ; load; *envptr28804
 %vptr28810 = alloca i64, align 8 
  %envptr28808 = inttoptr i64 %env11628 to i64* 
  store volatile i64 %emsg18637, i64* %vptr28810, align 8 ; closure/env cast; i64 -> i64*
  %vptr28811 = alloca i64*, align 8 
  %envptr28809 = getelementptr inbounds i64, i64* %envptr28808, i64 5 
  store volatile i64* %envptr28809, i64** %vptr28811, align 8 ; &envptr28808[4]
 %vptr28812 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr28809, align 8 
  store volatile i64 %emsg18637, i64* %vptr28812, align 8 ; load; *envptr28809
 %vptr28815 = alloca i64, align 8 
  %envptr28813 = inttoptr i64 %env11628 to i64* 
  store volatile i64 %lDS$_37foldr, i64* %vptr28815, align 8 ; closure/env cast; i64 -> i64*
  %vptr28816 = alloca i64*, align 8 
  %envptr28814 = getelementptr inbounds i64, i64* %envptr28813, i64 4 
  store volatile i64* %envptr28814, i64** %vptr28816, align 8 ; &envptr28813[3]
 %vptr28817 = alloca i64, align 8 
  %lDS$_37foldr = load i64, i64* %envptr28814, align 8 
  store volatile i64 %lDS$_37foldr, i64* %vptr28817, align 8 ; load; *envptr28814
 %vptr28820 = alloca i64, align 8 
  %envptr28818 = inttoptr i64 %env11628 to i64* 
  store volatile i64 %FWN$acc, i64* %vptr28820, align 8 ; closure/env cast; i64 -> i64*
  %vptr28821 = alloca i64*, align 8 
  %envptr28819 = getelementptr inbounds i64, i64* %envptr28818, i64 3 
  store volatile i64* %envptr28819, i64** %vptr28821, align 8 ; &envptr28818[2]
 %vptr28822 = alloca i64, align 8 
  %FWN$acc = load i64, i64* %envptr28819, align 8 
  store volatile i64 %FWN$acc, i64* %vptr28822, align 8 ; load; *envptr28819
 %vptr28825 = alloca i64, align 8 
  %envptr28823 = inttoptr i64 %env11628 to i64* 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr28825, align 8 ; closure/env cast; i64 -> i64*
  %vptr28826 = alloca i64*, align 8 
  %envptr28824 = getelementptr inbounds i64, i64* %envptr28823, i64 2 
  store volatile i64* %envptr28824, i64** %vptr28826, align 8 ; &envptr28823[1]
 %vptr28827 = alloca i64, align 8 
  %Mcq$_37foldr1 = load i64, i64* %envptr28824, align 8 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr28827, align 8 ; load; *envptr28824
 %vptr28828 = alloca i64, align 8 
  %_957322 = call i64 @prim_car(i64 %rvp11081) 
  store volatile i64 %_957322, i64* %vptr28828, align 8 ; call prim_car
 %vptr28829 = alloca i64, align 8 
  %rvp11077 = call i64 @prim_cdr(i64 %rvp11081) 
  store volatile i64 %rvp11077, i64* %vptr28829, align 8 ; call prim_cdr
 %vptr28830 = alloca i64, align 8 
  %n_6311082 = call i64 @prim_null_63(i64 %rvp11077) 
  store volatile i64 %n_6311082, i64* %vptr28830, align 8 ; call prim_null_63
  %cmpptr28834 = alloca i1, align 8  %cmp28831 = icmp eq i64 %n_6311082, 15 store volatile i1 %cmp28831, i1* %cmpptr28834, align 8; false?
  br i1 %cmp28831, label %else28833, label %then28832                                ; if

then28832:
 %vptr28835 = alloca i64, align 8 
  %h11083 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11083, i64* %vptr28835, align 8 ; call prim_halt
  %vptr28841 = alloca i64*, align 8 
  %cloptr28836 = inttoptr i64 %h11083 to i64* 
  store volatile i64* %cloptr28836, i64** %vptr28841, align 8 ; closure/env cast; i64 -> i64*
  %vptr28842 = alloca i64*, align 8 
  %i0ptr28837 = getelementptr inbounds i64, i64* %cloptr28836, i64 1 
  store volatile i64* %i0ptr28837, i64** %vptr28842, align 8 ; &cloptr28836[1]
 %vptr28843 = alloca i64, align 8 
  %f28839 = load i64, i64* %i0ptr28837, align 8 
  store volatile i64 %f28839, i64* %vptr28843, align 8 ; load; *i0ptr28837
  %fptr28838 = inttoptr i64 %f28839 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28838(i64 %h11083, i64 %h11083)                     ; tail call
  ret void

else28833:
 %vptr28844 = alloca i64, align 8 
  %Ymg$lsts = call i64 @prim_car(i64 %rvp11077) 
  store volatile i64 %Ymg$lsts, i64* %vptr28844, align 8 ; call prim_car
 %vptr28845 = alloca i64, align 8 
  %na10942 = call i64 @prim_cdr(i64 %rvp11077) 
  store volatile i64 %na10942, i64* %vptr28845, align 8 ; call prim_cdr
 %vptr28846 = alloca i64, align 8 
  %n_6311078 = call i64 @prim_null_63(i64 %na10942) 
  store volatile i64 %n_6311078, i64* %vptr28846, align 8 ; call prim_null_63
  %cmpptr28850 = alloca i1, align 8  %cmp28847 = icmp eq i64 %n_6311078, 15 store volatile i1 %cmp28847, i1* %cmpptr28850, align 8; false?
  br i1 %cmp28847, label %else28849, label %then28848                                ; if

then28848:
  %vptr28863 = alloca i64*, align 8 
  %cloptr28851 = call i64* @make_closure(i64 80) 
  store volatile i64* %cloptr28851, i64** %vptr28863, align 8 ; malloc
  %vptr28864 = alloca i64*, align 8 
  %eptr28853 = getelementptr inbounds i64, i64* %cloptr28851, i64 2 
  store volatile i64* %eptr28853, i64** %vptr28864, align 8 ; &eptr28853[1]
  %vptr28865 = alloca i64*, align 8 
  %eptr28854 = getelementptr inbounds i64, i64* %cloptr28851, i64 3 
  store volatile i64* %eptr28854, i64** %vptr28865, align 8 ; &eptr28854[2]
  %vptr28866 = alloca i64*, align 8 
  %eptr28855 = getelementptr inbounds i64, i64* %cloptr28851, i64 4 
  store volatile i64* %eptr28855, i64** %vptr28866, align 8 ; &eptr28855[3]
  %vptr28867 = alloca i64*, align 8 
  %eptr28856 = getelementptr inbounds i64, i64* %cloptr28851, i64 5 
  store volatile i64* %eptr28856, i64** %vptr28867, align 8 ; &eptr28856[4]
  %vptr28868 = alloca i64*, align 8 
  %eptr28857 = getelementptr inbounds i64, i64* %cloptr28851, i64 6 
  store volatile i64* %eptr28857, i64** %vptr28868, align 8 ; &eptr28857[5]
  %vptr28869 = alloca i64*, align 8 
  %eptr28858 = getelementptr inbounds i64, i64* %cloptr28851, i64 7 
  store volatile i64* %eptr28858, i64** %vptr28869, align 8 ; &eptr28858[6]
  %vptr28870 = alloca i64*, align 8 
  %eptr28859 = getelementptr inbounds i64, i64* %cloptr28851, i64 8 
  store volatile i64* %eptr28859, i64** %vptr28870, align 8 ; &eptr28859[7]
  %vptr28871 = alloca i64*, align 8 
  %eptr28860 = getelementptr inbounds i64, i64* %cloptr28851, i64 9 
  store volatile i64* %eptr28860, i64** %vptr28871, align 8 ; &eptr28860[8]
  %vptr28872 = alloca i64*, align 8 
  %eptr28861 = getelementptr inbounds i64, i64* %cloptr28851, i64 10 
  store volatile i64* %eptr28861, i64** %vptr28872, align 8 ; &eptr28861[9]
  store i64 %Mcq$_37foldr1, i64* %eptr28853                                          ; *eptr28853 = %Mcq$_37foldr1
  store i64 %FWN$acc, i64* %eptr28854                                                ; *eptr28854 = %FWN$acc
  store i64 %lDS$_37foldr, i64* %eptr28855                                           ; *eptr28855 = %lDS$_37foldr
  store i64 %emsg18637, i64* %eptr28856                                              ; *eptr28856 = %emsg18637
  store i64 %cont7319, i64* %eptr28857                                               ; *eptr28857 = %cont7319
  store i64 %Ymg$lsts, i64* %eptr28858                                               ; *eptr28858 = %Ymg$lsts
  store i64 %emsg08636, i64* %eptr28859                                              ; *eptr28859 = %emsg08636
  store i64 %MYb$f, i64* %eptr28860                                                  ; *eptr28860 = %MYb$f
  store i64 %Gcn$_37map1, i64* %eptr28861                                            ; *eptr28861 = %Gcn$_37map1
  %vptr28873 = alloca i64*, align 8 
  %eptr28852 = getelementptr inbounds i64, i64* %cloptr28851, i64 1 
  store volatile i64* %eptr28852, i64** %vptr28873, align 8 ; &cloptr28851[1]
 %vptr28874 = alloca i64, align 8 
  %f28862 = ptrtoint void(i64,i64)* @lam11625 to i64 
  store volatile i64 %f28862, i64* %vptr28874, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f28862, i64* %eptr28852                                                 ; store fptr
 %vptr28875 = alloca i64, align 8 
  %arg8474 = ptrtoint i64* %cloptr28851 to i64 
  store volatile i64 %arg8474, i64* %vptr28875, align 8 ; closure cast; i64* -> i64
  %vptr28881 = alloca i64*, align 8 
  %cloptr28876 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr28876, i64** %vptr28881, align 8 ; malloc
  %vptr28882 = alloca i64*, align 8 
  %eptr28878 = getelementptr inbounds i64, i64* %cloptr28876, i64 2 
  store volatile i64* %eptr28878, i64** %vptr28882, align 8 ; &eptr28878[1]
  %vptr28883 = alloca i64*, align 8 
  %eptr28879 = getelementptr inbounds i64, i64* %cloptr28876, i64 3 
  store volatile i64* %eptr28879, i64** %vptr28883, align 8 ; &eptr28879[2]
  store i64 %emsg18637, i64* %eptr28878                                              ; *eptr28878 = %emsg18637
  store i64 %emsg08636, i64* %eptr28879                                              ; *eptr28879 = %emsg08636
  %vptr28884 = alloca i64*, align 8 
  %eptr28877 = getelementptr inbounds i64, i64* %cloptr28876, i64 1 
  store volatile i64* %eptr28877, i64** %vptr28884, align 8 ; &cloptr28876[1]
 %vptr28885 = alloca i64, align 8 
  %f28880 = ptrtoint void(i64,i64)* @lam11597 to i64 
  store volatile i64 %f28880, i64* %vptr28885, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f28880, i64* %eptr28877                                                 ; store fptr
 %vptr28886 = alloca i64, align 8 
  %arg8473 = ptrtoint i64* %cloptr28876 to i64 
  store volatile i64 %arg8473, i64* %vptr28886, align 8 ; closure cast; i64* -> i64
 %vptr28887 = alloca i64, align 8 
  %arg8472 = call i64 @const_init_false() 
  store volatile i64 %arg8472, i64* %vptr28887, align 8 ; quoted #f
 %vptr28888 = alloca i64, align 8 
  %rva11076 = add i64 0, 0 
  store volatile i64 %rva11076, i64* %vptr28888, align 8 ; quoted ()
 %vptr28889 = alloca i64, align 8 
  %rva11075 = call i64 @prim_cons(i64 %Ymg$lsts, i64 %rva11076) 
  store volatile i64 %rva11075, i64* %vptr28889, align 8 ; call prim_cons
 %vptr28890 = alloca i64, align 8 
  %rva11074 = call i64 @prim_cons(i64 %arg8472, i64 %rva11075) 
  store volatile i64 %rva11074, i64* %vptr28890, align 8 ; call prim_cons
 %vptr28891 = alloca i64, align 8 
  %rva11073 = call i64 @prim_cons(i64 %arg8473, i64 %rva11074) 
  store volatile i64 %rva11073, i64* %vptr28891, align 8 ; call prim_cons
 %vptr28892 = alloca i64, align 8 
  %rva11072 = call i64 @prim_cons(i64 %arg8474, i64 %rva11073) 
  store volatile i64 %rva11072, i64* %vptr28892, align 8 ; call prim_cons
  %vptr28898 = alloca i64*, align 8 
  %cloptr28893 = inttoptr i64 %Mcq$_37foldr1 to i64* 
  store volatile i64* %cloptr28893, i64** %vptr28898, align 8 ; closure/env cast; i64 -> i64*
  %vptr28899 = alloca i64*, align 8 
  %i0ptr28894 = getelementptr inbounds i64, i64* %cloptr28893, i64 1 
  store volatile i64* %i0ptr28894, i64** %vptr28899, align 8 ; &cloptr28893[1]
 %vptr28900 = alloca i64, align 8 
  %f28896 = load i64, i64* %i0ptr28894, align 8 
  store volatile i64 %f28896, i64* %vptr28900, align 8 ; load; *i0ptr28894
  %fptr28895 = inttoptr i64 %f28896 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28895(i64 %Mcq$_37foldr1, i64 %rva11072)            ; tail call
  ret void

else28849:
 %vptr28901 = alloca i64, align 8 
  %h11079 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11079, i64* %vptr28901, align 8 ; call prim_halt
  %vptr28907 = alloca i64*, align 8 
  %cloptr28902 = inttoptr i64 %h11079 to i64* 
  store volatile i64* %cloptr28902, i64** %vptr28907, align 8 ; closure/env cast; i64 -> i64*
  %vptr28908 = alloca i64*, align 8 
  %i0ptr28903 = getelementptr inbounds i64, i64* %cloptr28902, i64 1 
  store volatile i64* %i0ptr28903, i64** %vptr28908, align 8 ; &cloptr28902[1]
 %vptr28909 = alloca i64, align 8 
  %f28905 = load i64, i64* %i0ptr28903, align 8 
  store volatile i64 %f28905, i64* %vptr28909, align 8 ; load; *i0ptr28903
  %fptr28904 = inttoptr i64 %f28905 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28904(i64 %h11079, i64 %h11079)                     ; tail call
  ret void
}


define void @lam11625(i64 %env11626, i64 %rvp11048) {
 %vptr28912 = alloca i64, align 8 
  %envptr28910 = inttoptr i64 %env11626 to i64* 
  store volatile i64 %Gcn$_37map1, i64* %vptr28912, align 8 ; closure/env cast; i64 -> i64*
  %vptr28913 = alloca i64*, align 8 
  %envptr28911 = getelementptr inbounds i64, i64* %envptr28910, i64 10 
  store volatile i64* %envptr28911, i64** %vptr28913, align 8 ; &envptr28910[9]
 %vptr28914 = alloca i64, align 8 
  %Gcn$_37map1 = load i64, i64* %envptr28911, align 8 
  store volatile i64 %Gcn$_37map1, i64* %vptr28914, align 8 ; load; *envptr28911
 %vptr28917 = alloca i64, align 8 
  %envptr28915 = inttoptr i64 %env11626 to i64* 
  store volatile i64 %MYb$f, i64* %vptr28917, align 8 ; closure/env cast; i64 -> i64*
  %vptr28918 = alloca i64*, align 8 
  %envptr28916 = getelementptr inbounds i64, i64* %envptr28915, i64 9 
  store volatile i64* %envptr28916, i64** %vptr28918, align 8 ; &envptr28915[8]
 %vptr28919 = alloca i64, align 8 
  %MYb$f = load i64, i64* %envptr28916, align 8 
  store volatile i64 %MYb$f, i64* %vptr28919, align 8 ; load; *envptr28916
 %vptr28922 = alloca i64, align 8 
  %envptr28920 = inttoptr i64 %env11626 to i64* 
  store volatile i64 %emsg08636, i64* %vptr28922, align 8 ; closure/env cast; i64 -> i64*
  %vptr28923 = alloca i64*, align 8 
  %envptr28921 = getelementptr inbounds i64, i64* %envptr28920, i64 8 
  store volatile i64* %envptr28921, i64** %vptr28923, align 8 ; &envptr28920[7]
 %vptr28924 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr28921, align 8 
  store volatile i64 %emsg08636, i64* %vptr28924, align 8 ; load; *envptr28921
 %vptr28927 = alloca i64, align 8 
  %envptr28925 = inttoptr i64 %env11626 to i64* 
  store volatile i64 %Ymg$lsts, i64* %vptr28927, align 8 ; closure/env cast; i64 -> i64*
  %vptr28928 = alloca i64*, align 8 
  %envptr28926 = getelementptr inbounds i64, i64* %envptr28925, i64 7 
  store volatile i64* %envptr28926, i64** %vptr28928, align 8 ; &envptr28925[6]
 %vptr28929 = alloca i64, align 8 
  %Ymg$lsts = load i64, i64* %envptr28926, align 8 
  store volatile i64 %Ymg$lsts, i64* %vptr28929, align 8 ; load; *envptr28926
 %vptr28932 = alloca i64, align 8 
  %envptr28930 = inttoptr i64 %env11626 to i64* 
  store volatile i64 %cont7319, i64* %vptr28932, align 8 ; closure/env cast; i64 -> i64*
  %vptr28933 = alloca i64*, align 8 
  %envptr28931 = getelementptr inbounds i64, i64* %envptr28930, i64 6 
  store volatile i64* %envptr28931, i64** %vptr28933, align 8 ; &envptr28930[5]
 %vptr28934 = alloca i64, align 8 
  %cont7319 = load i64, i64* %envptr28931, align 8 
  store volatile i64 %cont7319, i64* %vptr28934, align 8 ; load; *envptr28931
 %vptr28937 = alloca i64, align 8 
  %envptr28935 = inttoptr i64 %env11626 to i64* 
  store volatile i64 %emsg18637, i64* %vptr28937, align 8 ; closure/env cast; i64 -> i64*
  %vptr28938 = alloca i64*, align 8 
  %envptr28936 = getelementptr inbounds i64, i64* %envptr28935, i64 5 
  store volatile i64* %envptr28936, i64** %vptr28938, align 8 ; &envptr28935[4]
 %vptr28939 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr28936, align 8 
  store volatile i64 %emsg18637, i64* %vptr28939, align 8 ; load; *envptr28936
 %vptr28942 = alloca i64, align 8 
  %envptr28940 = inttoptr i64 %env11626 to i64* 
  store volatile i64 %lDS$_37foldr, i64* %vptr28942, align 8 ; closure/env cast; i64 -> i64*
  %vptr28943 = alloca i64*, align 8 
  %envptr28941 = getelementptr inbounds i64, i64* %envptr28940, i64 4 
  store volatile i64* %envptr28941, i64** %vptr28943, align 8 ; &envptr28940[3]
 %vptr28944 = alloca i64, align 8 
  %lDS$_37foldr = load i64, i64* %envptr28941, align 8 
  store volatile i64 %lDS$_37foldr, i64* %vptr28944, align 8 ; load; *envptr28941
 %vptr28947 = alloca i64, align 8 
  %envptr28945 = inttoptr i64 %env11626 to i64* 
  store volatile i64 %FWN$acc, i64* %vptr28947, align 8 ; closure/env cast; i64 -> i64*
  %vptr28948 = alloca i64*, align 8 
  %envptr28946 = getelementptr inbounds i64, i64* %envptr28945, i64 3 
  store volatile i64* %envptr28946, i64** %vptr28948, align 8 ; &envptr28945[2]
 %vptr28949 = alloca i64, align 8 
  %FWN$acc = load i64, i64* %envptr28946, align 8 
  store volatile i64 %FWN$acc, i64* %vptr28949, align 8 ; load; *envptr28946
 %vptr28952 = alloca i64, align 8 
  %envptr28950 = inttoptr i64 %env11626 to i64* 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr28952, align 8 ; closure/env cast; i64 -> i64*
  %vptr28953 = alloca i64*, align 8 
  %envptr28951 = getelementptr inbounds i64, i64* %envptr28950, i64 2 
  store volatile i64* %envptr28951, i64** %vptr28953, align 8 ; &envptr28950[1]
 %vptr28954 = alloca i64, align 8 
  %Mcq$_37foldr1 = load i64, i64* %envptr28951, align 8 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr28954, align 8 ; load; *envptr28951
 %vptr28955 = alloca i64, align 8 
  %_957323 = call i64 @prim_car(i64 %rvp11048) 
  store volatile i64 %_957323, i64* %vptr28955, align 8 ; call prim_car
 %vptr28956 = alloca i64, align 8 
  %rvp11044 = call i64 @prim_cdr(i64 %rvp11048) 
  store volatile i64 %rvp11044, i64* %vptr28956, align 8 ; call prim_cdr
 %vptr28957 = alloca i64, align 8 
  %n_6311049 = call i64 @prim_null_63(i64 %rvp11044) 
  store volatile i64 %n_6311049, i64* %vptr28957, align 8 ; call prim_null_63
  %cmpptr28961 = alloca i1, align 8  %cmp28958 = icmp eq i64 %n_6311049, 15 store volatile i1 %cmp28958, i1* %cmpptr28961, align 8; false?
  br i1 %cmp28958, label %else28960, label %then28959                                ; if

then28959:
 %vptr28962 = alloca i64, align 8 
  %h11050 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11050, i64* %vptr28962, align 8 ; call prim_halt
  %vptr28968 = alloca i64*, align 8 
  %cloptr28963 = inttoptr i64 %h11050 to i64* 
  store volatile i64* %cloptr28963, i64** %vptr28968, align 8 ; closure/env cast; i64 -> i64*
  %vptr28969 = alloca i64*, align 8 
  %i0ptr28964 = getelementptr inbounds i64, i64* %cloptr28963, i64 1 
  store volatile i64* %i0ptr28964, i64** %vptr28969, align 8 ; &cloptr28963[1]
 %vptr28970 = alloca i64, align 8 
  %f28966 = load i64, i64* %i0ptr28964, align 8 
  store volatile i64 %f28966, i64* %vptr28970, align 8 ; load; *i0ptr28964
  %fptr28965 = inttoptr i64 %f28966 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28965(i64 %h11050, i64 %h11050)                     ; tail call
  ret void

else28960:
 %vptr28971 = alloca i64, align 8 
  %a6935 = call i64 @prim_car(i64 %rvp11044) 
  store volatile i64 %a6935, i64* %vptr28971, align 8 ; call prim_car
 %vptr28972 = alloca i64, align 8 
  %na10944 = call i64 @prim_cdr(i64 %rvp11044) 
  store volatile i64 %na10944, i64* %vptr28972, align 8 ; call prim_cdr
 %vptr28973 = alloca i64, align 8 
  %n_6311045 = call i64 @prim_null_63(i64 %na10944) 
  store volatile i64 %n_6311045, i64* %vptr28973, align 8 ; call prim_null_63
  %cmpptr28977 = alloca i1, align 8  %cmp28974 = icmp eq i64 %n_6311045, 15 store volatile i1 %cmp28974, i1* %cmpptr28977, align 8; false?
  br i1 %cmp28974, label %else28976, label %then28975                                ; if

then28975:
  %cmpptr28981 = alloca i1, align 8  %cmp28978 = icmp eq i64 %a6935, 15 store volatile i1 %cmp28978, i1* %cmpptr28981, align 8; false?
  br i1 %cmp28978, label %else28980, label %then28979                                ; if

then28979:
 %vptr28982 = alloca i64, align 8 
  %arg8477 = add i64 0, 0 
  store volatile i64 %arg8477, i64* %vptr28982, align 8 ; quoted ()
 %vptr28983 = alloca i64, align 8 
  %rva10947 = add i64 0, 0 
  store volatile i64 %rva10947, i64* %vptr28983, align 8 ; quoted ()
 %vptr28984 = alloca i64, align 8 
  %rva10946 = call i64 @prim_cons(i64 %FWN$acc, i64 %rva10947) 
  store volatile i64 %rva10946, i64* %vptr28984, align 8 ; call prim_cons
 %vptr28985 = alloca i64, align 8 
  %rva10945 = call i64 @prim_cons(i64 %arg8477, i64 %rva10946) 
  store volatile i64 %rva10945, i64* %vptr28985, align 8 ; call prim_cons
  %vptr28991 = alloca i64*, align 8 
  %cloptr28986 = inttoptr i64 %cont7319 to i64* 
  store volatile i64* %cloptr28986, i64** %vptr28991, align 8 ; closure/env cast; i64 -> i64*
  %vptr28992 = alloca i64*, align 8 
  %i0ptr28987 = getelementptr inbounds i64, i64* %cloptr28986, i64 1 
  store volatile i64* %i0ptr28987, i64** %vptr28992, align 8 ; &cloptr28986[1]
 %vptr28993 = alloca i64, align 8 
  %f28989 = load i64, i64* %i0ptr28987, align 8 
  store volatile i64 %f28989, i64* %vptr28993, align 8 ; load; *i0ptr28987
  %fptr28988 = inttoptr i64 %f28989 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr28988(i64 %cont7319, i64 %rva10945)                 ; tail call
  ret void

else28980:
  %vptr29006 = alloca i64*, align 8 
  %cloptr28994 = call i64* @make_closure(i64 80) 
  store volatile i64* %cloptr28994, i64** %vptr29006, align 8 ; malloc
  %vptr29007 = alloca i64*, align 8 
  %eptr28996 = getelementptr inbounds i64, i64* %cloptr28994, i64 2 
  store volatile i64* %eptr28996, i64** %vptr29007, align 8 ; &eptr28996[1]
  %vptr29008 = alloca i64*, align 8 
  %eptr28997 = getelementptr inbounds i64, i64* %cloptr28994, i64 3 
  store volatile i64* %eptr28997, i64** %vptr29008, align 8 ; &eptr28997[2]
  %vptr29009 = alloca i64*, align 8 
  %eptr28998 = getelementptr inbounds i64, i64* %cloptr28994, i64 4 
  store volatile i64* %eptr28998, i64** %vptr29009, align 8 ; &eptr28998[3]
  %vptr29010 = alloca i64*, align 8 
  %eptr28999 = getelementptr inbounds i64, i64* %cloptr28994, i64 5 
  store volatile i64* %eptr28999, i64** %vptr29010, align 8 ; &eptr28999[4]
  %vptr29011 = alloca i64*, align 8 
  %eptr29000 = getelementptr inbounds i64, i64* %cloptr28994, i64 6 
  store volatile i64* %eptr29000, i64** %vptr29011, align 8 ; &eptr29000[5]
  %vptr29012 = alloca i64*, align 8 
  %eptr29001 = getelementptr inbounds i64, i64* %cloptr28994, i64 7 
  store volatile i64* %eptr29001, i64** %vptr29012, align 8 ; &eptr29001[6]
  %vptr29013 = alloca i64*, align 8 
  %eptr29002 = getelementptr inbounds i64, i64* %cloptr28994, i64 8 
  store volatile i64* %eptr29002, i64** %vptr29013, align 8 ; &eptr29002[7]
  %vptr29014 = alloca i64*, align 8 
  %eptr29003 = getelementptr inbounds i64, i64* %cloptr28994, i64 9 
  store volatile i64* %eptr29003, i64** %vptr29014, align 8 ; &eptr29003[8]
  %vptr29015 = alloca i64*, align 8 
  %eptr29004 = getelementptr inbounds i64, i64* %cloptr28994, i64 10 
  store volatile i64* %eptr29004, i64** %vptr29015, align 8 ; &eptr29004[9]
  store i64 %Mcq$_37foldr1, i64* %eptr28996                                          ; *eptr28996 = %Mcq$_37foldr1
  store i64 %FWN$acc, i64* %eptr28997                                                ; *eptr28997 = %FWN$acc
  store i64 %lDS$_37foldr, i64* %eptr28998                                           ; *eptr28998 = %lDS$_37foldr
  store i64 %emsg18637, i64* %eptr28999                                              ; *eptr28999 = %emsg18637
  store i64 %cont7319, i64* %eptr29000                                               ; *eptr29000 = %cont7319
  store i64 %Ymg$lsts, i64* %eptr29001                                               ; *eptr29001 = %Ymg$lsts
  store i64 %emsg08636, i64* %eptr29002                                              ; *eptr29002 = %emsg08636
  store i64 %MYb$f, i64* %eptr29003                                                  ; *eptr29003 = %MYb$f
  store i64 %Gcn$_37map1, i64* %eptr29004                                            ; *eptr29004 = %Gcn$_37map1
  %vptr29016 = alloca i64*, align 8 
  %eptr28995 = getelementptr inbounds i64, i64* %cloptr28994, i64 1 
  store volatile i64* %eptr28995, i64** %vptr29016, align 8 ; &cloptr28994[1]
 %vptr29017 = alloca i64, align 8 
  %f29005 = ptrtoint void(i64,i64)* @lam11623 to i64 
  store volatile i64 %f29005, i64* %vptr29017, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f29005, i64* %eptr28995                                                 ; store fptr
 %vptr29018 = alloca i64, align 8 
  %arg8481 = ptrtoint i64* %cloptr28994 to i64 
  store volatile i64 %arg8481, i64* %vptr29018, align 8 ; closure cast; i64* -> i64
  %vptr29024 = alloca i64*, align 8 
  %cloptr29019 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr29019, i64** %vptr29024, align 8 ; malloc
  %vptr29025 = alloca i64*, align 8 
  %eptr29021 = getelementptr inbounds i64, i64* %cloptr29019, i64 2 
  store volatile i64* %eptr29021, i64** %vptr29025, align 8 ; &eptr29021[1]
  %vptr29026 = alloca i64*, align 8 
  %eptr29022 = getelementptr inbounds i64, i64* %cloptr29019, i64 3 
  store volatile i64* %eptr29022, i64** %vptr29026, align 8 ; &eptr29022[2]
  store i64 %emsg18637, i64* %eptr29021                                              ; *eptr29021 = %emsg18637
  store i64 %emsg08636, i64* %eptr29022                                              ; *eptr29022 = %emsg08636
  %vptr29027 = alloca i64*, align 8 
  %eptr29020 = getelementptr inbounds i64, i64* %cloptr29019, i64 1 
  store volatile i64* %eptr29020, i64** %vptr29027, align 8 ; &cloptr29019[1]
 %vptr29028 = alloca i64, align 8 
  %f29023 = ptrtoint void(i64,i64)* @lam11604 to i64 
  store volatile i64 %f29023, i64* %vptr29028, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f29023, i64* %eptr29020                                                 ; store fptr
 %vptr29029 = alloca i64, align 8 
  %arg8480 = ptrtoint i64* %cloptr29019 to i64 
  store volatile i64 %arg8480, i64* %vptr29029, align 8 ; closure cast; i64* -> i64
 %vptr29030 = alloca i64, align 8 
  %rva11043 = add i64 0, 0 
  store volatile i64 %rva11043, i64* %vptr29030, align 8 ; quoted ()
 %vptr29031 = alloca i64, align 8 
  %rva11042 = call i64 @prim_cons(i64 %Ymg$lsts, i64 %rva11043) 
  store volatile i64 %rva11042, i64* %vptr29031, align 8 ; call prim_cons
 %vptr29032 = alloca i64, align 8 
  %rva11041 = call i64 @prim_cons(i64 %arg8480, i64 %rva11042) 
  store volatile i64 %rva11041, i64* %vptr29032, align 8 ; call prim_cons
 %vptr29033 = alloca i64, align 8 
  %rva11040 = call i64 @prim_cons(i64 %arg8481, i64 %rva11041) 
  store volatile i64 %rva11040, i64* %vptr29033, align 8 ; call prim_cons
  %vptr29039 = alloca i64*, align 8 
  %cloptr29034 = inttoptr i64 %Gcn$_37map1 to i64* 
  store volatile i64* %cloptr29034, i64** %vptr29039, align 8 ; closure/env cast; i64 -> i64*
  %vptr29040 = alloca i64*, align 8 
  %i0ptr29035 = getelementptr inbounds i64, i64* %cloptr29034, i64 1 
  store volatile i64* %i0ptr29035, i64** %vptr29040, align 8 ; &cloptr29034[1]
 %vptr29041 = alloca i64, align 8 
  %f29037 = load i64, i64* %i0ptr29035, align 8 
  store volatile i64 %f29037, i64* %vptr29041, align 8 ; load; *i0ptr29035
  %fptr29036 = inttoptr i64 %f29037 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29036(i64 %Gcn$_37map1, i64 %rva11040)              ; tail call
  ret void

else28976:
 %vptr29042 = alloca i64, align 8 
  %h11046 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11046, i64* %vptr29042, align 8 ; call prim_halt
  %vptr29048 = alloca i64*, align 8 
  %cloptr29043 = inttoptr i64 %h11046 to i64* 
  store volatile i64* %cloptr29043, i64** %vptr29048, align 8 ; closure/env cast; i64 -> i64*
  %vptr29049 = alloca i64*, align 8 
  %i0ptr29044 = getelementptr inbounds i64, i64* %cloptr29043, i64 1 
  store volatile i64* %i0ptr29044, i64** %vptr29049, align 8 ; &cloptr29043[1]
 %vptr29050 = alloca i64, align 8 
  %f29046 = load i64, i64* %i0ptr29044, align 8 
  store volatile i64 %f29046, i64* %vptr29050, align 8 ; load; *i0ptr29044
  %fptr29045 = inttoptr i64 %f29046 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29045(i64 %h11046, i64 %h11046)                     ; tail call
  ret void
}


define void @lam11623(i64 %env11624, i64 %rvp11023) {
 %vptr29053 = alloca i64, align 8 
  %envptr29051 = inttoptr i64 %env11624 to i64* 
  store volatile i64 %Gcn$_37map1, i64* %vptr29053, align 8 ; closure/env cast; i64 -> i64*
  %vptr29054 = alloca i64*, align 8 
  %envptr29052 = getelementptr inbounds i64, i64* %envptr29051, i64 10 
  store volatile i64* %envptr29052, i64** %vptr29054, align 8 ; &envptr29051[9]
 %vptr29055 = alloca i64, align 8 
  %Gcn$_37map1 = load i64, i64* %envptr29052, align 8 
  store volatile i64 %Gcn$_37map1, i64* %vptr29055, align 8 ; load; *envptr29052
 %vptr29058 = alloca i64, align 8 
  %envptr29056 = inttoptr i64 %env11624 to i64* 
  store volatile i64 %MYb$f, i64* %vptr29058, align 8 ; closure/env cast; i64 -> i64*
  %vptr29059 = alloca i64*, align 8 
  %envptr29057 = getelementptr inbounds i64, i64* %envptr29056, i64 9 
  store volatile i64* %envptr29057, i64** %vptr29059, align 8 ; &envptr29056[8]
 %vptr29060 = alloca i64, align 8 
  %MYb$f = load i64, i64* %envptr29057, align 8 
  store volatile i64 %MYb$f, i64* %vptr29060, align 8 ; load; *envptr29057
 %vptr29063 = alloca i64, align 8 
  %envptr29061 = inttoptr i64 %env11624 to i64* 
  store volatile i64 %emsg08636, i64* %vptr29063, align 8 ; closure/env cast; i64 -> i64*
  %vptr29064 = alloca i64*, align 8 
  %envptr29062 = getelementptr inbounds i64, i64* %envptr29061, i64 8 
  store volatile i64* %envptr29062, i64** %vptr29064, align 8 ; &envptr29061[7]
 %vptr29065 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr29062, align 8 
  store volatile i64 %emsg08636, i64* %vptr29065, align 8 ; load; *envptr29062
 %vptr29068 = alloca i64, align 8 
  %envptr29066 = inttoptr i64 %env11624 to i64* 
  store volatile i64 %Ymg$lsts, i64* %vptr29068, align 8 ; closure/env cast; i64 -> i64*
  %vptr29069 = alloca i64*, align 8 
  %envptr29067 = getelementptr inbounds i64, i64* %envptr29066, i64 7 
  store volatile i64* %envptr29067, i64** %vptr29069, align 8 ; &envptr29066[6]
 %vptr29070 = alloca i64, align 8 
  %Ymg$lsts = load i64, i64* %envptr29067, align 8 
  store volatile i64 %Ymg$lsts, i64* %vptr29070, align 8 ; load; *envptr29067
 %vptr29073 = alloca i64, align 8 
  %envptr29071 = inttoptr i64 %env11624 to i64* 
  store volatile i64 %cont7319, i64* %vptr29073, align 8 ; closure/env cast; i64 -> i64*
  %vptr29074 = alloca i64*, align 8 
  %envptr29072 = getelementptr inbounds i64, i64* %envptr29071, i64 6 
  store volatile i64* %envptr29072, i64** %vptr29074, align 8 ; &envptr29071[5]
 %vptr29075 = alloca i64, align 8 
  %cont7319 = load i64, i64* %envptr29072, align 8 
  store volatile i64 %cont7319, i64* %vptr29075, align 8 ; load; *envptr29072
 %vptr29078 = alloca i64, align 8 
  %envptr29076 = inttoptr i64 %env11624 to i64* 
  store volatile i64 %emsg18637, i64* %vptr29078, align 8 ; closure/env cast; i64 -> i64*
  %vptr29079 = alloca i64*, align 8 
  %envptr29077 = getelementptr inbounds i64, i64* %envptr29076, i64 5 
  store volatile i64* %envptr29077, i64** %vptr29079, align 8 ; &envptr29076[4]
 %vptr29080 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr29077, align 8 
  store volatile i64 %emsg18637, i64* %vptr29080, align 8 ; load; *envptr29077
 %vptr29083 = alloca i64, align 8 
  %envptr29081 = inttoptr i64 %env11624 to i64* 
  store volatile i64 %lDS$_37foldr, i64* %vptr29083, align 8 ; closure/env cast; i64 -> i64*
  %vptr29084 = alloca i64*, align 8 
  %envptr29082 = getelementptr inbounds i64, i64* %envptr29081, i64 4 
  store volatile i64* %envptr29082, i64** %vptr29084, align 8 ; &envptr29081[3]
 %vptr29085 = alloca i64, align 8 
  %lDS$_37foldr = load i64, i64* %envptr29082, align 8 
  store volatile i64 %lDS$_37foldr, i64* %vptr29085, align 8 ; load; *envptr29082
 %vptr29088 = alloca i64, align 8 
  %envptr29086 = inttoptr i64 %env11624 to i64* 
  store volatile i64 %FWN$acc, i64* %vptr29088, align 8 ; closure/env cast; i64 -> i64*
  %vptr29089 = alloca i64*, align 8 
  %envptr29087 = getelementptr inbounds i64, i64* %envptr29086, i64 3 
  store volatile i64* %envptr29087, i64** %vptr29089, align 8 ; &envptr29086[2]
 %vptr29090 = alloca i64, align 8 
  %FWN$acc = load i64, i64* %envptr29087, align 8 
  store volatile i64 %FWN$acc, i64* %vptr29090, align 8 ; load; *envptr29087
 %vptr29093 = alloca i64, align 8 
  %envptr29091 = inttoptr i64 %env11624 to i64* 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr29093, align 8 ; closure/env cast; i64 -> i64*
  %vptr29094 = alloca i64*, align 8 
  %envptr29092 = getelementptr inbounds i64, i64* %envptr29091, i64 2 
  store volatile i64* %envptr29092, i64** %vptr29094, align 8 ; &envptr29091[1]
 %vptr29095 = alloca i64, align 8 
  %Mcq$_37foldr1 = load i64, i64* %envptr29092, align 8 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr29095, align 8 ; load; *envptr29092
 %vptr29096 = alloca i64, align 8 
  %_957324 = call i64 @prim_car(i64 %rvp11023) 
  store volatile i64 %_957324, i64* %vptr29096, align 8 ; call prim_car
 %vptr29097 = alloca i64, align 8 
  %rvp11019 = call i64 @prim_cdr(i64 %rvp11023) 
  store volatile i64 %rvp11019, i64* %vptr29097, align 8 ; call prim_cdr
 %vptr29098 = alloca i64, align 8 
  %n_6311024 = call i64 @prim_null_63(i64 %rvp11019) 
  store volatile i64 %n_6311024, i64* %vptr29098, align 8 ; call prim_null_63
  %cmpptr29102 = alloca i1, align 8  %cmp29099 = icmp eq i64 %n_6311024, 15 store volatile i1 %cmp29099, i1* %cmpptr29102, align 8; false?
  br i1 %cmp29099, label %else29101, label %then29100                                ; if

then29100:
 %vptr29103 = alloca i64, align 8 
  %h11025 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11025, i64* %vptr29103, align 8 ; call prim_halt
  %vptr29109 = alloca i64*, align 8 
  %cloptr29104 = inttoptr i64 %h11025 to i64* 
  store volatile i64* %cloptr29104, i64** %vptr29109, align 8 ; closure/env cast; i64 -> i64*
  %vptr29110 = alloca i64*, align 8 
  %i0ptr29105 = getelementptr inbounds i64, i64* %cloptr29104, i64 1 
  store volatile i64* %i0ptr29105, i64** %vptr29110, align 8 ; &cloptr29104[1]
 %vptr29111 = alloca i64, align 8 
  %f29107 = load i64, i64* %i0ptr29105, align 8 
  store volatile i64 %f29107, i64* %vptr29111, align 8 ; load; *i0ptr29105
  %fptr29106 = inttoptr i64 %f29107 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29106(i64 %h11025, i64 %h11025)                     ; tail call
  ret void

else29101:
 %vptr29112 = alloca i64, align 8 
  %ORk$lsts_43 = call i64 @prim_car(i64 %rvp11019) 
  store volatile i64 %ORk$lsts_43, i64* %vptr29112, align 8 ; call prim_car
 %vptr29113 = alloca i64, align 8 
  %na10949 = call i64 @prim_cdr(i64 %rvp11019) 
  store volatile i64 %na10949, i64* %vptr29113, align 8 ; call prim_cdr
 %vptr29114 = alloca i64, align 8 
  %n_6311020 = call i64 @prim_null_63(i64 %na10949) 
  store volatile i64 %n_6311020, i64* %vptr29114, align 8 ; call prim_null_63
  %cmpptr29118 = alloca i1, align 8  %cmp29115 = icmp eq i64 %n_6311020, 15 store volatile i1 %cmp29115, i1* %cmpptr29118, align 8; false?
  br i1 %cmp29115, label %else29117, label %then29116                                ; if

then29116:
  %vptr29130 = alloca i64*, align 8 
  %cloptr29119 = call i64* @make_closure(i64 72) 
  store volatile i64* %cloptr29119, i64** %vptr29130, align 8 ; malloc
  %vptr29131 = alloca i64*, align 8 
  %eptr29121 = getelementptr inbounds i64, i64* %cloptr29119, i64 2 
  store volatile i64* %eptr29121, i64** %vptr29131, align 8 ; &eptr29121[1]
  %vptr29132 = alloca i64*, align 8 
  %eptr29122 = getelementptr inbounds i64, i64* %cloptr29119, i64 3 
  store volatile i64* %eptr29122, i64** %vptr29132, align 8 ; &eptr29122[2]
  %vptr29133 = alloca i64*, align 8 
  %eptr29123 = getelementptr inbounds i64, i64* %cloptr29119, i64 4 
  store volatile i64* %eptr29123, i64** %vptr29133, align 8 ; &eptr29123[3]
  %vptr29134 = alloca i64*, align 8 
  %eptr29124 = getelementptr inbounds i64, i64* %cloptr29119, i64 5 
  store volatile i64* %eptr29124, i64** %vptr29134, align 8 ; &eptr29124[4]
  %vptr29135 = alloca i64*, align 8 
  %eptr29125 = getelementptr inbounds i64, i64* %cloptr29119, i64 6 
  store volatile i64* %eptr29125, i64** %vptr29135, align 8 ; &eptr29125[5]
  %vptr29136 = alloca i64*, align 8 
  %eptr29126 = getelementptr inbounds i64, i64* %cloptr29119, i64 7 
  store volatile i64* %eptr29126, i64** %vptr29136, align 8 ; &eptr29126[6]
  %vptr29137 = alloca i64*, align 8 
  %eptr29127 = getelementptr inbounds i64, i64* %cloptr29119, i64 8 
  store volatile i64* %eptr29127, i64** %vptr29137, align 8 ; &eptr29127[7]
  %vptr29138 = alloca i64*, align 8 
  %eptr29128 = getelementptr inbounds i64, i64* %cloptr29119, i64 9 
  store volatile i64* %eptr29128, i64** %vptr29138, align 8 ; &eptr29128[8]
  store i64 %Mcq$_37foldr1, i64* %eptr29121                                          ; *eptr29121 = %Mcq$_37foldr1
  store i64 %FWN$acc, i64* %eptr29122                                                ; *eptr29122 = %FWN$acc
  store i64 %lDS$_37foldr, i64* %eptr29123                                           ; *eptr29123 = %lDS$_37foldr
  store i64 %emsg18637, i64* %eptr29124                                              ; *eptr29124 = %emsg18637
  store i64 %cont7319, i64* %eptr29125                                               ; *eptr29125 = %cont7319
  store i64 %ORk$lsts_43, i64* %eptr29126                                            ; *eptr29126 = %ORk$lsts_43
  store i64 %emsg08636, i64* %eptr29127                                              ; *eptr29127 = %emsg08636
  store i64 %MYb$f, i64* %eptr29128                                                  ; *eptr29128 = %MYb$f
  %vptr29139 = alloca i64*, align 8 
  %eptr29120 = getelementptr inbounds i64, i64* %cloptr29119, i64 1 
  store volatile i64* %eptr29120, i64** %vptr29139, align 8 ; &cloptr29119[1]
 %vptr29140 = alloca i64, align 8 
  %f29129 = ptrtoint void(i64,i64)* @lam11621 to i64 
  store volatile i64 %f29129, i64* %vptr29140, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f29129, i64* %eptr29120                                                 ; store fptr
 %vptr29141 = alloca i64, align 8 
  %arg8485 = ptrtoint i64* %cloptr29119 to i64 
  store volatile i64 %arg8485, i64* %vptr29141, align 8 ; closure cast; i64* -> i64
  %vptr29147 = alloca i64*, align 8 
  %cloptr29142 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr29142, i64** %vptr29147, align 8 ; malloc
  %vptr29148 = alloca i64*, align 8 
  %eptr29144 = getelementptr inbounds i64, i64* %cloptr29142, i64 2 
  store volatile i64* %eptr29144, i64** %vptr29148, align 8 ; &eptr29144[1]
  %vptr29149 = alloca i64*, align 8 
  %eptr29145 = getelementptr inbounds i64, i64* %cloptr29142, i64 3 
  store volatile i64* %eptr29145, i64** %vptr29149, align 8 ; &eptr29145[2]
  store i64 %emsg18637, i64* %eptr29144                                              ; *eptr29144 = %emsg18637
  store i64 %emsg08636, i64* %eptr29145                                              ; *eptr29145 = %emsg08636
  %vptr29150 = alloca i64*, align 8 
  %eptr29143 = getelementptr inbounds i64, i64* %cloptr29142, i64 1 
  store volatile i64* %eptr29143, i64** %vptr29150, align 8 ; &cloptr29142[1]
 %vptr29151 = alloca i64, align 8 
  %f29146 = ptrtoint void(i64,i64)* @lam11609 to i64 
  store volatile i64 %f29146, i64* %vptr29151, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f29146, i64* %eptr29143                                                 ; store fptr
 %vptr29152 = alloca i64, align 8 
  %arg8484 = ptrtoint i64* %cloptr29142 to i64 
  store volatile i64 %arg8484, i64* %vptr29152, align 8 ; closure cast; i64* -> i64
 %vptr29153 = alloca i64, align 8 
  %rva11018 = add i64 0, 0 
  store volatile i64 %rva11018, i64* %vptr29153, align 8 ; quoted ()
 %vptr29154 = alloca i64, align 8 
  %rva11017 = call i64 @prim_cons(i64 %Ymg$lsts, i64 %rva11018) 
  store volatile i64 %rva11017, i64* %vptr29154, align 8 ; call prim_cons
 %vptr29155 = alloca i64, align 8 
  %rva11016 = call i64 @prim_cons(i64 %arg8484, i64 %rva11017) 
  store volatile i64 %rva11016, i64* %vptr29155, align 8 ; call prim_cons
 %vptr29156 = alloca i64, align 8 
  %rva11015 = call i64 @prim_cons(i64 %arg8485, i64 %rva11016) 
  store volatile i64 %rva11015, i64* %vptr29156, align 8 ; call prim_cons
  %vptr29162 = alloca i64*, align 8 
  %cloptr29157 = inttoptr i64 %Gcn$_37map1 to i64* 
  store volatile i64* %cloptr29157, i64** %vptr29162, align 8 ; closure/env cast; i64 -> i64*
  %vptr29163 = alloca i64*, align 8 
  %i0ptr29158 = getelementptr inbounds i64, i64* %cloptr29157, i64 1 
  store volatile i64* %i0ptr29158, i64** %vptr29163, align 8 ; &cloptr29157[1]
 %vptr29164 = alloca i64, align 8 
  %f29160 = load i64, i64* %i0ptr29158, align 8 
  store volatile i64 %f29160, i64* %vptr29164, align 8 ; load; *i0ptr29158
  %fptr29159 = inttoptr i64 %f29160 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29159(i64 %Gcn$_37map1, i64 %rva11015)              ; tail call
  ret void

else29117:
 %vptr29165 = alloca i64, align 8 
  %h11021 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11021, i64* %vptr29165, align 8 ; call prim_halt
  %vptr29171 = alloca i64*, align 8 
  %cloptr29166 = inttoptr i64 %h11021 to i64* 
  store volatile i64* %cloptr29166, i64** %vptr29171, align 8 ; closure/env cast; i64 -> i64*
  %vptr29172 = alloca i64*, align 8 
  %i0ptr29167 = getelementptr inbounds i64, i64* %cloptr29166, i64 1 
  store volatile i64* %i0ptr29167, i64** %vptr29172, align 8 ; &cloptr29166[1]
 %vptr29173 = alloca i64, align 8 
  %f29169 = load i64, i64* %i0ptr29167, align 8 
  store volatile i64 %f29169, i64* %vptr29173, align 8 ; load; *i0ptr29167
  %fptr29168 = inttoptr i64 %f29169 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29168(i64 %h11021, i64 %h11021)                     ; tail call
  ret void
}


define void @lam11621(i64 %env11622, i64 %rvp10998) {
 %vptr29176 = alloca i64, align 8 
  %envptr29174 = inttoptr i64 %env11622 to i64* 
  store volatile i64 %MYb$f, i64* %vptr29176, align 8 ; closure/env cast; i64 -> i64*
  %vptr29177 = alloca i64*, align 8 
  %envptr29175 = getelementptr inbounds i64, i64* %envptr29174, i64 9 
  store volatile i64* %envptr29175, i64** %vptr29177, align 8 ; &envptr29174[8]
 %vptr29178 = alloca i64, align 8 
  %MYb$f = load i64, i64* %envptr29175, align 8 
  store volatile i64 %MYb$f, i64* %vptr29178, align 8 ; load; *envptr29175
 %vptr29181 = alloca i64, align 8 
  %envptr29179 = inttoptr i64 %env11622 to i64* 
  store volatile i64 %emsg08636, i64* %vptr29181, align 8 ; closure/env cast; i64 -> i64*
  %vptr29182 = alloca i64*, align 8 
  %envptr29180 = getelementptr inbounds i64, i64* %envptr29179, i64 8 
  store volatile i64* %envptr29180, i64** %vptr29182, align 8 ; &envptr29179[7]
 %vptr29183 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr29180, align 8 
  store volatile i64 %emsg08636, i64* %vptr29183, align 8 ; load; *envptr29180
 %vptr29186 = alloca i64, align 8 
  %envptr29184 = inttoptr i64 %env11622 to i64* 
  store volatile i64 %ORk$lsts_43, i64* %vptr29186, align 8 ; closure/env cast; i64 -> i64*
  %vptr29187 = alloca i64*, align 8 
  %envptr29185 = getelementptr inbounds i64, i64* %envptr29184, i64 7 
  store volatile i64* %envptr29185, i64** %vptr29187, align 8 ; &envptr29184[6]
 %vptr29188 = alloca i64, align 8 
  %ORk$lsts_43 = load i64, i64* %envptr29185, align 8 
  store volatile i64 %ORk$lsts_43, i64* %vptr29188, align 8 ; load; *envptr29185
 %vptr29191 = alloca i64, align 8 
  %envptr29189 = inttoptr i64 %env11622 to i64* 
  store volatile i64 %cont7319, i64* %vptr29191, align 8 ; closure/env cast; i64 -> i64*
  %vptr29192 = alloca i64*, align 8 
  %envptr29190 = getelementptr inbounds i64, i64* %envptr29189, i64 6 
  store volatile i64* %envptr29190, i64** %vptr29192, align 8 ; &envptr29189[5]
 %vptr29193 = alloca i64, align 8 
  %cont7319 = load i64, i64* %envptr29190, align 8 
  store volatile i64 %cont7319, i64* %vptr29193, align 8 ; load; *envptr29190
 %vptr29196 = alloca i64, align 8 
  %envptr29194 = inttoptr i64 %env11622 to i64* 
  store volatile i64 %emsg18637, i64* %vptr29196, align 8 ; closure/env cast; i64 -> i64*
  %vptr29197 = alloca i64*, align 8 
  %envptr29195 = getelementptr inbounds i64, i64* %envptr29194, i64 5 
  store volatile i64* %envptr29195, i64** %vptr29197, align 8 ; &envptr29194[4]
 %vptr29198 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr29195, align 8 
  store volatile i64 %emsg18637, i64* %vptr29198, align 8 ; load; *envptr29195
 %vptr29201 = alloca i64, align 8 
  %envptr29199 = inttoptr i64 %env11622 to i64* 
  store volatile i64 %lDS$_37foldr, i64* %vptr29201, align 8 ; closure/env cast; i64 -> i64*
  %vptr29202 = alloca i64*, align 8 
  %envptr29200 = getelementptr inbounds i64, i64* %envptr29199, i64 4 
  store volatile i64* %envptr29200, i64** %vptr29202, align 8 ; &envptr29199[3]
 %vptr29203 = alloca i64, align 8 
  %lDS$_37foldr = load i64, i64* %envptr29200, align 8 
  store volatile i64 %lDS$_37foldr, i64* %vptr29203, align 8 ; load; *envptr29200
 %vptr29206 = alloca i64, align 8 
  %envptr29204 = inttoptr i64 %env11622 to i64* 
  store volatile i64 %FWN$acc, i64* %vptr29206, align 8 ; closure/env cast; i64 -> i64*
  %vptr29207 = alloca i64*, align 8 
  %envptr29205 = getelementptr inbounds i64, i64* %envptr29204, i64 3 
  store volatile i64* %envptr29205, i64** %vptr29207, align 8 ; &envptr29204[2]
 %vptr29208 = alloca i64, align 8 
  %FWN$acc = load i64, i64* %envptr29205, align 8 
  store volatile i64 %FWN$acc, i64* %vptr29208, align 8 ; load; *envptr29205
 %vptr29211 = alloca i64, align 8 
  %envptr29209 = inttoptr i64 %env11622 to i64* 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr29211, align 8 ; closure/env cast; i64 -> i64*
  %vptr29212 = alloca i64*, align 8 
  %envptr29210 = getelementptr inbounds i64, i64* %envptr29209, i64 2 
  store volatile i64* %envptr29210, i64** %vptr29212, align 8 ; &envptr29209[1]
 %vptr29213 = alloca i64, align 8 
  %Mcq$_37foldr1 = load i64, i64* %envptr29210, align 8 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr29213, align 8 ; load; *envptr29210
 %vptr29214 = alloca i64, align 8 
  %_957325 = call i64 @prim_car(i64 %rvp10998) 
  store volatile i64 %_957325, i64* %vptr29214, align 8 ; call prim_car
 %vptr29215 = alloca i64, align 8 
  %rvp10994 = call i64 @prim_cdr(i64 %rvp10998) 
  store volatile i64 %rvp10994, i64* %vptr29215, align 8 ; call prim_cdr
 %vptr29216 = alloca i64, align 8 
  %n_6310999 = call i64 @prim_null_63(i64 %rvp10994) 
  store volatile i64 %n_6310999, i64* %vptr29216, align 8 ; call prim_null_63
  %cmpptr29220 = alloca i1, align 8  %cmp29217 = icmp eq i64 %n_6310999, 15 store volatile i1 %cmp29217, i1* %cmpptr29220, align 8; false?
  br i1 %cmp29217, label %else29219, label %then29218                                ; if

then29218:
 %vptr29221 = alloca i64, align 8 
  %h11000 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11000, i64* %vptr29221, align 8 ; call prim_halt
  %vptr29227 = alloca i64*, align 8 
  %cloptr29222 = inttoptr i64 %h11000 to i64* 
  store volatile i64* %cloptr29222, i64** %vptr29227, align 8 ; closure/env cast; i64 -> i64*
  %vptr29228 = alloca i64*, align 8 
  %i0ptr29223 = getelementptr inbounds i64, i64* %cloptr29222, i64 1 
  store volatile i64* %i0ptr29223, i64** %vptr29228, align 8 ; &cloptr29222[1]
 %vptr29229 = alloca i64, align 8 
  %f29225 = load i64, i64* %i0ptr29223, align 8 
  store volatile i64 %f29225, i64* %vptr29229, align 8 ; load; *i0ptr29223
  %fptr29224 = inttoptr i64 %f29225 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29224(i64 %h11000, i64 %h11000)                     ; tail call
  ret void

else29219:
 %vptr29230 = alloca i64, align 8 
  %CGh$vs = call i64 @prim_car(i64 %rvp10994) 
  store volatile i64 %CGh$vs, i64* %vptr29230, align 8 ; call prim_car
 %vptr29231 = alloca i64, align 8 
  %na10951 = call i64 @prim_cdr(i64 %rvp10994) 
  store volatile i64 %na10951, i64* %vptr29231, align 8 ; call prim_cdr
 %vptr29232 = alloca i64, align 8 
  %n_6310995 = call i64 @prim_null_63(i64 %na10951) 
  store volatile i64 %n_6310995, i64* %vptr29232, align 8 ; call prim_null_63
  %cmpptr29236 = alloca i1, align 8  %cmp29233 = icmp eq i64 %n_6310995, 15 store volatile i1 %cmp29233, i1* %cmpptr29236, align 8; false?
  br i1 %cmp29233, label %else29235, label %then29234                                ; if

then29234:
 %vptr29237 = alloca i64, align 8 
  %a6936 = call i64 @prim_cons(i64 %FWN$acc, i64 %ORk$lsts_43) 
  store volatile i64 %a6936, i64* %vptr29237, align 8 ; call prim_cons
 %vptr29238 = alloca i64, align 8 
  %a6937 = call i64 @prim_cons(i64 %MYb$f, i64 %a6936) 
  store volatile i64 %a6937, i64* %vptr29238, align 8 ; call prim_cons
  %vptr29248 = alloca i64*, align 8 
  %cloptr29239 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr29239, i64** %vptr29248, align 8 ; malloc
  %vptr29249 = alloca i64*, align 8 
  %eptr29241 = getelementptr inbounds i64, i64* %cloptr29239, i64 2 
  store volatile i64* %eptr29241, i64** %vptr29249, align 8 ; &eptr29241[1]
  %vptr29250 = alloca i64*, align 8 
  %eptr29242 = getelementptr inbounds i64, i64* %cloptr29239, i64 3 
  store volatile i64* %eptr29242, i64** %vptr29250, align 8 ; &eptr29242[2]
  %vptr29251 = alloca i64*, align 8 
  %eptr29243 = getelementptr inbounds i64, i64* %cloptr29239, i64 4 
  store volatile i64* %eptr29243, i64** %vptr29251, align 8 ; &eptr29243[3]
  %vptr29252 = alloca i64*, align 8 
  %eptr29244 = getelementptr inbounds i64, i64* %cloptr29239, i64 5 
  store volatile i64* %eptr29244, i64** %vptr29252, align 8 ; &eptr29244[4]
  %vptr29253 = alloca i64*, align 8 
  %eptr29245 = getelementptr inbounds i64, i64* %cloptr29239, i64 6 
  store volatile i64* %eptr29245, i64** %vptr29253, align 8 ; &eptr29245[5]
  %vptr29254 = alloca i64*, align 8 
  %eptr29246 = getelementptr inbounds i64, i64* %cloptr29239, i64 7 
  store volatile i64* %eptr29246, i64** %vptr29254, align 8 ; &eptr29246[6]
  store i64 %Mcq$_37foldr1, i64* %eptr29241                                          ; *eptr29241 = %Mcq$_37foldr1
  store i64 %CGh$vs, i64* %eptr29242                                                 ; *eptr29242 = %CGh$vs
  store i64 %emsg18637, i64* %eptr29243                                              ; *eptr29243 = %emsg18637
  store i64 %cont7319, i64* %eptr29244                                               ; *eptr29244 = %cont7319
  store i64 %emsg08636, i64* %eptr29245                                              ; *eptr29245 = %emsg08636
  store i64 %MYb$f, i64* %eptr29246                                                  ; *eptr29246 = %MYb$f
  %vptr29255 = alloca i64*, align 8 
  %eptr29240 = getelementptr inbounds i64, i64* %cloptr29239, i64 1 
  store volatile i64* %eptr29240, i64** %vptr29255, align 8 ; &cloptr29239[1]
 %vptr29256 = alloca i64, align 8 
  %f29247 = ptrtoint void(i64,i64)* @lam11619 to i64 
  store volatile i64 %f29247, i64* %vptr29256, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f29247, i64* %eptr29240                                                 ; store fptr
 %vptr29257 = alloca i64, align 8 
  %arg8492 = ptrtoint i64* %cloptr29239 to i64 
  store volatile i64 %arg8492, i64* %vptr29257, align 8 ; closure cast; i64* -> i64
 %vptr29258 = alloca i64, align 8 
  %cps_45lst7331 = call i64 @prim_cons(i64 %arg8492, i64 %a6937) 
  store volatile i64 %cps_45lst7331, i64* %vptr29258, align 8 ; call prim_cons
  %vptr29264 = alloca i64*, align 8 
  %cloptr29259 = inttoptr i64 %lDS$_37foldr to i64* 
  store volatile i64* %cloptr29259, i64** %vptr29264, align 8 ; closure/env cast; i64 -> i64*
  %vptr29265 = alloca i64*, align 8 
  %i0ptr29260 = getelementptr inbounds i64, i64* %cloptr29259, i64 1 
  store volatile i64* %i0ptr29260, i64** %vptr29265, align 8 ; &cloptr29259[1]
 %vptr29266 = alloca i64, align 8 
  %f29262 = load i64, i64* %i0ptr29260, align 8 
  store volatile i64 %f29262, i64* %vptr29266, align 8 ; load; *i0ptr29260
  %fptr29261 = inttoptr i64 %f29262 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29261(i64 %lDS$_37foldr, i64 %cps_45lst7331)        ; tail call
  ret void

else29235:
 %vptr29267 = alloca i64, align 8 
  %h10996 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10996, i64* %vptr29267, align 8 ; call prim_halt
  %vptr29273 = alloca i64*, align 8 
  %cloptr29268 = inttoptr i64 %h10996 to i64* 
  store volatile i64* %cloptr29268, i64** %vptr29273, align 8 ; closure/env cast; i64 -> i64*
  %vptr29274 = alloca i64*, align 8 
  %i0ptr29269 = getelementptr inbounds i64, i64* %cloptr29268, i64 1 
  store volatile i64* %i0ptr29269, i64** %vptr29274, align 8 ; &cloptr29268[1]
 %vptr29275 = alloca i64, align 8 
  %f29271 = load i64, i64* %i0ptr29269, align 8 
  store volatile i64 %f29271, i64* %vptr29275, align 8 ; load; *i0ptr29269
  %fptr29270 = inttoptr i64 %f29271 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29270(i64 %h10996, i64 %h10996)                     ; tail call
  ret void
}


define void @lam11619(i64 %env11620, i64 %rvp10990) {
 %vptr29278 = alloca i64, align 8 
  %envptr29276 = inttoptr i64 %env11620 to i64* 
  store volatile i64 %MYb$f, i64* %vptr29278, align 8 ; closure/env cast; i64 -> i64*
  %vptr29279 = alloca i64*, align 8 
  %envptr29277 = getelementptr inbounds i64, i64* %envptr29276, i64 7 
  store volatile i64* %envptr29277, i64** %vptr29279, align 8 ; &envptr29276[6]
 %vptr29280 = alloca i64, align 8 
  %MYb$f = load i64, i64* %envptr29277, align 8 
  store volatile i64 %MYb$f, i64* %vptr29280, align 8 ; load; *envptr29277
 %vptr29283 = alloca i64, align 8 
  %envptr29281 = inttoptr i64 %env11620 to i64* 
  store volatile i64 %emsg08636, i64* %vptr29283, align 8 ; closure/env cast; i64 -> i64*
  %vptr29284 = alloca i64*, align 8 
  %envptr29282 = getelementptr inbounds i64, i64* %envptr29281, i64 6 
  store volatile i64* %envptr29282, i64** %vptr29284, align 8 ; &envptr29281[5]
 %vptr29285 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr29282, align 8 
  store volatile i64 %emsg08636, i64* %vptr29285, align 8 ; load; *envptr29282
 %vptr29288 = alloca i64, align 8 
  %envptr29286 = inttoptr i64 %env11620 to i64* 
  store volatile i64 %cont7319, i64* %vptr29288, align 8 ; closure/env cast; i64 -> i64*
  %vptr29289 = alloca i64*, align 8 
  %envptr29287 = getelementptr inbounds i64, i64* %envptr29286, i64 5 
  store volatile i64* %envptr29287, i64** %vptr29289, align 8 ; &envptr29286[4]
 %vptr29290 = alloca i64, align 8 
  %cont7319 = load i64, i64* %envptr29287, align 8 
  store volatile i64 %cont7319, i64* %vptr29290, align 8 ; load; *envptr29287
 %vptr29293 = alloca i64, align 8 
  %envptr29291 = inttoptr i64 %env11620 to i64* 
  store volatile i64 %emsg18637, i64* %vptr29293, align 8 ; closure/env cast; i64 -> i64*
  %vptr29294 = alloca i64*, align 8 
  %envptr29292 = getelementptr inbounds i64, i64* %envptr29291, i64 4 
  store volatile i64* %envptr29292, i64** %vptr29294, align 8 ; &envptr29291[3]
 %vptr29295 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr29292, align 8 
  store volatile i64 %emsg18637, i64* %vptr29295, align 8 ; load; *envptr29292
 %vptr29298 = alloca i64, align 8 
  %envptr29296 = inttoptr i64 %env11620 to i64* 
  store volatile i64 %CGh$vs, i64* %vptr29298, align 8 ; closure/env cast; i64 -> i64*
  %vptr29299 = alloca i64*, align 8 
  %envptr29297 = getelementptr inbounds i64, i64* %envptr29296, i64 3 
  store volatile i64* %envptr29297, i64** %vptr29299, align 8 ; &envptr29296[2]
 %vptr29300 = alloca i64, align 8 
  %CGh$vs = load i64, i64* %envptr29297, align 8 
  store volatile i64 %CGh$vs, i64* %vptr29300, align 8 ; load; *envptr29297
 %vptr29303 = alloca i64, align 8 
  %envptr29301 = inttoptr i64 %env11620 to i64* 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr29303, align 8 ; closure/env cast; i64 -> i64*
  %vptr29304 = alloca i64*, align 8 
  %envptr29302 = getelementptr inbounds i64, i64* %envptr29301, i64 2 
  store volatile i64* %envptr29302, i64** %vptr29304, align 8 ; &envptr29301[1]
 %vptr29305 = alloca i64, align 8 
  %Mcq$_37foldr1 = load i64, i64* %envptr29302, align 8 
  store volatile i64 %Mcq$_37foldr1, i64* %vptr29305, align 8 ; load; *envptr29302
 %vptr29306 = alloca i64, align 8 
  %_957326 = call i64 @prim_car(i64 %rvp10990) 
  store volatile i64 %_957326, i64* %vptr29306, align 8 ; call prim_car
 %vptr29307 = alloca i64, align 8 
  %rvp10986 = call i64 @prim_cdr(i64 %rvp10990) 
  store volatile i64 %rvp10986, i64* %vptr29307, align 8 ; call prim_cdr
 %vptr29308 = alloca i64, align 8 
  %n_6310991 = call i64 @prim_null_63(i64 %rvp10986) 
  store volatile i64 %n_6310991, i64* %vptr29308, align 8 ; call prim_null_63
  %cmpptr29312 = alloca i1, align 8  %cmp29309 = icmp eq i64 %n_6310991, 15 store volatile i1 %cmp29309, i1* %cmpptr29312, align 8; false?
  br i1 %cmp29309, label %else29311, label %then29310                                ; if

then29310:
 %vptr29313 = alloca i64, align 8 
  %h10992 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10992, i64* %vptr29313, align 8 ; call prim_halt
  %vptr29319 = alloca i64*, align 8 
  %cloptr29314 = inttoptr i64 %h10992 to i64* 
  store volatile i64* %cloptr29314, i64** %vptr29319, align 8 ; closure/env cast; i64 -> i64*
  %vptr29320 = alloca i64*, align 8 
  %i0ptr29315 = getelementptr inbounds i64, i64* %cloptr29314, i64 1 
  store volatile i64* %i0ptr29315, i64** %vptr29320, align 8 ; &cloptr29314[1]
 %vptr29321 = alloca i64, align 8 
  %f29317 = load i64, i64* %i0ptr29315, align 8 
  store volatile i64 %f29317, i64* %vptr29321, align 8 ; load; *i0ptr29315
  %fptr29316 = inttoptr i64 %f29317 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29316(i64 %h10992, i64 %h10992)                     ; tail call
  ret void

else29311:
 %vptr29322 = alloca i64, align 8 
  %a6938 = call i64 @prim_car(i64 %rvp10986) 
  store volatile i64 %a6938, i64* %vptr29322, align 8 ; call prim_car
 %vptr29323 = alloca i64, align 8 
  %na10953 = call i64 @prim_cdr(i64 %rvp10986) 
  store volatile i64 %na10953, i64* %vptr29323, align 8 ; call prim_cdr
 %vptr29324 = alloca i64, align 8 
  %n_6310987 = call i64 @prim_null_63(i64 %na10953) 
  store volatile i64 %n_6310987, i64* %vptr29324, align 8 ; call prim_null_63
  %cmpptr29328 = alloca i1, align 8  %cmp29325 = icmp eq i64 %n_6310987, 15 store volatile i1 %cmp29325, i1* %cmpptr29328, align 8; false?
  br i1 %cmp29325, label %else29327, label %then29326                                ; if

then29326:
 %vptr29329 = alloca i64, align 8 
  %arg8493 = add i64 0, 0 
  store volatile i64 %arg8493, i64* %vptr29329, align 8 ; quoted ()
 %vptr29330 = alloca i64, align 8 
  %a6939 = call i64 @prim_cons(i64 %a6938, i64 %arg8493) 
  store volatile i64 %a6939, i64* %vptr29330, align 8 ; call prim_cons
  %vptr29338 = alloca i64*, align 8 
  %cloptr29331 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr29331, i64** %vptr29338, align 8 ; malloc
  %vptr29339 = alloca i64*, align 8 
  %eptr29333 = getelementptr inbounds i64, i64* %cloptr29331, i64 2 
  store volatile i64* %eptr29333, i64** %vptr29339, align 8 ; &eptr29333[1]
  %vptr29340 = alloca i64*, align 8 
  %eptr29334 = getelementptr inbounds i64, i64* %cloptr29331, i64 3 
  store volatile i64* %eptr29334, i64** %vptr29340, align 8 ; &eptr29334[2]
  %vptr29341 = alloca i64*, align 8 
  %eptr29335 = getelementptr inbounds i64, i64* %cloptr29331, i64 4 
  store volatile i64* %eptr29335, i64** %vptr29341, align 8 ; &eptr29335[3]
  %vptr29342 = alloca i64*, align 8 
  %eptr29336 = getelementptr inbounds i64, i64* %cloptr29331, i64 5 
  store volatile i64* %eptr29336, i64** %vptr29342, align 8 ; &eptr29336[4]
  store i64 %emsg18637, i64* %eptr29333                                              ; *eptr29333 = %emsg18637
  store i64 %cont7319, i64* %eptr29334                                               ; *eptr29334 = %cont7319
  store i64 %emsg08636, i64* %eptr29335                                              ; *eptr29335 = %emsg08636
  store i64 %MYb$f, i64* %eptr29336                                                  ; *eptr29336 = %MYb$f
  %vptr29343 = alloca i64*, align 8 
  %eptr29332 = getelementptr inbounds i64, i64* %cloptr29331, i64 1 
  store volatile i64* %eptr29332, i64** %vptr29343, align 8 ; &cloptr29331[1]
 %vptr29344 = alloca i64, align 8 
  %f29337 = ptrtoint void(i64,i64)* @lam11616 to i64 
  store volatile i64 %f29337, i64* %vptr29344, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f29337, i64* %eptr29332                                                 ; store fptr
 %vptr29345 = alloca i64, align 8 
  %arg8498 = ptrtoint i64* %cloptr29331 to i64 
  store volatile i64 %arg8498, i64* %vptr29345, align 8 ; closure cast; i64* -> i64
  %vptr29351 = alloca i64*, align 8 
  %cloptr29346 = call i64* @make_closure(i64 24) 
  store volatile i64* %cloptr29346, i64** %vptr29351, align 8 ; malloc
  %vptr29352 = alloca i64*, align 8 
  %eptr29348 = getelementptr inbounds i64, i64* %cloptr29346, i64 2 
  store volatile i64* %eptr29348, i64** %vptr29352, align 8 ; &eptr29348[1]
  %vptr29353 = alloca i64*, align 8 
  %eptr29349 = getelementptr inbounds i64, i64* %cloptr29346, i64 3 
  store volatile i64* %eptr29349, i64** %vptr29353, align 8 ; &eptr29349[2]
  store i64 %emsg18637, i64* %eptr29348                                              ; *eptr29348 = %emsg18637
  store i64 %emsg08636, i64* %eptr29349                                              ; *eptr29349 = %emsg08636
  %vptr29354 = alloca i64*, align 8 
  %eptr29347 = getelementptr inbounds i64, i64* %cloptr29346, i64 1 
  store volatile i64* %eptr29347, i64** %vptr29354, align 8 ; &cloptr29346[1]
 %vptr29355 = alloca i64, align 8 
  %f29350 = ptrtoint void(i64,i64)* @lam11614 to i64 
  store volatile i64 %f29350, i64* %vptr29355, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f29350, i64* %eptr29347                                                 ; store fptr
 %vptr29356 = alloca i64, align 8 
  %arg8497 = ptrtoint i64* %cloptr29346 to i64 
  store volatile i64 %arg8497, i64* %vptr29356, align 8 ; closure cast; i64* -> i64
 %vptr29357 = alloca i64, align 8 
  %rva10985 = add i64 0, 0 
  store volatile i64 %rva10985, i64* %vptr29357, align 8 ; quoted ()
 %vptr29358 = alloca i64, align 8 
  %rva10984 = call i64 @prim_cons(i64 %CGh$vs, i64 %rva10985) 
  store volatile i64 %rva10984, i64* %vptr29358, align 8 ; call prim_cons
 %vptr29359 = alloca i64, align 8 
  %rva10983 = call i64 @prim_cons(i64 %a6939, i64 %rva10984) 
  store volatile i64 %rva10983, i64* %vptr29359, align 8 ; call prim_cons
 %vptr29360 = alloca i64, align 8 
  %rva10982 = call i64 @prim_cons(i64 %arg8497, i64 %rva10983) 
  store volatile i64 %rva10982, i64* %vptr29360, align 8 ; call prim_cons
 %vptr29361 = alloca i64, align 8 
  %rva10981 = call i64 @prim_cons(i64 %arg8498, i64 %rva10982) 
  store volatile i64 %rva10981, i64* %vptr29361, align 8 ; call prim_cons
  %vptr29367 = alloca i64*, align 8 
  %cloptr29362 = inttoptr i64 %Mcq$_37foldr1 to i64* 
  store volatile i64* %cloptr29362, i64** %vptr29367, align 8 ; closure/env cast; i64 -> i64*
  %vptr29368 = alloca i64*, align 8 
  %i0ptr29363 = getelementptr inbounds i64, i64* %cloptr29362, i64 1 
  store volatile i64* %i0ptr29363, i64** %vptr29368, align 8 ; &cloptr29362[1]
 %vptr29369 = alloca i64, align 8 
  %f29365 = load i64, i64* %i0ptr29363, align 8 
  store volatile i64 %f29365, i64* %vptr29369, align 8 ; load; *i0ptr29363
  %fptr29364 = inttoptr i64 %f29365 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29364(i64 %Mcq$_37foldr1, i64 %rva10981)            ; tail call
  ret void

else29327:
 %vptr29370 = alloca i64, align 8 
  %h10988 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10988, i64* %vptr29370, align 8 ; call prim_halt
  %vptr29376 = alloca i64*, align 8 
  %cloptr29371 = inttoptr i64 %h10988 to i64* 
  store volatile i64* %cloptr29371, i64** %vptr29376, align 8 ; closure/env cast; i64 -> i64*
  %vptr29377 = alloca i64*, align 8 
  %i0ptr29372 = getelementptr inbounds i64, i64* %cloptr29371, i64 1 
  store volatile i64* %i0ptr29372, i64** %vptr29377, align 8 ; &cloptr29371[1]
 %vptr29378 = alloca i64, align 8 
  %f29374 = load i64, i64* %i0ptr29372, align 8 
  store volatile i64 %f29374, i64* %vptr29378, align 8 ; load; *i0ptr29372
  %fptr29373 = inttoptr i64 %f29374 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29373(i64 %h10988, i64 %h10988)                     ; tail call
  ret void
}


define void @lam11616(i64 %env11617, i64 %rvp10960) {
 %vptr29381 = alloca i64, align 8 
  %envptr29379 = inttoptr i64 %env11617 to i64* 
  store volatile i64 %MYb$f, i64* %vptr29381, align 8 ; closure/env cast; i64 -> i64*
  %vptr29382 = alloca i64*, align 8 
  %envptr29380 = getelementptr inbounds i64, i64* %envptr29379, i64 5 
  store volatile i64* %envptr29380, i64** %vptr29382, align 8 ; &envptr29379[4]
 %vptr29383 = alloca i64, align 8 
  %MYb$f = load i64, i64* %envptr29380, align 8 
  store volatile i64 %MYb$f, i64* %vptr29383, align 8 ; load; *envptr29380
 %vptr29386 = alloca i64, align 8 
  %envptr29384 = inttoptr i64 %env11617 to i64* 
  store volatile i64 %emsg08636, i64* %vptr29386, align 8 ; closure/env cast; i64 -> i64*
  %vptr29387 = alloca i64*, align 8 
  %envptr29385 = getelementptr inbounds i64, i64* %envptr29384, i64 4 
  store volatile i64* %envptr29385, i64** %vptr29387, align 8 ; &envptr29384[3]
 %vptr29388 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr29385, align 8 
  store volatile i64 %emsg08636, i64* %vptr29388, align 8 ; load; *envptr29385
 %vptr29391 = alloca i64, align 8 
  %envptr29389 = inttoptr i64 %env11617 to i64* 
  store volatile i64 %cont7319, i64* %vptr29391, align 8 ; closure/env cast; i64 -> i64*
  %vptr29392 = alloca i64*, align 8 
  %envptr29390 = getelementptr inbounds i64, i64* %envptr29389, i64 3 
  store volatile i64* %envptr29390, i64** %vptr29392, align 8 ; &envptr29389[2]
 %vptr29393 = alloca i64, align 8 
  %cont7319 = load i64, i64* %envptr29390, align 8 
  store volatile i64 %cont7319, i64* %vptr29393, align 8 ; load; *envptr29390
 %vptr29396 = alloca i64, align 8 
  %envptr29394 = inttoptr i64 %env11617 to i64* 
  store volatile i64 %emsg18637, i64* %vptr29396, align 8 ; closure/env cast; i64 -> i64*
  %vptr29397 = alloca i64*, align 8 
  %envptr29395 = getelementptr inbounds i64, i64* %envptr29394, i64 2 
  store volatile i64* %envptr29395, i64** %vptr29397, align 8 ; &envptr29394[1]
 %vptr29398 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr29395, align 8 
  store volatile i64 %emsg18637, i64* %vptr29398, align 8 ; load; *envptr29395
 %vptr29399 = alloca i64, align 8 
  %_957327 = call i64 @prim_car(i64 %rvp10960) 
  store volatile i64 %_957327, i64* %vptr29399, align 8 ; call prim_car
 %vptr29400 = alloca i64, align 8 
  %rvp10956 = call i64 @prim_cdr(i64 %rvp10960) 
  store volatile i64 %rvp10956, i64* %vptr29400, align 8 ; call prim_cdr
 %vptr29401 = alloca i64, align 8 
  %n_6310961 = call i64 @prim_null_63(i64 %rvp10956) 
  store volatile i64 %n_6310961, i64* %vptr29401, align 8 ; call prim_null_63
  %cmpptr29405 = alloca i1, align 8  %cmp29402 = icmp eq i64 %n_6310961, 15 store volatile i1 %cmp29402, i1* %cmpptr29405, align 8; false?
  br i1 %cmp29402, label %else29404, label %then29403                                ; if

then29403:
 %vptr29406 = alloca i64, align 8 
  %h10962 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10962, i64* %vptr29406, align 8 ; call prim_halt
  %vptr29412 = alloca i64*, align 8 
  %cloptr29407 = inttoptr i64 %h10962 to i64* 
  store volatile i64* %cloptr29407, i64** %vptr29412, align 8 ; closure/env cast; i64 -> i64*
  %vptr29413 = alloca i64*, align 8 
  %i0ptr29408 = getelementptr inbounds i64, i64* %cloptr29407, i64 1 
  store volatile i64* %i0ptr29408, i64** %vptr29413, align 8 ; &cloptr29407[1]
 %vptr29414 = alloca i64, align 8 
  %f29410 = load i64, i64* %i0ptr29408, align 8 
  store volatile i64 %f29410, i64* %vptr29414, align 8 ; load; *i0ptr29408
  %fptr29409 = inttoptr i64 %f29410 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29409(i64 %h10962, i64 %h10962)                     ; tail call
  ret void

else29404:
 %vptr29415 = alloca i64, align 8 
  %a6940 = call i64 @prim_car(i64 %rvp10956) 
  store volatile i64 %a6940, i64* %vptr29415, align 8 ; call prim_car
 %vptr29416 = alloca i64, align 8 
  %na10955 = call i64 @prim_cdr(i64 %rvp10956) 
  store volatile i64 %na10955, i64* %vptr29416, align 8 ; call prim_cdr
 %vptr29417 = alloca i64, align 8 
  %n_6310957 = call i64 @prim_null_63(i64 %na10955) 
  store volatile i64 %n_6310957, i64* %vptr29417, align 8 ; call prim_null_63
  %cmpptr29421 = alloca i1, align 8  %cmp29418 = icmp eq i64 %n_6310957, 15 store volatile i1 %cmp29418, i1* %cmpptr29421, align 8; false?
  br i1 %cmp29418, label %else29420, label %then29419                                ; if

then29419:
 %vptr29422 = alloca i64, align 8 
  %cps_45lst7328 = call i64 @prim_cons(i64 %cont7319, i64 %a6940) 
  store volatile i64 %cps_45lst7328, i64* %vptr29422, align 8 ; call prim_cons
  %vptr29428 = alloca i64*, align 8 
  %cloptr29423 = inttoptr i64 %MYb$f to i64* 
  store volatile i64* %cloptr29423, i64** %vptr29428, align 8 ; closure/env cast; i64 -> i64*
  %vptr29429 = alloca i64*, align 8 
  %i0ptr29424 = getelementptr inbounds i64, i64* %cloptr29423, i64 1 
  store volatile i64* %i0ptr29424, i64** %vptr29429, align 8 ; &cloptr29423[1]
 %vptr29430 = alloca i64, align 8 
  %f29426 = load i64, i64* %i0ptr29424, align 8 
  store volatile i64 %f29426, i64* %vptr29430, align 8 ; load; *i0ptr29424
  %fptr29425 = inttoptr i64 %f29426 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29425(i64 %MYb$f, i64 %cps_45lst7328)               ; tail call
  ret void

else29420:
 %vptr29431 = alloca i64, align 8 
  %h10958 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10958, i64* %vptr29431, align 8 ; call prim_halt
  %vptr29437 = alloca i64*, align 8 
  %cloptr29432 = inttoptr i64 %h10958 to i64* 
  store volatile i64* %cloptr29432, i64** %vptr29437, align 8 ; closure/env cast; i64 -> i64*
  %vptr29438 = alloca i64*, align 8 
  %i0ptr29433 = getelementptr inbounds i64, i64* %cloptr29432, i64 1 
  store volatile i64* %i0ptr29433, i64** %vptr29438, align 8 ; &cloptr29432[1]
 %vptr29439 = alloca i64, align 8 
  %f29435 = load i64, i64* %i0ptr29433, align 8 
  store volatile i64 %f29435, i64* %vptr29439, align 8 ; load; *i0ptr29433
  %fptr29434 = inttoptr i64 %f29435 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29434(i64 %h10958, i64 %h10958)                     ; tail call
  ret void
}


define void @lam11614(i64 %env11615, i64 %rvp10977) {
 %vptr29442 = alloca i64, align 8 
  %envptr29440 = inttoptr i64 %env11615 to i64* 
  store volatile i64 %emsg08636, i64* %vptr29442, align 8 ; closure/env cast; i64 -> i64*
  %vptr29443 = alloca i64*, align 8 
  %envptr29441 = getelementptr inbounds i64, i64* %envptr29440, i64 3 
  store volatile i64* %envptr29441, i64** %vptr29443, align 8 ; &envptr29440[2]
 %vptr29444 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr29441, align 8 
  store volatile i64 %emsg08636, i64* %vptr29444, align 8 ; load; *envptr29441
 %vptr29447 = alloca i64, align 8 
  %envptr29445 = inttoptr i64 %env11615 to i64* 
  store volatile i64 %emsg18637, i64* %vptr29447, align 8 ; closure/env cast; i64 -> i64*
  %vptr29448 = alloca i64*, align 8 
  %envptr29446 = getelementptr inbounds i64, i64* %envptr29445, i64 2 
  store volatile i64* %envptr29446, i64** %vptr29448, align 8 ; &envptr29445[1]
 %vptr29449 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr29446, align 8 
  store volatile i64 %emsg18637, i64* %vptr29449, align 8 ; load; *envptr29446
 %vptr29450 = alloca i64, align 8 
  %cont7329 = call i64 @prim_car(i64 %rvp10977) 
  store volatile i64 %cont7329, i64* %vptr29450, align 8 ; call prim_car
 %vptr29451 = alloca i64, align 8 
  %rvp10973 = call i64 @prim_cdr(i64 %rvp10977) 
  store volatile i64 %rvp10973, i64* %vptr29451, align 8 ; call prim_cdr
 %vptr29452 = alloca i64, align 8 
  %n_6310978 = call i64 @prim_null_63(i64 %rvp10973) 
  store volatile i64 %n_6310978, i64* %vptr29452, align 8 ; call prim_null_63
  %cmpptr29456 = alloca i1, align 8  %cmp29453 = icmp eq i64 %n_6310978, 15 store volatile i1 %cmp29453, i1* %cmpptr29456, align 8; false?
  br i1 %cmp29453, label %else29455, label %then29454                                ; if

then29454:
 %vptr29457 = alloca i64, align 8 
  %h10979 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10979, i64* %vptr29457, align 8 ; call prim_halt
  %vptr29463 = alloca i64*, align 8 
  %cloptr29458 = inttoptr i64 %h10979 to i64* 
  store volatile i64* %cloptr29458, i64** %vptr29463, align 8 ; closure/env cast; i64 -> i64*
  %vptr29464 = alloca i64*, align 8 
  %i0ptr29459 = getelementptr inbounds i64, i64* %cloptr29458, i64 1 
  store volatile i64* %i0ptr29459, i64** %vptr29464, align 8 ; &cloptr29458[1]
 %vptr29465 = alloca i64, align 8 
  %f29461 = load i64, i64* %i0ptr29459, align 8 
  store volatile i64 %f29461, i64* %vptr29465, align 8 ; load; *i0ptr29459
  %fptr29460 = inttoptr i64 %f29461 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29460(i64 %h10979, i64 %h10979)                     ; tail call
  ret void

else29455:
 %vptr29466 = alloca i64, align 8 
  %xpx$a = call i64 @prim_car(i64 %rvp10973) 
  store volatile i64 %xpx$a, i64* %vptr29466, align 8 ; call prim_car
 %vptr29467 = alloca i64, align 8 
  %rvp10969 = call i64 @prim_cdr(i64 %rvp10973) 
  store volatile i64 %rvp10969, i64* %vptr29467, align 8 ; call prim_cdr
 %vptr29468 = alloca i64, align 8 
  %n_6310974 = call i64 @prim_null_63(i64 %rvp10969) 
  store volatile i64 %n_6310974, i64* %vptr29468, align 8 ; call prim_null_63
  %cmpptr29472 = alloca i1, align 8  %cmp29469 = icmp eq i64 %n_6310974, 15 store volatile i1 %cmp29469, i1* %cmpptr29472, align 8; false?
  br i1 %cmp29469, label %else29471, label %then29470                                ; if

then29470:
 %vptr29473 = alloca i64, align 8 
  %h10975 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h10975, i64* %vptr29473, align 8 ; call prim_halt
  %vptr29479 = alloca i64*, align 8 
  %cloptr29474 = inttoptr i64 %h10975 to i64* 
  store volatile i64* %cloptr29474, i64** %vptr29479, align 8 ; closure/env cast; i64 -> i64*
  %vptr29480 = alloca i64*, align 8 
  %i0ptr29475 = getelementptr inbounds i64, i64* %cloptr29474, i64 1 
  store volatile i64* %i0ptr29475, i64** %vptr29480, align 8 ; &cloptr29474[1]
 %vptr29481 = alloca i64, align 8 
  %f29477 = load i64, i64* %i0ptr29475, align 8 
  store volatile i64 %f29477, i64* %vptr29481, align 8 ; load; *i0ptr29475
  %fptr29476 = inttoptr i64 %f29477 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29476(i64 %h10975, i64 %h10975)                     ; tail call
  ret void

else29471:
 %vptr29482 = alloca i64, align 8 
  %Xsv$b = call i64 @prim_car(i64 %rvp10969) 
  store volatile i64 %Xsv$b, i64* %vptr29482, align 8 ; call prim_car
 %vptr29483 = alloca i64, align 8 
  %na10965 = call i64 @prim_cdr(i64 %rvp10969) 
  store volatile i64 %na10965, i64* %vptr29483, align 8 ; call prim_cdr
 %vptr29484 = alloca i64, align 8 
  %n_6310970 = call i64 @prim_null_63(i64 %na10965) 
  store volatile i64 %n_6310970, i64* %vptr29484, align 8 ; call prim_null_63
  %cmpptr29488 = alloca i1, align 8  %cmp29485 = icmp eq i64 %n_6310970, 15 store volatile i1 %cmp29485, i1* %cmpptr29488, align 8; false?
  br i1 %cmp29485, label %else29487, label %then29486                                ; if

then29486:
 %vptr29489 = alloca i64, align 8 
  %retprim7330 = call i64 @prim_cons(i64 %xpx$a, i64 %Xsv$b) 
  store volatile i64 %retprim7330, i64* %vptr29489, align 8 ; call prim_cons
 %vptr29490 = alloca i64, align 8 
  %arg8505 = add i64 0, 0 
  store volatile i64 %arg8505, i64* %vptr29490, align 8 ; quoted ()
 %vptr29491 = alloca i64, align 8 
  %rva10968 = add i64 0, 0 
  store volatile i64 %rva10968, i64* %vptr29491, align 8 ; quoted ()
 %vptr29492 = alloca i64, align 8 
  %rva10967 = call i64 @prim_cons(i64 %retprim7330, i64 %rva10968) 
  store volatile i64 %rva10967, i64* %vptr29492, align 8 ; call prim_cons
 %vptr29493 = alloca i64, align 8 
  %rva10966 = call i64 @prim_cons(i64 %arg8505, i64 %rva10967) 
  store volatile i64 %rva10966, i64* %vptr29493, align 8 ; call prim_cons
  %vptr29499 = alloca i64*, align 8 
  %cloptr29494 = inttoptr i64 %cont7329 to i64* 
  store volatile i64* %cloptr29494, i64** %vptr29499, align 8 ; closure/env cast; i64 -> i64*
  %vptr29500 = alloca i64*, align 8 
  %i0ptr29495 = getelementptr inbounds i64, i64* %cloptr29494, i64 1 
  store volatile i64* %i0ptr29495, i64** %vptr29500, align 8 ; &cloptr29494[1]
 %vptr29501 = alloca i64, align 8 
  %f29497 = load i64, i64* %i0ptr29495, align 8 
  store volatile i64 %f29497, i64* %vptr29501, align 8 ; load; *i0ptr29495
  %fptr29496 = inttoptr i64 %f29497 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29496(i64 %cont7329, i64 %rva10966)                 ; tail call
  ret void

else29487:
 %vptr29502 = alloca i64, align 8 
  %h10971 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h10971, i64* %vptr29502, align 8 ; call prim_halt
  %vptr29508 = alloca i64*, align 8 
  %cloptr29503 = inttoptr i64 %h10971 to i64* 
  store volatile i64* %cloptr29503, i64** %vptr29508, align 8 ; closure/env cast; i64 -> i64*
  %vptr29509 = alloca i64*, align 8 
  %i0ptr29504 = getelementptr inbounds i64, i64* %cloptr29503, i64 1 
  store volatile i64* %i0ptr29504, i64** %vptr29509, align 8 ; &cloptr29503[1]
 %vptr29510 = alloca i64, align 8 
  %f29506 = load i64, i64* %i0ptr29504, align 8 
  store volatile i64 %f29506, i64* %vptr29510, align 8 ; load; *i0ptr29504
  %fptr29505 = inttoptr i64 %f29506 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29505(i64 %h10971, i64 %h10971)                     ; tail call
  ret void
}


define void @lam11609(i64 %env11610, i64 %rvp11011) {
 %vptr29513 = alloca i64, align 8 
  %envptr29511 = inttoptr i64 %env11610 to i64* 
  store volatile i64 %emsg08636, i64* %vptr29513, align 8 ; closure/env cast; i64 -> i64*
  %vptr29514 = alloca i64*, align 8 
  %envptr29512 = getelementptr inbounds i64, i64* %envptr29511, i64 3 
  store volatile i64* %envptr29512, i64** %vptr29514, align 8 ; &envptr29511[2]
 %vptr29515 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr29512, align 8 
  store volatile i64 %emsg08636, i64* %vptr29515, align 8 ; load; *envptr29512
 %vptr29518 = alloca i64, align 8 
  %envptr29516 = inttoptr i64 %env11610 to i64* 
  store volatile i64 %emsg18637, i64* %vptr29518, align 8 ; closure/env cast; i64 -> i64*
  %vptr29519 = alloca i64*, align 8 
  %envptr29517 = getelementptr inbounds i64, i64* %envptr29516, i64 2 
  store volatile i64* %envptr29517, i64** %vptr29519, align 8 ; &envptr29516[1]
 %vptr29520 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr29517, align 8 
  store volatile i64 %emsg18637, i64* %vptr29520, align 8 ; load; *envptr29517
 %vptr29521 = alloca i64, align 8 
  %cont7332 = call i64 @prim_car(i64 %rvp11011) 
  store volatile i64 %cont7332, i64* %vptr29521, align 8 ; call prim_car
 %vptr29522 = alloca i64, align 8 
  %rvp11007 = call i64 @prim_cdr(i64 %rvp11011) 
  store volatile i64 %rvp11007, i64* %vptr29522, align 8 ; call prim_cdr
 %vptr29523 = alloca i64, align 8 
  %n_6311012 = call i64 @prim_null_63(i64 %rvp11007) 
  store volatile i64 %n_6311012, i64* %vptr29523, align 8 ; call prim_null_63
  %cmpptr29527 = alloca i1, align 8  %cmp29524 = icmp eq i64 %n_6311012, 15 store volatile i1 %cmp29524, i1* %cmpptr29527, align 8; false?
  br i1 %cmp29524, label %else29526, label %then29525                                ; if

then29525:
 %vptr29528 = alloca i64, align 8 
  %h11013 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11013, i64* %vptr29528, align 8 ; call prim_halt
  %vptr29534 = alloca i64*, align 8 
  %cloptr29529 = inttoptr i64 %h11013 to i64* 
  store volatile i64* %cloptr29529, i64** %vptr29534, align 8 ; closure/env cast; i64 -> i64*
  %vptr29535 = alloca i64*, align 8 
  %i0ptr29530 = getelementptr inbounds i64, i64* %cloptr29529, i64 1 
  store volatile i64* %i0ptr29530, i64** %vptr29535, align 8 ; &cloptr29529[1]
 %vptr29536 = alloca i64, align 8 
  %f29532 = load i64, i64* %i0ptr29530, align 8 
  store volatile i64 %f29532, i64* %vptr29536, align 8 ; load; *i0ptr29530
  %fptr29531 = inttoptr i64 %f29532 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29531(i64 %h11013, i64 %h11013)                     ; tail call
  ret void

else29526:
 %vptr29537 = alloca i64, align 8 
  %s1w$x = call i64 @prim_car(i64 %rvp11007) 
  store volatile i64 %s1w$x, i64* %vptr29537, align 8 ; call prim_car
 %vptr29538 = alloca i64, align 8 
  %na11003 = call i64 @prim_cdr(i64 %rvp11007) 
  store volatile i64 %na11003, i64* %vptr29538, align 8 ; call prim_cdr
 %vptr29539 = alloca i64, align 8 
  %n_6311008 = call i64 @prim_null_63(i64 %na11003) 
  store volatile i64 %n_6311008, i64* %vptr29539, align 8 ; call prim_null_63
  %cmpptr29543 = alloca i1, align 8  %cmp29540 = icmp eq i64 %n_6311008, 15 store volatile i1 %cmp29540, i1* %cmpptr29543, align 8; false?
  br i1 %cmp29540, label %else29542, label %then29541                                ; if

then29541:
 %vptr29544 = alloca i64, align 8 
  %retprim7333 = call i64 @prim_car(i64 %s1w$x) 
  store volatile i64 %retprim7333, i64* %vptr29544, align 8 ; call prim_car
 %vptr29545 = alloca i64, align 8 
  %arg8509 = add i64 0, 0 
  store volatile i64 %arg8509, i64* %vptr29545, align 8 ; quoted ()
 %vptr29546 = alloca i64, align 8 
  %rva11006 = add i64 0, 0 
  store volatile i64 %rva11006, i64* %vptr29546, align 8 ; quoted ()
 %vptr29547 = alloca i64, align 8 
  %rva11005 = call i64 @prim_cons(i64 %retprim7333, i64 %rva11006) 
  store volatile i64 %rva11005, i64* %vptr29547, align 8 ; call prim_cons
 %vptr29548 = alloca i64, align 8 
  %rva11004 = call i64 @prim_cons(i64 %arg8509, i64 %rva11005) 
  store volatile i64 %rva11004, i64* %vptr29548, align 8 ; call prim_cons
  %vptr29554 = alloca i64*, align 8 
  %cloptr29549 = inttoptr i64 %cont7332 to i64* 
  store volatile i64* %cloptr29549, i64** %vptr29554, align 8 ; closure/env cast; i64 -> i64*
  %vptr29555 = alloca i64*, align 8 
  %i0ptr29550 = getelementptr inbounds i64, i64* %cloptr29549, i64 1 
  store volatile i64* %i0ptr29550, i64** %vptr29555, align 8 ; &cloptr29549[1]
 %vptr29556 = alloca i64, align 8 
  %f29552 = load i64, i64* %i0ptr29550, align 8 
  store volatile i64 %f29552, i64* %vptr29556, align 8 ; load; *i0ptr29550
  %fptr29551 = inttoptr i64 %f29552 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29551(i64 %cont7332, i64 %rva11004)                 ; tail call
  ret void

else29542:
 %vptr29557 = alloca i64, align 8 
  %h11009 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11009, i64* %vptr29557, align 8 ; call prim_halt
  %vptr29563 = alloca i64*, align 8 
  %cloptr29558 = inttoptr i64 %h11009 to i64* 
  store volatile i64* %cloptr29558, i64** %vptr29563, align 8 ; closure/env cast; i64 -> i64*
  %vptr29564 = alloca i64*, align 8 
  %i0ptr29559 = getelementptr inbounds i64, i64* %cloptr29558, i64 1 
  store volatile i64* %i0ptr29559, i64** %vptr29564, align 8 ; &cloptr29558[1]
 %vptr29565 = alloca i64, align 8 
  %f29561 = load i64, i64* %i0ptr29559, align 8 
  store volatile i64 %f29561, i64* %vptr29565, align 8 ; load; *i0ptr29559
  %fptr29560 = inttoptr i64 %f29561 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29560(i64 %h11009, i64 %h11009)                     ; tail call
  ret void
}


define void @lam11604(i64 %env11605, i64 %rvp11036) {
 %vptr29568 = alloca i64, align 8 
  %envptr29566 = inttoptr i64 %env11605 to i64* 
  store volatile i64 %emsg08636, i64* %vptr29568, align 8 ; closure/env cast; i64 -> i64*
  %vptr29569 = alloca i64*, align 8 
  %envptr29567 = getelementptr inbounds i64, i64* %envptr29566, i64 3 
  store volatile i64* %envptr29567, i64** %vptr29569, align 8 ; &envptr29566[2]
 %vptr29570 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr29567, align 8 
  store volatile i64 %emsg08636, i64* %vptr29570, align 8 ; load; *envptr29567
 %vptr29573 = alloca i64, align 8 
  %envptr29571 = inttoptr i64 %env11605 to i64* 
  store volatile i64 %emsg18637, i64* %vptr29573, align 8 ; closure/env cast; i64 -> i64*
  %vptr29574 = alloca i64*, align 8 
  %envptr29572 = getelementptr inbounds i64, i64* %envptr29571, i64 2 
  store volatile i64* %envptr29572, i64** %vptr29574, align 8 ; &envptr29571[1]
 %vptr29575 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr29572, align 8 
  store volatile i64 %emsg18637, i64* %vptr29575, align 8 ; load; *envptr29572
 %vptr29576 = alloca i64, align 8 
  %cont7334 = call i64 @prim_car(i64 %rvp11036) 
  store volatile i64 %cont7334, i64* %vptr29576, align 8 ; call prim_car
 %vptr29577 = alloca i64, align 8 
  %rvp11032 = call i64 @prim_cdr(i64 %rvp11036) 
  store volatile i64 %rvp11032, i64* %vptr29577, align 8 ; call prim_cdr
 %vptr29578 = alloca i64, align 8 
  %n_6311037 = call i64 @prim_null_63(i64 %rvp11032) 
  store volatile i64 %n_6311037, i64* %vptr29578, align 8 ; call prim_null_63
  %cmpptr29582 = alloca i1, align 8  %cmp29579 = icmp eq i64 %n_6311037, 15 store volatile i1 %cmp29579, i1* %cmpptr29582, align 8; false?
  br i1 %cmp29579, label %else29581, label %then29580                                ; if

then29580:
 %vptr29583 = alloca i64, align 8 
  %h11038 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11038, i64* %vptr29583, align 8 ; call prim_halt
  %vptr29589 = alloca i64*, align 8 
  %cloptr29584 = inttoptr i64 %h11038 to i64* 
  store volatile i64* %cloptr29584, i64** %vptr29589, align 8 ; closure/env cast; i64 -> i64*
  %vptr29590 = alloca i64*, align 8 
  %i0ptr29585 = getelementptr inbounds i64, i64* %cloptr29584, i64 1 
  store volatile i64* %i0ptr29585, i64** %vptr29590, align 8 ; &cloptr29584[1]
 %vptr29591 = alloca i64, align 8 
  %f29587 = load i64, i64* %i0ptr29585, align 8 
  store volatile i64 %f29587, i64* %vptr29591, align 8 ; load; *i0ptr29585
  %fptr29586 = inttoptr i64 %f29587 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29586(i64 %h11038, i64 %h11038)                     ; tail call
  ret void

else29581:
 %vptr29592 = alloca i64, align 8 
  %WKj$x = call i64 @prim_car(i64 %rvp11032) 
  store volatile i64 %WKj$x, i64* %vptr29592, align 8 ; call prim_car
 %vptr29593 = alloca i64, align 8 
  %na11028 = call i64 @prim_cdr(i64 %rvp11032) 
  store volatile i64 %na11028, i64* %vptr29593, align 8 ; call prim_cdr
 %vptr29594 = alloca i64, align 8 
  %n_6311033 = call i64 @prim_null_63(i64 %na11028) 
  store volatile i64 %n_6311033, i64* %vptr29594, align 8 ; call prim_null_63
  %cmpptr29598 = alloca i1, align 8  %cmp29595 = icmp eq i64 %n_6311033, 15 store volatile i1 %cmp29595, i1* %cmpptr29598, align 8; false?
  br i1 %cmp29595, label %else29597, label %then29596                                ; if

then29596:
 %vptr29599 = alloca i64, align 8 
  %retprim7335 = call i64 @prim_cdr(i64 %WKj$x) 
  store volatile i64 %retprim7335, i64* %vptr29599, align 8 ; call prim_cdr
 %vptr29600 = alloca i64, align 8 
  %arg8513 = add i64 0, 0 
  store volatile i64 %arg8513, i64* %vptr29600, align 8 ; quoted ()
 %vptr29601 = alloca i64, align 8 
  %rva11031 = add i64 0, 0 
  store volatile i64 %rva11031, i64* %vptr29601, align 8 ; quoted ()
 %vptr29602 = alloca i64, align 8 
  %rva11030 = call i64 @prim_cons(i64 %retprim7335, i64 %rva11031) 
  store volatile i64 %rva11030, i64* %vptr29602, align 8 ; call prim_cons
 %vptr29603 = alloca i64, align 8 
  %rva11029 = call i64 @prim_cons(i64 %arg8513, i64 %rva11030) 
  store volatile i64 %rva11029, i64* %vptr29603, align 8 ; call prim_cons
  %vptr29609 = alloca i64*, align 8 
  %cloptr29604 = inttoptr i64 %cont7334 to i64* 
  store volatile i64* %cloptr29604, i64** %vptr29609, align 8 ; closure/env cast; i64 -> i64*
  %vptr29610 = alloca i64*, align 8 
  %i0ptr29605 = getelementptr inbounds i64, i64* %cloptr29604, i64 1 
  store volatile i64* %i0ptr29605, i64** %vptr29610, align 8 ; &cloptr29604[1]
 %vptr29611 = alloca i64, align 8 
  %f29607 = load i64, i64* %i0ptr29605, align 8 
  store volatile i64 %f29607, i64* %vptr29611, align 8 ; load; *i0ptr29605
  %fptr29606 = inttoptr i64 %f29607 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29606(i64 %cont7334, i64 %rva11029)                 ; tail call
  ret void

else29597:
 %vptr29612 = alloca i64, align 8 
  %h11034 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11034, i64* %vptr29612, align 8 ; call prim_halt
  %vptr29618 = alloca i64*, align 8 
  %cloptr29613 = inttoptr i64 %h11034 to i64* 
  store volatile i64* %cloptr29613, i64** %vptr29618, align 8 ; closure/env cast; i64 -> i64*
  %vptr29619 = alloca i64*, align 8 
  %i0ptr29614 = getelementptr inbounds i64, i64* %cloptr29613, i64 1 
  store volatile i64* %i0ptr29614, i64** %vptr29619, align 8 ; &cloptr29613[1]
 %vptr29620 = alloca i64, align 8 
  %f29616 = load i64, i64* %i0ptr29614, align 8 
  store volatile i64 %f29616, i64* %vptr29620, align 8 ; load; *i0ptr29614
  %fptr29615 = inttoptr i64 %f29616 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29615(i64 %h11034, i64 %h11034)                     ; tail call
  ret void
}


define void @lam11597(i64 %env11598, i64 %rvp11068) {
 %vptr29623 = alloca i64, align 8 
  %envptr29621 = inttoptr i64 %env11598 to i64* 
  store volatile i64 %emsg08636, i64* %vptr29623, align 8 ; closure/env cast; i64 -> i64*
  %vptr29624 = alloca i64*, align 8 
  %envptr29622 = getelementptr inbounds i64, i64* %envptr29621, i64 3 
  store volatile i64* %envptr29622, i64** %vptr29624, align 8 ; &envptr29621[2]
 %vptr29625 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr29622, align 8 
  store volatile i64 %emsg08636, i64* %vptr29625, align 8 ; load; *envptr29622
 %vptr29628 = alloca i64, align 8 
  %envptr29626 = inttoptr i64 %env11598 to i64* 
  store volatile i64 %emsg18637, i64* %vptr29628, align 8 ; closure/env cast; i64 -> i64*
  %vptr29629 = alloca i64*, align 8 
  %envptr29627 = getelementptr inbounds i64, i64* %envptr29626, i64 2 
  store volatile i64* %envptr29627, i64** %vptr29629, align 8 ; &envptr29626[1]
 %vptr29630 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr29627, align 8 
  store volatile i64 %emsg18637, i64* %vptr29630, align 8 ; load; *envptr29627
 %vptr29631 = alloca i64, align 8 
  %cont7336 = call i64 @prim_car(i64 %rvp11068) 
  store volatile i64 %cont7336, i64* %vptr29631, align 8 ; call prim_car
 %vptr29632 = alloca i64, align 8 
  %rvp11064 = call i64 @prim_cdr(i64 %rvp11068) 
  store volatile i64 %rvp11064, i64* %vptr29632, align 8 ; call prim_cdr
 %vptr29633 = alloca i64, align 8 
  %n_6311069 = call i64 @prim_null_63(i64 %rvp11064) 
  store volatile i64 %n_6311069, i64* %vptr29633, align 8 ; call prim_null_63
  %cmpptr29637 = alloca i1, align 8  %cmp29634 = icmp eq i64 %n_6311069, 15 store volatile i1 %cmp29634, i1* %cmpptr29637, align 8; false?
  br i1 %cmp29634, label %else29636, label %then29635                                ; if

then29635:
 %vptr29638 = alloca i64, align 8 
  %h11070 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11070, i64* %vptr29638, align 8 ; call prim_halt
  %vptr29644 = alloca i64*, align 8 
  %cloptr29639 = inttoptr i64 %h11070 to i64* 
  store volatile i64* %cloptr29639, i64** %vptr29644, align 8 ; closure/env cast; i64 -> i64*
  %vptr29645 = alloca i64*, align 8 
  %i0ptr29640 = getelementptr inbounds i64, i64* %cloptr29639, i64 1 
  store volatile i64* %i0ptr29640, i64** %vptr29645, align 8 ; &cloptr29639[1]
 %vptr29646 = alloca i64, align 8 
  %f29642 = load i64, i64* %i0ptr29640, align 8 
  store volatile i64 %f29642, i64* %vptr29646, align 8 ; load; *i0ptr29640
  %fptr29641 = inttoptr i64 %f29642 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29641(i64 %h11070, i64 %h11070)                     ; tail call
  ret void

else29636:
 %vptr29647 = alloca i64, align 8 
  %K28$lst = call i64 @prim_car(i64 %rvp11064) 
  store volatile i64 %K28$lst, i64* %vptr29647, align 8 ; call prim_car
 %vptr29648 = alloca i64, align 8 
  %rvp11060 = call i64 @prim_cdr(i64 %rvp11064) 
  store volatile i64 %rvp11060, i64* %vptr29648, align 8 ; call prim_cdr
 %vptr29649 = alloca i64, align 8 
  %n_6311065 = call i64 @prim_null_63(i64 %rvp11060) 
  store volatile i64 %n_6311065, i64* %vptr29649, align 8 ; call prim_null_63
  %cmpptr29653 = alloca i1, align 8  %cmp29650 = icmp eq i64 %n_6311065, 15 store volatile i1 %cmp29650, i1* %cmpptr29653, align 8; false?
  br i1 %cmp29650, label %else29652, label %then29651                                ; if

then29651:
 %vptr29654 = alloca i64, align 8 
  %h11066 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11066, i64* %vptr29654, align 8 ; call prim_halt
  %vptr29660 = alloca i64*, align 8 
  %cloptr29655 = inttoptr i64 %h11066 to i64* 
  store volatile i64* %cloptr29655, i64** %vptr29660, align 8 ; closure/env cast; i64 -> i64*
  %vptr29661 = alloca i64*, align 8 
  %i0ptr29656 = getelementptr inbounds i64, i64* %cloptr29655, i64 1 
  store volatile i64* %i0ptr29656, i64** %vptr29661, align 8 ; &cloptr29655[1]
 %vptr29662 = alloca i64, align 8 
  %f29658 = load i64, i64* %i0ptr29656, align 8 
  store volatile i64 %f29658, i64* %vptr29662, align 8 ; load; *i0ptr29656
  %fptr29657 = inttoptr i64 %f29658 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29657(i64 %h11066, i64 %h11066)                     ; tail call
  ret void

else29652:
 %vptr29663 = alloca i64, align 8 
  %xOZ$b = call i64 @prim_car(i64 %rvp11060) 
  store volatile i64 %xOZ$b, i64* %vptr29663, align 8 ; call prim_car
 %vptr29664 = alloca i64, align 8 
  %na11053 = call i64 @prim_cdr(i64 %rvp11060) 
  store volatile i64 %na11053, i64* %vptr29664, align 8 ; call prim_cdr
 %vptr29665 = alloca i64, align 8 
  %n_6311061 = call i64 @prim_null_63(i64 %na11053) 
  store volatile i64 %n_6311061, i64* %vptr29665, align 8 ; call prim_null_63
  %cmpptr29669 = alloca i1, align 8  %cmp29666 = icmp eq i64 %n_6311061, 15 store volatile i1 %cmp29666, i1* %cmpptr29669, align 8; false?
  br i1 %cmp29666, label %else29668, label %then29667                                ; if

then29667:
  %cmpptr29673 = alloca i1, align 8  %cmp29670 = icmp eq i64 %xOZ$b, 15 store volatile i1 %cmp29670, i1* %cmpptr29673, align 8; false?
  br i1 %cmp29670, label %else29672, label %then29671                                ; if

then29671:
 %vptr29674 = alloca i64, align 8 
  %arg8516 = add i64 0, 0 
  store volatile i64 %arg8516, i64* %vptr29674, align 8 ; quoted ()
 %vptr29675 = alloca i64, align 8 
  %rva11056 = add i64 0, 0 
  store volatile i64 %rva11056, i64* %vptr29675, align 8 ; quoted ()
 %vptr29676 = alloca i64, align 8 
  %rva11055 = call i64 @prim_cons(i64 %xOZ$b, i64 %rva11056) 
  store volatile i64 %rva11055, i64* %vptr29676, align 8 ; call prim_cons
 %vptr29677 = alloca i64, align 8 
  %rva11054 = call i64 @prim_cons(i64 %arg8516, i64 %rva11055) 
  store volatile i64 %rva11054, i64* %vptr29677, align 8 ; call prim_cons
  %vptr29683 = alloca i64*, align 8 
  %cloptr29678 = inttoptr i64 %cont7336 to i64* 
  store volatile i64* %cloptr29678, i64** %vptr29683, align 8 ; closure/env cast; i64 -> i64*
  %vptr29684 = alloca i64*, align 8 
  %i0ptr29679 = getelementptr inbounds i64, i64* %cloptr29678, i64 1 
  store volatile i64* %i0ptr29679, i64** %vptr29684, align 8 ; &cloptr29678[1]
 %vptr29685 = alloca i64, align 8 
  %f29681 = load i64, i64* %i0ptr29679, align 8 
  store volatile i64 %f29681, i64* %vptr29685, align 8 ; load; *i0ptr29679
  %fptr29680 = inttoptr i64 %f29681 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29680(i64 %cont7336, i64 %rva11054)                 ; tail call
  ret void

else29672:
 %vptr29686 = alloca i64, align 8 
  %retprim7337 = call i64 @prim_null_63(i64 %K28$lst) 
  store volatile i64 %retprim7337, i64* %vptr29686, align 8 ; call prim_null_63
 %vptr29687 = alloca i64, align 8 
  %arg8520 = add i64 0, 0 
  store volatile i64 %arg8520, i64* %vptr29687, align 8 ; quoted ()
 %vptr29688 = alloca i64, align 8 
  %rva11059 = add i64 0, 0 
  store volatile i64 %rva11059, i64* %vptr29688, align 8 ; quoted ()
 %vptr29689 = alloca i64, align 8 
  %rva11058 = call i64 @prim_cons(i64 %retprim7337, i64 %rva11059) 
  store volatile i64 %rva11058, i64* %vptr29689, align 8 ; call prim_cons
 %vptr29690 = alloca i64, align 8 
  %rva11057 = call i64 @prim_cons(i64 %arg8520, i64 %rva11058) 
  store volatile i64 %rva11057, i64* %vptr29690, align 8 ; call prim_cons
  %vptr29696 = alloca i64*, align 8 
  %cloptr29691 = inttoptr i64 %cont7336 to i64* 
  store volatile i64* %cloptr29691, i64** %vptr29696, align 8 ; closure/env cast; i64 -> i64*
  %vptr29697 = alloca i64*, align 8 
  %i0ptr29692 = getelementptr inbounds i64, i64* %cloptr29691, i64 1 
  store volatile i64* %i0ptr29692, i64** %vptr29697, align 8 ; &cloptr29691[1]
 %vptr29698 = alloca i64, align 8 
  %f29694 = load i64, i64* %i0ptr29692, align 8 
  store volatile i64 %f29694, i64* %vptr29698, align 8 ; load; *i0ptr29692
  %fptr29693 = inttoptr i64 %f29694 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29693(i64 %cont7336, i64 %rva11057)                 ; tail call
  ret void

else29668:
 %vptr29699 = alloca i64, align 8 
  %h11062 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11062, i64* %vptr29699, align 8 ; call prim_halt
  %vptr29705 = alloca i64*, align 8 
  %cloptr29700 = inttoptr i64 %h11062 to i64* 
  store volatile i64* %cloptr29700, i64** %vptr29705, align 8 ; closure/env cast; i64 -> i64*
  %vptr29706 = alloca i64*, align 8 
  %i0ptr29701 = getelementptr inbounds i64, i64* %cloptr29700, i64 1 
  store volatile i64* %i0ptr29701, i64** %vptr29706, align 8 ; &cloptr29700[1]
 %vptr29707 = alloca i64, align 8 
  %f29703 = load i64, i64* %i0ptr29701, align 8 
  store volatile i64 %f29703, i64* %vptr29707, align 8 ; load; *i0ptr29701
  %fptr29702 = inttoptr i64 %f29703 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29702(i64 %h11062, i64 %h11062)                     ; tail call
  ret void
}


define void @lam11583(i64 %env11584, i64 %rvp11170) {
 %vptr29710 = alloca i64, align 8 
  %envptr29708 = inttoptr i64 %env11584 to i64* 
  store volatile i64 %emsg08636, i64* %vptr29710, align 8 ; closure/env cast; i64 -> i64*
  %vptr29711 = alloca i64*, align 8 
  %envptr29709 = getelementptr inbounds i64, i64* %envptr29708, i64 3 
  store volatile i64* %envptr29709, i64** %vptr29711, align 8 ; &envptr29708[2]
 %vptr29712 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr29709, align 8 
  store volatile i64 %emsg08636, i64* %vptr29712, align 8 ; load; *envptr29709
 %vptr29715 = alloca i64, align 8 
  %envptr29713 = inttoptr i64 %env11584 to i64* 
  store volatile i64 %emsg18637, i64* %vptr29715, align 8 ; closure/env cast; i64 -> i64*
  %vptr29716 = alloca i64*, align 8 
  %envptr29714 = getelementptr inbounds i64, i64* %envptr29713, i64 2 
  store volatile i64* %envptr29714, i64** %vptr29716, align 8 ; &envptr29713[1]
 %vptr29717 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr29714, align 8 
  store volatile i64 %emsg18637, i64* %vptr29717, align 8 ; load; *envptr29714
 %vptr29718 = alloca i64, align 8 
  %cont7340 = call i64 @prim_car(i64 %rvp11170) 
  store volatile i64 %cont7340, i64* %vptr29718, align 8 ; call prim_car
 %vptr29719 = alloca i64, align 8 
  %rvp11166 = call i64 @prim_cdr(i64 %rvp11170) 
  store volatile i64 %rvp11166, i64* %vptr29719, align 8 ; call prim_cdr
 %vptr29720 = alloca i64, align 8 
  %n_6311171 = call i64 @prim_null_63(i64 %rvp11166) 
  store volatile i64 %n_6311171, i64* %vptr29720, align 8 ; call prim_null_63
  %cmpptr29724 = alloca i1, align 8  %cmp29721 = icmp eq i64 %n_6311171, 15 store volatile i1 %cmp29721, i1* %cmpptr29724, align 8; false?
  br i1 %cmp29721, label %else29723, label %then29722                                ; if

then29722:
 %vptr29725 = alloca i64, align 8 
  %h11172 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11172, i64* %vptr29725, align 8 ; call prim_halt
  %vptr29731 = alloca i64*, align 8 
  %cloptr29726 = inttoptr i64 %h11172 to i64* 
  store volatile i64* %cloptr29726, i64** %vptr29731, align 8 ; closure/env cast; i64 -> i64*
  %vptr29732 = alloca i64*, align 8 
  %i0ptr29727 = getelementptr inbounds i64, i64* %cloptr29726, i64 1 
  store volatile i64* %i0ptr29727, i64** %vptr29732, align 8 ; &cloptr29726[1]
 %vptr29733 = alloca i64, align 8 
  %f29729 = load i64, i64* %i0ptr29727, align 8 
  store volatile i64 %f29729, i64* %vptr29733, align 8 ; load; *i0ptr29727
  %fptr29728 = inttoptr i64 %f29729 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29728(i64 %h11172, i64 %h11172)                     ; tail call
  ret void

else29723:
 %vptr29734 = alloca i64, align 8 
  %IUE$_37foldl1 = call i64 @prim_car(i64 %rvp11166) 
  store volatile i64 %IUE$_37foldl1, i64* %vptr29734, align 8 ; call prim_car
 %vptr29735 = alloca i64, align 8 
  %na11122 = call i64 @prim_cdr(i64 %rvp11166) 
  store volatile i64 %na11122, i64* %vptr29735, align 8 ; call prim_cdr
 %vptr29736 = alloca i64, align 8 
  %n_6311167 = call i64 @prim_null_63(i64 %na11122) 
  store volatile i64 %n_6311167, i64* %vptr29736, align 8 ; call prim_null_63
  %cmpptr29740 = alloca i1, align 8  %cmp29737 = icmp eq i64 %n_6311167, 15 store volatile i1 %cmp29737, i1* %cmpptr29740, align 8; false?
  br i1 %cmp29737, label %else29739, label %then29738                                ; if

then29738:
 %vptr29741 = alloca i64, align 8 
  %arg8523 = add i64 0, 0 
  store volatile i64 %arg8523, i64* %vptr29741, align 8 ; quoted ()
  %vptr29748 = alloca i64*, align 8 
  %cloptr29742 = call i64* @make_closure(i64 32) 
  store volatile i64* %cloptr29742, i64** %vptr29748, align 8 ; malloc
  %vptr29749 = alloca i64*, align 8 
  %eptr29744 = getelementptr inbounds i64, i64* %cloptr29742, i64 2 
  store volatile i64* %eptr29744, i64** %vptr29749, align 8 ; &eptr29744[1]
  %vptr29750 = alloca i64*, align 8 
  %eptr29745 = getelementptr inbounds i64, i64* %cloptr29742, i64 3 
  store volatile i64* %eptr29745, i64** %vptr29750, align 8 ; &eptr29745[2]
  %vptr29751 = alloca i64*, align 8 
  %eptr29746 = getelementptr inbounds i64, i64* %cloptr29742, i64 4 
  store volatile i64* %eptr29746, i64** %vptr29751, align 8 ; &eptr29746[3]
  store i64 %emsg18637, i64* %eptr29744                                              ; *eptr29744 = %emsg18637
  store i64 %emsg08636, i64* %eptr29745                                              ; *eptr29745 = %emsg08636
  store i64 %IUE$_37foldl1, i64* %eptr29746                                          ; *eptr29746 = %IUE$_37foldl1
  %vptr29752 = alloca i64*, align 8 
  %eptr29743 = getelementptr inbounds i64, i64* %cloptr29742, i64 1 
  store volatile i64* %eptr29743, i64** %vptr29752, align 8 ; &cloptr29742[1]
 %vptr29753 = alloca i64, align 8 
  %f29747 = ptrtoint void(i64,i64)* @lam11580 to i64 
  store volatile i64 %f29747, i64* %vptr29753, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f29747, i64* %eptr29743                                                 ; store fptr
 %vptr29754 = alloca i64, align 8 
  %arg8522 = ptrtoint i64* %cloptr29742 to i64 
  store volatile i64 %arg8522, i64* %vptr29754, align 8 ; closure cast; i64* -> i64
 %vptr29755 = alloca i64, align 8 
  %rva11165 = add i64 0, 0 
  store volatile i64 %rva11165, i64* %vptr29755, align 8 ; quoted ()
 %vptr29756 = alloca i64, align 8 
  %rva11164 = call i64 @prim_cons(i64 %arg8522, i64 %rva11165) 
  store volatile i64 %rva11164, i64* %vptr29756, align 8 ; call prim_cons
 %vptr29757 = alloca i64, align 8 
  %rva11163 = call i64 @prim_cons(i64 %arg8523, i64 %rva11164) 
  store volatile i64 %rva11163, i64* %vptr29757, align 8 ; call prim_cons
  %vptr29763 = alloca i64*, align 8 
  %cloptr29758 = inttoptr i64 %cont7340 to i64* 
  store volatile i64* %cloptr29758, i64** %vptr29763, align 8 ; closure/env cast; i64 -> i64*
  %vptr29764 = alloca i64*, align 8 
  %i0ptr29759 = getelementptr inbounds i64, i64* %cloptr29758, i64 1 
  store volatile i64* %i0ptr29759, i64** %vptr29764, align 8 ; &cloptr29758[1]
 %vptr29765 = alloca i64, align 8 
  %f29761 = load i64, i64* %i0ptr29759, align 8 
  store volatile i64 %f29761, i64* %vptr29765, align 8 ; load; *i0ptr29759
  %fptr29760 = inttoptr i64 %f29761 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29760(i64 %cont7340, i64 %rva11163)                 ; tail call
  ret void

else29739:
 %vptr29766 = alloca i64, align 8 
  %h11168 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11168, i64* %vptr29766, align 8 ; call prim_halt
  %vptr29772 = alloca i64*, align 8 
  %cloptr29767 = inttoptr i64 %h11168 to i64* 
  store volatile i64* %cloptr29767, i64** %vptr29772, align 8 ; closure/env cast; i64 -> i64*
  %vptr29773 = alloca i64*, align 8 
  %i0ptr29768 = getelementptr inbounds i64, i64* %cloptr29767, i64 1 
  store volatile i64* %i0ptr29768, i64** %vptr29773, align 8 ; &cloptr29767[1]
 %vptr29774 = alloca i64, align 8 
  %f29770 = load i64, i64* %i0ptr29768, align 8 
  store volatile i64 %f29770, i64* %vptr29774, align 8 ; load; *i0ptr29768
  %fptr29769 = inttoptr i64 %f29770 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29769(i64 %h11168, i64 %h11168)                     ; tail call
  ret void
}


define void @lam11580(i64 %env11581, i64 %rvp11159) {
 %vptr29777 = alloca i64, align 8 
  %envptr29775 = inttoptr i64 %env11581 to i64* 
  store volatile i64 %IUE$_37foldl1, i64* %vptr29777, align 8 ; closure/env cast; i64 -> i64*
  %vptr29778 = alloca i64*, align 8 
  %envptr29776 = getelementptr inbounds i64, i64* %envptr29775, i64 4 
  store volatile i64* %envptr29776, i64** %vptr29778, align 8 ; &envptr29775[3]
 %vptr29779 = alloca i64, align 8 
  %IUE$_37foldl1 = load i64, i64* %envptr29776, align 8 
  store volatile i64 %IUE$_37foldl1, i64* %vptr29779, align 8 ; load; *envptr29776
 %vptr29782 = alloca i64, align 8 
  %envptr29780 = inttoptr i64 %env11581 to i64* 
  store volatile i64 %emsg08636, i64* %vptr29782, align 8 ; closure/env cast; i64 -> i64*
  %vptr29783 = alloca i64*, align 8 
  %envptr29781 = getelementptr inbounds i64, i64* %envptr29780, i64 3 
  store volatile i64* %envptr29781, i64** %vptr29783, align 8 ; &envptr29780[2]
 %vptr29784 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr29781, align 8 
  store volatile i64 %emsg08636, i64* %vptr29784, align 8 ; load; *envptr29781
 %vptr29787 = alloca i64, align 8 
  %envptr29785 = inttoptr i64 %env11581 to i64* 
  store volatile i64 %emsg18637, i64* %vptr29787, align 8 ; closure/env cast; i64 -> i64*
  %vptr29788 = alloca i64*, align 8 
  %envptr29786 = getelementptr inbounds i64, i64* %envptr29785, i64 2 
  store volatile i64* %envptr29786, i64** %vptr29788, align 8 ; &envptr29785[1]
 %vptr29789 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr29786, align 8 
  store volatile i64 %emsg18637, i64* %vptr29789, align 8 ; load; *envptr29786
 %vptr29790 = alloca i64, align 8 
  %cont7341 = call i64 @prim_car(i64 %rvp11159) 
  store volatile i64 %cont7341, i64* %vptr29790, align 8 ; call prim_car
 %vptr29791 = alloca i64, align 8 
  %rvp11155 = call i64 @prim_cdr(i64 %rvp11159) 
  store volatile i64 %rvp11155, i64* %vptr29791, align 8 ; call prim_cdr
 %vptr29792 = alloca i64, align 8 
  %n_6311160 = call i64 @prim_null_63(i64 %rvp11155) 
  store volatile i64 %n_6311160, i64* %vptr29792, align 8 ; call prim_null_63
  %cmpptr29796 = alloca i1, align 8  %cmp29793 = icmp eq i64 %n_6311160, 15 store volatile i1 %cmp29793, i1* %cmpptr29796, align 8; false?
  br i1 %cmp29793, label %else29795, label %then29794                                ; if

then29794:
 %vptr29797 = alloca i64, align 8 
  %h11161 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11161, i64* %vptr29797, align 8 ; call prim_halt
  %vptr29803 = alloca i64*, align 8 
  %cloptr29798 = inttoptr i64 %h11161 to i64* 
  store volatile i64* %cloptr29798, i64** %vptr29803, align 8 ; closure/env cast; i64 -> i64*
  %vptr29804 = alloca i64*, align 8 
  %i0ptr29799 = getelementptr inbounds i64, i64* %cloptr29798, i64 1 
  store volatile i64* %i0ptr29799, i64** %vptr29804, align 8 ; &cloptr29798[1]
 %vptr29805 = alloca i64, align 8 
  %f29801 = load i64, i64* %i0ptr29799, align 8 
  store volatile i64 %f29801, i64* %vptr29805, align 8 ; load; *i0ptr29799
  %fptr29800 = inttoptr i64 %f29801 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29800(i64 %h11161, i64 %h11161)                     ; tail call
  ret void

else29795:
 %vptr29806 = alloca i64, align 8 
  %dSO$f = call i64 @prim_car(i64 %rvp11155) 
  store volatile i64 %dSO$f, i64* %vptr29806, align 8 ; call prim_car
 %vptr29807 = alloca i64, align 8 
  %rvp11151 = call i64 @prim_cdr(i64 %rvp11155) 
  store volatile i64 %rvp11151, i64* %vptr29807, align 8 ; call prim_cdr
 %vptr29808 = alloca i64, align 8 
  %n_6311156 = call i64 @prim_null_63(i64 %rvp11151) 
  store volatile i64 %n_6311156, i64* %vptr29808, align 8 ; call prim_null_63
  %cmpptr29812 = alloca i1, align 8  %cmp29809 = icmp eq i64 %n_6311156, 15 store volatile i1 %cmp29809, i1* %cmpptr29812, align 8; false?
  br i1 %cmp29809, label %else29811, label %then29810                                ; if

then29810:
 %vptr29813 = alloca i64, align 8 
  %h11157 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11157, i64* %vptr29813, align 8 ; call prim_halt
  %vptr29819 = alloca i64*, align 8 
  %cloptr29814 = inttoptr i64 %h11157 to i64* 
  store volatile i64* %cloptr29814, i64** %vptr29819, align 8 ; closure/env cast; i64 -> i64*
  %vptr29820 = alloca i64*, align 8 
  %i0ptr29815 = getelementptr inbounds i64, i64* %cloptr29814, i64 1 
  store volatile i64* %i0ptr29815, i64** %vptr29820, align 8 ; &cloptr29814[1]
 %vptr29821 = alloca i64, align 8 
  %f29817 = load i64, i64* %i0ptr29815, align 8 
  store volatile i64 %f29817, i64* %vptr29821, align 8 ; load; *i0ptr29815
  %fptr29816 = inttoptr i64 %f29817 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29816(i64 %h11157, i64 %h11157)                     ; tail call
  ret void

else29811:
 %vptr29822 = alloca i64, align 8 
  %cbg$acc = call i64 @prim_car(i64 %rvp11151) 
  store volatile i64 %cbg$acc, i64* %vptr29822, align 8 ; call prim_car
 %vptr29823 = alloca i64, align 8 
  %rvp11147 = call i64 @prim_cdr(i64 %rvp11151) 
  store volatile i64 %rvp11147, i64* %vptr29823, align 8 ; call prim_cdr
 %vptr29824 = alloca i64, align 8 
  %n_6311152 = call i64 @prim_null_63(i64 %rvp11147) 
  store volatile i64 %n_6311152, i64* %vptr29824, align 8 ; call prim_null_63
  %cmpptr29828 = alloca i1, align 8  %cmp29825 = icmp eq i64 %n_6311152, 15 store volatile i1 %cmp29825, i1* %cmpptr29828, align 8; false?
  br i1 %cmp29825, label %else29827, label %then29826                                ; if

then29826:
 %vptr29829 = alloca i64, align 8 
  %h11153 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11153, i64* %vptr29829, align 8 ; call prim_halt
  %vptr29835 = alloca i64*, align 8 
  %cloptr29830 = inttoptr i64 %h11153 to i64* 
  store volatile i64* %cloptr29830, i64** %vptr29835, align 8 ; closure/env cast; i64 -> i64*
  %vptr29836 = alloca i64*, align 8 
  %i0ptr29831 = getelementptr inbounds i64, i64* %cloptr29830, i64 1 
  store volatile i64* %i0ptr29831, i64** %vptr29836, align 8 ; &cloptr29830[1]
 %vptr29837 = alloca i64, align 8 
  %f29833 = load i64, i64* %i0ptr29831, align 8 
  store volatile i64 %f29833, i64* %vptr29837, align 8 ; load; *i0ptr29831
  %fptr29832 = inttoptr i64 %f29833 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29832(i64 %h11153, i64 %h11153)                     ; tail call
  ret void

else29827:
 %vptr29838 = alloca i64, align 8 
  %szu$lst = call i64 @prim_car(i64 %rvp11147) 
  store volatile i64 %szu$lst, i64* %vptr29838, align 8 ; call prim_car
 %vptr29839 = alloca i64, align 8 
  %na11124 = call i64 @prim_cdr(i64 %rvp11147) 
  store volatile i64 %na11124, i64* %vptr29839, align 8 ; call prim_cdr
 %vptr29840 = alloca i64, align 8 
  %n_6311148 = call i64 @prim_null_63(i64 %na11124) 
  store volatile i64 %n_6311148, i64* %vptr29840, align 8 ; call prim_null_63
  %cmpptr29844 = alloca i1, align 8  %cmp29841 = icmp eq i64 %n_6311148, 15 store volatile i1 %cmp29841, i1* %cmpptr29844, align 8; false?
  br i1 %cmp29841, label %else29843, label %then29842                                ; if

then29842:
 %vptr29845 = alloca i64, align 8 
  %a6927 = call i64 @prim_null_63(i64 %szu$lst) 
  store volatile i64 %a6927, i64* %vptr29845, align 8 ; call prim_null_63
  %cmpptr29849 = alloca i1, align 8  %cmp29846 = icmp eq i64 %a6927, 15 store volatile i1 %cmp29846, i1* %cmpptr29849, align 8; false?
  br i1 %cmp29846, label %else29848, label %then29847                                ; if

then29847:
 %vptr29850 = alloca i64, align 8 
  %arg8527 = add i64 0, 0 
  store volatile i64 %arg8527, i64* %vptr29850, align 8 ; quoted ()
 %vptr29851 = alloca i64, align 8 
  %rva11127 = add i64 0, 0 
  store volatile i64 %rva11127, i64* %vptr29851, align 8 ; quoted ()
 %vptr29852 = alloca i64, align 8 
  %rva11126 = call i64 @prim_cons(i64 %cbg$acc, i64 %rva11127) 
  store volatile i64 %rva11126, i64* %vptr29852, align 8 ; call prim_cons
 %vptr29853 = alloca i64, align 8 
  %rva11125 = call i64 @prim_cons(i64 %arg8527, i64 %rva11126) 
  store volatile i64 %rva11125, i64* %vptr29853, align 8 ; call prim_cons
  %vptr29859 = alloca i64*, align 8 
  %cloptr29854 = inttoptr i64 %cont7341 to i64* 
  store volatile i64* %cloptr29854, i64** %vptr29859, align 8 ; closure/env cast; i64 -> i64*
  %vptr29860 = alloca i64*, align 8 
  %i0ptr29855 = getelementptr inbounds i64, i64* %cloptr29854, i64 1 
  store volatile i64* %i0ptr29855, i64** %vptr29860, align 8 ; &cloptr29854[1]
 %vptr29861 = alloca i64, align 8 
  %f29857 = load i64, i64* %i0ptr29855, align 8 
  store volatile i64 %f29857, i64* %vptr29861, align 8 ; load; *i0ptr29855
  %fptr29856 = inttoptr i64 %f29857 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29856(i64 %cont7341, i64 %rva11125)                 ; tail call
  ret void

else29848:
 %vptr29862 = alloca i64, align 8 
  %a6928 = call i64 @prim_car(i64 %szu$lst) 
  store volatile i64 %a6928, i64* %vptr29862, align 8 ; call prim_car
  %vptr29872 = alloca i64*, align 8 
  %cloptr29863 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr29863, i64** %vptr29872, align 8 ; malloc
  %vptr29873 = alloca i64*, align 8 
  %eptr29865 = getelementptr inbounds i64, i64* %cloptr29863, i64 2 
  store volatile i64* %eptr29865, i64** %vptr29873, align 8 ; &eptr29865[1]
  %vptr29874 = alloca i64*, align 8 
  %eptr29866 = getelementptr inbounds i64, i64* %cloptr29863, i64 3 
  store volatile i64* %eptr29866, i64** %vptr29874, align 8 ; &eptr29866[2]
  %vptr29875 = alloca i64*, align 8 
  %eptr29867 = getelementptr inbounds i64, i64* %cloptr29863, i64 4 
  store volatile i64* %eptr29867, i64** %vptr29875, align 8 ; &eptr29867[3]
  %vptr29876 = alloca i64*, align 8 
  %eptr29868 = getelementptr inbounds i64, i64* %cloptr29863, i64 5 
  store volatile i64* %eptr29868, i64** %vptr29876, align 8 ; &eptr29868[4]
  %vptr29877 = alloca i64*, align 8 
  %eptr29869 = getelementptr inbounds i64, i64* %cloptr29863, i64 6 
  store volatile i64* %eptr29869, i64** %vptr29877, align 8 ; &eptr29869[5]
  %vptr29878 = alloca i64*, align 8 
  %eptr29870 = getelementptr inbounds i64, i64* %cloptr29863, i64 7 
  store volatile i64* %eptr29870, i64** %vptr29878, align 8 ; &eptr29870[6]
  store i64 %emsg18637, i64* %eptr29865                                              ; *eptr29865 = %emsg18637
  store i64 %dSO$f, i64* %eptr29866                                                  ; *eptr29866 = %dSO$f
  store i64 %szu$lst, i64* %eptr29867                                                ; *eptr29867 = %szu$lst
  store i64 %emsg08636, i64* %eptr29868                                              ; *eptr29868 = %emsg08636
  store i64 %IUE$_37foldl1, i64* %eptr29869                                          ; *eptr29869 = %IUE$_37foldl1
  store i64 %cont7341, i64* %eptr29870                                               ; *eptr29870 = %cont7341
  %vptr29879 = alloca i64*, align 8 
  %eptr29864 = getelementptr inbounds i64, i64* %cloptr29863, i64 1 
  store volatile i64* %eptr29864, i64** %vptr29879, align 8 ; &cloptr29863[1]
 %vptr29880 = alloca i64, align 8 
  %f29871 = ptrtoint void(i64,i64)* @lam11578 to i64 
  store volatile i64 %f29871, i64* %vptr29880, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f29871, i64* %eptr29864                                                 ; store fptr
 %vptr29881 = alloca i64, align 8 
  %arg8532 = ptrtoint i64* %cloptr29863 to i64 
  store volatile i64 %arg8532, i64* %vptr29881, align 8 ; closure cast; i64* -> i64
 %vptr29882 = alloca i64, align 8 
  %rva11146 = add i64 0, 0 
  store volatile i64 %rva11146, i64* %vptr29882, align 8 ; quoted ()
 %vptr29883 = alloca i64, align 8 
  %rva11145 = call i64 @prim_cons(i64 %cbg$acc, i64 %rva11146) 
  store volatile i64 %rva11145, i64* %vptr29883, align 8 ; call prim_cons
 %vptr29884 = alloca i64, align 8 
  %rva11144 = call i64 @prim_cons(i64 %a6928, i64 %rva11145) 
  store volatile i64 %rva11144, i64* %vptr29884, align 8 ; call prim_cons
 %vptr29885 = alloca i64, align 8 
  %rva11143 = call i64 @prim_cons(i64 %arg8532, i64 %rva11144) 
  store volatile i64 %rva11143, i64* %vptr29885, align 8 ; call prim_cons
  %vptr29891 = alloca i64*, align 8 
  %cloptr29886 = inttoptr i64 %dSO$f to i64* 
  store volatile i64* %cloptr29886, i64** %vptr29891, align 8 ; closure/env cast; i64 -> i64*
  %vptr29892 = alloca i64*, align 8 
  %i0ptr29887 = getelementptr inbounds i64, i64* %cloptr29886, i64 1 
  store volatile i64* %i0ptr29887, i64** %vptr29892, align 8 ; &cloptr29886[1]
 %vptr29893 = alloca i64, align 8 
  %f29889 = load i64, i64* %i0ptr29887, align 8 
  store volatile i64 %f29889, i64* %vptr29893, align 8 ; load; *i0ptr29887
  %fptr29888 = inttoptr i64 %f29889 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29888(i64 %dSO$f, i64 %rva11143)                    ; tail call
  ret void

else29843:
 %vptr29894 = alloca i64, align 8 
  %h11149 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11149, i64* %vptr29894, align 8 ; call prim_halt
  %vptr29900 = alloca i64*, align 8 
  %cloptr29895 = inttoptr i64 %h11149 to i64* 
  store volatile i64* %cloptr29895, i64** %vptr29900, align 8 ; closure/env cast; i64 -> i64*
  %vptr29901 = alloca i64*, align 8 
  %i0ptr29896 = getelementptr inbounds i64, i64* %cloptr29895, i64 1 
  store volatile i64* %i0ptr29896, i64** %vptr29901, align 8 ; &cloptr29895[1]
 %vptr29902 = alloca i64, align 8 
  %f29898 = load i64, i64* %i0ptr29896, align 8 
  store volatile i64 %f29898, i64* %vptr29902, align 8 ; load; *i0ptr29896
  %fptr29897 = inttoptr i64 %f29898 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29897(i64 %h11149, i64 %h11149)                     ; tail call
  ret void
}


define void @lam11578(i64 %env11579, i64 %rvp11139) {
 %vptr29905 = alloca i64, align 8 
  %envptr29903 = inttoptr i64 %env11579 to i64* 
  store volatile i64 %cont7341, i64* %vptr29905, align 8 ; closure/env cast; i64 -> i64*
  %vptr29906 = alloca i64*, align 8 
  %envptr29904 = getelementptr inbounds i64, i64* %envptr29903, i64 7 
  store volatile i64* %envptr29904, i64** %vptr29906, align 8 ; &envptr29903[6]
 %vptr29907 = alloca i64, align 8 
  %cont7341 = load i64, i64* %envptr29904, align 8 
  store volatile i64 %cont7341, i64* %vptr29907, align 8 ; load; *envptr29904
 %vptr29910 = alloca i64, align 8 
  %envptr29908 = inttoptr i64 %env11579 to i64* 
  store volatile i64 %IUE$_37foldl1, i64* %vptr29910, align 8 ; closure/env cast; i64 -> i64*
  %vptr29911 = alloca i64*, align 8 
  %envptr29909 = getelementptr inbounds i64, i64* %envptr29908, i64 6 
  store volatile i64* %envptr29909, i64** %vptr29911, align 8 ; &envptr29908[5]
 %vptr29912 = alloca i64, align 8 
  %IUE$_37foldl1 = load i64, i64* %envptr29909, align 8 
  store volatile i64 %IUE$_37foldl1, i64* %vptr29912, align 8 ; load; *envptr29909
 %vptr29915 = alloca i64, align 8 
  %envptr29913 = inttoptr i64 %env11579 to i64* 
  store volatile i64 %emsg08636, i64* %vptr29915, align 8 ; closure/env cast; i64 -> i64*
  %vptr29916 = alloca i64*, align 8 
  %envptr29914 = getelementptr inbounds i64, i64* %envptr29913, i64 5 
  store volatile i64* %envptr29914, i64** %vptr29916, align 8 ; &envptr29913[4]
 %vptr29917 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr29914, align 8 
  store volatile i64 %emsg08636, i64* %vptr29917, align 8 ; load; *envptr29914
 %vptr29920 = alloca i64, align 8 
  %envptr29918 = inttoptr i64 %env11579 to i64* 
  store volatile i64 %szu$lst, i64* %vptr29920, align 8 ; closure/env cast; i64 -> i64*
  %vptr29921 = alloca i64*, align 8 
  %envptr29919 = getelementptr inbounds i64, i64* %envptr29918, i64 4 
  store volatile i64* %envptr29919, i64** %vptr29921, align 8 ; &envptr29918[3]
 %vptr29922 = alloca i64, align 8 
  %szu$lst = load i64, i64* %envptr29919, align 8 
  store volatile i64 %szu$lst, i64* %vptr29922, align 8 ; load; *envptr29919
 %vptr29925 = alloca i64, align 8 
  %envptr29923 = inttoptr i64 %env11579 to i64* 
  store volatile i64 %dSO$f, i64* %vptr29925, align 8 ; closure/env cast; i64 -> i64*
  %vptr29926 = alloca i64*, align 8 
  %envptr29924 = getelementptr inbounds i64, i64* %envptr29923, i64 3 
  store volatile i64* %envptr29924, i64** %vptr29926, align 8 ; &envptr29923[2]
 %vptr29927 = alloca i64, align 8 
  %dSO$f = load i64, i64* %envptr29924, align 8 
  store volatile i64 %dSO$f, i64* %vptr29927, align 8 ; load; *envptr29924
 %vptr29930 = alloca i64, align 8 
  %envptr29928 = inttoptr i64 %env11579 to i64* 
  store volatile i64 %emsg18637, i64* %vptr29930, align 8 ; closure/env cast; i64 -> i64*
  %vptr29931 = alloca i64*, align 8 
  %envptr29929 = getelementptr inbounds i64, i64* %envptr29928, i64 2 
  store volatile i64* %envptr29929, i64** %vptr29931, align 8 ; &envptr29928[1]
 %vptr29932 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr29929, align 8 
  store volatile i64 %emsg18637, i64* %vptr29932, align 8 ; load; *envptr29929
 %vptr29933 = alloca i64, align 8 
  %_957342 = call i64 @prim_car(i64 %rvp11139) 
  store volatile i64 %_957342, i64* %vptr29933, align 8 ; call prim_car
 %vptr29934 = alloca i64, align 8 
  %rvp11135 = call i64 @prim_cdr(i64 %rvp11139) 
  store volatile i64 %rvp11135, i64* %vptr29934, align 8 ; call prim_cdr
 %vptr29935 = alloca i64, align 8 
  %n_6311140 = call i64 @prim_null_63(i64 %rvp11135) 
  store volatile i64 %n_6311140, i64* %vptr29935, align 8 ; call prim_null_63
  %cmpptr29939 = alloca i1, align 8  %cmp29936 = icmp eq i64 %n_6311140, 15 store volatile i1 %cmp29936, i1* %cmpptr29939, align 8; false?
  br i1 %cmp29936, label %else29938, label %then29937                                ; if

then29937:
 %vptr29940 = alloca i64, align 8 
  %h11141 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11141, i64* %vptr29940, align 8 ; call prim_halt
  %vptr29946 = alloca i64*, align 8 
  %cloptr29941 = inttoptr i64 %h11141 to i64* 
  store volatile i64* %cloptr29941, i64** %vptr29946, align 8 ; closure/env cast; i64 -> i64*
  %vptr29947 = alloca i64*, align 8 
  %i0ptr29942 = getelementptr inbounds i64, i64* %cloptr29941, i64 1 
  store volatile i64* %i0ptr29942, i64** %vptr29947, align 8 ; &cloptr29941[1]
 %vptr29948 = alloca i64, align 8 
  %f29944 = load i64, i64* %i0ptr29942, align 8 
  store volatile i64 %f29944, i64* %vptr29948, align 8 ; load; *i0ptr29942
  %fptr29943 = inttoptr i64 %f29944 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29943(i64 %h11141, i64 %h11141)                     ; tail call
  ret void

else29938:
 %vptr29949 = alloca i64, align 8 
  %a6929 = call i64 @prim_car(i64 %rvp11135) 
  store volatile i64 %a6929, i64* %vptr29949, align 8 ; call prim_car
 %vptr29950 = alloca i64, align 8 
  %na11129 = call i64 @prim_cdr(i64 %rvp11135) 
  store volatile i64 %na11129, i64* %vptr29950, align 8 ; call prim_cdr
 %vptr29951 = alloca i64, align 8 
  %n_6311136 = call i64 @prim_null_63(i64 %na11129) 
  store volatile i64 %n_6311136, i64* %vptr29951, align 8 ; call prim_null_63
  %cmpptr29955 = alloca i1, align 8  %cmp29952 = icmp eq i64 %n_6311136, 15 store volatile i1 %cmp29952, i1* %cmpptr29955, align 8; false?
  br i1 %cmp29952, label %else29954, label %then29953                                ; if

then29953:
 %vptr29956 = alloca i64, align 8 
  %a6930 = call i64 @prim_cdr(i64 %szu$lst) 
  store volatile i64 %a6930, i64* %vptr29956, align 8 ; call prim_cdr
 %vptr29957 = alloca i64, align 8 
  %rva11134 = add i64 0, 0 
  store volatile i64 %rva11134, i64* %vptr29957, align 8 ; quoted ()
 %vptr29958 = alloca i64, align 8 
  %rva11133 = call i64 @prim_cons(i64 %a6930, i64 %rva11134) 
  store volatile i64 %rva11133, i64* %vptr29958, align 8 ; call prim_cons
 %vptr29959 = alloca i64, align 8 
  %rva11132 = call i64 @prim_cons(i64 %a6929, i64 %rva11133) 
  store volatile i64 %rva11132, i64* %vptr29959, align 8 ; call prim_cons
 %vptr29960 = alloca i64, align 8 
  %rva11131 = call i64 @prim_cons(i64 %dSO$f, i64 %rva11132) 
  store volatile i64 %rva11131, i64* %vptr29960, align 8 ; call prim_cons
 %vptr29961 = alloca i64, align 8 
  %rva11130 = call i64 @prim_cons(i64 %cont7341, i64 %rva11131) 
  store volatile i64 %rva11130, i64* %vptr29961, align 8 ; call prim_cons
  %vptr29967 = alloca i64*, align 8 
  %cloptr29962 = inttoptr i64 %IUE$_37foldl1 to i64* 
  store volatile i64* %cloptr29962, i64** %vptr29967, align 8 ; closure/env cast; i64 -> i64*
  %vptr29968 = alloca i64*, align 8 
  %i0ptr29963 = getelementptr inbounds i64, i64* %cloptr29962, i64 1 
  store volatile i64* %i0ptr29963, i64** %vptr29968, align 8 ; &cloptr29962[1]
 %vptr29969 = alloca i64, align 8 
  %f29965 = load i64, i64* %i0ptr29963, align 8 
  store volatile i64 %f29965, i64* %vptr29969, align 8 ; load; *i0ptr29963
  %fptr29964 = inttoptr i64 %f29965 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29964(i64 %IUE$_37foldl1, i64 %rva11130)            ; tail call
  ret void

else29954:
 %vptr29970 = alloca i64, align 8 
  %h11137 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11137, i64* %vptr29970, align 8 ; call prim_halt
  %vptr29976 = alloca i64*, align 8 
  %cloptr29971 = inttoptr i64 %h11137 to i64* 
  store volatile i64* %cloptr29971, i64** %vptr29976, align 8 ; closure/env cast; i64 -> i64*
  %vptr29977 = alloca i64*, align 8 
  %i0ptr29972 = getelementptr inbounds i64, i64* %cloptr29971, i64 1 
  store volatile i64* %i0ptr29972, i64** %vptr29977, align 8 ; &cloptr29971[1]
 %vptr29978 = alloca i64, align 8 
  %f29974 = load i64, i64* %i0ptr29972, align 8 
  store volatile i64 %f29974, i64* %vptr29978, align 8 ; load; *i0ptr29972
  %fptr29973 = inttoptr i64 %f29974 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29973(i64 %h11137, i64 %h11137)                     ; tail call
  ret void
}


define void @lam11570(i64 %env11571, i64 %rvp11223) {
 %vptr29981 = alloca i64, align 8 
  %envptr29979 = inttoptr i64 %env11571 to i64* 
  store volatile i64 %emsg08636, i64* %vptr29981, align 8 ; closure/env cast; i64 -> i64*
  %vptr29982 = alloca i64*, align 8 
  %envptr29980 = getelementptr inbounds i64, i64* %envptr29979, i64 3 
  store volatile i64* %envptr29980, i64** %vptr29982, align 8 ; &envptr29979[2]
 %vptr29983 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr29980, align 8 
  store volatile i64 %emsg08636, i64* %vptr29983, align 8 ; load; *envptr29980
 %vptr29986 = alloca i64, align 8 
  %envptr29984 = inttoptr i64 %env11571 to i64* 
  store volatile i64 %emsg18637, i64* %vptr29986, align 8 ; closure/env cast; i64 -> i64*
  %vptr29987 = alloca i64*, align 8 
  %envptr29985 = getelementptr inbounds i64, i64* %envptr29984, i64 2 
  store volatile i64* %envptr29985, i64** %vptr29987, align 8 ; &envptr29984[1]
 %vptr29988 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr29985, align 8 
  store volatile i64 %emsg18637, i64* %vptr29988, align 8 ; load; *envptr29985
 %vptr29989 = alloca i64, align 8 
  %cont7343 = call i64 @prim_car(i64 %rvp11223) 
  store volatile i64 %cont7343, i64* %vptr29989, align 8 ; call prim_car
 %vptr29990 = alloca i64, align 8 
  %rvp11219 = call i64 @prim_cdr(i64 %rvp11223) 
  store volatile i64 %rvp11219, i64* %vptr29990, align 8 ; call prim_cdr
 %vptr29991 = alloca i64, align 8 
  %n_6311224 = call i64 @prim_null_63(i64 %rvp11219) 
  store volatile i64 %n_6311224, i64* %vptr29991, align 8 ; call prim_null_63
  %cmpptr29995 = alloca i1, align 8  %cmp29992 = icmp eq i64 %n_6311224, 15 store volatile i1 %cmp29992, i1* %cmpptr29995, align 8; false?
  br i1 %cmp29992, label %else29994, label %then29993                                ; if

then29993:
 %vptr29996 = alloca i64, align 8 
  %h11225 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11225, i64* %vptr29996, align 8 ; call prim_halt
  %vptr30002 = alloca i64*, align 8 
  %cloptr29997 = inttoptr i64 %h11225 to i64* 
  store volatile i64* %cloptr29997, i64** %vptr30002, align 8 ; closure/env cast; i64 -> i64*
  %vptr30003 = alloca i64*, align 8 
  %i0ptr29998 = getelementptr inbounds i64, i64* %cloptr29997, i64 1 
  store volatile i64* %i0ptr29998, i64** %vptr30003, align 8 ; &cloptr29997[1]
 %vptr30004 = alloca i64, align 8 
  %f30000 = load i64, i64* %i0ptr29998, align 8 
  store volatile i64 %f30000, i64* %vptr30004, align 8 ; load; *i0ptr29998
  %fptr29999 = inttoptr i64 %f30000 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr29999(i64 %h11225, i64 %h11225)                     ; tail call
  ret void

else29994:
 %vptr30005 = alloca i64, align 8 
  %Y8J$_37length = call i64 @prim_car(i64 %rvp11219) 
  store volatile i64 %Y8J$_37length, i64* %vptr30005, align 8 ; call prim_car
 %vptr30006 = alloca i64, align 8 
  %na11186 = call i64 @prim_cdr(i64 %rvp11219) 
  store volatile i64 %na11186, i64* %vptr30006, align 8 ; call prim_cdr
 %vptr30007 = alloca i64, align 8 
  %n_6311220 = call i64 @prim_null_63(i64 %na11186) 
  store volatile i64 %n_6311220, i64* %vptr30007, align 8 ; call prim_null_63
  %cmpptr30011 = alloca i1, align 8  %cmp30008 = icmp eq i64 %n_6311220, 15 store volatile i1 %cmp30008, i1* %cmpptr30011, align 8; false?
  br i1 %cmp30008, label %else30010, label %then30009                                ; if

then30009:
 %vptr30012 = alloca i64, align 8 
  %arg8541 = add i64 0, 0 
  store volatile i64 %arg8541, i64* %vptr30012, align 8 ; quoted ()
  %vptr30019 = alloca i64*, align 8 
  %cloptr30013 = call i64* @make_closure(i64 32) 
  store volatile i64* %cloptr30013, i64** %vptr30019, align 8 ; malloc
  %vptr30020 = alloca i64*, align 8 
  %eptr30015 = getelementptr inbounds i64, i64* %cloptr30013, i64 2 
  store volatile i64* %eptr30015, i64** %vptr30020, align 8 ; &eptr30015[1]
  %vptr30021 = alloca i64*, align 8 
  %eptr30016 = getelementptr inbounds i64, i64* %cloptr30013, i64 3 
  store volatile i64* %eptr30016, i64** %vptr30021, align 8 ; &eptr30016[2]
  %vptr30022 = alloca i64*, align 8 
  %eptr30017 = getelementptr inbounds i64, i64* %cloptr30013, i64 4 
  store volatile i64* %eptr30017, i64** %vptr30022, align 8 ; &eptr30017[3]
  store i64 %emsg18637, i64* %eptr30015                                              ; *eptr30015 = %emsg18637
  store i64 %Y8J$_37length, i64* %eptr30016                                          ; *eptr30016 = %Y8J$_37length
  store i64 %emsg08636, i64* %eptr30017                                              ; *eptr30017 = %emsg08636
  %vptr30023 = alloca i64*, align 8 
  %eptr30014 = getelementptr inbounds i64, i64* %cloptr30013, i64 1 
  store volatile i64* %eptr30014, i64** %vptr30023, align 8 ; &cloptr30013[1]
 %vptr30024 = alloca i64, align 8 
  %f30018 = ptrtoint void(i64,i64)* @lam11567 to i64 
  store volatile i64 %f30018, i64* %vptr30024, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f30018, i64* %eptr30014                                                 ; store fptr
 %vptr30025 = alloca i64, align 8 
  %arg8540 = ptrtoint i64* %cloptr30013 to i64 
  store volatile i64 %arg8540, i64* %vptr30025, align 8 ; closure cast; i64* -> i64
 %vptr30026 = alloca i64, align 8 
  %rva11218 = add i64 0, 0 
  store volatile i64 %rva11218, i64* %vptr30026, align 8 ; quoted ()
 %vptr30027 = alloca i64, align 8 
  %rva11217 = call i64 @prim_cons(i64 %arg8540, i64 %rva11218) 
  store volatile i64 %rva11217, i64* %vptr30027, align 8 ; call prim_cons
 %vptr30028 = alloca i64, align 8 
  %rva11216 = call i64 @prim_cons(i64 %arg8541, i64 %rva11217) 
  store volatile i64 %rva11216, i64* %vptr30028, align 8 ; call prim_cons
  %vptr30034 = alloca i64*, align 8 
  %cloptr30029 = inttoptr i64 %cont7343 to i64* 
  store volatile i64* %cloptr30029, i64** %vptr30034, align 8 ; closure/env cast; i64 -> i64*
  %vptr30035 = alloca i64*, align 8 
  %i0ptr30030 = getelementptr inbounds i64, i64* %cloptr30029, i64 1 
  store volatile i64* %i0ptr30030, i64** %vptr30035, align 8 ; &cloptr30029[1]
 %vptr30036 = alloca i64, align 8 
  %f30032 = load i64, i64* %i0ptr30030, align 8 
  store volatile i64 %f30032, i64* %vptr30036, align 8 ; load; *i0ptr30030
  %fptr30031 = inttoptr i64 %f30032 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30031(i64 %cont7343, i64 %rva11216)                 ; tail call
  ret void

else30010:
 %vptr30037 = alloca i64, align 8 
  %h11221 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11221, i64* %vptr30037, align 8 ; call prim_halt
  %vptr30043 = alloca i64*, align 8 
  %cloptr30038 = inttoptr i64 %h11221 to i64* 
  store volatile i64* %cloptr30038, i64** %vptr30043, align 8 ; closure/env cast; i64 -> i64*
  %vptr30044 = alloca i64*, align 8 
  %i0ptr30039 = getelementptr inbounds i64, i64* %cloptr30038, i64 1 
  store volatile i64* %i0ptr30039, i64** %vptr30044, align 8 ; &cloptr30038[1]
 %vptr30045 = alloca i64, align 8 
  %f30041 = load i64, i64* %i0ptr30039, align 8 
  store volatile i64 %f30041, i64* %vptr30045, align 8 ; load; *i0ptr30039
  %fptr30040 = inttoptr i64 %f30041 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30040(i64 %h11221, i64 %h11221)                     ; tail call
  ret void
}


define void @lam11567(i64 %env11568, i64 %rvp11212) {
 %vptr30048 = alloca i64, align 8 
  %envptr30046 = inttoptr i64 %env11568 to i64* 
  store volatile i64 %emsg08636, i64* %vptr30048, align 8 ; closure/env cast; i64 -> i64*
  %vptr30049 = alloca i64*, align 8 
  %envptr30047 = getelementptr inbounds i64, i64* %envptr30046, i64 4 
  store volatile i64* %envptr30047, i64** %vptr30049, align 8 ; &envptr30046[3]
 %vptr30050 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr30047, align 8 
  store volatile i64 %emsg08636, i64* %vptr30050, align 8 ; load; *envptr30047
 %vptr30053 = alloca i64, align 8 
  %envptr30051 = inttoptr i64 %env11568 to i64* 
  store volatile i64 %Y8J$_37length, i64* %vptr30053, align 8 ; closure/env cast; i64 -> i64*
  %vptr30054 = alloca i64*, align 8 
  %envptr30052 = getelementptr inbounds i64, i64* %envptr30051, i64 3 
  store volatile i64* %envptr30052, i64** %vptr30054, align 8 ; &envptr30051[2]
 %vptr30055 = alloca i64, align 8 
  %Y8J$_37length = load i64, i64* %envptr30052, align 8 
  store volatile i64 %Y8J$_37length, i64* %vptr30055, align 8 ; load; *envptr30052
 %vptr30058 = alloca i64, align 8 
  %envptr30056 = inttoptr i64 %env11568 to i64* 
  store volatile i64 %emsg18637, i64* %vptr30058, align 8 ; closure/env cast; i64 -> i64*
  %vptr30059 = alloca i64*, align 8 
  %envptr30057 = getelementptr inbounds i64, i64* %envptr30056, i64 2 
  store volatile i64* %envptr30057, i64** %vptr30059, align 8 ; &envptr30056[1]
 %vptr30060 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr30057, align 8 
  store volatile i64 %emsg18637, i64* %vptr30060, align 8 ; load; *envptr30057
 %vptr30061 = alloca i64, align 8 
  %cont7344 = call i64 @prim_car(i64 %rvp11212) 
  store volatile i64 %cont7344, i64* %vptr30061, align 8 ; call prim_car
 %vptr30062 = alloca i64, align 8 
  %rvp11208 = call i64 @prim_cdr(i64 %rvp11212) 
  store volatile i64 %rvp11208, i64* %vptr30062, align 8 ; call prim_cdr
 %vptr30063 = alloca i64, align 8 
  %n_6311213 = call i64 @prim_null_63(i64 %rvp11208) 
  store volatile i64 %n_6311213, i64* %vptr30063, align 8 ; call prim_null_63
  %cmpptr30067 = alloca i1, align 8  %cmp30064 = icmp eq i64 %n_6311213, 15 store volatile i1 %cmp30064, i1* %cmpptr30067, align 8; false?
  br i1 %cmp30064, label %else30066, label %then30065                                ; if

then30065:
 %vptr30068 = alloca i64, align 8 
  %h11214 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11214, i64* %vptr30068, align 8 ; call prim_halt
  %vptr30074 = alloca i64*, align 8 
  %cloptr30069 = inttoptr i64 %h11214 to i64* 
  store volatile i64* %cloptr30069, i64** %vptr30074, align 8 ; closure/env cast; i64 -> i64*
  %vptr30075 = alloca i64*, align 8 
  %i0ptr30070 = getelementptr inbounds i64, i64* %cloptr30069, i64 1 
  store volatile i64* %i0ptr30070, i64** %vptr30075, align 8 ; &cloptr30069[1]
 %vptr30076 = alloca i64, align 8 
  %f30072 = load i64, i64* %i0ptr30070, align 8 
  store volatile i64 %f30072, i64* %vptr30076, align 8 ; load; *i0ptr30070
  %fptr30071 = inttoptr i64 %f30072 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30071(i64 %h11214, i64 %h11214)                     ; tail call
  ret void

else30066:
 %vptr30077 = alloca i64, align 8 
  %E2J$lst = call i64 @prim_car(i64 %rvp11208) 
  store volatile i64 %E2J$lst, i64* %vptr30077, align 8 ; call prim_car
 %vptr30078 = alloca i64, align 8 
  %na11188 = call i64 @prim_cdr(i64 %rvp11208) 
  store volatile i64 %na11188, i64* %vptr30078, align 8 ; call prim_cdr
 %vptr30079 = alloca i64, align 8 
  %n_6311209 = call i64 @prim_null_63(i64 %na11188) 
  store volatile i64 %n_6311209, i64* %vptr30079, align 8 ; call prim_null_63
  %cmpptr30083 = alloca i1, align 8  %cmp30080 = icmp eq i64 %n_6311209, 15 store volatile i1 %cmp30080, i1* %cmpptr30083, align 8; false?
  br i1 %cmp30080, label %else30082, label %then30081                                ; if

then30081:
 %vptr30084 = alloca i64, align 8 
  %a6924 = call i64 @prim_null_63(i64 %E2J$lst) 
  store volatile i64 %a6924, i64* %vptr30084, align 8 ; call prim_null_63
  %cmpptr30088 = alloca i1, align 8  %cmp30085 = icmp eq i64 %a6924, 15 store volatile i1 %cmp30085, i1* %cmpptr30088, align 8; false?
  br i1 %cmp30085, label %else30087, label %then30086                                ; if

then30086:
 %vptr30089 = alloca i64, align 8 
  %arg8545 = add i64 0, 0 
  store volatile i64 %arg8545, i64* %vptr30089, align 8 ; quoted ()
 %vptr30090 = alloca i64, align 8 
  %arg8544 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8544, i64* %vptr30090, align 8 ; quoted int
 %vptr30091 = alloca i64, align 8 
  %rva11191 = add i64 0, 0 
  store volatile i64 %rva11191, i64* %vptr30091, align 8 ; quoted ()
 %vptr30092 = alloca i64, align 8 
  %rva11190 = call i64 @prim_cons(i64 %arg8544, i64 %rva11191) 
  store volatile i64 %rva11190, i64* %vptr30092, align 8 ; call prim_cons
 %vptr30093 = alloca i64, align 8 
  %rva11189 = call i64 @prim_cons(i64 %arg8545, i64 %rva11190) 
  store volatile i64 %rva11189, i64* %vptr30093, align 8 ; call prim_cons
  %vptr30099 = alloca i64*, align 8 
  %cloptr30094 = inttoptr i64 %cont7344 to i64* 
  store volatile i64* %cloptr30094, i64** %vptr30099, align 8 ; closure/env cast; i64 -> i64*
  %vptr30100 = alloca i64*, align 8 
  %i0ptr30095 = getelementptr inbounds i64, i64* %cloptr30094, i64 1 
  store volatile i64* %i0ptr30095, i64** %vptr30100, align 8 ; &cloptr30094[1]
 %vptr30101 = alloca i64, align 8 
  %f30097 = load i64, i64* %i0ptr30095, align 8 
  store volatile i64 %f30097, i64* %vptr30101, align 8 ; load; *i0ptr30095
  %fptr30096 = inttoptr i64 %f30097 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30096(i64 %cont7344, i64 %rva11189)                 ; tail call
  ret void

else30087:
 %vptr30102 = alloca i64, align 8 
  %a6925 = call i64 @prim_cdr(i64 %E2J$lst) 
  store volatile i64 %a6925, i64* %vptr30102, align 8 ; call prim_cdr
  %vptr30109 = alloca i64*, align 8 
  %cloptr30103 = call i64* @make_closure(i64 32) 
  store volatile i64* %cloptr30103, i64** %vptr30109, align 8 ; malloc
  %vptr30110 = alloca i64*, align 8 
  %eptr30105 = getelementptr inbounds i64, i64* %cloptr30103, i64 2 
  store volatile i64* %eptr30105, i64** %vptr30110, align 8 ; &eptr30105[1]
  %vptr30111 = alloca i64*, align 8 
  %eptr30106 = getelementptr inbounds i64, i64* %cloptr30103, i64 3 
  store volatile i64* %eptr30106, i64** %vptr30111, align 8 ; &eptr30106[2]
  %vptr30112 = alloca i64*, align 8 
  %eptr30107 = getelementptr inbounds i64, i64* %cloptr30103, i64 4 
  store volatile i64* %eptr30107, i64** %vptr30112, align 8 ; &eptr30107[3]
  store i64 %emsg18637, i64* %eptr30105                                              ; *eptr30105 = %emsg18637
  store i64 %cont7344, i64* %eptr30106                                               ; *eptr30106 = %cont7344
  store i64 %emsg08636, i64* %eptr30107                                              ; *eptr30107 = %emsg08636
  %vptr30113 = alloca i64*, align 8 
  %eptr30104 = getelementptr inbounds i64, i64* %cloptr30103, i64 1 
  store volatile i64* %eptr30104, i64** %vptr30113, align 8 ; &cloptr30103[1]
 %vptr30114 = alloca i64, align 8 
  %f30108 = ptrtoint void(i64,i64)* @lam11565 to i64 
  store volatile i64 %f30108, i64* %vptr30114, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f30108, i64* %eptr30104                                                 ; store fptr
 %vptr30115 = alloca i64, align 8 
  %arg8549 = ptrtoint i64* %cloptr30103 to i64 
  store volatile i64 %arg8549, i64* %vptr30115, align 8 ; closure cast; i64* -> i64
 %vptr30116 = alloca i64, align 8 
  %rva11207 = add i64 0, 0 
  store volatile i64 %rva11207, i64* %vptr30116, align 8 ; quoted ()
 %vptr30117 = alloca i64, align 8 
  %rva11206 = call i64 @prim_cons(i64 %a6925, i64 %rva11207) 
  store volatile i64 %rva11206, i64* %vptr30117, align 8 ; call prim_cons
 %vptr30118 = alloca i64, align 8 
  %rva11205 = call i64 @prim_cons(i64 %arg8549, i64 %rva11206) 
  store volatile i64 %rva11205, i64* %vptr30118, align 8 ; call prim_cons
  %vptr30124 = alloca i64*, align 8 
  %cloptr30119 = inttoptr i64 %Y8J$_37length to i64* 
  store volatile i64* %cloptr30119, i64** %vptr30124, align 8 ; closure/env cast; i64 -> i64*
  %vptr30125 = alloca i64*, align 8 
  %i0ptr30120 = getelementptr inbounds i64, i64* %cloptr30119, i64 1 
  store volatile i64* %i0ptr30120, i64** %vptr30125, align 8 ; &cloptr30119[1]
 %vptr30126 = alloca i64, align 8 
  %f30122 = load i64, i64* %i0ptr30120, align 8 
  store volatile i64 %f30122, i64* %vptr30126, align 8 ; load; *i0ptr30120
  %fptr30121 = inttoptr i64 %f30122 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30121(i64 %Y8J$_37length, i64 %rva11205)            ; tail call
  ret void

else30082:
 %vptr30127 = alloca i64, align 8 
  %h11210 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11210, i64* %vptr30127, align 8 ; call prim_halt
  %vptr30133 = alloca i64*, align 8 
  %cloptr30128 = inttoptr i64 %h11210 to i64* 
  store volatile i64* %cloptr30128, i64** %vptr30133, align 8 ; closure/env cast; i64 -> i64*
  %vptr30134 = alloca i64*, align 8 
  %i0ptr30129 = getelementptr inbounds i64, i64* %cloptr30128, i64 1 
  store volatile i64* %i0ptr30129, i64** %vptr30134, align 8 ; &cloptr30128[1]
 %vptr30135 = alloca i64, align 8 
  %f30131 = load i64, i64* %i0ptr30129, align 8 
  store volatile i64 %f30131, i64* %vptr30135, align 8 ; load; *i0ptr30129
  %fptr30130 = inttoptr i64 %f30131 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30130(i64 %h11210, i64 %h11210)                     ; tail call
  ret void
}


define void @lam11565(i64 %env11566, i64 %rvp11201) {
 %vptr30138 = alloca i64, align 8 
  %envptr30136 = inttoptr i64 %env11566 to i64* 
  store volatile i64 %emsg08636, i64* %vptr30138, align 8 ; closure/env cast; i64 -> i64*
  %vptr30139 = alloca i64*, align 8 
  %envptr30137 = getelementptr inbounds i64, i64* %envptr30136, i64 4 
  store volatile i64* %envptr30137, i64** %vptr30139, align 8 ; &envptr30136[3]
 %vptr30140 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr30137, align 8 
  store volatile i64 %emsg08636, i64* %vptr30140, align 8 ; load; *envptr30137
 %vptr30143 = alloca i64, align 8 
  %envptr30141 = inttoptr i64 %env11566 to i64* 
  store volatile i64 %cont7344, i64* %vptr30143, align 8 ; closure/env cast; i64 -> i64*
  %vptr30144 = alloca i64*, align 8 
  %envptr30142 = getelementptr inbounds i64, i64* %envptr30141, i64 3 
  store volatile i64* %envptr30142, i64** %vptr30144, align 8 ; &envptr30141[2]
 %vptr30145 = alloca i64, align 8 
  %cont7344 = load i64, i64* %envptr30142, align 8 
  store volatile i64 %cont7344, i64* %vptr30145, align 8 ; load; *envptr30142
 %vptr30148 = alloca i64, align 8 
  %envptr30146 = inttoptr i64 %env11566 to i64* 
  store volatile i64 %emsg18637, i64* %vptr30148, align 8 ; closure/env cast; i64 -> i64*
  %vptr30149 = alloca i64*, align 8 
  %envptr30147 = getelementptr inbounds i64, i64* %envptr30146, i64 2 
  store volatile i64* %envptr30147, i64** %vptr30149, align 8 ; &envptr30146[1]
 %vptr30150 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr30147, align 8 
  store volatile i64 %emsg18637, i64* %vptr30150, align 8 ; load; *envptr30147
 %vptr30151 = alloca i64, align 8 
  %_957345 = call i64 @prim_car(i64 %rvp11201) 
  store volatile i64 %_957345, i64* %vptr30151, align 8 ; call prim_car
 %vptr30152 = alloca i64, align 8 
  %rvp11197 = call i64 @prim_cdr(i64 %rvp11201) 
  store volatile i64 %rvp11197, i64* %vptr30152, align 8 ; call prim_cdr
 %vptr30153 = alloca i64, align 8 
  %n_6311202 = call i64 @prim_null_63(i64 %rvp11197) 
  store volatile i64 %n_6311202, i64* %vptr30153, align 8 ; call prim_null_63
  %cmpptr30157 = alloca i1, align 8  %cmp30154 = icmp eq i64 %n_6311202, 15 store volatile i1 %cmp30154, i1* %cmpptr30157, align 8; false?
  br i1 %cmp30154, label %else30156, label %then30155                                ; if

then30155:
 %vptr30158 = alloca i64, align 8 
  %h11203 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11203, i64* %vptr30158, align 8 ; call prim_halt
  %vptr30164 = alloca i64*, align 8 
  %cloptr30159 = inttoptr i64 %h11203 to i64* 
  store volatile i64* %cloptr30159, i64** %vptr30164, align 8 ; closure/env cast; i64 -> i64*
  %vptr30165 = alloca i64*, align 8 
  %i0ptr30160 = getelementptr inbounds i64, i64* %cloptr30159, i64 1 
  store volatile i64* %i0ptr30160, i64** %vptr30165, align 8 ; &cloptr30159[1]
 %vptr30166 = alloca i64, align 8 
  %f30162 = load i64, i64* %i0ptr30160, align 8 
  store volatile i64 %f30162, i64* %vptr30166, align 8 ; load; *i0ptr30160
  %fptr30161 = inttoptr i64 %f30162 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30161(i64 %h11203, i64 %h11203)                     ; tail call
  ret void

else30156:
 %vptr30167 = alloca i64, align 8 
  %a6926 = call i64 @prim_car(i64 %rvp11197) 
  store volatile i64 %a6926, i64* %vptr30167, align 8 ; call prim_car
 %vptr30168 = alloca i64, align 8 
  %na11193 = call i64 @prim_cdr(i64 %rvp11197) 
  store volatile i64 %na11193, i64* %vptr30168, align 8 ; call prim_cdr
 %vptr30169 = alloca i64, align 8 
  %n_6311198 = call i64 @prim_null_63(i64 %na11193) 
  store volatile i64 %n_6311198, i64* %vptr30169, align 8 ; call prim_null_63
  %cmpptr30173 = alloca i1, align 8  %cmp30170 = icmp eq i64 %n_6311198, 15 store volatile i1 %cmp30170, i1* %cmpptr30173, align 8; false?
  br i1 %cmp30170, label %else30172, label %then30171                                ; if

then30171:
 %vptr30174 = alloca i64, align 8 
  %arg8552 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg8552, i64* %vptr30174, align 8 ; quoted int
 %vptr30175 = alloca i64, align 8 
  %retprim7346 = call i64 @prim__43(i64 %arg8552, i64 %a6926) 
  store volatile i64 %retprim7346, i64* %vptr30175, align 8 ; call prim__43
 %vptr30176 = alloca i64, align 8 
  %arg8554 = add i64 0, 0 
  store volatile i64 %arg8554, i64* %vptr30176, align 8 ; quoted ()
 %vptr30177 = alloca i64, align 8 
  %rva11196 = add i64 0, 0 
  store volatile i64 %rva11196, i64* %vptr30177, align 8 ; quoted ()
 %vptr30178 = alloca i64, align 8 
  %rva11195 = call i64 @prim_cons(i64 %retprim7346, i64 %rva11196) 
  store volatile i64 %rva11195, i64* %vptr30178, align 8 ; call prim_cons
 %vptr30179 = alloca i64, align 8 
  %rva11194 = call i64 @prim_cons(i64 %arg8554, i64 %rva11195) 
  store volatile i64 %rva11194, i64* %vptr30179, align 8 ; call prim_cons
  %vptr30185 = alloca i64*, align 8 
  %cloptr30180 = inttoptr i64 %cont7344 to i64* 
  store volatile i64* %cloptr30180, i64** %vptr30185, align 8 ; closure/env cast; i64 -> i64*
  %vptr30186 = alloca i64*, align 8 
  %i0ptr30181 = getelementptr inbounds i64, i64* %cloptr30180, i64 1 
  store volatile i64* %i0ptr30181, i64** %vptr30186, align 8 ; &cloptr30180[1]
 %vptr30187 = alloca i64, align 8 
  %f30183 = load i64, i64* %i0ptr30181, align 8 
  store volatile i64 %f30183, i64* %vptr30187, align 8 ; load; *i0ptr30181
  %fptr30182 = inttoptr i64 %f30183 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30182(i64 %cont7344, i64 %rva11194)                 ; tail call
  ret void

else30172:
 %vptr30188 = alloca i64, align 8 
  %h11199 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11199, i64* %vptr30188, align 8 ; call prim_halt
  %vptr30194 = alloca i64*, align 8 
  %cloptr30189 = inttoptr i64 %h11199 to i64* 
  store volatile i64* %cloptr30189, i64** %vptr30194, align 8 ; closure/env cast; i64 -> i64*
  %vptr30195 = alloca i64*, align 8 
  %i0ptr30190 = getelementptr inbounds i64, i64* %cloptr30189, i64 1 
  store volatile i64* %i0ptr30190, i64** %vptr30195, align 8 ; &cloptr30189[1]
 %vptr30196 = alloca i64, align 8 
  %f30192 = load i64, i64* %i0ptr30190, align 8 
  store volatile i64 %f30192, i64* %vptr30196, align 8 ; load; *i0ptr30190
  %fptr30191 = inttoptr i64 %f30192 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30191(i64 %h11199, i64 %h11199)                     ; tail call
  ret void
}


define void @lam11554(i64 %env11555, i64 %rvp11284) {
 %vptr30199 = alloca i64, align 8 
  %envptr30197 = inttoptr i64 %env11555 to i64* 
  store volatile i64 %emsg08636, i64* %vptr30199, align 8 ; closure/env cast; i64 -> i64*
  %vptr30200 = alloca i64*, align 8 
  %envptr30198 = getelementptr inbounds i64, i64* %envptr30197, i64 3 
  store volatile i64* %envptr30198, i64** %vptr30200, align 8 ; &envptr30197[2]
 %vptr30201 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr30198, align 8 
  store volatile i64 %emsg08636, i64* %vptr30201, align 8 ; load; *envptr30198
 %vptr30204 = alloca i64, align 8 
  %envptr30202 = inttoptr i64 %env11555 to i64* 
  store volatile i64 %emsg18637, i64* %vptr30204, align 8 ; closure/env cast; i64 -> i64*
  %vptr30205 = alloca i64*, align 8 
  %envptr30203 = getelementptr inbounds i64, i64* %envptr30202, i64 2 
  store volatile i64* %envptr30203, i64** %vptr30205, align 8 ; &envptr30202[1]
 %vptr30206 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr30203, align 8 
  store volatile i64 %emsg18637, i64* %vptr30206, align 8 ; load; *envptr30203
 %vptr30207 = alloca i64, align 8 
  %cont7347 = call i64 @prim_car(i64 %rvp11284) 
  store volatile i64 %cont7347, i64* %vptr30207, align 8 ; call prim_car
 %vptr30208 = alloca i64, align 8 
  %rvp11280 = call i64 @prim_cdr(i64 %rvp11284) 
  store volatile i64 %rvp11280, i64* %vptr30208, align 8 ; call prim_cdr
 %vptr30209 = alloca i64, align 8 
  %n_6311285 = call i64 @prim_null_63(i64 %rvp11280) 
  store volatile i64 %n_6311285, i64* %vptr30209, align 8 ; call prim_null_63
  %cmpptr30213 = alloca i1, align 8  %cmp30210 = icmp eq i64 %n_6311285, 15 store volatile i1 %cmp30210, i1* %cmpptr30213, align 8; false?
  br i1 %cmp30210, label %else30212, label %then30211                                ; if

then30211:
 %vptr30214 = alloca i64, align 8 
  %h11286 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11286, i64* %vptr30214, align 8 ; call prim_halt
  %vptr30220 = alloca i64*, align 8 
  %cloptr30215 = inttoptr i64 %h11286 to i64* 
  store volatile i64* %cloptr30215, i64** %vptr30220, align 8 ; closure/env cast; i64 -> i64*
  %vptr30221 = alloca i64*, align 8 
  %i0ptr30216 = getelementptr inbounds i64, i64* %cloptr30215, i64 1 
  store volatile i64* %i0ptr30216, i64** %vptr30221, align 8 ; &cloptr30215[1]
 %vptr30222 = alloca i64, align 8 
  %f30218 = load i64, i64* %i0ptr30216, align 8 
  store volatile i64 %f30218, i64* %vptr30222, align 8 ; load; *i0ptr30216
  %fptr30217 = inttoptr i64 %f30218 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30217(i64 %h11286, i64 %h11286)                     ; tail call
  ret void

else30212:
 %vptr30223 = alloca i64, align 8 
  %h4r$_37take = call i64 @prim_car(i64 %rvp11280) 
  store volatile i64 %h4r$_37take, i64* %vptr30223, align 8 ; call prim_car
 %vptr30224 = alloca i64, align 8 
  %na11239 = call i64 @prim_cdr(i64 %rvp11280) 
  store volatile i64 %na11239, i64* %vptr30224, align 8 ; call prim_cdr
 %vptr30225 = alloca i64, align 8 
  %n_6311281 = call i64 @prim_null_63(i64 %na11239) 
  store volatile i64 %n_6311281, i64* %vptr30225, align 8 ; call prim_null_63
  %cmpptr30229 = alloca i1, align 8  %cmp30226 = icmp eq i64 %n_6311281, 15 store volatile i1 %cmp30226, i1* %cmpptr30229, align 8; false?
  br i1 %cmp30226, label %else30228, label %then30227                                ; if

then30227:
 %vptr30230 = alloca i64, align 8 
  %arg8557 = add i64 0, 0 
  store volatile i64 %arg8557, i64* %vptr30230, align 8 ; quoted ()
  %vptr30237 = alloca i64*, align 8 
  %cloptr30231 = call i64* @make_closure(i64 32) 
  store volatile i64* %cloptr30231, i64** %vptr30237, align 8 ; malloc
  %vptr30238 = alloca i64*, align 8 
  %eptr30233 = getelementptr inbounds i64, i64* %cloptr30231, i64 2 
  store volatile i64* %eptr30233, i64** %vptr30238, align 8 ; &eptr30233[1]
  %vptr30239 = alloca i64*, align 8 
  %eptr30234 = getelementptr inbounds i64, i64* %cloptr30231, i64 3 
  store volatile i64* %eptr30234, i64** %vptr30239, align 8 ; &eptr30234[2]
  %vptr30240 = alloca i64*, align 8 
  %eptr30235 = getelementptr inbounds i64, i64* %cloptr30231, i64 4 
  store volatile i64* %eptr30235, i64** %vptr30240, align 8 ; &eptr30235[3]
  store i64 %h4r$_37take, i64* %eptr30233                                            ; *eptr30233 = %h4r$_37take
  store i64 %emsg18637, i64* %eptr30234                                              ; *eptr30234 = %emsg18637
  store i64 %emsg08636, i64* %eptr30235                                              ; *eptr30235 = %emsg08636
  %vptr30241 = alloca i64*, align 8 
  %eptr30232 = getelementptr inbounds i64, i64* %cloptr30231, i64 1 
  store volatile i64* %eptr30232, i64** %vptr30241, align 8 ; &cloptr30231[1]
 %vptr30242 = alloca i64, align 8 
  %f30236 = ptrtoint void(i64,i64)* @lam11551 to i64 
  store volatile i64 %f30236, i64* %vptr30242, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f30236, i64* %eptr30232                                                 ; store fptr
 %vptr30243 = alloca i64, align 8 
  %arg8556 = ptrtoint i64* %cloptr30231 to i64 
  store volatile i64 %arg8556, i64* %vptr30243, align 8 ; closure cast; i64* -> i64
 %vptr30244 = alloca i64, align 8 
  %rva11279 = add i64 0, 0 
  store volatile i64 %rva11279, i64* %vptr30244, align 8 ; quoted ()
 %vptr30245 = alloca i64, align 8 
  %rva11278 = call i64 @prim_cons(i64 %arg8556, i64 %rva11279) 
  store volatile i64 %rva11278, i64* %vptr30245, align 8 ; call prim_cons
 %vptr30246 = alloca i64, align 8 
  %rva11277 = call i64 @prim_cons(i64 %arg8557, i64 %rva11278) 
  store volatile i64 %rva11277, i64* %vptr30246, align 8 ; call prim_cons
  %vptr30252 = alloca i64*, align 8 
  %cloptr30247 = inttoptr i64 %cont7347 to i64* 
  store volatile i64* %cloptr30247, i64** %vptr30252, align 8 ; closure/env cast; i64 -> i64*
  %vptr30253 = alloca i64*, align 8 
  %i0ptr30248 = getelementptr inbounds i64, i64* %cloptr30247, i64 1 
  store volatile i64* %i0ptr30248, i64** %vptr30253, align 8 ; &cloptr30247[1]
 %vptr30254 = alloca i64, align 8 
  %f30250 = load i64, i64* %i0ptr30248, align 8 
  store volatile i64 %f30250, i64* %vptr30254, align 8 ; load; *i0ptr30248
  %fptr30249 = inttoptr i64 %f30250 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30249(i64 %cont7347, i64 %rva11277)                 ; tail call
  ret void

else30228:
 %vptr30255 = alloca i64, align 8 
  %h11282 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11282, i64* %vptr30255, align 8 ; call prim_halt
  %vptr30261 = alloca i64*, align 8 
  %cloptr30256 = inttoptr i64 %h11282 to i64* 
  store volatile i64* %cloptr30256, i64** %vptr30261, align 8 ; closure/env cast; i64 -> i64*
  %vptr30262 = alloca i64*, align 8 
  %i0ptr30257 = getelementptr inbounds i64, i64* %cloptr30256, i64 1 
  store volatile i64* %i0ptr30257, i64** %vptr30262, align 8 ; &cloptr30256[1]
 %vptr30263 = alloca i64, align 8 
  %f30259 = load i64, i64* %i0ptr30257, align 8 
  store volatile i64 %f30259, i64* %vptr30263, align 8 ; load; *i0ptr30257
  %fptr30258 = inttoptr i64 %f30259 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30258(i64 %h11282, i64 %h11282)                     ; tail call
  ret void
}


define void @lam11551(i64 %env11552, i64 %rvp11273) {
 %vptr30266 = alloca i64, align 8 
  %envptr30264 = inttoptr i64 %env11552 to i64* 
  store volatile i64 %emsg08636, i64* %vptr30266, align 8 ; closure/env cast; i64 -> i64*
  %vptr30267 = alloca i64*, align 8 
  %envptr30265 = getelementptr inbounds i64, i64* %envptr30264, i64 4 
  store volatile i64* %envptr30265, i64** %vptr30267, align 8 ; &envptr30264[3]
 %vptr30268 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr30265, align 8 
  store volatile i64 %emsg08636, i64* %vptr30268, align 8 ; load; *envptr30265
 %vptr30271 = alloca i64, align 8 
  %envptr30269 = inttoptr i64 %env11552 to i64* 
  store volatile i64 %emsg18637, i64* %vptr30271, align 8 ; closure/env cast; i64 -> i64*
  %vptr30272 = alloca i64*, align 8 
  %envptr30270 = getelementptr inbounds i64, i64* %envptr30269, i64 3 
  store volatile i64* %envptr30270, i64** %vptr30272, align 8 ; &envptr30269[2]
 %vptr30273 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr30270, align 8 
  store volatile i64 %emsg18637, i64* %vptr30273, align 8 ; load; *envptr30270
 %vptr30276 = alloca i64, align 8 
  %envptr30274 = inttoptr i64 %env11552 to i64* 
  store volatile i64 %h4r$_37take, i64* %vptr30276, align 8 ; closure/env cast; i64 -> i64*
  %vptr30277 = alloca i64*, align 8 
  %envptr30275 = getelementptr inbounds i64, i64* %envptr30274, i64 2 
  store volatile i64* %envptr30275, i64** %vptr30277, align 8 ; &envptr30274[1]
 %vptr30278 = alloca i64, align 8 
  %h4r$_37take = load i64, i64* %envptr30275, align 8 
  store volatile i64 %h4r$_37take, i64* %vptr30278, align 8 ; load; *envptr30275
 %vptr30279 = alloca i64, align 8 
  %cont7348 = call i64 @prim_car(i64 %rvp11273) 
  store volatile i64 %cont7348, i64* %vptr30279, align 8 ; call prim_car
 %vptr30280 = alloca i64, align 8 
  %rvp11269 = call i64 @prim_cdr(i64 %rvp11273) 
  store volatile i64 %rvp11269, i64* %vptr30280, align 8 ; call prim_cdr
 %vptr30281 = alloca i64, align 8 
  %n_6311274 = call i64 @prim_null_63(i64 %rvp11269) 
  store volatile i64 %n_6311274, i64* %vptr30281, align 8 ; call prim_null_63
  %cmpptr30285 = alloca i1, align 8  %cmp30282 = icmp eq i64 %n_6311274, 15 store volatile i1 %cmp30282, i1* %cmpptr30285, align 8; false?
  br i1 %cmp30282, label %else30284, label %then30283                                ; if

then30283:
 %vptr30286 = alloca i64, align 8 
  %h11275 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11275, i64* %vptr30286, align 8 ; call prim_halt
  %vptr30292 = alloca i64*, align 8 
  %cloptr30287 = inttoptr i64 %h11275 to i64* 
  store volatile i64* %cloptr30287, i64** %vptr30292, align 8 ; closure/env cast; i64 -> i64*
  %vptr30293 = alloca i64*, align 8 
  %i0ptr30288 = getelementptr inbounds i64, i64* %cloptr30287, i64 1 
  store volatile i64* %i0ptr30288, i64** %vptr30293, align 8 ; &cloptr30287[1]
 %vptr30294 = alloca i64, align 8 
  %f30290 = load i64, i64* %i0ptr30288, align 8 
  store volatile i64 %f30290, i64* %vptr30294, align 8 ; load; *i0ptr30288
  %fptr30289 = inttoptr i64 %f30290 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30289(i64 %h11275, i64 %h11275)                     ; tail call
  ret void

else30284:
 %vptr30295 = alloca i64, align 8 
  %Fvt$lst = call i64 @prim_car(i64 %rvp11269) 
  store volatile i64 %Fvt$lst, i64* %vptr30295, align 8 ; call prim_car
 %vptr30296 = alloca i64, align 8 
  %rvp11265 = call i64 @prim_cdr(i64 %rvp11269) 
  store volatile i64 %rvp11265, i64* %vptr30296, align 8 ; call prim_cdr
 %vptr30297 = alloca i64, align 8 
  %n_6311270 = call i64 @prim_null_63(i64 %rvp11265) 
  store volatile i64 %n_6311270, i64* %vptr30297, align 8 ; call prim_null_63
  %cmpptr30301 = alloca i1, align 8  %cmp30298 = icmp eq i64 %n_6311270, 15 store volatile i1 %cmp30298, i1* %cmpptr30301, align 8; false?
  br i1 %cmp30298, label %else30300, label %then30299                                ; if

then30299:
 %vptr30302 = alloca i64, align 8 
  %h11271 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11271, i64* %vptr30302, align 8 ; call prim_halt
  %vptr30308 = alloca i64*, align 8 
  %cloptr30303 = inttoptr i64 %h11271 to i64* 
  store volatile i64* %cloptr30303, i64** %vptr30308, align 8 ; closure/env cast; i64 -> i64*
  %vptr30309 = alloca i64*, align 8 
  %i0ptr30304 = getelementptr inbounds i64, i64* %cloptr30303, i64 1 
  store volatile i64* %i0ptr30304, i64** %vptr30309, align 8 ; &cloptr30303[1]
 %vptr30310 = alloca i64, align 8 
  %f30306 = load i64, i64* %i0ptr30304, align 8 
  store volatile i64 %f30306, i64* %vptr30310, align 8 ; load; *i0ptr30304
  %fptr30305 = inttoptr i64 %f30306 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30305(i64 %h11271, i64 %h11271)                     ; tail call
  ret void

else30300:
 %vptr30311 = alloca i64, align 8 
  %jmL$n = call i64 @prim_car(i64 %rvp11265) 
  store volatile i64 %jmL$n, i64* %vptr30311, align 8 ; call prim_car
 %vptr30312 = alloca i64, align 8 
  %na11241 = call i64 @prim_cdr(i64 %rvp11265) 
  store volatile i64 %na11241, i64* %vptr30312, align 8 ; call prim_cdr
 %vptr30313 = alloca i64, align 8 
  %n_6311266 = call i64 @prim_null_63(i64 %na11241) 
  store volatile i64 %n_6311266, i64* %vptr30313, align 8 ; call prim_null_63
  %cmpptr30317 = alloca i1, align 8  %cmp30314 = icmp eq i64 %n_6311266, 15 store volatile i1 %cmp30314, i1* %cmpptr30317, align 8; false?
  br i1 %cmp30314, label %else30316, label %then30315                                ; if

then30315:
 %vptr30318 = alloca i64, align 8 
  %arg8559 = call i64 @const_init_int(i64 0) 
  store volatile i64 %arg8559, i64* %vptr30318, align 8 ; quoted int
 %vptr30319 = alloca i64, align 8 
  %a6918 = call i64 @prim__61(i64 %jmL$n, i64 %arg8559) 
  store volatile i64 %a6918, i64* %vptr30319, align 8 ; call prim__61
  %cmpptr30323 = alloca i1, align 8  %cmp30320 = icmp eq i64 %a6918, 15 store volatile i1 %cmp30320, i1* %cmpptr30323, align 8; false?
  br i1 %cmp30320, label %else30322, label %then30321                                ; if

then30321:
 %vptr30324 = alloca i64, align 8 
  %arg8562 = add i64 0, 0 
  store volatile i64 %arg8562, i64* %vptr30324, align 8 ; quoted ()
 %vptr30325 = alloca i64, align 8 
  %arg8561 = add i64 0, 0 
  store volatile i64 %arg8561, i64* %vptr30325, align 8 ; quoted ()
 %vptr30326 = alloca i64, align 8 
  %rva11244 = add i64 0, 0 
  store volatile i64 %rva11244, i64* %vptr30326, align 8 ; quoted ()
 %vptr30327 = alloca i64, align 8 
  %rva11243 = call i64 @prim_cons(i64 %arg8561, i64 %rva11244) 
  store volatile i64 %rva11243, i64* %vptr30327, align 8 ; call prim_cons
 %vptr30328 = alloca i64, align 8 
  %rva11242 = call i64 @prim_cons(i64 %arg8562, i64 %rva11243) 
  store volatile i64 %rva11242, i64* %vptr30328, align 8 ; call prim_cons
  %vptr30334 = alloca i64*, align 8 
  %cloptr30329 = inttoptr i64 %cont7348 to i64* 
  store volatile i64* %cloptr30329, i64** %vptr30334, align 8 ; closure/env cast; i64 -> i64*
  %vptr30335 = alloca i64*, align 8 
  %i0ptr30330 = getelementptr inbounds i64, i64* %cloptr30329, i64 1 
  store volatile i64* %i0ptr30330, i64** %vptr30335, align 8 ; &cloptr30329[1]
 %vptr30336 = alloca i64, align 8 
  %f30332 = load i64, i64* %i0ptr30330, align 8 
  store volatile i64 %f30332, i64* %vptr30336, align 8 ; load; *i0ptr30330
  %fptr30331 = inttoptr i64 %f30332 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30331(i64 %cont7348, i64 %rva11242)                 ; tail call
  ret void

else30322:
 %vptr30337 = alloca i64, align 8 
  %a6919 = call i64 @prim_null_63(i64 %Fvt$lst) 
  store volatile i64 %a6919, i64* %vptr30337, align 8 ; call prim_null_63
  %cmpptr30341 = alloca i1, align 8  %cmp30338 = icmp eq i64 %a6919, 15 store volatile i1 %cmp30338, i1* %cmpptr30341, align 8; false?
  br i1 %cmp30338, label %else30340, label %then30339                                ; if

then30339:
 %vptr30342 = alloca i64, align 8 
  %arg8566 = add i64 0, 0 
  store volatile i64 %arg8566, i64* %vptr30342, align 8 ; quoted ()
 %vptr30343 = alloca i64, align 8 
  %arg8565 = add i64 0, 0 
  store volatile i64 %arg8565, i64* %vptr30343, align 8 ; quoted ()
 %vptr30344 = alloca i64, align 8 
  %rva11247 = add i64 0, 0 
  store volatile i64 %rva11247, i64* %vptr30344, align 8 ; quoted ()
 %vptr30345 = alloca i64, align 8 
  %rva11246 = call i64 @prim_cons(i64 %arg8565, i64 %rva11247) 
  store volatile i64 %rva11246, i64* %vptr30345, align 8 ; call prim_cons
 %vptr30346 = alloca i64, align 8 
  %rva11245 = call i64 @prim_cons(i64 %arg8566, i64 %rva11246) 
  store volatile i64 %rva11245, i64* %vptr30346, align 8 ; call prim_cons
  %vptr30352 = alloca i64*, align 8 
  %cloptr30347 = inttoptr i64 %cont7348 to i64* 
  store volatile i64* %cloptr30347, i64** %vptr30352, align 8 ; closure/env cast; i64 -> i64*
  %vptr30353 = alloca i64*, align 8 
  %i0ptr30348 = getelementptr inbounds i64, i64* %cloptr30347, i64 1 
  store volatile i64* %i0ptr30348, i64** %vptr30353, align 8 ; &cloptr30347[1]
 %vptr30354 = alloca i64, align 8 
  %f30350 = load i64, i64* %i0ptr30348, align 8 
  store volatile i64 %f30350, i64* %vptr30354, align 8 ; load; *i0ptr30348
  %fptr30349 = inttoptr i64 %f30350 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30349(i64 %cont7348, i64 %rva11245)                 ; tail call
  ret void

else30340:
 %vptr30355 = alloca i64, align 8 
  %a6920 = call i64 @prim_car(i64 %Fvt$lst) 
  store volatile i64 %a6920, i64* %vptr30355, align 8 ; call prim_car
 %vptr30356 = alloca i64, align 8 
  %a6921 = call i64 @prim_cdr(i64 %Fvt$lst) 
  store volatile i64 %a6921, i64* %vptr30356, align 8 ; call prim_cdr
 %vptr30357 = alloca i64, align 8 
  %arg8570 = call i64 @const_init_int(i64 1) 
  store volatile i64 %arg8570, i64* %vptr30357, align 8 ; quoted int
 %vptr30358 = alloca i64, align 8 
  %a6922 = call i64 @prim__45(i64 %jmL$n, i64 %arg8570) 
  store volatile i64 %a6922, i64* %vptr30358, align 8 ; call prim__45
  %vptr30366 = alloca i64*, align 8 
  %cloptr30359 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr30359, i64** %vptr30366, align 8 ; malloc
  %vptr30367 = alloca i64*, align 8 
  %eptr30361 = getelementptr inbounds i64, i64* %cloptr30359, i64 2 
  store volatile i64* %eptr30361, i64** %vptr30367, align 8 ; &eptr30361[1]
  %vptr30368 = alloca i64*, align 8 
  %eptr30362 = getelementptr inbounds i64, i64* %cloptr30359, i64 3 
  store volatile i64* %eptr30362, i64** %vptr30368, align 8 ; &eptr30362[2]
  %vptr30369 = alloca i64*, align 8 
  %eptr30363 = getelementptr inbounds i64, i64* %cloptr30359, i64 4 
  store volatile i64* %eptr30363, i64** %vptr30369, align 8 ; &eptr30363[3]
  %vptr30370 = alloca i64*, align 8 
  %eptr30364 = getelementptr inbounds i64, i64* %cloptr30359, i64 5 
  store volatile i64* %eptr30364, i64** %vptr30370, align 8 ; &eptr30364[4]
  store i64 %emsg18637, i64* %eptr30361                                              ; *eptr30361 = %emsg18637
  store i64 %a6920, i64* %eptr30362                                                  ; *eptr30362 = %a6920
  store i64 %cont7348, i64* %eptr30363                                               ; *eptr30363 = %cont7348
  store i64 %emsg08636, i64* %eptr30364                                              ; *eptr30364 = %emsg08636
  %vptr30371 = alloca i64*, align 8 
  %eptr30360 = getelementptr inbounds i64, i64* %cloptr30359, i64 1 
  store volatile i64* %eptr30360, i64** %vptr30371, align 8 ; &cloptr30359[1]
 %vptr30372 = alloca i64, align 8 
  %f30365 = ptrtoint void(i64,i64)* @lam11547 to i64 
  store volatile i64 %f30365, i64* %vptr30372, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f30365, i64* %eptr30360                                                 ; store fptr
 %vptr30373 = alloca i64, align 8 
  %arg8574 = ptrtoint i64* %cloptr30359 to i64 
  store volatile i64 %arg8574, i64* %vptr30373, align 8 ; closure cast; i64* -> i64
 %vptr30374 = alloca i64, align 8 
  %rva11264 = add i64 0, 0 
  store volatile i64 %rva11264, i64* %vptr30374, align 8 ; quoted ()
 %vptr30375 = alloca i64, align 8 
  %rva11263 = call i64 @prim_cons(i64 %a6922, i64 %rva11264) 
  store volatile i64 %rva11263, i64* %vptr30375, align 8 ; call prim_cons
 %vptr30376 = alloca i64, align 8 
  %rva11262 = call i64 @prim_cons(i64 %a6921, i64 %rva11263) 
  store volatile i64 %rva11262, i64* %vptr30376, align 8 ; call prim_cons
 %vptr30377 = alloca i64, align 8 
  %rva11261 = call i64 @prim_cons(i64 %arg8574, i64 %rva11262) 
  store volatile i64 %rva11261, i64* %vptr30377, align 8 ; call prim_cons
  %vptr30383 = alloca i64*, align 8 
  %cloptr30378 = inttoptr i64 %h4r$_37take to i64* 
  store volatile i64* %cloptr30378, i64** %vptr30383, align 8 ; closure/env cast; i64 -> i64*
  %vptr30384 = alloca i64*, align 8 
  %i0ptr30379 = getelementptr inbounds i64, i64* %cloptr30378, i64 1 
  store volatile i64* %i0ptr30379, i64** %vptr30384, align 8 ; &cloptr30378[1]
 %vptr30385 = alloca i64, align 8 
  %f30381 = load i64, i64* %i0ptr30379, align 8 
  store volatile i64 %f30381, i64* %vptr30385, align 8 ; load; *i0ptr30379
  %fptr30380 = inttoptr i64 %f30381 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30380(i64 %h4r$_37take, i64 %rva11261)              ; tail call
  ret void

else30316:
 %vptr30386 = alloca i64, align 8 
  %h11267 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11267, i64* %vptr30386, align 8 ; call prim_halt
  %vptr30392 = alloca i64*, align 8 
  %cloptr30387 = inttoptr i64 %h11267 to i64* 
  store volatile i64* %cloptr30387, i64** %vptr30392, align 8 ; closure/env cast; i64 -> i64*
  %vptr30393 = alloca i64*, align 8 
  %i0ptr30388 = getelementptr inbounds i64, i64* %cloptr30387, i64 1 
  store volatile i64* %i0ptr30388, i64** %vptr30393, align 8 ; &cloptr30387[1]
 %vptr30394 = alloca i64, align 8 
  %f30390 = load i64, i64* %i0ptr30388, align 8 
  store volatile i64 %f30390, i64* %vptr30394, align 8 ; load; *i0ptr30388
  %fptr30389 = inttoptr i64 %f30390 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30389(i64 %h11267, i64 %h11267)                     ; tail call
  ret void
}


define void @lam11547(i64 %env11548, i64 %rvp11257) {
 %vptr30397 = alloca i64, align 8 
  %envptr30395 = inttoptr i64 %env11548 to i64* 
  store volatile i64 %emsg08636, i64* %vptr30397, align 8 ; closure/env cast; i64 -> i64*
  %vptr30398 = alloca i64*, align 8 
  %envptr30396 = getelementptr inbounds i64, i64* %envptr30395, i64 5 
  store volatile i64* %envptr30396, i64** %vptr30398, align 8 ; &envptr30395[4]
 %vptr30399 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr30396, align 8 
  store volatile i64 %emsg08636, i64* %vptr30399, align 8 ; load; *envptr30396
 %vptr30402 = alloca i64, align 8 
  %envptr30400 = inttoptr i64 %env11548 to i64* 
  store volatile i64 %cont7348, i64* %vptr30402, align 8 ; closure/env cast; i64 -> i64*
  %vptr30403 = alloca i64*, align 8 
  %envptr30401 = getelementptr inbounds i64, i64* %envptr30400, i64 4 
  store volatile i64* %envptr30401, i64** %vptr30403, align 8 ; &envptr30400[3]
 %vptr30404 = alloca i64, align 8 
  %cont7348 = load i64, i64* %envptr30401, align 8 
  store volatile i64 %cont7348, i64* %vptr30404, align 8 ; load; *envptr30401
 %vptr30407 = alloca i64, align 8 
  %envptr30405 = inttoptr i64 %env11548 to i64* 
  store volatile i64 %a6920, i64* %vptr30407, align 8 ; closure/env cast; i64 -> i64*
  %vptr30408 = alloca i64*, align 8 
  %envptr30406 = getelementptr inbounds i64, i64* %envptr30405, i64 3 
  store volatile i64* %envptr30406, i64** %vptr30408, align 8 ; &envptr30405[2]
 %vptr30409 = alloca i64, align 8 
  %a6920 = load i64, i64* %envptr30406, align 8 
  store volatile i64 %a6920, i64* %vptr30409, align 8 ; load; *envptr30406
 %vptr30412 = alloca i64, align 8 
  %envptr30410 = inttoptr i64 %env11548 to i64* 
  store volatile i64 %emsg18637, i64* %vptr30412, align 8 ; closure/env cast; i64 -> i64*
  %vptr30413 = alloca i64*, align 8 
  %envptr30411 = getelementptr inbounds i64, i64* %envptr30410, i64 2 
  store volatile i64* %envptr30411, i64** %vptr30413, align 8 ; &envptr30410[1]
 %vptr30414 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr30411, align 8 
  store volatile i64 %emsg18637, i64* %vptr30414, align 8 ; load; *envptr30411
 %vptr30415 = alloca i64, align 8 
  %_957349 = call i64 @prim_car(i64 %rvp11257) 
  store volatile i64 %_957349, i64* %vptr30415, align 8 ; call prim_car
 %vptr30416 = alloca i64, align 8 
  %rvp11253 = call i64 @prim_cdr(i64 %rvp11257) 
  store volatile i64 %rvp11253, i64* %vptr30416, align 8 ; call prim_cdr
 %vptr30417 = alloca i64, align 8 
  %n_6311258 = call i64 @prim_null_63(i64 %rvp11253) 
  store volatile i64 %n_6311258, i64* %vptr30417, align 8 ; call prim_null_63
  %cmpptr30421 = alloca i1, align 8  %cmp30418 = icmp eq i64 %n_6311258, 15 store volatile i1 %cmp30418, i1* %cmpptr30421, align 8; false?
  br i1 %cmp30418, label %else30420, label %then30419                                ; if

then30419:
 %vptr30422 = alloca i64, align 8 
  %h11259 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11259, i64* %vptr30422, align 8 ; call prim_halt
  %vptr30428 = alloca i64*, align 8 
  %cloptr30423 = inttoptr i64 %h11259 to i64* 
  store volatile i64* %cloptr30423, i64** %vptr30428, align 8 ; closure/env cast; i64 -> i64*
  %vptr30429 = alloca i64*, align 8 
  %i0ptr30424 = getelementptr inbounds i64, i64* %cloptr30423, i64 1 
  store volatile i64* %i0ptr30424, i64** %vptr30429, align 8 ; &cloptr30423[1]
 %vptr30430 = alloca i64, align 8 
  %f30426 = load i64, i64* %i0ptr30424, align 8 
  store volatile i64 %f30426, i64* %vptr30430, align 8 ; load; *i0ptr30424
  %fptr30425 = inttoptr i64 %f30426 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30425(i64 %h11259, i64 %h11259)                     ; tail call
  ret void

else30420:
 %vptr30431 = alloca i64, align 8 
  %a6923 = call i64 @prim_car(i64 %rvp11253) 
  store volatile i64 %a6923, i64* %vptr30431, align 8 ; call prim_car
 %vptr30432 = alloca i64, align 8 
  %na11249 = call i64 @prim_cdr(i64 %rvp11253) 
  store volatile i64 %na11249, i64* %vptr30432, align 8 ; call prim_cdr
 %vptr30433 = alloca i64, align 8 
  %n_6311254 = call i64 @prim_null_63(i64 %na11249) 
  store volatile i64 %n_6311254, i64* %vptr30433, align 8 ; call prim_null_63
  %cmpptr30437 = alloca i1, align 8  %cmp30434 = icmp eq i64 %n_6311254, 15 store volatile i1 %cmp30434, i1* %cmpptr30437, align 8; false?
  br i1 %cmp30434, label %else30436, label %then30435                                ; if

then30435:
 %vptr30438 = alloca i64, align 8 
  %retprim7350 = call i64 @prim_cons(i64 %a6920, i64 %a6923) 
  store volatile i64 %retprim7350, i64* %vptr30438, align 8 ; call prim_cons
 %vptr30439 = alloca i64, align 8 
  %arg8579 = add i64 0, 0 
  store volatile i64 %arg8579, i64* %vptr30439, align 8 ; quoted ()
 %vptr30440 = alloca i64, align 8 
  %rva11252 = add i64 0, 0 
  store volatile i64 %rva11252, i64* %vptr30440, align 8 ; quoted ()
 %vptr30441 = alloca i64, align 8 
  %rva11251 = call i64 @prim_cons(i64 %retprim7350, i64 %rva11252) 
  store volatile i64 %rva11251, i64* %vptr30441, align 8 ; call prim_cons
 %vptr30442 = alloca i64, align 8 
  %rva11250 = call i64 @prim_cons(i64 %arg8579, i64 %rva11251) 
  store volatile i64 %rva11250, i64* %vptr30442, align 8 ; call prim_cons
  %vptr30448 = alloca i64*, align 8 
  %cloptr30443 = inttoptr i64 %cont7348 to i64* 
  store volatile i64* %cloptr30443, i64** %vptr30448, align 8 ; closure/env cast; i64 -> i64*
  %vptr30449 = alloca i64*, align 8 
  %i0ptr30444 = getelementptr inbounds i64, i64* %cloptr30443, i64 1 
  store volatile i64* %i0ptr30444, i64** %vptr30449, align 8 ; &cloptr30443[1]
 %vptr30450 = alloca i64, align 8 
  %f30446 = load i64, i64* %i0ptr30444, align 8 
  store volatile i64 %f30446, i64* %vptr30450, align 8 ; load; *i0ptr30444
  %fptr30445 = inttoptr i64 %f30446 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30445(i64 %cont7348, i64 %rva11250)                 ; tail call
  ret void

else30436:
 %vptr30451 = alloca i64, align 8 
  %h11255 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11255, i64* %vptr30451, align 8 ; call prim_halt
  %vptr30457 = alloca i64*, align 8 
  %cloptr30452 = inttoptr i64 %h11255 to i64* 
  store volatile i64* %cloptr30452, i64** %vptr30457, align 8 ; closure/env cast; i64 -> i64*
  %vptr30458 = alloca i64*, align 8 
  %i0ptr30453 = getelementptr inbounds i64, i64* %cloptr30452, i64 1 
  store volatile i64* %i0ptr30453, i64** %vptr30458, align 8 ; &cloptr30452[1]
 %vptr30459 = alloca i64, align 8 
  %f30455 = load i64, i64* %i0ptr30453, align 8 
  store volatile i64 %f30455, i64* %vptr30459, align 8 ; load; *i0ptr30453
  %fptr30454 = inttoptr i64 %f30455 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30454(i64 %h11255, i64 %h11255)                     ; tail call
  ret void
}


define void @lam11534(i64 %env11535, i64 %rvp11355) {
 %vptr30462 = alloca i64, align 8 
  %envptr30460 = inttoptr i64 %env11535 to i64* 
  store volatile i64 %emsg08636, i64* %vptr30462, align 8 ; closure/env cast; i64 -> i64*
  %vptr30463 = alloca i64*, align 8 
  %envptr30461 = getelementptr inbounds i64, i64* %envptr30460, i64 3 
  store volatile i64* %envptr30461, i64** %vptr30463, align 8 ; &envptr30460[2]
 %vptr30464 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr30461, align 8 
  store volatile i64 %emsg08636, i64* %vptr30464, align 8 ; load; *envptr30461
 %vptr30467 = alloca i64, align 8 
  %envptr30465 = inttoptr i64 %env11535 to i64* 
  store volatile i64 %emsg18637, i64* %vptr30467, align 8 ; closure/env cast; i64 -> i64*
  %vptr30468 = alloca i64*, align 8 
  %envptr30466 = getelementptr inbounds i64, i64* %envptr30465, i64 2 
  store volatile i64* %envptr30466, i64** %vptr30468, align 8 ; &envptr30465[1]
 %vptr30469 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr30466, align 8 
  store volatile i64 %emsg18637, i64* %vptr30469, align 8 ; load; *envptr30466
 %vptr30470 = alloca i64, align 8 
  %cont7351 = call i64 @prim_car(i64 %rvp11355) 
  store volatile i64 %cont7351, i64* %vptr30470, align 8 ; call prim_car
 %vptr30471 = alloca i64, align 8 
  %rvp11351 = call i64 @prim_cdr(i64 %rvp11355) 
  store volatile i64 %rvp11351, i64* %vptr30471, align 8 ; call prim_cdr
 %vptr30472 = alloca i64, align 8 
  %n_6311356 = call i64 @prim_null_63(i64 %rvp11351) 
  store volatile i64 %n_6311356, i64* %vptr30472, align 8 ; call prim_null_63
  %cmpptr30476 = alloca i1, align 8  %cmp30473 = icmp eq i64 %n_6311356, 15 store volatile i1 %cmp30473, i1* %cmpptr30476, align 8; false?
  br i1 %cmp30473, label %else30475, label %then30474                                ; if

then30474:
 %vptr30477 = alloca i64, align 8 
  %h11357 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11357, i64* %vptr30477, align 8 ; call prim_halt
  %vptr30483 = alloca i64*, align 8 
  %cloptr30478 = inttoptr i64 %h11357 to i64* 
  store volatile i64* %cloptr30478, i64** %vptr30483, align 8 ; closure/env cast; i64 -> i64*
  %vptr30484 = alloca i64*, align 8 
  %i0ptr30479 = getelementptr inbounds i64, i64* %cloptr30478, i64 1 
  store volatile i64* %i0ptr30479, i64** %vptr30484, align 8 ; &cloptr30478[1]
 %vptr30485 = alloca i64, align 8 
  %f30481 = load i64, i64* %i0ptr30479, align 8 
  store volatile i64 %f30481, i64* %vptr30485, align 8 ; load; *i0ptr30479
  %fptr30480 = inttoptr i64 %f30481 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30480(i64 %h11357, i64 %h11357)                     ; tail call
  ret void

else30475:
 %vptr30486 = alloca i64, align 8 
  %nBN$_37map = call i64 @prim_car(i64 %rvp11351) 
  store volatile i64 %nBN$_37map, i64* %vptr30486, align 8 ; call prim_car
 %vptr30487 = alloca i64, align 8 
  %na11300 = call i64 @prim_cdr(i64 %rvp11351) 
  store volatile i64 %na11300, i64* %vptr30487, align 8 ; call prim_cdr
 %vptr30488 = alloca i64, align 8 
  %n_6311352 = call i64 @prim_null_63(i64 %na11300) 
  store volatile i64 %n_6311352, i64* %vptr30488, align 8 ; call prim_null_63
  %cmpptr30492 = alloca i1, align 8  %cmp30489 = icmp eq i64 %n_6311352, 15 store volatile i1 %cmp30489, i1* %cmpptr30492, align 8; false?
  br i1 %cmp30489, label %else30491, label %then30490                                ; if

then30490:
 %vptr30493 = alloca i64, align 8 
  %arg8582 = add i64 0, 0 
  store volatile i64 %arg8582, i64* %vptr30493, align 8 ; quoted ()
  %vptr30500 = alloca i64*, align 8 
  %cloptr30494 = call i64* @make_closure(i64 32) 
  store volatile i64* %cloptr30494, i64** %vptr30500, align 8 ; malloc
  %vptr30501 = alloca i64*, align 8 
  %eptr30496 = getelementptr inbounds i64, i64* %cloptr30494, i64 2 
  store volatile i64* %eptr30496, i64** %vptr30501, align 8 ; &eptr30496[1]
  %vptr30502 = alloca i64*, align 8 
  %eptr30497 = getelementptr inbounds i64, i64* %cloptr30494, i64 3 
  store volatile i64* %eptr30497, i64** %vptr30502, align 8 ; &eptr30497[2]
  %vptr30503 = alloca i64*, align 8 
  %eptr30498 = getelementptr inbounds i64, i64* %cloptr30494, i64 4 
  store volatile i64* %eptr30498, i64** %vptr30503, align 8 ; &eptr30498[3]
  store i64 %nBN$_37map, i64* %eptr30496                                             ; *eptr30496 = %nBN$_37map
  store i64 %emsg18637, i64* %eptr30497                                              ; *eptr30497 = %emsg18637
  store i64 %emsg08636, i64* %eptr30498                                              ; *eptr30498 = %emsg08636
  %vptr30504 = alloca i64*, align 8 
  %eptr30495 = getelementptr inbounds i64, i64* %cloptr30494, i64 1 
  store volatile i64* %eptr30495, i64** %vptr30504, align 8 ; &cloptr30494[1]
 %vptr30505 = alloca i64, align 8 
  %f30499 = ptrtoint void(i64,i64)* @lam11531 to i64 
  store volatile i64 %f30499, i64* %vptr30505, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f30499, i64* %eptr30495                                                 ; store fptr
 %vptr30506 = alloca i64, align 8 
  %arg8581 = ptrtoint i64* %cloptr30494 to i64 
  store volatile i64 %arg8581, i64* %vptr30506, align 8 ; closure cast; i64* -> i64
 %vptr30507 = alloca i64, align 8 
  %rva11350 = add i64 0, 0 
  store volatile i64 %rva11350, i64* %vptr30507, align 8 ; quoted ()
 %vptr30508 = alloca i64, align 8 
  %rva11349 = call i64 @prim_cons(i64 %arg8581, i64 %rva11350) 
  store volatile i64 %rva11349, i64* %vptr30508, align 8 ; call prim_cons
 %vptr30509 = alloca i64, align 8 
  %rva11348 = call i64 @prim_cons(i64 %arg8582, i64 %rva11349) 
  store volatile i64 %rva11348, i64* %vptr30509, align 8 ; call prim_cons
  %vptr30515 = alloca i64*, align 8 
  %cloptr30510 = inttoptr i64 %cont7351 to i64* 
  store volatile i64* %cloptr30510, i64** %vptr30515, align 8 ; closure/env cast; i64 -> i64*
  %vptr30516 = alloca i64*, align 8 
  %i0ptr30511 = getelementptr inbounds i64, i64* %cloptr30510, i64 1 
  store volatile i64* %i0ptr30511, i64** %vptr30516, align 8 ; &cloptr30510[1]
 %vptr30517 = alloca i64, align 8 
  %f30513 = load i64, i64* %i0ptr30511, align 8 
  store volatile i64 %f30513, i64* %vptr30517, align 8 ; load; *i0ptr30511
  %fptr30512 = inttoptr i64 %f30513 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30512(i64 %cont7351, i64 %rva11348)                 ; tail call
  ret void

else30491:
 %vptr30518 = alloca i64, align 8 
  %h11353 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11353, i64* %vptr30518, align 8 ; call prim_halt
  %vptr30524 = alloca i64*, align 8 
  %cloptr30519 = inttoptr i64 %h11353 to i64* 
  store volatile i64* %cloptr30519, i64** %vptr30524, align 8 ; closure/env cast; i64 -> i64*
  %vptr30525 = alloca i64*, align 8 
  %i0ptr30520 = getelementptr inbounds i64, i64* %cloptr30519, i64 1 
  store volatile i64* %i0ptr30520, i64** %vptr30525, align 8 ; &cloptr30519[1]
 %vptr30526 = alloca i64, align 8 
  %f30522 = load i64, i64* %i0ptr30520, align 8 
  store volatile i64 %f30522, i64* %vptr30526, align 8 ; load; *i0ptr30520
  %fptr30521 = inttoptr i64 %f30522 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30521(i64 %h11353, i64 %h11353)                     ; tail call
  ret void
}


define void @lam11531(i64 %env11532, i64 %rvp11344) {
 %vptr30529 = alloca i64, align 8 
  %envptr30527 = inttoptr i64 %env11532 to i64* 
  store volatile i64 %emsg08636, i64* %vptr30529, align 8 ; closure/env cast; i64 -> i64*
  %vptr30530 = alloca i64*, align 8 
  %envptr30528 = getelementptr inbounds i64, i64* %envptr30527, i64 4 
  store volatile i64* %envptr30528, i64** %vptr30530, align 8 ; &envptr30527[3]
 %vptr30531 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr30528, align 8 
  store volatile i64 %emsg08636, i64* %vptr30531, align 8 ; load; *envptr30528
 %vptr30534 = alloca i64, align 8 
  %envptr30532 = inttoptr i64 %env11532 to i64* 
  store volatile i64 %emsg18637, i64* %vptr30534, align 8 ; closure/env cast; i64 -> i64*
  %vptr30535 = alloca i64*, align 8 
  %envptr30533 = getelementptr inbounds i64, i64* %envptr30532, i64 3 
  store volatile i64* %envptr30533, i64** %vptr30535, align 8 ; &envptr30532[2]
 %vptr30536 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr30533, align 8 
  store volatile i64 %emsg18637, i64* %vptr30536, align 8 ; load; *envptr30533
 %vptr30539 = alloca i64, align 8 
  %envptr30537 = inttoptr i64 %env11532 to i64* 
  store volatile i64 %nBN$_37map, i64* %vptr30539, align 8 ; closure/env cast; i64 -> i64*
  %vptr30540 = alloca i64*, align 8 
  %envptr30538 = getelementptr inbounds i64, i64* %envptr30537, i64 2 
  store volatile i64* %envptr30538, i64** %vptr30540, align 8 ; &envptr30537[1]
 %vptr30541 = alloca i64, align 8 
  %nBN$_37map = load i64, i64* %envptr30538, align 8 
  store volatile i64 %nBN$_37map, i64* %vptr30541, align 8 ; load; *envptr30538
 %vptr30542 = alloca i64, align 8 
  %cont7352 = call i64 @prim_car(i64 %rvp11344) 
  store volatile i64 %cont7352, i64* %vptr30542, align 8 ; call prim_car
 %vptr30543 = alloca i64, align 8 
  %rvp11340 = call i64 @prim_cdr(i64 %rvp11344) 
  store volatile i64 %rvp11340, i64* %vptr30543, align 8 ; call prim_cdr
 %vptr30544 = alloca i64, align 8 
  %n_6311345 = call i64 @prim_null_63(i64 %rvp11340) 
  store volatile i64 %n_6311345, i64* %vptr30544, align 8 ; call prim_null_63
  %cmpptr30548 = alloca i1, align 8  %cmp30545 = icmp eq i64 %n_6311345, 15 store volatile i1 %cmp30545, i1* %cmpptr30548, align 8; false?
  br i1 %cmp30545, label %else30547, label %then30546                                ; if

then30546:
 %vptr30549 = alloca i64, align 8 
  %h11346 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11346, i64* %vptr30549, align 8 ; call prim_halt
  %vptr30555 = alloca i64*, align 8 
  %cloptr30550 = inttoptr i64 %h11346 to i64* 
  store volatile i64* %cloptr30550, i64** %vptr30555, align 8 ; closure/env cast; i64 -> i64*
  %vptr30556 = alloca i64*, align 8 
  %i0ptr30551 = getelementptr inbounds i64, i64* %cloptr30550, i64 1 
  store volatile i64* %i0ptr30551, i64** %vptr30556, align 8 ; &cloptr30550[1]
 %vptr30557 = alloca i64, align 8 
  %f30553 = load i64, i64* %i0ptr30551, align 8 
  store volatile i64 %f30553, i64* %vptr30557, align 8 ; load; *i0ptr30551
  %fptr30552 = inttoptr i64 %f30553 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30552(i64 %h11346, i64 %h11346)                     ; tail call
  ret void

else30547:
 %vptr30558 = alloca i64, align 8 
  %Eoq$f = call i64 @prim_car(i64 %rvp11340) 
  store volatile i64 %Eoq$f, i64* %vptr30558, align 8 ; call prim_car
 %vptr30559 = alloca i64, align 8 
  %rvp11336 = call i64 @prim_cdr(i64 %rvp11340) 
  store volatile i64 %rvp11336, i64* %vptr30559, align 8 ; call prim_cdr
 %vptr30560 = alloca i64, align 8 
  %n_6311341 = call i64 @prim_null_63(i64 %rvp11336) 
  store volatile i64 %n_6311341, i64* %vptr30560, align 8 ; call prim_null_63
  %cmpptr30564 = alloca i1, align 8  %cmp30561 = icmp eq i64 %n_6311341, 15 store volatile i1 %cmp30561, i1* %cmpptr30564, align 8; false?
  br i1 %cmp30561, label %else30563, label %then30562                                ; if

then30562:
 %vptr30565 = alloca i64, align 8 
  %h11342 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11342, i64* %vptr30565, align 8 ; call prim_halt
  %vptr30571 = alloca i64*, align 8 
  %cloptr30566 = inttoptr i64 %h11342 to i64* 
  store volatile i64* %cloptr30566, i64** %vptr30571, align 8 ; closure/env cast; i64 -> i64*
  %vptr30572 = alloca i64*, align 8 
  %i0ptr30567 = getelementptr inbounds i64, i64* %cloptr30566, i64 1 
  store volatile i64* %i0ptr30567, i64** %vptr30572, align 8 ; &cloptr30566[1]
 %vptr30573 = alloca i64, align 8 
  %f30569 = load i64, i64* %i0ptr30567, align 8 
  store volatile i64 %f30569, i64* %vptr30573, align 8 ; load; *i0ptr30567
  %fptr30568 = inttoptr i64 %f30569 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30568(i64 %h11342, i64 %h11342)                     ; tail call
  ret void

else30563:
 %vptr30574 = alloca i64, align 8 
  %hvW$lst = call i64 @prim_car(i64 %rvp11336) 
  store volatile i64 %hvW$lst, i64* %vptr30574, align 8 ; call prim_car
 %vptr30575 = alloca i64, align 8 
  %na11302 = call i64 @prim_cdr(i64 %rvp11336) 
  store volatile i64 %na11302, i64* %vptr30575, align 8 ; call prim_cdr
 %vptr30576 = alloca i64, align 8 
  %n_6311337 = call i64 @prim_null_63(i64 %na11302) 
  store volatile i64 %n_6311337, i64* %vptr30576, align 8 ; call prim_null_63
  %cmpptr30580 = alloca i1, align 8  %cmp30577 = icmp eq i64 %n_6311337, 15 store volatile i1 %cmp30577, i1* %cmpptr30580, align 8; false?
  br i1 %cmp30577, label %else30579, label %then30578                                ; if

then30578:
 %vptr30581 = alloca i64, align 8 
  %a6913 = call i64 @prim_null_63(i64 %hvW$lst) 
  store volatile i64 %a6913, i64* %vptr30581, align 8 ; call prim_null_63
  %cmpptr30585 = alloca i1, align 8  %cmp30582 = icmp eq i64 %a6913, 15 store volatile i1 %cmp30582, i1* %cmpptr30585, align 8; false?
  br i1 %cmp30582, label %else30584, label %then30583                                ; if

then30583:
 %vptr30586 = alloca i64, align 8 
  %arg8586 = add i64 0, 0 
  store volatile i64 %arg8586, i64* %vptr30586, align 8 ; quoted ()
 %vptr30587 = alloca i64, align 8 
  %arg8585 = add i64 0, 0 
  store volatile i64 %arg8585, i64* %vptr30587, align 8 ; quoted ()
 %vptr30588 = alloca i64, align 8 
  %rva11305 = add i64 0, 0 
  store volatile i64 %rva11305, i64* %vptr30588, align 8 ; quoted ()
 %vptr30589 = alloca i64, align 8 
  %rva11304 = call i64 @prim_cons(i64 %arg8585, i64 %rva11305) 
  store volatile i64 %rva11304, i64* %vptr30589, align 8 ; call prim_cons
 %vptr30590 = alloca i64, align 8 
  %rva11303 = call i64 @prim_cons(i64 %arg8586, i64 %rva11304) 
  store volatile i64 %rva11303, i64* %vptr30590, align 8 ; call prim_cons
  %vptr30596 = alloca i64*, align 8 
  %cloptr30591 = inttoptr i64 %cont7352 to i64* 
  store volatile i64* %cloptr30591, i64** %vptr30596, align 8 ; closure/env cast; i64 -> i64*
  %vptr30597 = alloca i64*, align 8 
  %i0ptr30592 = getelementptr inbounds i64, i64* %cloptr30591, i64 1 
  store volatile i64* %i0ptr30592, i64** %vptr30597, align 8 ; &cloptr30591[1]
 %vptr30598 = alloca i64, align 8 
  %f30594 = load i64, i64* %i0ptr30592, align 8 
  store volatile i64 %f30594, i64* %vptr30598, align 8 ; load; *i0ptr30592
  %fptr30593 = inttoptr i64 %f30594 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30593(i64 %cont7352, i64 %rva11303)                 ; tail call
  ret void

else30584:
 %vptr30599 = alloca i64, align 8 
  %a6914 = call i64 @prim_car(i64 %hvW$lst) 
  store volatile i64 %a6914, i64* %vptr30599, align 8 ; call prim_car
  %vptr30609 = alloca i64*, align 8 
  %cloptr30600 = call i64* @make_closure(i64 56) 
  store volatile i64* %cloptr30600, i64** %vptr30609, align 8 ; malloc
  %vptr30610 = alloca i64*, align 8 
  %eptr30602 = getelementptr inbounds i64, i64* %cloptr30600, i64 2 
  store volatile i64* %eptr30602, i64** %vptr30610, align 8 ; &eptr30602[1]
  %vptr30611 = alloca i64*, align 8 
  %eptr30603 = getelementptr inbounds i64, i64* %cloptr30600, i64 3 
  store volatile i64* %eptr30603, i64** %vptr30611, align 8 ; &eptr30603[2]
  %vptr30612 = alloca i64*, align 8 
  %eptr30604 = getelementptr inbounds i64, i64* %cloptr30600, i64 4 
  store volatile i64* %eptr30604, i64** %vptr30612, align 8 ; &eptr30604[3]
  %vptr30613 = alloca i64*, align 8 
  %eptr30605 = getelementptr inbounds i64, i64* %cloptr30600, i64 5 
  store volatile i64* %eptr30605, i64** %vptr30613, align 8 ; &eptr30605[4]
  %vptr30614 = alloca i64*, align 8 
  %eptr30606 = getelementptr inbounds i64, i64* %cloptr30600, i64 6 
  store volatile i64* %eptr30606, i64** %vptr30614, align 8 ; &eptr30606[5]
  %vptr30615 = alloca i64*, align 8 
  %eptr30607 = getelementptr inbounds i64, i64* %cloptr30600, i64 7 
  store volatile i64* %eptr30607, i64** %vptr30615, align 8 ; &eptr30607[6]
  store i64 %nBN$_37map, i64* %eptr30602                                             ; *eptr30602 = %nBN$_37map
  store i64 %emsg18637, i64* %eptr30603                                              ; *eptr30603 = %emsg18637
  store i64 %Eoq$f, i64* %eptr30604                                                  ; *eptr30604 = %Eoq$f
  store i64 %cont7352, i64* %eptr30605                                               ; *eptr30605 = %cont7352
  store i64 %hvW$lst, i64* %eptr30606                                                ; *eptr30606 = %hvW$lst
  store i64 %emsg08636, i64* %eptr30607                                              ; *eptr30607 = %emsg08636
  %vptr30616 = alloca i64*, align 8 
  %eptr30601 = getelementptr inbounds i64, i64* %cloptr30600, i64 1 
  store volatile i64* %eptr30601, i64** %vptr30616, align 8 ; &cloptr30600[1]
 %vptr30617 = alloca i64, align 8 
  %f30608 = ptrtoint void(i64,i64)* @lam11529 to i64 
  store volatile i64 %f30608, i64* %vptr30617, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f30608, i64* %eptr30601                                                 ; store fptr
 %vptr30618 = alloca i64, align 8 
  %arg8590 = ptrtoint i64* %cloptr30600 to i64 
  store volatile i64 %arg8590, i64* %vptr30618, align 8 ; closure cast; i64* -> i64
 %vptr30619 = alloca i64, align 8 
  %rva11335 = add i64 0, 0 
  store volatile i64 %rva11335, i64* %vptr30619, align 8 ; quoted ()
 %vptr30620 = alloca i64, align 8 
  %rva11334 = call i64 @prim_cons(i64 %a6914, i64 %rva11335) 
  store volatile i64 %rva11334, i64* %vptr30620, align 8 ; call prim_cons
 %vptr30621 = alloca i64, align 8 
  %rva11333 = call i64 @prim_cons(i64 %arg8590, i64 %rva11334) 
  store volatile i64 %rva11333, i64* %vptr30621, align 8 ; call prim_cons
  %vptr30627 = alloca i64*, align 8 
  %cloptr30622 = inttoptr i64 %Eoq$f to i64* 
  store volatile i64* %cloptr30622, i64** %vptr30627, align 8 ; closure/env cast; i64 -> i64*
  %vptr30628 = alloca i64*, align 8 
  %i0ptr30623 = getelementptr inbounds i64, i64* %cloptr30622, i64 1 
  store volatile i64* %i0ptr30623, i64** %vptr30628, align 8 ; &cloptr30622[1]
 %vptr30629 = alloca i64, align 8 
  %f30625 = load i64, i64* %i0ptr30623, align 8 
  store volatile i64 %f30625, i64* %vptr30629, align 8 ; load; *i0ptr30623
  %fptr30624 = inttoptr i64 %f30625 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30624(i64 %Eoq$f, i64 %rva11333)                    ; tail call
  ret void

else30579:
 %vptr30630 = alloca i64, align 8 
  %h11338 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11338, i64* %vptr30630, align 8 ; call prim_halt
  %vptr30636 = alloca i64*, align 8 
  %cloptr30631 = inttoptr i64 %h11338 to i64* 
  store volatile i64* %cloptr30631, i64** %vptr30636, align 8 ; closure/env cast; i64 -> i64*
  %vptr30637 = alloca i64*, align 8 
  %i0ptr30632 = getelementptr inbounds i64, i64* %cloptr30631, i64 1 
  store volatile i64* %i0ptr30632, i64** %vptr30637, align 8 ; &cloptr30631[1]
 %vptr30638 = alloca i64, align 8 
  %f30634 = load i64, i64* %i0ptr30632, align 8 
  store volatile i64 %f30634, i64* %vptr30638, align 8 ; load; *i0ptr30632
  %fptr30633 = inttoptr i64 %f30634 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30633(i64 %h11338, i64 %h11338)                     ; tail call
  ret void
}


define void @lam11529(i64 %env11530, i64 %rvp11329) {
 %vptr30641 = alloca i64, align 8 
  %envptr30639 = inttoptr i64 %env11530 to i64* 
  store volatile i64 %emsg08636, i64* %vptr30641, align 8 ; closure/env cast; i64 -> i64*
  %vptr30642 = alloca i64*, align 8 
  %envptr30640 = getelementptr inbounds i64, i64* %envptr30639, i64 7 
  store volatile i64* %envptr30640, i64** %vptr30642, align 8 ; &envptr30639[6]
 %vptr30643 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr30640, align 8 
  store volatile i64 %emsg08636, i64* %vptr30643, align 8 ; load; *envptr30640
 %vptr30646 = alloca i64, align 8 
  %envptr30644 = inttoptr i64 %env11530 to i64* 
  store volatile i64 %hvW$lst, i64* %vptr30646, align 8 ; closure/env cast; i64 -> i64*
  %vptr30647 = alloca i64*, align 8 
  %envptr30645 = getelementptr inbounds i64, i64* %envptr30644, i64 6 
  store volatile i64* %envptr30645, i64** %vptr30647, align 8 ; &envptr30644[5]
 %vptr30648 = alloca i64, align 8 
  %hvW$lst = load i64, i64* %envptr30645, align 8 
  store volatile i64 %hvW$lst, i64* %vptr30648, align 8 ; load; *envptr30645
 %vptr30651 = alloca i64, align 8 
  %envptr30649 = inttoptr i64 %env11530 to i64* 
  store volatile i64 %cont7352, i64* %vptr30651, align 8 ; closure/env cast; i64 -> i64*
  %vptr30652 = alloca i64*, align 8 
  %envptr30650 = getelementptr inbounds i64, i64* %envptr30649, i64 5 
  store volatile i64* %envptr30650, i64** %vptr30652, align 8 ; &envptr30649[4]
 %vptr30653 = alloca i64, align 8 
  %cont7352 = load i64, i64* %envptr30650, align 8 
  store volatile i64 %cont7352, i64* %vptr30653, align 8 ; load; *envptr30650
 %vptr30656 = alloca i64, align 8 
  %envptr30654 = inttoptr i64 %env11530 to i64* 
  store volatile i64 %Eoq$f, i64* %vptr30656, align 8 ; closure/env cast; i64 -> i64*
  %vptr30657 = alloca i64*, align 8 
  %envptr30655 = getelementptr inbounds i64, i64* %envptr30654, i64 4 
  store volatile i64* %envptr30655, i64** %vptr30657, align 8 ; &envptr30654[3]
 %vptr30658 = alloca i64, align 8 
  %Eoq$f = load i64, i64* %envptr30655, align 8 
  store volatile i64 %Eoq$f, i64* %vptr30658, align 8 ; load; *envptr30655
 %vptr30661 = alloca i64, align 8 
  %envptr30659 = inttoptr i64 %env11530 to i64* 
  store volatile i64 %emsg18637, i64* %vptr30661, align 8 ; closure/env cast; i64 -> i64*
  %vptr30662 = alloca i64*, align 8 
  %envptr30660 = getelementptr inbounds i64, i64* %envptr30659, i64 3 
  store volatile i64* %envptr30660, i64** %vptr30662, align 8 ; &envptr30659[2]
 %vptr30663 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr30660, align 8 
  store volatile i64 %emsg18637, i64* %vptr30663, align 8 ; load; *envptr30660
 %vptr30666 = alloca i64, align 8 
  %envptr30664 = inttoptr i64 %env11530 to i64* 
  store volatile i64 %nBN$_37map, i64* %vptr30666, align 8 ; closure/env cast; i64 -> i64*
  %vptr30667 = alloca i64*, align 8 
  %envptr30665 = getelementptr inbounds i64, i64* %envptr30664, i64 2 
  store volatile i64* %envptr30665, i64** %vptr30667, align 8 ; &envptr30664[1]
 %vptr30668 = alloca i64, align 8 
  %nBN$_37map = load i64, i64* %envptr30665, align 8 
  store volatile i64 %nBN$_37map, i64* %vptr30668, align 8 ; load; *envptr30665
 %vptr30669 = alloca i64, align 8 
  %_957353 = call i64 @prim_car(i64 %rvp11329) 
  store volatile i64 %_957353, i64* %vptr30669, align 8 ; call prim_car
 %vptr30670 = alloca i64, align 8 
  %rvp11325 = call i64 @prim_cdr(i64 %rvp11329) 
  store volatile i64 %rvp11325, i64* %vptr30670, align 8 ; call prim_cdr
 %vptr30671 = alloca i64, align 8 
  %n_6311330 = call i64 @prim_null_63(i64 %rvp11325) 
  store volatile i64 %n_6311330, i64* %vptr30671, align 8 ; call prim_null_63
  %cmpptr30675 = alloca i1, align 8  %cmp30672 = icmp eq i64 %n_6311330, 15 store volatile i1 %cmp30672, i1* %cmpptr30675, align 8; false?
  br i1 %cmp30672, label %else30674, label %then30673                                ; if

then30673:
 %vptr30676 = alloca i64, align 8 
  %h11331 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11331, i64* %vptr30676, align 8 ; call prim_halt
  %vptr30682 = alloca i64*, align 8 
  %cloptr30677 = inttoptr i64 %h11331 to i64* 
  store volatile i64* %cloptr30677, i64** %vptr30682, align 8 ; closure/env cast; i64 -> i64*
  %vptr30683 = alloca i64*, align 8 
  %i0ptr30678 = getelementptr inbounds i64, i64* %cloptr30677, i64 1 
  store volatile i64* %i0ptr30678, i64** %vptr30683, align 8 ; &cloptr30677[1]
 %vptr30684 = alloca i64, align 8 
  %f30680 = load i64, i64* %i0ptr30678, align 8 
  store volatile i64 %f30680, i64* %vptr30684, align 8 ; load; *i0ptr30678
  %fptr30679 = inttoptr i64 %f30680 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30679(i64 %h11331, i64 %h11331)                     ; tail call
  ret void

else30674:
 %vptr30685 = alloca i64, align 8 
  %a6915 = call i64 @prim_car(i64 %rvp11325) 
  store volatile i64 %a6915, i64* %vptr30685, align 8 ; call prim_car
 %vptr30686 = alloca i64, align 8 
  %na11307 = call i64 @prim_cdr(i64 %rvp11325) 
  store volatile i64 %na11307, i64* %vptr30686, align 8 ; call prim_cdr
 %vptr30687 = alloca i64, align 8 
  %n_6311326 = call i64 @prim_null_63(i64 %na11307) 
  store volatile i64 %n_6311326, i64* %vptr30687, align 8 ; call prim_null_63
  %cmpptr30691 = alloca i1, align 8  %cmp30688 = icmp eq i64 %n_6311326, 15 store volatile i1 %cmp30688, i1* %cmpptr30691, align 8; false?
  br i1 %cmp30688, label %else30690, label %then30689                                ; if

then30689:
 %vptr30692 = alloca i64, align 8 
  %a6916 = call i64 @prim_cdr(i64 %hvW$lst) 
  store volatile i64 %a6916, i64* %vptr30692, align 8 ; call prim_cdr
  %vptr30700 = alloca i64*, align 8 
  %cloptr30693 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr30693, i64** %vptr30700, align 8 ; malloc
  %vptr30701 = alloca i64*, align 8 
  %eptr30695 = getelementptr inbounds i64, i64* %cloptr30693, i64 2 
  store volatile i64* %eptr30695, i64** %vptr30701, align 8 ; &eptr30695[1]
  %vptr30702 = alloca i64*, align 8 
  %eptr30696 = getelementptr inbounds i64, i64* %cloptr30693, i64 3 
  store volatile i64* %eptr30696, i64** %vptr30702, align 8 ; &eptr30696[2]
  %vptr30703 = alloca i64*, align 8 
  %eptr30697 = getelementptr inbounds i64, i64* %cloptr30693, i64 4 
  store volatile i64* %eptr30697, i64** %vptr30703, align 8 ; &eptr30697[3]
  %vptr30704 = alloca i64*, align 8 
  %eptr30698 = getelementptr inbounds i64, i64* %cloptr30693, i64 5 
  store volatile i64* %eptr30698, i64** %vptr30704, align 8 ; &eptr30698[4]
  store i64 %emsg18637, i64* %eptr30695                                              ; *eptr30695 = %emsg18637
  store i64 %cont7352, i64* %eptr30696                                               ; *eptr30696 = %cont7352
  store i64 %a6915, i64* %eptr30697                                                  ; *eptr30697 = %a6915
  store i64 %emsg08636, i64* %eptr30698                                              ; *eptr30698 = %emsg08636
  %vptr30705 = alloca i64*, align 8 
  %eptr30694 = getelementptr inbounds i64, i64* %cloptr30693, i64 1 
  store volatile i64* %eptr30694, i64** %vptr30705, align 8 ; &cloptr30693[1]
 %vptr30706 = alloca i64, align 8 
  %f30699 = ptrtoint void(i64,i64)* @lam11527 to i64 
  store volatile i64 %f30699, i64* %vptr30706, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f30699, i64* %eptr30694                                                 ; store fptr
 %vptr30707 = alloca i64, align 8 
  %arg8595 = ptrtoint i64* %cloptr30693 to i64 
  store volatile i64 %arg8595, i64* %vptr30707, align 8 ; closure cast; i64* -> i64
 %vptr30708 = alloca i64, align 8 
  %rva11324 = add i64 0, 0 
  store volatile i64 %rva11324, i64* %vptr30708, align 8 ; quoted ()
 %vptr30709 = alloca i64, align 8 
  %rva11323 = call i64 @prim_cons(i64 %a6916, i64 %rva11324) 
  store volatile i64 %rva11323, i64* %vptr30709, align 8 ; call prim_cons
 %vptr30710 = alloca i64, align 8 
  %rva11322 = call i64 @prim_cons(i64 %Eoq$f, i64 %rva11323) 
  store volatile i64 %rva11322, i64* %vptr30710, align 8 ; call prim_cons
 %vptr30711 = alloca i64, align 8 
  %rva11321 = call i64 @prim_cons(i64 %arg8595, i64 %rva11322) 
  store volatile i64 %rva11321, i64* %vptr30711, align 8 ; call prim_cons
  %vptr30717 = alloca i64*, align 8 
  %cloptr30712 = inttoptr i64 %nBN$_37map to i64* 
  store volatile i64* %cloptr30712, i64** %vptr30717, align 8 ; closure/env cast; i64 -> i64*
  %vptr30718 = alloca i64*, align 8 
  %i0ptr30713 = getelementptr inbounds i64, i64* %cloptr30712, i64 1 
  store volatile i64* %i0ptr30713, i64** %vptr30718, align 8 ; &cloptr30712[1]
 %vptr30719 = alloca i64, align 8 
  %f30715 = load i64, i64* %i0ptr30713, align 8 
  store volatile i64 %f30715, i64* %vptr30719, align 8 ; load; *i0ptr30713
  %fptr30714 = inttoptr i64 %f30715 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30714(i64 %nBN$_37map, i64 %rva11321)               ; tail call
  ret void

else30690:
 %vptr30720 = alloca i64, align 8 
  %h11327 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11327, i64* %vptr30720, align 8 ; call prim_halt
  %vptr30726 = alloca i64*, align 8 
  %cloptr30721 = inttoptr i64 %h11327 to i64* 
  store volatile i64* %cloptr30721, i64** %vptr30726, align 8 ; closure/env cast; i64 -> i64*
  %vptr30727 = alloca i64*, align 8 
  %i0ptr30722 = getelementptr inbounds i64, i64* %cloptr30721, i64 1 
  store volatile i64* %i0ptr30722, i64** %vptr30727, align 8 ; &cloptr30721[1]
 %vptr30728 = alloca i64, align 8 
  %f30724 = load i64, i64* %i0ptr30722, align 8 
  store volatile i64 %f30724, i64* %vptr30728, align 8 ; load; *i0ptr30722
  %fptr30723 = inttoptr i64 %f30724 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30723(i64 %h11327, i64 %h11327)                     ; tail call
  ret void
}


define void @lam11527(i64 %env11528, i64 %rvp11317) {
 %vptr30731 = alloca i64, align 8 
  %envptr30729 = inttoptr i64 %env11528 to i64* 
  store volatile i64 %emsg08636, i64* %vptr30731, align 8 ; closure/env cast; i64 -> i64*
  %vptr30732 = alloca i64*, align 8 
  %envptr30730 = getelementptr inbounds i64, i64* %envptr30729, i64 5 
  store volatile i64* %envptr30730, i64** %vptr30732, align 8 ; &envptr30729[4]
 %vptr30733 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr30730, align 8 
  store volatile i64 %emsg08636, i64* %vptr30733, align 8 ; load; *envptr30730
 %vptr30736 = alloca i64, align 8 
  %envptr30734 = inttoptr i64 %env11528 to i64* 
  store volatile i64 %a6915, i64* %vptr30736, align 8 ; closure/env cast; i64 -> i64*
  %vptr30737 = alloca i64*, align 8 
  %envptr30735 = getelementptr inbounds i64, i64* %envptr30734, i64 4 
  store volatile i64* %envptr30735, i64** %vptr30737, align 8 ; &envptr30734[3]
 %vptr30738 = alloca i64, align 8 
  %a6915 = load i64, i64* %envptr30735, align 8 
  store volatile i64 %a6915, i64* %vptr30738, align 8 ; load; *envptr30735
 %vptr30741 = alloca i64, align 8 
  %envptr30739 = inttoptr i64 %env11528 to i64* 
  store volatile i64 %cont7352, i64* %vptr30741, align 8 ; closure/env cast; i64 -> i64*
  %vptr30742 = alloca i64*, align 8 
  %envptr30740 = getelementptr inbounds i64, i64* %envptr30739, i64 3 
  store volatile i64* %envptr30740, i64** %vptr30742, align 8 ; &envptr30739[2]
 %vptr30743 = alloca i64, align 8 
  %cont7352 = load i64, i64* %envptr30740, align 8 
  store volatile i64 %cont7352, i64* %vptr30743, align 8 ; load; *envptr30740
 %vptr30746 = alloca i64, align 8 
  %envptr30744 = inttoptr i64 %env11528 to i64* 
  store volatile i64 %emsg18637, i64* %vptr30746, align 8 ; closure/env cast; i64 -> i64*
  %vptr30747 = alloca i64*, align 8 
  %envptr30745 = getelementptr inbounds i64, i64* %envptr30744, i64 2 
  store volatile i64* %envptr30745, i64** %vptr30747, align 8 ; &envptr30744[1]
 %vptr30748 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr30745, align 8 
  store volatile i64 %emsg18637, i64* %vptr30748, align 8 ; load; *envptr30745
 %vptr30749 = alloca i64, align 8 
  %_957354 = call i64 @prim_car(i64 %rvp11317) 
  store volatile i64 %_957354, i64* %vptr30749, align 8 ; call prim_car
 %vptr30750 = alloca i64, align 8 
  %rvp11313 = call i64 @prim_cdr(i64 %rvp11317) 
  store volatile i64 %rvp11313, i64* %vptr30750, align 8 ; call prim_cdr
 %vptr30751 = alloca i64, align 8 
  %n_6311318 = call i64 @prim_null_63(i64 %rvp11313) 
  store volatile i64 %n_6311318, i64* %vptr30751, align 8 ; call prim_null_63
  %cmpptr30755 = alloca i1, align 8  %cmp30752 = icmp eq i64 %n_6311318, 15 store volatile i1 %cmp30752, i1* %cmpptr30755, align 8; false?
  br i1 %cmp30752, label %else30754, label %then30753                                ; if

then30753:
 %vptr30756 = alloca i64, align 8 
  %h11319 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11319, i64* %vptr30756, align 8 ; call prim_halt
  %vptr30762 = alloca i64*, align 8 
  %cloptr30757 = inttoptr i64 %h11319 to i64* 
  store volatile i64* %cloptr30757, i64** %vptr30762, align 8 ; closure/env cast; i64 -> i64*
  %vptr30763 = alloca i64*, align 8 
  %i0ptr30758 = getelementptr inbounds i64, i64* %cloptr30757, i64 1 
  store volatile i64* %i0ptr30758, i64** %vptr30763, align 8 ; &cloptr30757[1]
 %vptr30764 = alloca i64, align 8 
  %f30760 = load i64, i64* %i0ptr30758, align 8 
  store volatile i64 %f30760, i64* %vptr30764, align 8 ; load; *i0ptr30758
  %fptr30759 = inttoptr i64 %f30760 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30759(i64 %h11319, i64 %h11319)                     ; tail call
  ret void

else30754:
 %vptr30765 = alloca i64, align 8 
  %a6917 = call i64 @prim_car(i64 %rvp11313) 
  store volatile i64 %a6917, i64* %vptr30765, align 8 ; call prim_car
 %vptr30766 = alloca i64, align 8 
  %na11309 = call i64 @prim_cdr(i64 %rvp11313) 
  store volatile i64 %na11309, i64* %vptr30766, align 8 ; call prim_cdr
 %vptr30767 = alloca i64, align 8 
  %n_6311314 = call i64 @prim_null_63(i64 %na11309) 
  store volatile i64 %n_6311314, i64* %vptr30767, align 8 ; call prim_null_63
  %cmpptr30771 = alloca i1, align 8  %cmp30768 = icmp eq i64 %n_6311314, 15 store volatile i1 %cmp30768, i1* %cmpptr30771, align 8; false?
  br i1 %cmp30768, label %else30770, label %then30769                                ; if

then30769:
 %vptr30772 = alloca i64, align 8 
  %retprim7355 = call i64 @prim_cons(i64 %a6915, i64 %a6917) 
  store volatile i64 %retprim7355, i64* %vptr30772, align 8 ; call prim_cons
 %vptr30773 = alloca i64, align 8 
  %arg8600 = add i64 0, 0 
  store volatile i64 %arg8600, i64* %vptr30773, align 8 ; quoted ()
 %vptr30774 = alloca i64, align 8 
  %rva11312 = add i64 0, 0 
  store volatile i64 %rva11312, i64* %vptr30774, align 8 ; quoted ()
 %vptr30775 = alloca i64, align 8 
  %rva11311 = call i64 @prim_cons(i64 %retprim7355, i64 %rva11312) 
  store volatile i64 %rva11311, i64* %vptr30775, align 8 ; call prim_cons
 %vptr30776 = alloca i64, align 8 
  %rva11310 = call i64 @prim_cons(i64 %arg8600, i64 %rva11311) 
  store volatile i64 %rva11310, i64* %vptr30776, align 8 ; call prim_cons
  %vptr30782 = alloca i64*, align 8 
  %cloptr30777 = inttoptr i64 %cont7352 to i64* 
  store volatile i64* %cloptr30777, i64** %vptr30782, align 8 ; closure/env cast; i64 -> i64*
  %vptr30783 = alloca i64*, align 8 
  %i0ptr30778 = getelementptr inbounds i64, i64* %cloptr30777, i64 1 
  store volatile i64* %i0ptr30778, i64** %vptr30783, align 8 ; &cloptr30777[1]
 %vptr30784 = alloca i64, align 8 
  %f30780 = load i64, i64* %i0ptr30778, align 8 
  store volatile i64 %f30780, i64* %vptr30784, align 8 ; load; *i0ptr30778
  %fptr30779 = inttoptr i64 %f30780 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30779(i64 %cont7352, i64 %rva11310)                 ; tail call
  ret void

else30770:
 %vptr30785 = alloca i64, align 8 
  %h11315 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11315, i64* %vptr30785, align 8 ; call prim_halt
  %vptr30791 = alloca i64*, align 8 
  %cloptr30786 = inttoptr i64 %h11315 to i64* 
  store volatile i64* %cloptr30786, i64** %vptr30791, align 8 ; closure/env cast; i64 -> i64*
  %vptr30792 = alloca i64*, align 8 
  %i0ptr30787 = getelementptr inbounds i64, i64* %cloptr30786, i64 1 
  store volatile i64* %i0ptr30787, i64** %vptr30792, align 8 ; &cloptr30786[1]
 %vptr30793 = alloca i64, align 8 
  %f30789 = load i64, i64* %i0ptr30787, align 8 
  store volatile i64 %f30789, i64* %vptr30793, align 8 ; load; *i0ptr30787
  %fptr30788 = inttoptr i64 %f30789 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30788(i64 %h11315, i64 %h11315)                     ; tail call
  ret void
}


define void @lam11516(i64 %env11517, i64 %rvp11419) {
 %vptr30796 = alloca i64, align 8 
  %envptr30794 = inttoptr i64 %env11517 to i64* 
  store volatile i64 %emsg08636, i64* %vptr30796, align 8 ; closure/env cast; i64 -> i64*
  %vptr30797 = alloca i64*, align 8 
  %envptr30795 = getelementptr inbounds i64, i64* %envptr30794, i64 3 
  store volatile i64* %envptr30795, i64** %vptr30797, align 8 ; &envptr30794[2]
 %vptr30798 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr30795, align 8 
  store volatile i64 %emsg08636, i64* %vptr30798, align 8 ; load; *envptr30795
 %vptr30801 = alloca i64, align 8 
  %envptr30799 = inttoptr i64 %env11517 to i64* 
  store volatile i64 %emsg18637, i64* %vptr30801, align 8 ; closure/env cast; i64 -> i64*
  %vptr30802 = alloca i64*, align 8 
  %envptr30800 = getelementptr inbounds i64, i64* %envptr30799, i64 2 
  store volatile i64* %envptr30800, i64** %vptr30802, align 8 ; &envptr30799[1]
 %vptr30803 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr30800, align 8 
  store volatile i64 %emsg18637, i64* %vptr30803, align 8 ; load; *envptr30800
 %vptr30804 = alloca i64, align 8 
  %cont7356 = call i64 @prim_car(i64 %rvp11419) 
  store volatile i64 %cont7356, i64* %vptr30804, align 8 ; call prim_car
 %vptr30805 = alloca i64, align 8 
  %rvp11415 = call i64 @prim_cdr(i64 %rvp11419) 
  store volatile i64 %rvp11415, i64* %vptr30805, align 8 ; call prim_cdr
 %vptr30806 = alloca i64, align 8 
  %n_6311420 = call i64 @prim_null_63(i64 %rvp11415) 
  store volatile i64 %n_6311420, i64* %vptr30806, align 8 ; call prim_null_63
  %cmpptr30810 = alloca i1, align 8  %cmp30807 = icmp eq i64 %n_6311420, 15 store volatile i1 %cmp30807, i1* %cmpptr30810, align 8; false?
  br i1 %cmp30807, label %else30809, label %then30808                                ; if

then30808:
 %vptr30811 = alloca i64, align 8 
  %h11421 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11421, i64* %vptr30811, align 8 ; call prim_halt
  %vptr30817 = alloca i64*, align 8 
  %cloptr30812 = inttoptr i64 %h11421 to i64* 
  store volatile i64* %cloptr30812, i64** %vptr30817, align 8 ; closure/env cast; i64 -> i64*
  %vptr30818 = alloca i64*, align 8 
  %i0ptr30813 = getelementptr inbounds i64, i64* %cloptr30812, i64 1 
  store volatile i64* %i0ptr30813, i64** %vptr30818, align 8 ; &cloptr30812[1]
 %vptr30819 = alloca i64, align 8 
  %f30815 = load i64, i64* %i0ptr30813, align 8 
  store volatile i64 %f30815, i64* %vptr30819, align 8 ; load; *i0ptr30813
  %fptr30814 = inttoptr i64 %f30815 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30814(i64 %h11421, i64 %h11421)                     ; tail call
  ret void

else30809:
 %vptr30820 = alloca i64, align 8 
  %YhE$_37foldr1 = call i64 @prim_car(i64 %rvp11415) 
  store volatile i64 %YhE$_37foldr1, i64* %vptr30820, align 8 ; call prim_car
 %vptr30821 = alloca i64, align 8 
  %na11371 = call i64 @prim_cdr(i64 %rvp11415) 
  store volatile i64 %na11371, i64* %vptr30821, align 8 ; call prim_cdr
 %vptr30822 = alloca i64, align 8 
  %n_6311416 = call i64 @prim_null_63(i64 %na11371) 
  store volatile i64 %n_6311416, i64* %vptr30822, align 8 ; call prim_null_63
  %cmpptr30826 = alloca i1, align 8  %cmp30823 = icmp eq i64 %n_6311416, 15 store volatile i1 %cmp30823, i1* %cmpptr30826, align 8; false?
  br i1 %cmp30823, label %else30825, label %then30824                                ; if

then30824:
 %vptr30827 = alloca i64, align 8 
  %arg8603 = add i64 0, 0 
  store volatile i64 %arg8603, i64* %vptr30827, align 8 ; quoted ()
  %vptr30834 = alloca i64*, align 8 
  %cloptr30828 = call i64* @make_closure(i64 32) 
  store volatile i64* %cloptr30828, i64** %vptr30834, align 8 ; malloc
  %vptr30835 = alloca i64*, align 8 
  %eptr30830 = getelementptr inbounds i64, i64* %cloptr30828, i64 2 
  store volatile i64* %eptr30830, i64** %vptr30835, align 8 ; &eptr30830[1]
  %vptr30836 = alloca i64*, align 8 
  %eptr30831 = getelementptr inbounds i64, i64* %cloptr30828, i64 3 
  store volatile i64* %eptr30831, i64** %vptr30836, align 8 ; &eptr30831[2]
  %vptr30837 = alloca i64*, align 8 
  %eptr30832 = getelementptr inbounds i64, i64* %cloptr30828, i64 4 
  store volatile i64* %eptr30832, i64** %vptr30837, align 8 ; &eptr30832[3]
  store i64 %emsg18637, i64* %eptr30830                                              ; *eptr30830 = %emsg18637
  store i64 %YhE$_37foldr1, i64* %eptr30831                                          ; *eptr30831 = %YhE$_37foldr1
  store i64 %emsg08636, i64* %eptr30832                                              ; *eptr30832 = %emsg08636
  %vptr30838 = alloca i64*, align 8 
  %eptr30829 = getelementptr inbounds i64, i64* %cloptr30828, i64 1 
  store volatile i64* %eptr30829, i64** %vptr30838, align 8 ; &cloptr30828[1]
 %vptr30839 = alloca i64, align 8 
  %f30833 = ptrtoint void(i64,i64)* @lam11513 to i64 
  store volatile i64 %f30833, i64* %vptr30839, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f30833, i64* %eptr30829                                                 ; store fptr
 %vptr30840 = alloca i64, align 8 
  %arg8602 = ptrtoint i64* %cloptr30828 to i64 
  store volatile i64 %arg8602, i64* %vptr30840, align 8 ; closure cast; i64* -> i64
 %vptr30841 = alloca i64, align 8 
  %rva11414 = add i64 0, 0 
  store volatile i64 %rva11414, i64* %vptr30841, align 8 ; quoted ()
 %vptr30842 = alloca i64, align 8 
  %rva11413 = call i64 @prim_cons(i64 %arg8602, i64 %rva11414) 
  store volatile i64 %rva11413, i64* %vptr30842, align 8 ; call prim_cons
 %vptr30843 = alloca i64, align 8 
  %rva11412 = call i64 @prim_cons(i64 %arg8603, i64 %rva11413) 
  store volatile i64 %rva11412, i64* %vptr30843, align 8 ; call prim_cons
  %vptr30849 = alloca i64*, align 8 
  %cloptr30844 = inttoptr i64 %cont7356 to i64* 
  store volatile i64* %cloptr30844, i64** %vptr30849, align 8 ; closure/env cast; i64 -> i64*
  %vptr30850 = alloca i64*, align 8 
  %i0ptr30845 = getelementptr inbounds i64, i64* %cloptr30844, i64 1 
  store volatile i64* %i0ptr30845, i64** %vptr30850, align 8 ; &cloptr30844[1]
 %vptr30851 = alloca i64, align 8 
  %f30847 = load i64, i64* %i0ptr30845, align 8 
  store volatile i64 %f30847, i64* %vptr30851, align 8 ; load; *i0ptr30845
  %fptr30846 = inttoptr i64 %f30847 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30846(i64 %cont7356, i64 %rva11412)                 ; tail call
  ret void

else30825:
 %vptr30852 = alloca i64, align 8 
  %h11417 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11417, i64* %vptr30852, align 8 ; call prim_halt
  %vptr30858 = alloca i64*, align 8 
  %cloptr30853 = inttoptr i64 %h11417 to i64* 
  store volatile i64* %cloptr30853, i64** %vptr30858, align 8 ; closure/env cast; i64 -> i64*
  %vptr30859 = alloca i64*, align 8 
  %i0ptr30854 = getelementptr inbounds i64, i64* %cloptr30853, i64 1 
  store volatile i64* %i0ptr30854, i64** %vptr30859, align 8 ; &cloptr30853[1]
 %vptr30860 = alloca i64, align 8 
  %f30856 = load i64, i64* %i0ptr30854, align 8 
  store volatile i64 %f30856, i64* %vptr30860, align 8 ; load; *i0ptr30854
  %fptr30855 = inttoptr i64 %f30856 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30855(i64 %h11417, i64 %h11417)                     ; tail call
  ret void
}


define void @lam11513(i64 %env11514, i64 %rvp11408) {
 %vptr30863 = alloca i64, align 8 
  %envptr30861 = inttoptr i64 %env11514 to i64* 
  store volatile i64 %emsg08636, i64* %vptr30863, align 8 ; closure/env cast; i64 -> i64*
  %vptr30864 = alloca i64*, align 8 
  %envptr30862 = getelementptr inbounds i64, i64* %envptr30861, i64 4 
  store volatile i64* %envptr30862, i64** %vptr30864, align 8 ; &envptr30861[3]
 %vptr30865 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr30862, align 8 
  store volatile i64 %emsg08636, i64* %vptr30865, align 8 ; load; *envptr30862
 %vptr30868 = alloca i64, align 8 
  %envptr30866 = inttoptr i64 %env11514 to i64* 
  store volatile i64 %YhE$_37foldr1, i64* %vptr30868, align 8 ; closure/env cast; i64 -> i64*
  %vptr30869 = alloca i64*, align 8 
  %envptr30867 = getelementptr inbounds i64, i64* %envptr30866, i64 3 
  store volatile i64* %envptr30867, i64** %vptr30869, align 8 ; &envptr30866[2]
 %vptr30870 = alloca i64, align 8 
  %YhE$_37foldr1 = load i64, i64* %envptr30867, align 8 
  store volatile i64 %YhE$_37foldr1, i64* %vptr30870, align 8 ; load; *envptr30867
 %vptr30873 = alloca i64, align 8 
  %envptr30871 = inttoptr i64 %env11514 to i64* 
  store volatile i64 %emsg18637, i64* %vptr30873, align 8 ; closure/env cast; i64 -> i64*
  %vptr30874 = alloca i64*, align 8 
  %envptr30872 = getelementptr inbounds i64, i64* %envptr30871, i64 2 
  store volatile i64* %envptr30872, i64** %vptr30874, align 8 ; &envptr30871[1]
 %vptr30875 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr30872, align 8 
  store volatile i64 %emsg18637, i64* %vptr30875, align 8 ; load; *envptr30872
 %vptr30876 = alloca i64, align 8 
  %cont7357 = call i64 @prim_car(i64 %rvp11408) 
  store volatile i64 %cont7357, i64* %vptr30876, align 8 ; call prim_car
 %vptr30877 = alloca i64, align 8 
  %rvp11404 = call i64 @prim_cdr(i64 %rvp11408) 
  store volatile i64 %rvp11404, i64* %vptr30877, align 8 ; call prim_cdr
 %vptr30878 = alloca i64, align 8 
  %n_6311409 = call i64 @prim_null_63(i64 %rvp11404) 
  store volatile i64 %n_6311409, i64* %vptr30878, align 8 ; call prim_null_63
  %cmpptr30882 = alloca i1, align 8  %cmp30879 = icmp eq i64 %n_6311409, 15 store volatile i1 %cmp30879, i1* %cmpptr30882, align 8; false?
  br i1 %cmp30879, label %else30881, label %then30880                                ; if

then30880:
 %vptr30883 = alloca i64, align 8 
  %h11410 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11410, i64* %vptr30883, align 8 ; call prim_halt
  %vptr30889 = alloca i64*, align 8 
  %cloptr30884 = inttoptr i64 %h11410 to i64* 
  store volatile i64* %cloptr30884, i64** %vptr30889, align 8 ; closure/env cast; i64 -> i64*
  %vptr30890 = alloca i64*, align 8 
  %i0ptr30885 = getelementptr inbounds i64, i64* %cloptr30884, i64 1 
  store volatile i64* %i0ptr30885, i64** %vptr30890, align 8 ; &cloptr30884[1]
 %vptr30891 = alloca i64, align 8 
  %f30887 = load i64, i64* %i0ptr30885, align 8 
  store volatile i64 %f30887, i64* %vptr30891, align 8 ; load; *i0ptr30885
  %fptr30886 = inttoptr i64 %f30887 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30886(i64 %h11410, i64 %h11410)                     ; tail call
  ret void

else30881:
 %vptr30892 = alloca i64, align 8 
  %ICf$f = call i64 @prim_car(i64 %rvp11404) 
  store volatile i64 %ICf$f, i64* %vptr30892, align 8 ; call prim_car
 %vptr30893 = alloca i64, align 8 
  %rvp11400 = call i64 @prim_cdr(i64 %rvp11404) 
  store volatile i64 %rvp11400, i64* %vptr30893, align 8 ; call prim_cdr
 %vptr30894 = alloca i64, align 8 
  %n_6311405 = call i64 @prim_null_63(i64 %rvp11400) 
  store volatile i64 %n_6311405, i64* %vptr30894, align 8 ; call prim_null_63
  %cmpptr30898 = alloca i1, align 8  %cmp30895 = icmp eq i64 %n_6311405, 15 store volatile i1 %cmp30895, i1* %cmpptr30898, align 8; false?
  br i1 %cmp30895, label %else30897, label %then30896                                ; if

then30896:
 %vptr30899 = alloca i64, align 8 
  %h11406 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11406, i64* %vptr30899, align 8 ; call prim_halt
  %vptr30905 = alloca i64*, align 8 
  %cloptr30900 = inttoptr i64 %h11406 to i64* 
  store volatile i64* %cloptr30900, i64** %vptr30905, align 8 ; closure/env cast; i64 -> i64*
  %vptr30906 = alloca i64*, align 8 
  %i0ptr30901 = getelementptr inbounds i64, i64* %cloptr30900, i64 1 
  store volatile i64* %i0ptr30901, i64** %vptr30906, align 8 ; &cloptr30900[1]
 %vptr30907 = alloca i64, align 8 
  %f30903 = load i64, i64* %i0ptr30901, align 8 
  store volatile i64 %f30903, i64* %vptr30907, align 8 ; load; *i0ptr30901
  %fptr30902 = inttoptr i64 %f30903 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30902(i64 %h11406, i64 %h11406)                     ; tail call
  ret void

else30897:
 %vptr30908 = alloca i64, align 8 
  %IlK$acc = call i64 @prim_car(i64 %rvp11400) 
  store volatile i64 %IlK$acc, i64* %vptr30908, align 8 ; call prim_car
 %vptr30909 = alloca i64, align 8 
  %rvp11396 = call i64 @prim_cdr(i64 %rvp11400) 
  store volatile i64 %rvp11396, i64* %vptr30909, align 8 ; call prim_cdr
 %vptr30910 = alloca i64, align 8 
  %n_6311401 = call i64 @prim_null_63(i64 %rvp11396) 
  store volatile i64 %n_6311401, i64* %vptr30910, align 8 ; call prim_null_63
  %cmpptr30914 = alloca i1, align 8  %cmp30911 = icmp eq i64 %n_6311401, 15 store volatile i1 %cmp30911, i1* %cmpptr30914, align 8; false?
  br i1 %cmp30911, label %else30913, label %then30912                                ; if

then30912:
 %vptr30915 = alloca i64, align 8 
  %h11402 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11402, i64* %vptr30915, align 8 ; call prim_halt
  %vptr30921 = alloca i64*, align 8 
  %cloptr30916 = inttoptr i64 %h11402 to i64* 
  store volatile i64* %cloptr30916, i64** %vptr30921, align 8 ; closure/env cast; i64 -> i64*
  %vptr30922 = alloca i64*, align 8 
  %i0ptr30917 = getelementptr inbounds i64, i64* %cloptr30916, i64 1 
  store volatile i64* %i0ptr30917, i64** %vptr30922, align 8 ; &cloptr30916[1]
 %vptr30923 = alloca i64, align 8 
  %f30919 = load i64, i64* %i0ptr30917, align 8 
  store volatile i64 %f30919, i64* %vptr30923, align 8 ; load; *i0ptr30917
  %fptr30918 = inttoptr i64 %f30919 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30918(i64 %h11402, i64 %h11402)                     ; tail call
  ret void

else30913:
 %vptr30924 = alloca i64, align 8 
  %tvt$lst = call i64 @prim_car(i64 %rvp11396) 
  store volatile i64 %tvt$lst, i64* %vptr30924, align 8 ; call prim_car
 %vptr30925 = alloca i64, align 8 
  %na11373 = call i64 @prim_cdr(i64 %rvp11396) 
  store volatile i64 %na11373, i64* %vptr30925, align 8 ; call prim_cdr
 %vptr30926 = alloca i64, align 8 
  %n_6311397 = call i64 @prim_null_63(i64 %na11373) 
  store volatile i64 %n_6311397, i64* %vptr30926, align 8 ; call prim_null_63
  %cmpptr30930 = alloca i1, align 8  %cmp30927 = icmp eq i64 %n_6311397, 15 store volatile i1 %cmp30927, i1* %cmpptr30930, align 8; false?
  br i1 %cmp30927, label %else30929, label %then30928                                ; if

then30928:
 %vptr30931 = alloca i64, align 8 
  %a6909 = call i64 @prim_null_63(i64 %tvt$lst) 
  store volatile i64 %a6909, i64* %vptr30931, align 8 ; call prim_null_63
  %cmpptr30935 = alloca i1, align 8  %cmp30932 = icmp eq i64 %a6909, 15 store volatile i1 %cmp30932, i1* %cmpptr30935, align 8; false?
  br i1 %cmp30932, label %else30934, label %then30933                                ; if

then30933:
 %vptr30936 = alloca i64, align 8 
  %arg8607 = add i64 0, 0 
  store volatile i64 %arg8607, i64* %vptr30936, align 8 ; quoted ()
 %vptr30937 = alloca i64, align 8 
  %rva11376 = add i64 0, 0 
  store volatile i64 %rva11376, i64* %vptr30937, align 8 ; quoted ()
 %vptr30938 = alloca i64, align 8 
  %rva11375 = call i64 @prim_cons(i64 %IlK$acc, i64 %rva11376) 
  store volatile i64 %rva11375, i64* %vptr30938, align 8 ; call prim_cons
 %vptr30939 = alloca i64, align 8 
  %rva11374 = call i64 @prim_cons(i64 %arg8607, i64 %rva11375) 
  store volatile i64 %rva11374, i64* %vptr30939, align 8 ; call prim_cons
  %vptr30945 = alloca i64*, align 8 
  %cloptr30940 = inttoptr i64 %cont7357 to i64* 
  store volatile i64* %cloptr30940, i64** %vptr30945, align 8 ; closure/env cast; i64 -> i64*
  %vptr30946 = alloca i64*, align 8 
  %i0ptr30941 = getelementptr inbounds i64, i64* %cloptr30940, i64 1 
  store volatile i64* %i0ptr30941, i64** %vptr30946, align 8 ; &cloptr30940[1]
 %vptr30947 = alloca i64, align 8 
  %f30943 = load i64, i64* %i0ptr30941, align 8 
  store volatile i64 %f30943, i64* %vptr30947, align 8 ; load; *i0ptr30941
  %fptr30942 = inttoptr i64 %f30943 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30942(i64 %cont7357, i64 %rva11374)                 ; tail call
  ret void

else30934:
 %vptr30948 = alloca i64, align 8 
  %a6910 = call i64 @prim_car(i64 %tvt$lst) 
  store volatile i64 %a6910, i64* %vptr30948, align 8 ; call prim_car
 %vptr30949 = alloca i64, align 8 
  %a6911 = call i64 @prim_cdr(i64 %tvt$lst) 
  store volatile i64 %a6911, i64* %vptr30949, align 8 ; call prim_cdr
  %vptr30958 = alloca i64*, align 8 
  %cloptr30950 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr30950, i64** %vptr30958, align 8 ; malloc
  %vptr30959 = alloca i64*, align 8 
  %eptr30952 = getelementptr inbounds i64, i64* %cloptr30950, i64 2 
  store volatile i64* %eptr30952, i64** %vptr30959, align 8 ; &eptr30952[1]
  %vptr30960 = alloca i64*, align 8 
  %eptr30953 = getelementptr inbounds i64, i64* %cloptr30950, i64 3 
  store volatile i64* %eptr30953, i64** %vptr30960, align 8 ; &eptr30953[2]
  %vptr30961 = alloca i64*, align 8 
  %eptr30954 = getelementptr inbounds i64, i64* %cloptr30950, i64 4 
  store volatile i64* %eptr30954, i64** %vptr30961, align 8 ; &eptr30954[3]
  %vptr30962 = alloca i64*, align 8 
  %eptr30955 = getelementptr inbounds i64, i64* %cloptr30950, i64 5 
  store volatile i64* %eptr30955, i64** %vptr30962, align 8 ; &eptr30955[4]
  %vptr30963 = alloca i64*, align 8 
  %eptr30956 = getelementptr inbounds i64, i64* %cloptr30950, i64 6 
  store volatile i64* %eptr30956, i64** %vptr30963, align 8 ; &eptr30956[5]
  store i64 %emsg18637, i64* %eptr30952                                              ; *eptr30952 = %emsg18637
  store i64 %a6910, i64* %eptr30953                                                  ; *eptr30953 = %a6910
  store i64 %ICf$f, i64* %eptr30954                                                  ; *eptr30954 = %ICf$f
  store i64 %emsg08636, i64* %eptr30955                                              ; *eptr30955 = %emsg08636
  store i64 %cont7357, i64* %eptr30956                                               ; *eptr30956 = %cont7357
  %vptr30964 = alloca i64*, align 8 
  %eptr30951 = getelementptr inbounds i64, i64* %cloptr30950, i64 1 
  store volatile i64* %eptr30951, i64** %vptr30964, align 8 ; &cloptr30950[1]
 %vptr30965 = alloca i64, align 8 
  %f30957 = ptrtoint void(i64,i64)* @lam11511 to i64 
  store volatile i64 %f30957, i64* %vptr30965, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f30957, i64* %eptr30951                                                 ; store fptr
 %vptr30966 = alloca i64, align 8 
  %arg8614 = ptrtoint i64* %cloptr30950 to i64 
  store volatile i64 %arg8614, i64* %vptr30966, align 8 ; closure cast; i64* -> i64
 %vptr30967 = alloca i64, align 8 
  %rva11395 = add i64 0, 0 
  store volatile i64 %rva11395, i64* %vptr30967, align 8 ; quoted ()
 %vptr30968 = alloca i64, align 8 
  %rva11394 = call i64 @prim_cons(i64 %a6911, i64 %rva11395) 
  store volatile i64 %rva11394, i64* %vptr30968, align 8 ; call prim_cons
 %vptr30969 = alloca i64, align 8 
  %rva11393 = call i64 @prim_cons(i64 %IlK$acc, i64 %rva11394) 
  store volatile i64 %rva11393, i64* %vptr30969, align 8 ; call prim_cons
 %vptr30970 = alloca i64, align 8 
  %rva11392 = call i64 @prim_cons(i64 %ICf$f, i64 %rva11393) 
  store volatile i64 %rva11392, i64* %vptr30970, align 8 ; call prim_cons
 %vptr30971 = alloca i64, align 8 
  %rva11391 = call i64 @prim_cons(i64 %arg8614, i64 %rva11392) 
  store volatile i64 %rva11391, i64* %vptr30971, align 8 ; call prim_cons
  %vptr30977 = alloca i64*, align 8 
  %cloptr30972 = inttoptr i64 %YhE$_37foldr1 to i64* 
  store volatile i64* %cloptr30972, i64** %vptr30977, align 8 ; closure/env cast; i64 -> i64*
  %vptr30978 = alloca i64*, align 8 
  %i0ptr30973 = getelementptr inbounds i64, i64* %cloptr30972, i64 1 
  store volatile i64* %i0ptr30973, i64** %vptr30978, align 8 ; &cloptr30972[1]
 %vptr30979 = alloca i64, align 8 
  %f30975 = load i64, i64* %i0ptr30973, align 8 
  store volatile i64 %f30975, i64* %vptr30979, align 8 ; load; *i0ptr30973
  %fptr30974 = inttoptr i64 %f30975 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30974(i64 %YhE$_37foldr1, i64 %rva11391)            ; tail call
  ret void

else30929:
 %vptr30980 = alloca i64, align 8 
  %h11398 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11398, i64* %vptr30980, align 8 ; call prim_halt
  %vptr30986 = alloca i64*, align 8 
  %cloptr30981 = inttoptr i64 %h11398 to i64* 
  store volatile i64* %cloptr30981, i64** %vptr30986, align 8 ; closure/env cast; i64 -> i64*
  %vptr30987 = alloca i64*, align 8 
  %i0ptr30982 = getelementptr inbounds i64, i64* %cloptr30981, i64 1 
  store volatile i64* %i0ptr30982, i64** %vptr30987, align 8 ; &cloptr30981[1]
 %vptr30988 = alloca i64, align 8 
  %f30984 = load i64, i64* %i0ptr30982, align 8 
  store volatile i64 %f30984, i64* %vptr30988, align 8 ; load; *i0ptr30982
  %fptr30983 = inttoptr i64 %f30984 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr30983(i64 %h11398, i64 %h11398)                     ; tail call
  ret void
}


define void @lam11511(i64 %env11512, i64 %rvp11387) {
 %vptr30991 = alloca i64, align 8 
  %envptr30989 = inttoptr i64 %env11512 to i64* 
  store volatile i64 %cont7357, i64* %vptr30991, align 8 ; closure/env cast; i64 -> i64*
  %vptr30992 = alloca i64*, align 8 
  %envptr30990 = getelementptr inbounds i64, i64* %envptr30989, i64 6 
  store volatile i64* %envptr30990, i64** %vptr30992, align 8 ; &envptr30989[5]
 %vptr30993 = alloca i64, align 8 
  %cont7357 = load i64, i64* %envptr30990, align 8 
  store volatile i64 %cont7357, i64* %vptr30993, align 8 ; load; *envptr30990
 %vptr30996 = alloca i64, align 8 
  %envptr30994 = inttoptr i64 %env11512 to i64* 
  store volatile i64 %emsg08636, i64* %vptr30996, align 8 ; closure/env cast; i64 -> i64*
  %vptr30997 = alloca i64*, align 8 
  %envptr30995 = getelementptr inbounds i64, i64* %envptr30994, i64 5 
  store volatile i64* %envptr30995, i64** %vptr30997, align 8 ; &envptr30994[4]
 %vptr30998 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr30995, align 8 
  store volatile i64 %emsg08636, i64* %vptr30998, align 8 ; load; *envptr30995
 %vptr31001 = alloca i64, align 8 
  %envptr30999 = inttoptr i64 %env11512 to i64* 
  store volatile i64 %ICf$f, i64* %vptr31001, align 8 ; closure/env cast; i64 -> i64*
  %vptr31002 = alloca i64*, align 8 
  %envptr31000 = getelementptr inbounds i64, i64* %envptr30999, i64 4 
  store volatile i64* %envptr31000, i64** %vptr31002, align 8 ; &envptr30999[3]
 %vptr31003 = alloca i64, align 8 
  %ICf$f = load i64, i64* %envptr31000, align 8 
  store volatile i64 %ICf$f, i64* %vptr31003, align 8 ; load; *envptr31000
 %vptr31006 = alloca i64, align 8 
  %envptr31004 = inttoptr i64 %env11512 to i64* 
  store volatile i64 %a6910, i64* %vptr31006, align 8 ; closure/env cast; i64 -> i64*
  %vptr31007 = alloca i64*, align 8 
  %envptr31005 = getelementptr inbounds i64, i64* %envptr31004, i64 3 
  store volatile i64* %envptr31005, i64** %vptr31007, align 8 ; &envptr31004[2]
 %vptr31008 = alloca i64, align 8 
  %a6910 = load i64, i64* %envptr31005, align 8 
  store volatile i64 %a6910, i64* %vptr31008, align 8 ; load; *envptr31005
 %vptr31011 = alloca i64, align 8 
  %envptr31009 = inttoptr i64 %env11512 to i64* 
  store volatile i64 %emsg18637, i64* %vptr31011, align 8 ; closure/env cast; i64 -> i64*
  %vptr31012 = alloca i64*, align 8 
  %envptr31010 = getelementptr inbounds i64, i64* %envptr31009, i64 2 
  store volatile i64* %envptr31010, i64** %vptr31012, align 8 ; &envptr31009[1]
 %vptr31013 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr31010, align 8 
  store volatile i64 %emsg18637, i64* %vptr31013, align 8 ; load; *envptr31010
 %vptr31014 = alloca i64, align 8 
  %_957358 = call i64 @prim_car(i64 %rvp11387) 
  store volatile i64 %_957358, i64* %vptr31014, align 8 ; call prim_car
 %vptr31015 = alloca i64, align 8 
  %rvp11383 = call i64 @prim_cdr(i64 %rvp11387) 
  store volatile i64 %rvp11383, i64* %vptr31015, align 8 ; call prim_cdr
 %vptr31016 = alloca i64, align 8 
  %n_6311388 = call i64 @prim_null_63(i64 %rvp11383) 
  store volatile i64 %n_6311388, i64* %vptr31016, align 8 ; call prim_null_63
  %cmpptr31020 = alloca i1, align 8  %cmp31017 = icmp eq i64 %n_6311388, 15 store volatile i1 %cmp31017, i1* %cmpptr31020, align 8; false?
  br i1 %cmp31017, label %else31019, label %then31018                                ; if

then31018:
 %vptr31021 = alloca i64, align 8 
  %h11389 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11389, i64* %vptr31021, align 8 ; call prim_halt
  %vptr31027 = alloca i64*, align 8 
  %cloptr31022 = inttoptr i64 %h11389 to i64* 
  store volatile i64* %cloptr31022, i64** %vptr31027, align 8 ; closure/env cast; i64 -> i64*
  %vptr31028 = alloca i64*, align 8 
  %i0ptr31023 = getelementptr inbounds i64, i64* %cloptr31022, i64 1 
  store volatile i64* %i0ptr31023, i64** %vptr31028, align 8 ; &cloptr31022[1]
 %vptr31029 = alloca i64, align 8 
  %f31025 = load i64, i64* %i0ptr31023, align 8 
  store volatile i64 %f31025, i64* %vptr31029, align 8 ; load; *i0ptr31023
  %fptr31024 = inttoptr i64 %f31025 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr31024(i64 %h11389, i64 %h11389)                     ; tail call
  ret void

else31019:
 %vptr31030 = alloca i64, align 8 
  %a6912 = call i64 @prim_car(i64 %rvp11383) 
  store volatile i64 %a6912, i64* %vptr31030, align 8 ; call prim_car
 %vptr31031 = alloca i64, align 8 
  %na11378 = call i64 @prim_cdr(i64 %rvp11383) 
  store volatile i64 %na11378, i64* %vptr31031, align 8 ; call prim_cdr
 %vptr31032 = alloca i64, align 8 
  %n_6311384 = call i64 @prim_null_63(i64 %na11378) 
  store volatile i64 %n_6311384, i64* %vptr31032, align 8 ; call prim_null_63
  %cmpptr31036 = alloca i1, align 8  %cmp31033 = icmp eq i64 %n_6311384, 15 store volatile i1 %cmp31033, i1* %cmpptr31036, align 8; false?
  br i1 %cmp31033, label %else31035, label %then31034                                ; if

then31034:
 %vptr31037 = alloca i64, align 8 
  %rva11382 = add i64 0, 0 
  store volatile i64 %rva11382, i64* %vptr31037, align 8 ; quoted ()
 %vptr31038 = alloca i64, align 8 
  %rva11381 = call i64 @prim_cons(i64 %a6912, i64 %rva11382) 
  store volatile i64 %rva11381, i64* %vptr31038, align 8 ; call prim_cons
 %vptr31039 = alloca i64, align 8 
  %rva11380 = call i64 @prim_cons(i64 %a6910, i64 %rva11381) 
  store volatile i64 %rva11380, i64* %vptr31039, align 8 ; call prim_cons
 %vptr31040 = alloca i64, align 8 
  %rva11379 = call i64 @prim_cons(i64 %cont7357, i64 %rva11380) 
  store volatile i64 %rva11379, i64* %vptr31040, align 8 ; call prim_cons
  %vptr31046 = alloca i64*, align 8 
  %cloptr31041 = inttoptr i64 %ICf$f to i64* 
  store volatile i64* %cloptr31041, i64** %vptr31046, align 8 ; closure/env cast; i64 -> i64*
  %vptr31047 = alloca i64*, align 8 
  %i0ptr31042 = getelementptr inbounds i64, i64* %cloptr31041, i64 1 
  store volatile i64* %i0ptr31042, i64** %vptr31047, align 8 ; &cloptr31041[1]
 %vptr31048 = alloca i64, align 8 
  %f31044 = load i64, i64* %i0ptr31042, align 8 
  store volatile i64 %f31044, i64* %vptr31048, align 8 ; load; *i0ptr31042
  %fptr31043 = inttoptr i64 %f31044 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr31043(i64 %ICf$f, i64 %rva11379)                    ; tail call
  ret void

else31035:
 %vptr31049 = alloca i64, align 8 
  %h11385 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11385, i64* %vptr31049, align 8 ; call prim_halt
  %vptr31055 = alloca i64*, align 8 
  %cloptr31050 = inttoptr i64 %h11385 to i64* 
  store volatile i64* %cloptr31050, i64** %vptr31055, align 8 ; closure/env cast; i64 -> i64*
  %vptr31056 = alloca i64*, align 8 
  %i0ptr31051 = getelementptr inbounds i64, i64* %cloptr31050, i64 1 
  store volatile i64* %i0ptr31051, i64** %vptr31056, align 8 ; &cloptr31050[1]
 %vptr31057 = alloca i64, align 8 
  %f31053 = load i64, i64* %i0ptr31051, align 8 
  store volatile i64 %f31053, i64* %vptr31057, align 8 ; load; *i0ptr31051
  %fptr31052 = inttoptr i64 %f31053 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr31052(i64 %h11385, i64 %h11385)                     ; tail call
  ret void
}


define void @lam11503(i64 %env11504, i64 %rvp11482) {
 %vptr31060 = alloca i64, align 8 
  %envptr31058 = inttoptr i64 %env11504 to i64* 
  store volatile i64 %emsg08636, i64* %vptr31060, align 8 ; closure/env cast; i64 -> i64*
  %vptr31061 = alloca i64*, align 8 
  %envptr31059 = getelementptr inbounds i64, i64* %envptr31058, i64 3 
  store volatile i64* %envptr31059, i64** %vptr31061, align 8 ; &envptr31058[2]
 %vptr31062 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr31059, align 8 
  store volatile i64 %emsg08636, i64* %vptr31062, align 8 ; load; *envptr31059
 %vptr31065 = alloca i64, align 8 
  %envptr31063 = inttoptr i64 %env11504 to i64* 
  store volatile i64 %emsg18637, i64* %vptr31065, align 8 ; closure/env cast; i64 -> i64*
  %vptr31066 = alloca i64*, align 8 
  %envptr31064 = getelementptr inbounds i64, i64* %envptr31063, i64 2 
  store volatile i64* %envptr31064, i64** %vptr31066, align 8 ; &envptr31063[1]
 %vptr31067 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr31064, align 8 
  store volatile i64 %emsg18637, i64* %vptr31067, align 8 ; load; *envptr31064
 %vptr31068 = alloca i64, align 8 
  %cont7360 = call i64 @prim_car(i64 %rvp11482) 
  store volatile i64 %cont7360, i64* %vptr31068, align 8 ; call prim_car
 %vptr31069 = alloca i64, align 8 
  %rvp11478 = call i64 @prim_cdr(i64 %rvp11482) 
  store volatile i64 %rvp11478, i64* %vptr31069, align 8 ; call prim_cdr
 %vptr31070 = alloca i64, align 8 
  %n_6311483 = call i64 @prim_null_63(i64 %rvp11478) 
  store volatile i64 %n_6311483, i64* %vptr31070, align 8 ; call prim_null_63
  %cmpptr31074 = alloca i1, align 8  %cmp31071 = icmp eq i64 %n_6311483, 15 store volatile i1 %cmp31071, i1* %cmpptr31074, align 8; false?
  br i1 %cmp31071, label %else31073, label %then31072                                ; if

then31072:
 %vptr31075 = alloca i64, align 8 
  %h11484 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11484, i64* %vptr31075, align 8 ; call prim_halt
  %vptr31081 = alloca i64*, align 8 
  %cloptr31076 = inttoptr i64 %h11484 to i64* 
  store volatile i64* %cloptr31076, i64** %vptr31081, align 8 ; closure/env cast; i64 -> i64*
  %vptr31082 = alloca i64*, align 8 
  %i0ptr31077 = getelementptr inbounds i64, i64* %cloptr31076, i64 1 
  store volatile i64* %i0ptr31077, i64** %vptr31082, align 8 ; &cloptr31076[1]
 %vptr31083 = alloca i64, align 8 
  %f31079 = load i64, i64* %i0ptr31077, align 8 
  store volatile i64 %f31079, i64* %vptr31083, align 8 ; load; *i0ptr31077
  %fptr31078 = inttoptr i64 %f31079 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr31078(i64 %h11484, i64 %h11484)                     ; tail call
  ret void

else31073:
 %vptr31084 = alloca i64, align 8 
  %Fzp$y = call i64 @prim_car(i64 %rvp11478) 
  store volatile i64 %Fzp$y, i64* %vptr31084, align 8 ; call prim_car
 %vptr31085 = alloca i64, align 8 
  %na11435 = call i64 @prim_cdr(i64 %rvp11478) 
  store volatile i64 %na11435, i64* %vptr31085, align 8 ; call prim_cdr
 %vptr31086 = alloca i64, align 8 
  %n_6311479 = call i64 @prim_null_63(i64 %na11435) 
  store volatile i64 %n_6311479, i64* %vptr31086, align 8 ; call prim_null_63
  %cmpptr31090 = alloca i1, align 8  %cmp31087 = icmp eq i64 %n_6311479, 15 store volatile i1 %cmp31087, i1* %cmpptr31090, align 8; false?
  br i1 %cmp31087, label %else31089, label %then31088                                ; if

then31088:
 %vptr31091 = alloca i64, align 8 
  %arg8621 = add i64 0, 0 
  store volatile i64 %arg8621, i64* %vptr31091, align 8 ; quoted ()
  %vptr31098 = alloca i64*, align 8 
  %cloptr31092 = call i64* @make_closure(i64 32) 
  store volatile i64* %cloptr31092, i64** %vptr31098, align 8 ; malloc
  %vptr31099 = alloca i64*, align 8 
  %eptr31094 = getelementptr inbounds i64, i64* %cloptr31092, i64 2 
  store volatile i64* %eptr31094, i64** %vptr31099, align 8 ; &eptr31094[1]
  %vptr31100 = alloca i64*, align 8 
  %eptr31095 = getelementptr inbounds i64, i64* %cloptr31092, i64 3 
  store volatile i64* %eptr31095, i64** %vptr31100, align 8 ; &eptr31095[2]
  %vptr31101 = alloca i64*, align 8 
  %eptr31096 = getelementptr inbounds i64, i64* %cloptr31092, i64 4 
  store volatile i64* %eptr31096, i64** %vptr31101, align 8 ; &eptr31096[3]
  store i64 %emsg18637, i64* %eptr31094                                              ; *eptr31094 = %emsg18637
  store i64 %Fzp$y, i64* %eptr31095                                                  ; *eptr31095 = %Fzp$y
  store i64 %emsg08636, i64* %eptr31096                                              ; *eptr31096 = %emsg08636
  %vptr31102 = alloca i64*, align 8 
  %eptr31093 = getelementptr inbounds i64, i64* %cloptr31092, i64 1 
  store volatile i64* %eptr31093, i64** %vptr31102, align 8 ; &cloptr31092[1]
 %vptr31103 = alloca i64, align 8 
  %f31097 = ptrtoint void(i64,i64)* @lam11500 to i64 
  store volatile i64 %f31097, i64* %vptr31103, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f31097, i64* %eptr31093                                                 ; store fptr
 %vptr31104 = alloca i64, align 8 
  %arg8620 = ptrtoint i64* %cloptr31092 to i64 
  store volatile i64 %arg8620, i64* %vptr31104, align 8 ; closure cast; i64* -> i64
 %vptr31105 = alloca i64, align 8 
  %rva11477 = add i64 0, 0 
  store volatile i64 %rva11477, i64* %vptr31105, align 8 ; quoted ()
 %vptr31106 = alloca i64, align 8 
  %rva11476 = call i64 @prim_cons(i64 %arg8620, i64 %rva11477) 
  store volatile i64 %rva11476, i64* %vptr31106, align 8 ; call prim_cons
 %vptr31107 = alloca i64, align 8 
  %rva11475 = call i64 @prim_cons(i64 %arg8621, i64 %rva11476) 
  store volatile i64 %rva11475, i64* %vptr31107, align 8 ; call prim_cons
  %vptr31113 = alloca i64*, align 8 
  %cloptr31108 = inttoptr i64 %cont7360 to i64* 
  store volatile i64* %cloptr31108, i64** %vptr31113, align 8 ; closure/env cast; i64 -> i64*
  %vptr31114 = alloca i64*, align 8 
  %i0ptr31109 = getelementptr inbounds i64, i64* %cloptr31108, i64 1 
  store volatile i64* %i0ptr31109, i64** %vptr31114, align 8 ; &cloptr31108[1]
 %vptr31115 = alloca i64, align 8 
  %f31111 = load i64, i64* %i0ptr31109, align 8 
  store volatile i64 %f31111, i64* %vptr31115, align 8 ; load; *i0ptr31109
  %fptr31110 = inttoptr i64 %f31111 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr31110(i64 %cont7360, i64 %rva11475)                 ; tail call
  ret void

else31089:
 %vptr31116 = alloca i64, align 8 
  %h11480 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11480, i64* %vptr31116, align 8 ; call prim_halt
  %vptr31122 = alloca i64*, align 8 
  %cloptr31117 = inttoptr i64 %h11480 to i64* 
  store volatile i64* %cloptr31117, i64** %vptr31122, align 8 ; closure/env cast; i64 -> i64*
  %vptr31123 = alloca i64*, align 8 
  %i0ptr31118 = getelementptr inbounds i64, i64* %cloptr31117, i64 1 
  store volatile i64* %i0ptr31118, i64** %vptr31123, align 8 ; &cloptr31117[1]
 %vptr31124 = alloca i64, align 8 
  %f31120 = load i64, i64* %i0ptr31118, align 8 
  store volatile i64 %f31120, i64* %vptr31124, align 8 ; load; *i0ptr31118
  %fptr31119 = inttoptr i64 %f31120 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr31119(i64 %h11480, i64 %h11480)                     ; tail call
  ret void
}


define void @lam11500(i64 %env11501, i64 %rvp11471) {
 %vptr31127 = alloca i64, align 8 
  %envptr31125 = inttoptr i64 %env11501 to i64* 
  store volatile i64 %emsg08636, i64* %vptr31127, align 8 ; closure/env cast; i64 -> i64*
  %vptr31128 = alloca i64*, align 8 
  %envptr31126 = getelementptr inbounds i64, i64* %envptr31125, i64 4 
  store volatile i64* %envptr31126, i64** %vptr31128, align 8 ; &envptr31125[3]
 %vptr31129 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr31126, align 8 
  store volatile i64 %emsg08636, i64* %vptr31129, align 8 ; load; *envptr31126
 %vptr31132 = alloca i64, align 8 
  %envptr31130 = inttoptr i64 %env11501 to i64* 
  store volatile i64 %Fzp$y, i64* %vptr31132, align 8 ; closure/env cast; i64 -> i64*
  %vptr31133 = alloca i64*, align 8 
  %envptr31131 = getelementptr inbounds i64, i64* %envptr31130, i64 3 
  store volatile i64* %envptr31131, i64** %vptr31133, align 8 ; &envptr31130[2]
 %vptr31134 = alloca i64, align 8 
  %Fzp$y = load i64, i64* %envptr31131, align 8 
  store volatile i64 %Fzp$y, i64* %vptr31134, align 8 ; load; *envptr31131
 %vptr31137 = alloca i64, align 8 
  %envptr31135 = inttoptr i64 %env11501 to i64* 
  store volatile i64 %emsg18637, i64* %vptr31137, align 8 ; closure/env cast; i64 -> i64*
  %vptr31138 = alloca i64*, align 8 
  %envptr31136 = getelementptr inbounds i64, i64* %envptr31135, i64 2 
  store volatile i64* %envptr31136, i64** %vptr31138, align 8 ; &envptr31135[1]
 %vptr31139 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr31136, align 8 
  store volatile i64 %emsg18637, i64* %vptr31139, align 8 ; load; *envptr31136
 %vptr31140 = alloca i64, align 8 
  %cont7361 = call i64 @prim_car(i64 %rvp11471) 
  store volatile i64 %cont7361, i64* %vptr31140, align 8 ; call prim_car
 %vptr31141 = alloca i64, align 8 
  %rvp11467 = call i64 @prim_cdr(i64 %rvp11471) 
  store volatile i64 %rvp11467, i64* %vptr31141, align 8 ; call prim_cdr
 %vptr31142 = alloca i64, align 8 
  %n_6311472 = call i64 @prim_null_63(i64 %rvp11467) 
  store volatile i64 %n_6311472, i64* %vptr31142, align 8 ; call prim_null_63
  %cmpptr31146 = alloca i1, align 8  %cmp31143 = icmp eq i64 %n_6311472, 15 store volatile i1 %cmp31143, i1* %cmpptr31146, align 8; false?
  br i1 %cmp31143, label %else31145, label %then31144                                ; if

then31144:
 %vptr31147 = alloca i64, align 8 
  %h11473 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11473, i64* %vptr31147, align 8 ; call prim_halt
  %vptr31153 = alloca i64*, align 8 
  %cloptr31148 = inttoptr i64 %h11473 to i64* 
  store volatile i64* %cloptr31148, i64** %vptr31153, align 8 ; closure/env cast; i64 -> i64*
  %vptr31154 = alloca i64*, align 8 
  %i0ptr31149 = getelementptr inbounds i64, i64* %cloptr31148, i64 1 
  store volatile i64* %i0ptr31149, i64** %vptr31154, align 8 ; &cloptr31148[1]
 %vptr31155 = alloca i64, align 8 
  %f31151 = load i64, i64* %i0ptr31149, align 8 
  store volatile i64 %f31151, i64* %vptr31155, align 8 ; load; *i0ptr31149
  %fptr31150 = inttoptr i64 %f31151 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr31150(i64 %h11473, i64 %h11473)                     ; tail call
  ret void

else31145:
 %vptr31156 = alloca i64, align 8 
  %Ywq$f = call i64 @prim_car(i64 %rvp11467) 
  store volatile i64 %Ywq$f, i64* %vptr31156, align 8 ; call prim_car
 %vptr31157 = alloca i64, align 8 
  %na11437 = call i64 @prim_cdr(i64 %rvp11467) 
  store volatile i64 %na11437, i64* %vptr31157, align 8 ; call prim_cdr
 %vptr31158 = alloca i64, align 8 
  %n_6311468 = call i64 @prim_null_63(i64 %na11437) 
  store volatile i64 %n_6311468, i64* %vptr31158, align 8 ; call prim_null_63
  %cmpptr31162 = alloca i1, align 8  %cmp31159 = icmp eq i64 %n_6311468, 15 store volatile i1 %cmp31159, i1* %cmpptr31162, align 8; false?
  br i1 %cmp31159, label %else31161, label %then31160                                ; if

then31160:
  %vptr31170 = alloca i64*, align 8 
  %cloptr31163 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr31163, i64** %vptr31170, align 8 ; malloc
  %vptr31171 = alloca i64*, align 8 
  %eptr31165 = getelementptr inbounds i64, i64* %cloptr31163, i64 2 
  store volatile i64* %eptr31165, i64** %vptr31171, align 8 ; &eptr31165[1]
  %vptr31172 = alloca i64*, align 8 
  %eptr31166 = getelementptr inbounds i64, i64* %cloptr31163, i64 3 
  store volatile i64* %eptr31166, i64** %vptr31172, align 8 ; &eptr31166[2]
  %vptr31173 = alloca i64*, align 8 
  %eptr31167 = getelementptr inbounds i64, i64* %cloptr31163, i64 4 
  store volatile i64* %eptr31167, i64** %vptr31173, align 8 ; &eptr31167[3]
  %vptr31174 = alloca i64*, align 8 
  %eptr31168 = getelementptr inbounds i64, i64* %cloptr31163, i64 5 
  store volatile i64* %eptr31168, i64** %vptr31174, align 8 ; &eptr31168[4]
  store i64 %emsg18637, i64* %eptr31165                                              ; *eptr31165 = %emsg18637
  store i64 %Fzp$y, i64* %eptr31166                                                  ; *eptr31166 = %Fzp$y
  store i64 %Ywq$f, i64* %eptr31167                                                  ; *eptr31167 = %Ywq$f
  store i64 %emsg08636, i64* %eptr31168                                              ; *eptr31168 = %emsg08636
  %vptr31175 = alloca i64*, align 8 
  %eptr31164 = getelementptr inbounds i64, i64* %cloptr31163, i64 1 
  store volatile i64* %eptr31164, i64** %vptr31175, align 8 ; &cloptr31163[1]
 %vptr31176 = alloca i64, align 8 
  %f31169 = ptrtoint void(i64,i64)* @lam11498 to i64 
  store volatile i64 %f31169, i64* %vptr31176, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f31169, i64* %eptr31164                                                 ; store fptr
 %vptr31177 = alloca i64, align 8 
  %arg8623 = ptrtoint i64* %cloptr31163 to i64 
  store volatile i64 %arg8623, i64* %vptr31177, align 8 ; closure cast; i64* -> i64
 %vptr31178 = alloca i64, align 8 
  %rva11466 = add i64 0, 0 
  store volatile i64 %rva11466, i64* %vptr31178, align 8 ; quoted ()
 %vptr31179 = alloca i64, align 8 
  %rva11465 = call i64 @prim_cons(i64 %arg8623, i64 %rva11466) 
  store volatile i64 %rva11465, i64* %vptr31179, align 8 ; call prim_cons
 %vptr31180 = alloca i64, align 8 
  %rva11464 = call i64 @prim_cons(i64 %cont7361, i64 %rva11465) 
  store volatile i64 %rva11464, i64* %vptr31180, align 8 ; call prim_cons
  %vptr31186 = alloca i64*, align 8 
  %cloptr31181 = inttoptr i64 %Ywq$f to i64* 
  store volatile i64* %cloptr31181, i64** %vptr31186, align 8 ; closure/env cast; i64 -> i64*
  %vptr31187 = alloca i64*, align 8 
  %i0ptr31182 = getelementptr inbounds i64, i64* %cloptr31181, i64 1 
  store volatile i64* %i0ptr31182, i64** %vptr31187, align 8 ; &cloptr31181[1]
 %vptr31188 = alloca i64, align 8 
  %f31184 = load i64, i64* %i0ptr31182, align 8 
  store volatile i64 %f31184, i64* %vptr31188, align 8 ; load; *i0ptr31182
  %fptr31183 = inttoptr i64 %f31184 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr31183(i64 %Ywq$f, i64 %rva11464)                    ; tail call
  ret void

else31161:
 %vptr31189 = alloca i64, align 8 
  %h11469 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11469, i64* %vptr31189, align 8 ; call prim_halt
  %vptr31195 = alloca i64*, align 8 
  %cloptr31190 = inttoptr i64 %h11469 to i64* 
  store volatile i64* %cloptr31190, i64** %vptr31195, align 8 ; closure/env cast; i64 -> i64*
  %vptr31196 = alloca i64*, align 8 
  %i0ptr31191 = getelementptr inbounds i64, i64* %cloptr31190, i64 1 
  store volatile i64* %i0ptr31191, i64** %vptr31196, align 8 ; &cloptr31190[1]
 %vptr31197 = alloca i64, align 8 
  %f31193 = load i64, i64* %i0ptr31191, align 8 
  store volatile i64 %f31193, i64* %vptr31197, align 8 ; load; *i0ptr31191
  %fptr31192 = inttoptr i64 %f31193 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr31192(i64 %h11469, i64 %h11469)                     ; tail call
  ret void
}


define void @lam11498(i64 %env11499, i64 %VTV$args7363) {
 %vptr31200 = alloca i64, align 8 
  %envptr31198 = inttoptr i64 %env11499 to i64* 
  store volatile i64 %emsg08636, i64* %vptr31200, align 8 ; closure/env cast; i64 -> i64*
  %vptr31201 = alloca i64*, align 8 
  %envptr31199 = getelementptr inbounds i64, i64* %envptr31198, i64 5 
  store volatile i64* %envptr31199, i64** %vptr31201, align 8 ; &envptr31198[4]
 %vptr31202 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr31199, align 8 
  store volatile i64 %emsg08636, i64* %vptr31202, align 8 ; load; *envptr31199
 %vptr31205 = alloca i64, align 8 
  %envptr31203 = inttoptr i64 %env11499 to i64* 
  store volatile i64 %Ywq$f, i64* %vptr31205, align 8 ; closure/env cast; i64 -> i64*
  %vptr31206 = alloca i64*, align 8 
  %envptr31204 = getelementptr inbounds i64, i64* %envptr31203, i64 4 
  store volatile i64* %envptr31204, i64** %vptr31206, align 8 ; &envptr31203[3]
 %vptr31207 = alloca i64, align 8 
  %Ywq$f = load i64, i64* %envptr31204, align 8 
  store volatile i64 %Ywq$f, i64* %vptr31207, align 8 ; load; *envptr31204
 %vptr31210 = alloca i64, align 8 
  %envptr31208 = inttoptr i64 %env11499 to i64* 
  store volatile i64 %Fzp$y, i64* %vptr31210, align 8 ; closure/env cast; i64 -> i64*
  %vptr31211 = alloca i64*, align 8 
  %envptr31209 = getelementptr inbounds i64, i64* %envptr31208, i64 3 
  store volatile i64* %envptr31209, i64** %vptr31211, align 8 ; &envptr31208[2]
 %vptr31212 = alloca i64, align 8 
  %Fzp$y = load i64, i64* %envptr31209, align 8 
  store volatile i64 %Fzp$y, i64* %vptr31212, align 8 ; load; *envptr31209
 %vptr31215 = alloca i64, align 8 
  %envptr31213 = inttoptr i64 %env11499 to i64* 
  store volatile i64 %emsg18637, i64* %vptr31215, align 8 ; closure/env cast; i64 -> i64*
  %vptr31216 = alloca i64*, align 8 
  %envptr31214 = getelementptr inbounds i64, i64* %envptr31213, i64 2 
  store volatile i64* %envptr31214, i64** %vptr31216, align 8 ; &envptr31213[1]
 %vptr31217 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr31214, align 8 
  store volatile i64 %emsg18637, i64* %vptr31217, align 8 ; load; *envptr31214
 %vptr31218 = alloca i64, align 8 
  %cont7362 = call i64 @prim_car(i64 %VTV$args7363) 
  store volatile i64 %cont7362, i64* %vptr31218, align 8 ; call prim_car
 %vptr31219 = alloca i64, align 8 
  %VTV$args = call i64 @prim_cdr(i64 %VTV$args7363) 
  store volatile i64 %VTV$args, i64* %vptr31219, align 8 ; call prim_cdr
  %vptr31228 = alloca i64*, align 8 
  %cloptr31220 = call i64* @make_closure(i64 48) 
  store volatile i64* %cloptr31220, i64** %vptr31228, align 8 ; malloc
  %vptr31229 = alloca i64*, align 8 
  %eptr31222 = getelementptr inbounds i64, i64* %cloptr31220, i64 2 
  store volatile i64* %eptr31222, i64** %vptr31229, align 8 ; &eptr31222[1]
  %vptr31230 = alloca i64*, align 8 
  %eptr31223 = getelementptr inbounds i64, i64* %cloptr31220, i64 3 
  store volatile i64* %eptr31223, i64** %vptr31230, align 8 ; &eptr31223[2]
  %vptr31231 = alloca i64*, align 8 
  %eptr31224 = getelementptr inbounds i64, i64* %cloptr31220, i64 4 
  store volatile i64* %eptr31224, i64** %vptr31231, align 8 ; &eptr31224[3]
  %vptr31232 = alloca i64*, align 8 
  %eptr31225 = getelementptr inbounds i64, i64* %cloptr31220, i64 5 
  store volatile i64* %eptr31225, i64** %vptr31232, align 8 ; &eptr31225[4]
  %vptr31233 = alloca i64*, align 8 
  %eptr31226 = getelementptr inbounds i64, i64* %cloptr31220, i64 6 
  store volatile i64* %eptr31226, i64** %vptr31233, align 8 ; &eptr31226[5]
  store i64 %emsg18637, i64* %eptr31222                                              ; *eptr31222 = %emsg18637
  store i64 %cont7362, i64* %eptr31223                                               ; *eptr31223 = %cont7362
  store i64 %VTV$args, i64* %eptr31224                                               ; *eptr31224 = %VTV$args
  store i64 %Ywq$f, i64* %eptr31225                                                  ; *eptr31225 = %Ywq$f
  store i64 %emsg08636, i64* %eptr31226                                              ; *eptr31226 = %emsg08636
  %vptr31234 = alloca i64*, align 8 
  %eptr31221 = getelementptr inbounds i64, i64* %cloptr31220, i64 1 
  store volatile i64* %eptr31221, i64** %vptr31234, align 8 ; &cloptr31220[1]
 %vptr31235 = alloca i64, align 8 
  %f31227 = ptrtoint void(i64,i64)* @lam11496 to i64 
  store volatile i64 %f31227, i64* %vptr31235, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f31227, i64* %eptr31221                                                 ; store fptr
 %vptr31236 = alloca i64, align 8 
  %arg8629 = ptrtoint i64* %cloptr31220 to i64 
  store volatile i64 %arg8629, i64* %vptr31236, align 8 ; closure cast; i64* -> i64
 %vptr31237 = alloca i64, align 8 
  %rva11463 = add i64 0, 0 
  store volatile i64 %rva11463, i64* %vptr31237, align 8 ; quoted ()
 %vptr31238 = alloca i64, align 8 
  %rva11462 = call i64 @prim_cons(i64 %Fzp$y, i64 %rva11463) 
  store volatile i64 %rva11462, i64* %vptr31238, align 8 ; call prim_cons
 %vptr31239 = alloca i64, align 8 
  %rva11461 = call i64 @prim_cons(i64 %arg8629, i64 %rva11462) 
  store volatile i64 %rva11461, i64* %vptr31239, align 8 ; call prim_cons
  %vptr31245 = alloca i64*, align 8 
  %cloptr31240 = inttoptr i64 %Fzp$y to i64* 
  store volatile i64* %cloptr31240, i64** %vptr31245, align 8 ; closure/env cast; i64 -> i64*
  %vptr31246 = alloca i64*, align 8 
  %i0ptr31241 = getelementptr inbounds i64, i64* %cloptr31240, i64 1 
  store volatile i64* %i0ptr31241, i64** %vptr31246, align 8 ; &cloptr31240[1]
 %vptr31247 = alloca i64, align 8 
  %f31243 = load i64, i64* %i0ptr31241, align 8 
  store volatile i64 %f31243, i64* %vptr31247, align 8 ; load; *i0ptr31241
  %fptr31242 = inttoptr i64 %f31243 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr31242(i64 %Fzp$y, i64 %rva11461)                    ; tail call
  ret void
}


define void @lam11496(i64 %env11497, i64 %rvp11457) {
 %vptr31250 = alloca i64, align 8 
  %envptr31248 = inttoptr i64 %env11497 to i64* 
  store volatile i64 %emsg08636, i64* %vptr31250, align 8 ; closure/env cast; i64 -> i64*
  %vptr31251 = alloca i64*, align 8 
  %envptr31249 = getelementptr inbounds i64, i64* %envptr31248, i64 6 
  store volatile i64* %envptr31249, i64** %vptr31251, align 8 ; &envptr31248[5]
 %vptr31252 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr31249, align 8 
  store volatile i64 %emsg08636, i64* %vptr31252, align 8 ; load; *envptr31249
 %vptr31255 = alloca i64, align 8 
  %envptr31253 = inttoptr i64 %env11497 to i64* 
  store volatile i64 %Ywq$f, i64* %vptr31255, align 8 ; closure/env cast; i64 -> i64*
  %vptr31256 = alloca i64*, align 8 
  %envptr31254 = getelementptr inbounds i64, i64* %envptr31253, i64 5 
  store volatile i64* %envptr31254, i64** %vptr31256, align 8 ; &envptr31253[4]
 %vptr31257 = alloca i64, align 8 
  %Ywq$f = load i64, i64* %envptr31254, align 8 
  store volatile i64 %Ywq$f, i64* %vptr31257, align 8 ; load; *envptr31254
 %vptr31260 = alloca i64, align 8 
  %envptr31258 = inttoptr i64 %env11497 to i64* 
  store volatile i64 %VTV$args, i64* %vptr31260, align 8 ; closure/env cast; i64 -> i64*
  %vptr31261 = alloca i64*, align 8 
  %envptr31259 = getelementptr inbounds i64, i64* %envptr31258, i64 4 
  store volatile i64* %envptr31259, i64** %vptr31261, align 8 ; &envptr31258[3]
 %vptr31262 = alloca i64, align 8 
  %VTV$args = load i64, i64* %envptr31259, align 8 
  store volatile i64 %VTV$args, i64* %vptr31262, align 8 ; load; *envptr31259
 %vptr31265 = alloca i64, align 8 
  %envptr31263 = inttoptr i64 %env11497 to i64* 
  store volatile i64 %cont7362, i64* %vptr31265, align 8 ; closure/env cast; i64 -> i64*
  %vptr31266 = alloca i64*, align 8 
  %envptr31264 = getelementptr inbounds i64, i64* %envptr31263, i64 3 
  store volatile i64* %envptr31264, i64** %vptr31266, align 8 ; &envptr31263[2]
 %vptr31267 = alloca i64, align 8 
  %cont7362 = load i64, i64* %envptr31264, align 8 
  store volatile i64 %cont7362, i64* %vptr31267, align 8 ; load; *envptr31264
 %vptr31270 = alloca i64, align 8 
  %envptr31268 = inttoptr i64 %env11497 to i64* 
  store volatile i64 %emsg18637, i64* %vptr31270, align 8 ; closure/env cast; i64 -> i64*
  %vptr31271 = alloca i64*, align 8 
  %envptr31269 = getelementptr inbounds i64, i64* %envptr31268, i64 2 
  store volatile i64* %envptr31269, i64** %vptr31271, align 8 ; &envptr31268[1]
 %vptr31272 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr31269, align 8 
  store volatile i64 %emsg18637, i64* %vptr31272, align 8 ; load; *envptr31269
 %vptr31273 = alloca i64, align 8 
  %_957364 = call i64 @prim_car(i64 %rvp11457) 
  store volatile i64 %_957364, i64* %vptr31273, align 8 ; call prim_car
 %vptr31274 = alloca i64, align 8 
  %rvp11453 = call i64 @prim_cdr(i64 %rvp11457) 
  store volatile i64 %rvp11453, i64* %vptr31274, align 8 ; call prim_cdr
 %vptr31275 = alloca i64, align 8 
  %n_6311458 = call i64 @prim_null_63(i64 %rvp11453) 
  store volatile i64 %n_6311458, i64* %vptr31275, align 8 ; call prim_null_63
  %cmpptr31279 = alloca i1, align 8  %cmp31276 = icmp eq i64 %n_6311458, 15 store volatile i1 %cmp31276, i1* %cmpptr31279, align 8; false?
  br i1 %cmp31276, label %else31278, label %then31277                                ; if

then31277:
 %vptr31280 = alloca i64, align 8 
  %h11459 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11459, i64* %vptr31280, align 8 ; call prim_halt
  %vptr31286 = alloca i64*, align 8 
  %cloptr31281 = inttoptr i64 %h11459 to i64* 
  store volatile i64* %cloptr31281, i64** %vptr31286, align 8 ; closure/env cast; i64 -> i64*
  %vptr31287 = alloca i64*, align 8 
  %i0ptr31282 = getelementptr inbounds i64, i64* %cloptr31281, i64 1 
  store volatile i64* %i0ptr31282, i64** %vptr31287, align 8 ; &cloptr31281[1]
 %vptr31288 = alloca i64, align 8 
  %f31284 = load i64, i64* %i0ptr31282, align 8 
  store volatile i64 %f31284, i64* %vptr31288, align 8 ; load; *i0ptr31282
  %fptr31283 = inttoptr i64 %f31284 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr31283(i64 %h11459, i64 %h11459)                     ; tail call
  ret void

else31278:
 %vptr31289 = alloca i64, align 8 
  %a6907 = call i64 @prim_car(i64 %rvp11453) 
  store volatile i64 %a6907, i64* %vptr31289, align 8 ; call prim_car
 %vptr31290 = alloca i64, align 8 
  %na11439 = call i64 @prim_cdr(i64 %rvp11453) 
  store volatile i64 %na11439, i64* %vptr31290, align 8 ; call prim_cdr
 %vptr31291 = alloca i64, align 8 
  %n_6311454 = call i64 @prim_null_63(i64 %na11439) 
  store volatile i64 %n_6311454, i64* %vptr31291, align 8 ; call prim_null_63
  %cmpptr31295 = alloca i1, align 8  %cmp31292 = icmp eq i64 %n_6311454, 15 store volatile i1 %cmp31292, i1* %cmpptr31295, align 8; false?
  br i1 %cmp31292, label %else31294, label %then31293                                ; if

then31293:
  %vptr31303 = alloca i64*, align 8 
  %cloptr31296 = call i64* @make_closure(i64 40) 
  store volatile i64* %cloptr31296, i64** %vptr31303, align 8 ; malloc
  %vptr31304 = alloca i64*, align 8 
  %eptr31298 = getelementptr inbounds i64, i64* %cloptr31296, i64 2 
  store volatile i64* %eptr31298, i64** %vptr31304, align 8 ; &eptr31298[1]
  %vptr31305 = alloca i64*, align 8 
  %eptr31299 = getelementptr inbounds i64, i64* %cloptr31296, i64 3 
  store volatile i64* %eptr31299, i64** %vptr31305, align 8 ; &eptr31299[2]
  %vptr31306 = alloca i64*, align 8 
  %eptr31300 = getelementptr inbounds i64, i64* %cloptr31296, i64 4 
  store volatile i64* %eptr31300, i64** %vptr31306, align 8 ; &eptr31300[3]
  %vptr31307 = alloca i64*, align 8 
  %eptr31301 = getelementptr inbounds i64, i64* %cloptr31296, i64 5 
  store volatile i64* %eptr31301, i64** %vptr31307, align 8 ; &eptr31301[4]
  store i64 %emsg18637, i64* %eptr31298                                              ; *eptr31298 = %emsg18637
  store i64 %cont7362, i64* %eptr31299                                               ; *eptr31299 = %cont7362
  store i64 %VTV$args, i64* %eptr31300                                               ; *eptr31300 = %VTV$args
  store i64 %emsg08636, i64* %eptr31301                                              ; *eptr31301 = %emsg08636
  %vptr31308 = alloca i64*, align 8 
  %eptr31297 = getelementptr inbounds i64, i64* %cloptr31296, i64 1 
  store volatile i64* %eptr31297, i64** %vptr31308, align 8 ; &cloptr31296[1]
 %vptr31309 = alloca i64, align 8 
  %f31302 = ptrtoint void(i64,i64)* @lam11494 to i64 
  store volatile i64 %f31302, i64* %vptr31309, align 8 ; fptr cast; i64(...)* -> i64
  store i64 %f31302, i64* %eptr31297                                                 ; store fptr
 %vptr31310 = alloca i64, align 8 
  %arg8632 = ptrtoint i64* %cloptr31296 to i64 
  store volatile i64 %arg8632, i64* %vptr31310, align 8 ; closure cast; i64* -> i64
 %vptr31311 = alloca i64, align 8 
  %rva11452 = add i64 0, 0 
  store volatile i64 %rva11452, i64* %vptr31311, align 8 ; quoted ()
 %vptr31312 = alloca i64, align 8 
  %rva11451 = call i64 @prim_cons(i64 %Ywq$f, i64 %rva11452) 
  store volatile i64 %rva11451, i64* %vptr31312, align 8 ; call prim_cons
 %vptr31313 = alloca i64, align 8 
  %rva11450 = call i64 @prim_cons(i64 %arg8632, i64 %rva11451) 
  store volatile i64 %rva11450, i64* %vptr31313, align 8 ; call prim_cons
  %vptr31319 = alloca i64*, align 8 
  %cloptr31314 = inttoptr i64 %a6907 to i64* 
  store volatile i64* %cloptr31314, i64** %vptr31319, align 8 ; closure/env cast; i64 -> i64*
  %vptr31320 = alloca i64*, align 8 
  %i0ptr31315 = getelementptr inbounds i64, i64* %cloptr31314, i64 1 
  store volatile i64* %i0ptr31315, i64** %vptr31320, align 8 ; &cloptr31314[1]
 %vptr31321 = alloca i64, align 8 
  %f31317 = load i64, i64* %i0ptr31315, align 8 
  store volatile i64 %f31317, i64* %vptr31321, align 8 ; load; *i0ptr31315
  %fptr31316 = inttoptr i64 %f31317 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr31316(i64 %a6907, i64 %rva11450)                    ; tail call
  ret void

else31294:
 %vptr31322 = alloca i64, align 8 
  %h11455 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11455, i64* %vptr31322, align 8 ; call prim_halt
  %vptr31328 = alloca i64*, align 8 
  %cloptr31323 = inttoptr i64 %h11455 to i64* 
  store volatile i64* %cloptr31323, i64** %vptr31328, align 8 ; closure/env cast; i64 -> i64*
  %vptr31329 = alloca i64*, align 8 
  %i0ptr31324 = getelementptr inbounds i64, i64* %cloptr31323, i64 1 
  store volatile i64* %i0ptr31324, i64** %vptr31329, align 8 ; &cloptr31323[1]
 %vptr31330 = alloca i64, align 8 
  %f31326 = load i64, i64* %i0ptr31324, align 8 
  store volatile i64 %f31326, i64* %vptr31330, align 8 ; load; *i0ptr31324
  %fptr31325 = inttoptr i64 %f31326 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr31325(i64 %h11455, i64 %h11455)                     ; tail call
  ret void
}


define void @lam11494(i64 %env11495, i64 %rvp11446) {
 %vptr31333 = alloca i64, align 8 
  %envptr31331 = inttoptr i64 %env11495 to i64* 
  store volatile i64 %emsg08636, i64* %vptr31333, align 8 ; closure/env cast; i64 -> i64*
  %vptr31334 = alloca i64*, align 8 
  %envptr31332 = getelementptr inbounds i64, i64* %envptr31331, i64 5 
  store volatile i64* %envptr31332, i64** %vptr31334, align 8 ; &envptr31331[4]
 %vptr31335 = alloca i64, align 8 
  %emsg08636 = load i64, i64* %envptr31332, align 8 
  store volatile i64 %emsg08636, i64* %vptr31335, align 8 ; load; *envptr31332
 %vptr31338 = alloca i64, align 8 
  %envptr31336 = inttoptr i64 %env11495 to i64* 
  store volatile i64 %VTV$args, i64* %vptr31338, align 8 ; closure/env cast; i64 -> i64*
  %vptr31339 = alloca i64*, align 8 
  %envptr31337 = getelementptr inbounds i64, i64* %envptr31336, i64 4 
  store volatile i64* %envptr31337, i64** %vptr31339, align 8 ; &envptr31336[3]
 %vptr31340 = alloca i64, align 8 
  %VTV$args = load i64, i64* %envptr31337, align 8 
  store volatile i64 %VTV$args, i64* %vptr31340, align 8 ; load; *envptr31337
 %vptr31343 = alloca i64, align 8 
  %envptr31341 = inttoptr i64 %env11495 to i64* 
  store volatile i64 %cont7362, i64* %vptr31343, align 8 ; closure/env cast; i64 -> i64*
  %vptr31344 = alloca i64*, align 8 
  %envptr31342 = getelementptr inbounds i64, i64* %envptr31341, i64 3 
  store volatile i64* %envptr31342, i64** %vptr31344, align 8 ; &envptr31341[2]
 %vptr31345 = alloca i64, align 8 
  %cont7362 = load i64, i64* %envptr31342, align 8 
  store volatile i64 %cont7362, i64* %vptr31345, align 8 ; load; *envptr31342
 %vptr31348 = alloca i64, align 8 
  %envptr31346 = inttoptr i64 %env11495 to i64* 
  store volatile i64 %emsg18637, i64* %vptr31348, align 8 ; closure/env cast; i64 -> i64*
  %vptr31349 = alloca i64*, align 8 
  %envptr31347 = getelementptr inbounds i64, i64* %envptr31346, i64 2 
  store volatile i64* %envptr31347, i64** %vptr31349, align 8 ; &envptr31346[1]
 %vptr31350 = alloca i64, align 8 
  %emsg18637 = load i64, i64* %envptr31347, align 8 
  store volatile i64 %emsg18637, i64* %vptr31350, align 8 ; load; *envptr31347
 %vptr31351 = alloca i64, align 8 
  %_957365 = call i64 @prim_car(i64 %rvp11446) 
  store volatile i64 %_957365, i64* %vptr31351, align 8 ; call prim_car
 %vptr31352 = alloca i64, align 8 
  %rvp11442 = call i64 @prim_cdr(i64 %rvp11446) 
  store volatile i64 %rvp11442, i64* %vptr31352, align 8 ; call prim_cdr
 %vptr31353 = alloca i64, align 8 
  %n_6311447 = call i64 @prim_null_63(i64 %rvp11442) 
  store volatile i64 %n_6311447, i64* %vptr31353, align 8 ; call prim_null_63
  %cmpptr31357 = alloca i1, align 8  %cmp31354 = icmp eq i64 %n_6311447, 15 store volatile i1 %cmp31354, i1* %cmpptr31357, align 8; false?
  br i1 %cmp31354, label %else31356, label %then31355                                ; if

then31355:
 %vptr31358 = alloca i64, align 8 
  %h11448 = call i64 @prim_halt(i64 %emsg08636) 
  store volatile i64 %h11448, i64* %vptr31358, align 8 ; call prim_halt
  %vptr31364 = alloca i64*, align 8 
  %cloptr31359 = inttoptr i64 %h11448 to i64* 
  store volatile i64* %cloptr31359, i64** %vptr31364, align 8 ; closure/env cast; i64 -> i64*
  %vptr31365 = alloca i64*, align 8 
  %i0ptr31360 = getelementptr inbounds i64, i64* %cloptr31359, i64 1 
  store volatile i64* %i0ptr31360, i64** %vptr31365, align 8 ; &cloptr31359[1]
 %vptr31366 = alloca i64, align 8 
  %f31362 = load i64, i64* %i0ptr31360, align 8 
  store volatile i64 %f31362, i64* %vptr31366, align 8 ; load; *i0ptr31360
  %fptr31361 = inttoptr i64 %f31362 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr31361(i64 %h11448, i64 %h11448)                     ; tail call
  ret void

else31356:
 %vptr31367 = alloca i64, align 8 
  %a6908 = call i64 @prim_car(i64 %rvp11442) 
  store volatile i64 %a6908, i64* %vptr31367, align 8 ; call prim_car
 %vptr31368 = alloca i64, align 8 
  %na11441 = call i64 @prim_cdr(i64 %rvp11442) 
  store volatile i64 %na11441, i64* %vptr31368, align 8 ; call prim_cdr
 %vptr31369 = alloca i64, align 8 
  %n_6311443 = call i64 @prim_null_63(i64 %na11441) 
  store volatile i64 %n_6311443, i64* %vptr31369, align 8 ; call prim_null_63
  %cmpptr31373 = alloca i1, align 8  %cmp31370 = icmp eq i64 %n_6311443, 15 store volatile i1 %cmp31370, i1* %cmpptr31373, align 8; false?
  br i1 %cmp31370, label %else31372, label %then31371                                ; if

then31371:
 %vptr31374 = alloca i64, align 8 
  %cps_45lst7366 = call i64 @prim_cons(i64 %cont7362, i64 %VTV$args) 
  store volatile i64 %cps_45lst7366, i64* %vptr31374, align 8 ; call prim_cons
  %vptr31380 = alloca i64*, align 8 
  %cloptr31375 = inttoptr i64 %a6908 to i64* 
  store volatile i64* %cloptr31375, i64** %vptr31380, align 8 ; closure/env cast; i64 -> i64*
  %vptr31381 = alloca i64*, align 8 
  %i0ptr31376 = getelementptr inbounds i64, i64* %cloptr31375, i64 1 
  store volatile i64* %i0ptr31376, i64** %vptr31381, align 8 ; &cloptr31375[1]
 %vptr31382 = alloca i64, align 8 
  %f31378 = load i64, i64* %i0ptr31376, align 8 
  store volatile i64 %f31378, i64* %vptr31382, align 8 ; load; *i0ptr31376
  %fptr31377 = inttoptr i64 %f31378 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr31377(i64 %a6908, i64 %cps_45lst7366)               ; tail call
  ret void

else31372:
 %vptr31383 = alloca i64, align 8 
  %h11444 = call i64 @prim_halt(i64 %emsg18637) 
  store volatile i64 %h11444, i64* %vptr31383, align 8 ; call prim_halt
  %vptr31389 = alloca i64*, align 8 
  %cloptr31384 = inttoptr i64 %h11444 to i64* 
  store volatile i64* %cloptr31384, i64** %vptr31389, align 8 ; closure/env cast; i64 -> i64*
  %vptr31390 = alloca i64*, align 8 
  %i0ptr31385 = getelementptr inbounds i64, i64* %cloptr31384, i64 1 
  store volatile i64* %i0ptr31385, i64** %vptr31390, align 8 ; &cloptr31384[1]
 %vptr31391 = alloca i64, align 8 
  %f31387 = load i64, i64* %i0ptr31385, align 8 
  store volatile i64 %f31387, i64* %vptr31391, align 8 ; load; *i0ptr31385
  %fptr31386 = inttoptr i64 %f31387 to void (i64,i64)*                               ; cast fptr; i64 -> void(...)*
  musttail call fastcc void %fptr31386(i64 %h11444, i64 %h11444)                     ; tail call
  ret void
}





@str12445 = private unnamed_addr constant [51 x i8] c"library runtime error: Too few arguments provided.\00", align 8
@str12447 = private unnamed_addr constant [52 x i8] c"library runtime error: Too many arguments provided.\00", align 8
@str17425 = private unnamed_addr constant [42 x i8] c"library runtime error: Hash key not found\00", align 8
@sym17510 = private unnamed_addr constant [10 x i8] c"%%promise\00", align 8
